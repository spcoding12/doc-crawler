### Features¶

# Features[¶](#features "Permanent link")

## FastAPI features[¶](#fastapi-features "Permanent link")

**FastAPI** gives you the following:

### Based on open standards[¶](#based-on-open-standards "Permanent link")

  * [**OpenAPI**](https://github.com/OAI/OpenAPI-Specification) for API creation, including declarations of path operations, parameters, request bodies, security, etc.
  * Automatic data model documentation with [**JSON Schema**](https://json-schema.org/) (as OpenAPI itself is based on JSON Schema).
  * Designed around these standards, after a meticulous study. Instead of an afterthought layer on top.
  * This also allows using automatic **client code generation** in many languages.

### Automatic docs[¶](#automatic-docs "Permanent link")

Interactive API documentation and exploration web user interfaces. As the framework is based on OpenAPI, there are multiple options, 2 included by default.

  * [**Swagger UI**](https://github.com/swagger-api/swagger-ui), with interactive exploration, call and test your API directly from the browser.

![Swagger UI interaction](https://fastapi.tiangolo.com/img/index/index-03-swagger-02.png)

  * Alternative API documentation with [**ReDoc**](https://github.com/Rebilly/ReDoc).

![ReDoc](https://fastapi.tiangolo.com/img/index/index-06-redoc-02.png)

### Just Modern Python[¶](#just-modern-python "Permanent link")

It's all based on standard **Python type** declarations (thanks to Pydantic). No new syntax to learn. Just standard modern Python.

If you need a 2 minute refresher of how to use Python types (even if you don't use FastAPI), check the short tutorial: [Python Types](../python-types/).

You write standard Python with types:
    
    
    from datetime import date
    
    from pydantic import BaseModel
    
    # Declare a variable as a str
    # and get editor support inside the function
    def main(user_id: str):
        return user_id
    
    
    # A Pydantic model
    class User(BaseModel):
        id: int
        name: str
        joined: date
    

That can then be used like:
    
    
    my_user: User = User(id=3, name="John Doe", joined="2018-07-19")
    
    second_user_data = {
        "id": 4,
        "name": "Mary",
        "joined": "2018-11-30",
    }
    
    my_second_user: User = User(**second_user_data)
    

Info

`**second_user_data` means:

Pass the keys and values of the `second_user_data` dict directly as key-value arguments, equivalent to: `User(id=4, name="Mary", joined="2018-11-30")`

### Editor support[¶](#editor-support "Permanent link")

All the framework was designed to be easy and intuitive to use, all the decisions were tested on multiple editors even before starting development, to ensure the best development experience.

In the Python developer surveys, it's clear [that one of the most used features is "autocompletion"](https://www.jetbrains.com/research/python-developers-survey-2017/#tools-and-features).

The whole **FastAPI** framework is based to satisfy that. Autocompletion works everywhere.

You will rarely need to come back to the docs.

Here's how your editor might help you:

  * in [Visual Studio Code](https://code.visualstudio.com/):

![editor support](https://fastapi.tiangolo.com/img/vscode-completion.png)

  * in [PyCharm](https://www.jetbrains.com/pycharm/):

![editor support](https://fastapi.tiangolo.com/img/pycharm-completion.png)

You will get completion in code you might even consider impossible before. As for example, the `price` key inside a JSON body (that could have been nested) that comes from a request.

No more typing the wrong key names, coming back and forth between docs, or scrolling up and down to find if you finally used `username` or `user_name`.

### Short[¶](#short "Permanent link")

It has sensible **defaults** for everything, with optional configurations everywhere. All the parameters can be fine-tuned to do what you need and to define the API you need.

But by default, it all **"just works"**.

### Validation[¶](#validation "Permanent link")

  * Validation for most (or all?) Python **data types** , including:

    * JSON objects (`dict`).
    * JSON array (`list`) defining item types.
    * String (`str`) fields, defining min and max lengths.
    * Numbers (`int`, `float`) with min and max values, etc.
  * Validation for more exotic types, like:

    * URL.
    * Email.
    * UUID.
    * ...and others.

All the validation is handled by the well-established and robust **Pydantic**.

### Security and authentication[¶](#security-and-authentication "Permanent link")

Security and authentication integrated. Without any compromise with databases or data models.

All the security schemes defined in OpenAPI, including:

  * HTTP Basic.
  * **OAuth2** (also with **JWT tokens**). Check the tutorial on [OAuth2 with JWT](../tutorial/security/oauth2-jwt/).
  * API keys in:
    * Headers.
    * Query parameters.
    * Cookies, etc.

Plus all the security features from Starlette (including **session cookies**).

All built as reusable tools and components that are easy to integrate with your systems, data stores, relational and NoSQL databases, etc.

### Dependency Injection[¶](#dependency-injection "Permanent link")

FastAPI includes an extremely easy to use, but extremely powerful **Dependency Injection** system.

  * Even dependencies can have dependencies, creating a hierarchy or **"graph" of dependencies**.
  * All **automatically handled** by the framework.
  * All the dependencies can require data from requests and **augment the path operation** constraints and automatic documentation.
  * **Automatic validation** even for _path operation_ parameters defined in dependencies.
  * Support for complex user authentication systems, **database connections** , etc.
  * **No compromise** with databases, frontends, etc. But easy integration with all of them.

### Unlimited "plug-ins"[¶](#unlimited-plug-ins "Permanent link")

Or in other way, no need for them, import and use the code you need.

Any integration is designed to be so simple to use (with dependencies) that you can create a "plug-in" for your application in 2 lines of code using the same structure and syntax used for your _path operations_.

### Tested[¶](#tested "Permanent link")

  * 100% test coverage.
  * 100% type annotated code base.
  * Used in production applications.

## Starlette features[¶](#starlette-features "Permanent link")

**FastAPI** is fully compatible with (and based on) [**Starlette**](https://www.starlette.dev/). So, any additional Starlette code you have, will also work.

`FastAPI` is actually a sub-class of `Starlette`. So, if you already know or use Starlette, most of the functionality will work the same way.

With **FastAPI** you get all of **Starlette** 's features (as FastAPI is just Starlette on steroids):

  * Seriously impressive performance. It is [one of the fastest Python frameworks available, on par with **NodeJS** and **Go**](https://github.com/encode/starlette#performance).
  * **WebSocket** support.
  * In-process background tasks.
  * Startup and shutdown events.
  * Test client built on HTTPX.
  * **CORS** , GZip, Static Files, Streaming responses.
  * **Session and Cookie** support.
  * 100% test coverage.
  * 100% type annotated codebase.

## Pydantic features[¶](#pydantic-features "Permanent link")

**FastAPI** is fully compatible with (and based on) [**Pydantic**](https://docs.pydantic.dev/). So, any additional Pydantic code you have, will also work.

Including external libraries also based on Pydantic, as ORMs, ODMs for databases.

This also means that in many cases you can pass the same object you get from a request **directly to the database** , as everything is validated automatically.

The same applies the other way around, in many cases you can just pass the object you get from the database **directly to the client**.

With **FastAPI** you get all of **Pydantic** 's features (as FastAPI is based on Pydantic for all the data handling):

  * **No brainfuck** :
    * No new schema definition micro-language to learn.
    * If you know Python types you know how to use Pydantic.
  * Plays nicely with your **IDE /linter/brain**:
    * Because pydantic data structures are just instances of classes you define; auto-completion, linting, mypy and your intuition should all work properly with your validated data.
  * Validate **complex structures** :
    * Use of hierarchical Pydantic models, Python `typing`‚Äôs `List` and `Dict`, etc.
    * And validators allow complex data schemas to be clearly and easily defined, checked and documented as JSON Schema.
    * You can have deeply **nested JSON** objects and have them all validated and annotated.
  * **Extensible** :
    * Pydantic allows custom data types to be defined or you can extend validation with methods on a model decorated with the validator decorator.
  * 100% test coverage.

  *[path]: also known as: endpoints, routes
  *[operations]: also known as HTTP methods, as POST, GET, PUT, DELETE
  *[**Dependency Injection**]: also known as "components", "resources", "services", "providers"
  *[test coverage]: The amount of code that is automatically tested
  *[type annotated]: Python type annotations, with this your editor and external tools can give you better support
  *[ORM]: Object-Relational Mapper
  *[ODM]: Object-Document Mapper
  *[IDE]: Integrated Development Environment: similar to a code editor
  *[linter]: A program that checks for code errors

---

#### Learn¶

# Learn[¶](#learn "Permanent link")

Here are the introductory sections and the tutorials to learn **FastAPI**.

You could consider this a **book** , a **course** , the **official** and recommended way to learn FastAPI. üòé

---

###### Python Types Intro¶

# Python Types Intro[¶](#python-types-intro "Permanent link")

Python has support for optional "type hints" (also called "type annotations").

These **"type hints"** or annotations are a special syntax that allow declaring the type of a variable.

By declaring types for your variables, editors and tools can give you better support.

This is just a **quick tutorial / refresher** about Python type hints. It covers only the minimum necessary to use them with **FastAPI**... which is actually very little.

**FastAPI** is all based on these type hints, they give it many advantages and benefits.

But even if you never use **FastAPI** , you would benefit from learning a bit about them.

Note

If you are a Python expert, and you already know everything about type hints, skip to the next chapter.

## Motivation[¶](#motivation "Permanent link")

Let's start with a simple example:

Python 3.9+
    
    
    def get_full_name(first_name, last_name):
        full_name = first_name.title() + " " + last_name.title()
        return full_name
    
    
    print(get_full_name("john", "doe"))
    

Calling this program outputs:
    
    
    John Doe
    

The function does the following:

  * Takes a `first_name` and `last_name`.
  * Converts the first letter of each one to upper case with `title()`.
  * Concatenates them with a space in the middle.

Python 3.9+
    
    
    def get_full_name(first_name, last_name):
        full_name = first_name.title() + " " + last_name.title()
        return full_name
    
    
    print(get_full_name("john", "doe"))
    

### Edit it[¶](#edit-it "Permanent link")

It's a very simple program.

But now imagine that you were writing it from scratch.

At some point you would have started the definition of the function, you had the parameters ready...

But then you have to call "that method that converts the first letter to upper case".

Was it `upper`? Was it `uppercase`? `first_uppercase`? `capitalize`?

Then, you try with the old programmer's friend, editor autocompletion.

You type the first parameter of the function, `first_name`, then a dot (`.`) and then hit `Ctrl+Space` to trigger the completion.

But, sadly, you get nothing useful:

![](/img/python-types/image01.png)

### Add types[¶](#add-types "Permanent link")

Let's modify a single line from the previous version.

We will change exactly this fragment, the parameters of the function, from:
    
    
        first_name, last_name
    

to:
    
    
        first_name: str, last_name: str
    

That's it.

Those are the "type hints":

Python 3.9+
    
    
    def get_full_name(first_name: str, last_name: str):
        full_name = first_name.title() + " " + last_name.title()
        return full_name
    
    
    print(get_full_name("john", "doe"))
    

That is not the same as declaring default values like would be with:
    
    
        first_name="john", last_name="doe"
    

It's a different thing.

We are using colons (`:`), not equals (`=`).

And adding type hints normally doesn't change what happens from what would happen without them.

But now, imagine you are again in the middle of creating that function, but with type hints.

At the same point, you try to trigger the autocomplete with `Ctrl+Space` and you see:

![](/img/python-types/image02.png)

With that, you can scroll, seeing the options, until you find the one that "rings a bell":

![](/img/python-types/image03.png)

## More motivation[¶](#more-motivation "Permanent link")

Check this function, it already has type hints:

Python 3.9+
    
    
    def get_name_with_age(name: str, age: int):
        name_with_age = name + " is this old: " + age
        return name_with_age
    

Because the editor knows the types of the variables, you don't only get completion, you also get error checks:

![](/img/python-types/image04.png)

Now you know that you have to fix it, convert `age` to a string with `str(age)`:

Python 3.9+
    
    
    def get_name_with_age(name: str, age: int):
        name_with_age = name + " is this old: " + str(age)
        return name_with_age
    

## Declaring types[¶](#declaring-types "Permanent link")

You just saw the main place to declare type hints. As function parameters.

This is also the main place you would use them with **FastAPI**.

### Simple types[¶](#simple-types "Permanent link")

You can declare all the standard Python types, not only `str`.

You can use, for example:

  * `int`
  * `float`
  * `bool`
  * `bytes`

Python 3.9+
    
    
    def get_items(item_a: str, item_b: int, item_c: float, item_d: bool, item_e: bytes):
        return item_a, item_b, item_c, item_d, item_e
    

### Generic types with type parameters[¶](#generic-types-with-type-parameters "Permanent link")

There are some data structures that can contain other values, like `dict`, `list`, `set` and `tuple`. And the internal values can have their own type too.

These types that have internal types are called "**generic** " types. And it's possible to declare them, even with their internal types.

To declare those types and the internal types, you can use the standard Python module `typing`. It exists specifically to support these type hints.

#### Newer versions of Python[¶](#newer-versions-of-python "Permanent link")

The syntax using `typing` is **compatible** with all versions, from Python 3.6 to the latest ones, including Python 3.9, Python 3.10, etc.

As Python advances, **newer versions** come with improved support for these type annotations and in many cases you won't even need to import and use the `typing` module to declare the type annotations.

If you can choose a more recent version of Python for your project, you will be able to take advantage of that extra simplicity.

In all the docs there are examples compatible with each version of Python (when there's a difference).

For example "**Python 3.6+** " means it's compatible with Python 3.6 or above (including 3.7, 3.8, 3.9, 3.10, etc). And "**Python 3.9+** " means it's compatible with Python 3.9 or above (including 3.10, etc).

If you can use the **latest versions of Python** , use the examples for the latest version, those will have the **best and simplest syntax** , for example, "**Python 3.10+** ".

#### List[¶](#list "Permanent link")

For example, let's define a variable to be a `list` of `str`.

Declare the variable, with the same colon (`:`) syntax.

As the type, put `list`.

As the list is a type that contains some internal types, you put them in square brackets:

Python 3.9+
    
    
    def process_items(items: list[str]):
        for item in items:
            print(item)
    

Info

Those internal types in the square brackets are called "type parameters".

In this case, `str` is the type parameter passed to `list`.

That means: "the variable `items` is a `list`, and each of the items in this list is a `str`".

By doing that, your editor can provide support even while processing items from the list:

![](/img/python-types/image05.png)

Without types, that's almost impossible to achieve.

Notice that the variable `item` is one of the elements in the list `items`.

And still, the editor knows it is a `str`, and provides support for that.

#### Tuple and Set[¶](#tuple-and-set "Permanent link")

You would do the same to declare `tuple`s and `set`s:

Python 3.9+
    
    
    def process_items(items_t: tuple[int, int, str], items_s: set[bytes]):
        return items_t, items_s
    

This means:

  * The variable `items_t` is a `tuple` with 3 items, an `int`, another `int`, and a `str`.
  * The variable `items_s` is a `set`, and each of its items is of type `bytes`.

#### Dict[¶](#dict "Permanent link")

To define a `dict`, you pass 2 type parameters, separated by commas.

The first type parameter is for the keys of the `dict`.

The second type parameter is for the values of the `dict`:

Python 3.9+
    
    
    def process_items(prices: dict[str, float]):
        for item_name, item_price in prices.items():
            print(item_name)
            print(item_price)
    

This means:

  * The variable `prices` is a `dict`:
    * The keys of this `dict` are of type `str` (let's say, the name of each item).
    * The values of this `dict` are of type `float` (let's say, the price of each item).

#### Union[¶](#union "Permanent link")

You can declare that a variable can be any of **several types** , for example, an `int` or a `str`.

In Python 3.6 and above (including Python 3.10) you can use the `Union` type from `typing` and put inside the square brackets the possible types to accept.

In Python 3.10 there's also a **new syntax** where you can put the possible types separated by a vertical bar (`|`).

Python 3.10+Python 3.9+
    
    
    def process_item(item: int | str):
        print(item)
    
    
    
    from typing import Union
    
    
    def process_item(item: Union[int, str]):
        print(item)
    

In both cases this means that `item` could be an `int` or a `str`.

#### Possibly `None`[¶](#possibly-none "Permanent link")

You can declare that a value could have a type, like `str`, but that it could also be `None`.

In Python 3.6 and above (including Python 3.10) you can declare it by importing and using `Optional` from the `typing` module.
    
    
    from typing import Optional
    
    
    def say_hi(name: Optional[str] = None):
        if name is not None:
            print(f"Hey {name}!")
        else:
            print("Hello World")
    

Using `Optional[str]` instead of just `str` will let the editor help you detect errors where you could be assuming that a value is always a `str`, when it could actually be `None` too.

`Optional[Something]` is actually a shortcut for `Union[Something, None]`, they are equivalent.

This also means that in Python 3.10, you can use `Something | None`:

Python 3.10+Python 3.9+Python 3.9+ alternative
    
    
    def say_hi(name: str | None = None):
        if name is not None:
            print(f"Hey {name}!")
        else:
            print("Hello World")
    
    
    
    from typing import Optional
    
    
    def say_hi(name: Optional[str] = None):
        if name is not None:
            print(f"Hey {name}!")
        else:
            print("Hello World")
    
    
    
    from typing import Union
    
    
    def say_hi(name: Union[str, None] = None):
        if name is not None:
            print(f"Hey {name}!")
        else:
            print("Hello World")
    

#### Using `Union` or `Optional`[¶](#using-union-or-optional "Permanent link")

If you are using a Python version below 3.10, here's a tip from my very **subjective** point of view:

  * üö® Avoid using `Optional[SomeType]`
  * Instead ‚ú® **use`Union[SomeType, None]`** ‚ú®.

Both are equivalent and underneath they are the same, but I would recommend `Union` instead of `Optional` because the word "**optional** " would seem to imply that the value is optional, and it actually means "it can be `None`", even if it's not optional and is still required.

I think `Union[SomeType, None]` is more explicit about what it means.

It's just about the words and names. But those words can affect how you and your teammates think about the code.

As an example, let's take this function:

Python 3.9+
    
    
    from typing import Optional
    
    
    def say_hi(name: Optional[str]):
        print(f"Hey {name}!")
    

ü§ì Other versions and variants

Python 3.10+
    
    
    def say_hi(name: str | None):
        print(f"Hey {name}!")
    

The parameter `name` is defined as `Optional[str]`, but it is **not optional** , you cannot call the function without the parameter:
    
    
    say_hi()  # Oh, no, this throws an error! üò±
    

The `name` parameter is **still required** (not _optional_) because it doesn't have a default value. Still, `name` accepts `None` as the value:
    
    
    say_hi(name=None)  # This works, None is valid üéâ
    

The good news is, once you are on Python 3.10 you won't have to worry about that, as you will be able to simply use `|` to define unions of types:

Python 3.10+
    
    
    def say_hi(name: str | None):
        print(f"Hey {name}!")
    

ü§ì Other versions and variants

Python 3.9+
    
    
    from typing import Optional
    
    
    def say_hi(name: Optional[str]):
        print(f"Hey {name}!")
    

And then you won't have to worry about names like `Optional` and `Union`. üòé

#### Generic types[¶](#generic-types "Permanent link")

These types that take type parameters in square brackets are called **Generic types** or **Generics** , for example:

Python 3.10+Python 3.9+

You can use the same builtin types as generics (with square brackets and types inside):

  * `list`
  * `tuple`
  * `set`
  * `dict`

And the same as with previous Python versions, from the `typing` module:

  * `Union`
  * `Optional`
  * ...and others.

In Python 3.10, as an alternative to using the generics `Union` and `Optional`, you can use the vertical bar (`|`) to declare unions of types, that's a lot better and simpler.

You can use the same builtin types as generics (with square brackets and types inside):

  * `list`
  * `tuple`
  * `set`
  * `dict`

And generics from the `typing` module:

  * `Union`
  * `Optional`
  * ...and others.

### Classes as types[¶](#classes-as-types "Permanent link")

You can also declare a class as the type of a variable.

Let's say you have a class `Person`, with a name:

Python 3.9+
    
    
    class Person:
        def __init__(self, name: str):
            self.name = name
    
    
    def get_person_name(one_person: Person):
        return one_person.name
    

Then you can declare a variable to be of type `Person`:

Python 3.9+
    
    
    class Person:
        def __init__(self, name: str):
            self.name = name
    
    
    def get_person_name(one_person: Person):
        return one_person.name
    

And then, again, you get all the editor support:

![](/img/python-types/image06.png)

Notice that this means "`one_person` is an **instance** of the class `Person`".

It doesn't mean "`one_person` is the **class** called `Person`".

## Pydantic models[¶](#pydantic-models "Permanent link")

[Pydantic](https://docs.pydantic.dev/) is a Python library to perform data validation.

You declare the "shape" of the data as classes with attributes.

And each attribute has a type.

Then you create an instance of that class with some values and it will validate the values, convert them to the appropriate type (if that's the case) and give you an object with all the data.

And you get all the editor support with that resulting object.

An example from the official Pydantic docs:

Python 3.10+
    
    
    from datetime import datetime
    
    from pydantic import BaseModel
    
    
    class User(BaseModel):
        id: int
        name: str = "John Doe"
        signup_ts: datetime | None = None
        friends: list[int] = []
    
    
    external_data = {
        "id": "123",
        "signup_ts": "2017-06-01 12:22",
        "friends": [1, "2", b"3"],
    }
    user = User(**external_data)
    print(user)
    # > User id=123 name='John Doe' signup_ts=datetime.datetime(2017, 6, 1, 12, 22) friends=[1, 2, 3]
    print(user.id)
    # > 123
    

ü§ì Other versions and variants

Python 3.9+
    
    
    from datetime import datetime
    from typing import Union
    
    from pydantic import BaseModel
    
    
    class User(BaseModel):
        id: int
        name: str = "John Doe"
        signup_ts: Union[datetime, None] = None
        friends: list[int] = []
    
    
    external_data = {
        "id": "123",
        "signup_ts": "2017-06-01 12:22",
        "friends": [1, "2", b"3"],
    }
    user = User(**external_data)
    print(user)
    # > User id=123 name='John Doe' signup_ts=datetime.datetime(2017, 6, 1, 12, 22) friends=[1, 2, 3]
    print(user.id)
    # > 123
    

Info

To learn more about [Pydantic, check its docs](https://docs.pydantic.dev/).

**FastAPI** is all based on Pydantic.

You will see a lot more of all this in practice in the [Tutorial - User Guide](../tutorial/).

Tip

Pydantic has a special behavior when you use `Optional` or `Union[Something, None]` without a default value, you can read more about it in the Pydantic docs about [Required Optional fields](https://docs.pydantic.dev/2.3/usage/models/#required-fields).

## Type Hints with Metadata Annotations[¶](#type-hints-with-metadata-annotations "Permanent link")

Python also has a feature that allows putting **additional metadata** in these type hints using `Annotated`.

Since Python 3.9, `Annotated` is a part of the standard library, so you can import it from `typing`.

Python 3.9+
    
    
    from typing import Annotated
    
    
    def say_hello(name: Annotated[str, "this is just metadata"]) -> str:
        return f"Hello {name}"
    

Python itself doesn't do anything with this `Annotated`. And for editors and other tools, the type is still `str`.

But you can use this space in `Annotated` to provide **FastAPI** with additional metadata about how you want your application to behave.

The important thing to remember is that **the first _type parameter_** you pass to `Annotated` is the **actual type**. The rest, is just metadata for other tools.

For now, you just need to know that `Annotated` exists, and that it's standard Python. üòé

Later you will see how **powerful** it can be.

Tip

The fact that this is **standard Python** means that you will still get the **best possible developer experience** in your editor, with the tools you use to analyze and refactor your code, etc. ‚ú®

And also that your code will be very compatible with many other Python tools and libraries. üöÄ

## Type hints in **FastAPI**[¶](#type-hints-in-fastapi "Permanent link")

**FastAPI** takes advantage of these type hints to do several things.

With **FastAPI** you declare parameters with type hints and you get:

  * **Editor support**.
  * **Type checks**.

...and **FastAPI** uses the same declarations to:

  * **Define requirements** : from request path parameters, query parameters, headers, bodies, dependencies, etc.
  * **Convert data** : from the request to the required type.
  * **Validate data** : coming from each request:
    * Generating **automatic errors** returned to the client when the data is invalid.
  * **Document** the API using OpenAPI:
    * which is then used by the automatic interactive documentation user interfaces.

This might all sound abstract. Don't worry. You'll see all this in action in the [Tutorial - User Guide](../tutorial/).

The important thing is that by using standard Python types, in a single place (instead of adding more classes, decorators, etc), **FastAPI** will do a lot of the work for you.

Info

If you already went through all the tutorial and came back to see more about types, a good resource is [the "cheat sheet" from `mypy`](https://mypy.readthedocs.io/en/latest/cheat_sheet_py3.html).
  *[type]: for example: str, int, float, bool
  *[Concatenates]: Puts them together, as one. With the contents of one after the other.
  *[vertical bar (`|`)]: also called "bitwise or operator", but that meaning is not relevant here
  *[ metadata]: Data about the data, in this case, information about the type, e.g. a description.

---

###### Concurrency and async / await¶

# Concurrency and async / await[¶](#concurrency-and-async-await "Permanent link")

Details about the `async def` syntax for _path operation functions_ and some background about asynchronous code, concurrency, and parallelism.

## In a hurry?[¶](#in-a-hurry "Permanent link")

**TL;DR:**

If you are using third party libraries that tell you to call them with `await`, like:
    
    
    results = await some_library()
    

Then, declare your _path operation functions_ with `async def` like:
    
    
    @app.get('/')
    async def read_results():
        results = await some_library()
        return results
    

Note

You can only use `await` inside of functions created with `async def`.

* * *

If you are using a third party library that communicates with something (a database, an API, the file system, etc.) and doesn't have support for using `await`, (this is currently the case for most database libraries), then declare your _path operation functions_ as normally, with just `def`, like:
    
    
    @app.get('/')
    def results():
        results = some_library()
        return results
    

* * *

If your application (somehow) doesn't have to communicate with anything else and wait for it to respond, use `async def`, even if you don't need to use `await` inside.

* * *

If you just don't know, use normal `def`.

* * *

**Note** : You can mix `def` and `async def` in your _path operation functions_ as much as you need and define each one using the best option for you. FastAPI will do the right thing with them.

Anyway, in any of the cases above, FastAPI will still work asynchronously and be extremely fast.

But by following the steps above, it will be able to do some performance optimizations.

## Technical Details[¶](#technical-details "Permanent link")

Modern versions of Python have support for **"asynchronous code"** using something called **"coroutines"** , with **`async` and `await`** syntax.

Let's see that phrase by parts in the sections below:

  * **Asynchronous Code**
  * **`async` and `await`**
  * **Coroutines**

## Asynchronous Code[¶](#asynchronous-code "Permanent link")

Asynchronous code just means that the language üí¨ has a way to tell the computer / program ü§ñ that at some point in the code, it ü§ñ will have to wait for _something else_ to finish somewhere else. Let's say that _something else_ is called "slow-file" üìù.

So, during that time, the computer can go and do some other work, while "slow-file" üìù finishes.

Then the computer / program ü§ñ will come back every time it has a chance because it's waiting again, or whenever it ü§ñ finished all the work it had at that point. And it ü§ñ will see if any of the tasks it was waiting for have already finished, doing whatever it had to do.

Next, it ü§ñ takes the first task to finish (let's say, our "slow-file" üìù) and continues whatever it had to do with it.

That "wait for something else" normally refers to I/O operations that are relatively "slow" (compared to the speed of the processor and the RAM memory), like waiting for:

  * the data from the client to be sent through the network
  * the data sent by your program to be received by the client through the network
  * the contents of a file in the disk to be read by the system and given to your program
  * the contents your program gave to the system to be written to disk
  * a remote API operation
  * a database operation to finish
  * a database query to return the results
  * etc.

As the execution time is consumed mostly by waiting for I/O operations, they call them "I/O bound" operations.

It's called "asynchronous" because the computer / program doesn't have to be "synchronized" with the slow task, waiting for the exact moment that the task finishes, while doing nothing, to be able to take the task result and continue the work.

Instead of that, by being an "asynchronous" system, once finished, the task can wait in line a little bit (some microseconds) for the computer / program to finish whatever it went to do, and then come back to take the results and continue working with them.

For "synchronous" (contrary to "asynchronous") they commonly also use the term "sequential", because the computer / program follows all the steps in sequence before switching to a different task, even if those steps involve waiting.

### Concurrency and Burgers[¶](#concurrency-and-burgers "Permanent link")

This idea of **asynchronous** code described above is also sometimes called **"concurrency"**. It is different from **"parallelism"**.

**Concurrency** and **parallelism** both relate to "different things happening more or less at the same time".

But the details between _concurrency_ and _parallelism_ are quite different.

To see the difference, imagine the following story about burgers:

### Concurrent Burgers[¶](#concurrent-burgers "Permanent link")

You go with your crush to get fast food, you stand in line while the cashier takes the orders from the people in front of you. üòç

![](/img/async/concurrent-burgers/concurrent-burgers-01.png)

Then it's your turn, you place your order of 2 very fancy burgers for your crush and you. üçîüçî

![](/img/async/concurrent-burgers/concurrent-burgers-02.png)

The cashier says something to the cook in the kitchen so they know they have to prepare your burgers (even though they are currently preparing the ones for the previous clients).

![](/img/async/concurrent-burgers/concurrent-burgers-03.png)

You pay. üí∏

The cashier gives you the number of your turn.

![](/img/async/concurrent-burgers/concurrent-burgers-04.png)

While you are waiting, you go with your crush and pick a table, you sit and talk with your crush for a long time (as your burgers are very fancy and take some time to prepare).

As you are sitting at the table with your crush, while you wait for the burgers, you can spend that time admiring how awesome, cute and smart your crush is ‚ú®üòç‚ú®.

![](/img/async/concurrent-burgers/concurrent-burgers-05.png)

While waiting and talking to your crush, from time to time, you check the number displayed on the counter to see if it's your turn already.

Then at some point, it finally is your turn. You go to the counter, get your burgers and come back to the table.

![](/img/async/concurrent-burgers/concurrent-burgers-06.png)

You and your crush eat the burgers and have a nice time. ‚ú®

![](/img/async/concurrent-burgers/concurrent-burgers-07.png)

Info

Beautiful illustrations by [Ketrina Thompson](https://www.instagram.com/ketrinadrawsalot). üé®

* * *

Imagine you are the computer / program ü§ñ in that story.

While you are at the line, you are just idle üò¥, waiting for your turn, not doing anything very "productive". But the line is fast because the cashier is only taking the orders (not preparing them), so that's fine.

Then, when it's your turn, you do actual "productive" work, you process the menu, decide what you want, get your crush's choice, pay, check that you give the correct bill or card, check that you are charged correctly, check that the order has the correct items, etc.

But then, even though you still don't have your burgers, your work with the cashier is "on pause" ‚è∏, because you have to wait üïô for your burgers to be ready.

But as you go away from the counter and sit at the table with a number for your turn, you can switch üîÄ your attention to your crush, and "work" ‚èØ ü§ì on that. Then you are again doing something very "productive" as is flirting with your crush üòç.

Then the cashier üíÅ says "I'm finished with doing the burgers" by putting your number on the counter's display, but you don't jump like crazy immediately when the displayed number changes to your turn number. You know no one will steal your burgers because you have the number of your turn, and they have theirs.

So you wait for your crush to finish the story (finish the current work ‚èØ / task being processed ü§ì), smile gently and say that you are going for the burgers ‚è∏.

Then you go to the counter üîÄ, to the initial task that is now finished ‚èØ, pick the burgers, say thanks and take them to the table. That finishes that step / task of interaction with the counter ‚èπ. That in turn, creates a new task, of "eating burgers" üîÄ ‚èØ, but the previous one of "getting burgers" is finished ‚èπ.

### Parallel Burgers[¶](#parallel-burgers "Permanent link")

Now let's imagine these aren't "Concurrent Burgers", but "Parallel Burgers".

You go with your crush to get parallel fast food.

You stand in line while several (let's say 8) cashiers that at the same time are cooks take the orders from the people in front of you.

Everyone before you is waiting for their burgers to be ready before leaving the counter because each of the 8 cashiers goes and prepares the burger right away before getting the next order.

![](/img/async/parallel-burgers/parallel-burgers-01.png)

Then it's finally your turn, you place your order of 2 very fancy burgers for your crush and you.

You pay üí∏.

![](/img/async/parallel-burgers/parallel-burgers-02.png)

The cashier goes to the kitchen.

You wait, standing in front of the counter üïô, so that no one else takes your burgers before you do, as there are no numbers for turns.

![](/img/async/parallel-burgers/parallel-burgers-03.png)

As you and your crush are busy not letting anyone get in front of you and take your burgers whenever they arrive, you cannot pay attention to your crush. üòû

This is "synchronous" work, you are "synchronized" with the cashier/cook üë®‚Äçüç≥. You have to wait üïô and be there at the exact moment that the cashier/cook üë®‚Äçüç≥ finishes the burgers and gives them to you, or otherwise, someone else might take them.

![](/img/async/parallel-burgers/parallel-burgers-04.png)

Then your cashier/cook üë®‚Äçüç≥ finally comes back with your burgers, after a long time waiting üïô there in front of the counter.

![](/img/async/parallel-burgers/parallel-burgers-05.png)

You take your burgers and go to the table with your crush.

You just eat them, and you are done. ‚èπ

![](/img/async/parallel-burgers/parallel-burgers-06.png)

There was not much talk or flirting as most of the time was spent waiting üïô in front of the counter. üòû

Info

Beautiful illustrations by [Ketrina Thompson](https://www.instagram.com/ketrinadrawsalot). üé®

* * *

In this scenario of the parallel burgers, you are a computer / program ü§ñ with two processors (you and your crush), both waiting üïô and dedicating their attention ‚èØ to be "waiting on the counter" üïô for a long time.

The fast food store has 8 processors (cashiers/cooks). While the concurrent burgers store might have had only 2 (one cashier and one cook).

But still, the final experience is not the best. üòû

* * *

This would be the parallel equivalent story for burgers. üçî

For a more "real life" example of this, imagine a bank.

Up to recently, most of the banks had multiple cashiers üë®‚Äçüíºüë®‚Äçüíºüë®‚Äçüíºüë®‚Äçüíº and a big line üïôüïôüïôüïôüïôüïôüïôüïô.

All of the cashiers doing all the work with one client after the other üë®‚Äçüíº‚èØ.

And you have to wait üïô in the line for a long time or you lose your turn.

You probably wouldn't want to take your crush üòç with you to run errands at the bank üè¶.

### Burger Conclusion[¶](#burger-conclusion "Permanent link")

In this scenario of "fast food burgers with your crush", as there is a lot of waiting üïô, it makes a lot more sense to have a concurrent system ‚è∏üîÄ‚èØ.

This is the case for most of the web applications.

Many, many users, but your server is waiting üïô for their not-so-good connection to send their requests.

And then waiting üïô again for the responses to come back.

This "waiting" üïô is measured in microseconds, but still, summing it all, it's a lot of waiting in the end.

That's why it makes a lot of sense to use asynchronous ‚è∏üîÄ‚èØ code for web APIs.

This kind of asynchronicity is what made NodeJS popular (even though NodeJS is not parallel) and that's the strength of Go as a programming language.

And that's the same level of performance you get with **FastAPI**.

And as you can have parallelism and asynchronicity at the same time, you get higher performance than most of the tested NodeJS frameworks and on par with Go, which is a compiled language closer to C [(all thanks to Starlette)](https://www.techempower.com/benchmarks/#section=data-r17&hw=ph&test=query&l=zijmkf-1).

### Is concurrency better than parallelism?[¶](#is-concurrency-better-than-parallelism "Permanent link")

Nope! That's not the moral of the story.

Concurrency is different than parallelism. And it is better on **specific** scenarios that involve a lot of waiting. Because of that, it generally is a lot better than parallelism for web application development. But not for everything.

So, to balance that out, imagine the following short story:

> You have to clean a big, dirty house.

_Yep, that's the whole story_.

* * *

There's no waiting üïô anywhere, just a lot of work to be done, on multiple places of the house.

You could have turns as in the burgers example, first the living room, then the kitchen, but as you are not waiting üïô for anything, just cleaning and cleaning, the turns wouldn't affect anything.

It would take the same amount of time to finish with or without turns (concurrency) and you would have done the same amount of work.

But in this case, if you could bring the 8 ex-cashier/cooks/now-cleaners, and each one of them (plus you) could take a zone of the house to clean it, you could do all the work in **parallel** , with the extra help, and finish much sooner.

In this scenario, each one of the cleaners (including you) would be a processor, doing their part of the job.

And as most of the execution time is taken by actual work (instead of waiting), and the work in a computer is done by a CPU, they call these problems "CPU bound".

* * *

Common examples of CPU bound operations are things that require complex math processing.

For example:

  * **Audio** or **image processing**.
  * **Computer vision** : an image is composed of millions of pixels, each pixel has 3 values / colors, processing that normally requires computing something on those pixels, all at the same time.
  * **Machine Learning** : it normally requires lots of "matrix" and "vector" multiplications. Think of a huge spreadsheet with numbers and multiplying all of them together at the same time.
  * **Deep Learning** : this is a sub-field of Machine Learning, so, the same applies. It's just that there is not a single spreadsheet of numbers to multiply, but a huge set of them, and in many cases, you use a special processor to build and / or use those models.

### Concurrency + Parallelism: Web + Machine Learning[¶](#concurrency-parallelism-web-machine-learning "Permanent link")

With **FastAPI** you can take advantage of concurrency that is very common for web development (the same main attraction of NodeJS).

But you can also exploit the benefits of parallelism and multiprocessing (having multiple processes running in parallel) for **CPU bound** workloads like those in Machine Learning systems.

That, plus the simple fact that Python is the main language for **Data Science** , Machine Learning and especially Deep Learning, make FastAPI a very good match for Data Science / Machine Learning web APIs and applications (among many others).

To see how to achieve this parallelism in production see the section about [Deployment](../deployment/).

## `async` and `await`[¶](#async-and-await "Permanent link")

Modern versions of Python have a very intuitive way to define asynchronous code. This makes it look just like normal "sequential" code and do the "awaiting" for you at the right moments.

When there is an operation that will require waiting before giving the results and has support for these new Python features, you can code it like:
    
    
    burgers = await get_burgers(2)
    

The key here is the `await`. It tells Python that it has to wait ‚è∏ for `get_burgers(2)` to finish doing its thing üïô before storing the results in `burgers`. With that, Python will know that it can go and do something else üîÄ ‚èØ in the meanwhile (like receiving another request).

For `await` to work, it has to be inside a function that supports this asynchronicity. To do that, you just declare it with `async def`:
    
    
    async def get_burgers(number: int):
        # Do some asynchronous stuff to create the burgers
        return burgers
    

...instead of `def`:
    
    
    # This is not asynchronous
    def get_sequential_burgers(number: int):
        # Do some sequential stuff to create the burgers
        return burgers
    

With `async def`, Python knows that, inside that function, it has to be aware of `await` expressions, and that it can "pause" ‚è∏ the execution of that function and go do something else üîÄ before coming back.

When you want to call an `async def` function, you have to "await" it. So, this won't work:
    
    
    # This won't work, because get_burgers was defined with: async def
    burgers = get_burgers(2)
    

* * *

So, if you are using a library that tells you that you can call it with `await`, you need to create the _path operation functions_ that uses it with `async def`, like in:
    
    
    @app.get('/burgers')
    async def read_burgers():
        burgers = await get_burgers(2)
        return burgers
    

### More technical details[¶](#more-technical-details "Permanent link")

You might have noticed that `await` can only be used inside of functions defined with `async def`.

But at the same time, functions defined with `async def` have to be "awaited". So, functions with `async def` can only be called inside of functions defined with `async def` too.

So, about the egg and the chicken, how do you call the first `async` function?

If you are working with **FastAPI** you don't have to worry about that, because that "first" function will be your _path operation function_ , and FastAPI will know how to do the right thing.

But if you want to use `async` / `await` without FastAPI, you can do it as well.

### Write your own async code[¶](#write-your-own-async-code "Permanent link")

Starlette (and **FastAPI**) are based on [AnyIO](https://anyio.readthedocs.io/en/stable/), which makes it compatible with both Python's standard library [asyncio](https://docs.python.org/3/library/asyncio-task.html) and [Trio](https://trio.readthedocs.io/en/stable/).

In particular, you can directly use [AnyIO](https://anyio.readthedocs.io/en/stable/) for your advanced concurrency use cases that require more advanced patterns in your own code.

And even if you were not using FastAPI, you could also write your own async applications with [AnyIO](https://anyio.readthedocs.io/en/stable/) to be highly compatible and get its benefits (e.g. _structured concurrency_).

I created another library on top of AnyIO, as a thin layer on top, to improve a bit the type annotations and get better **autocompletion** , **inline errors** , etc. It also has a friendly introduction and tutorial to help you **understand** and write **your own async code** : [Asyncer](https://asyncer.tiangolo.com/). It would be particularly useful if you need to **combine async code with regular** (blocking/synchronous) code.

### Other forms of asynchronous code[¶](#other-forms-of-asynchronous-code "Permanent link")

This style of using `async` and `await` is relatively new in the language.

But it makes working with asynchronous code a lot easier.

This same syntax (or almost identical) was also included recently in modern versions of JavaScript (in Browser and NodeJS).

But before that, handling asynchronous code was quite more complex and difficult.

In previous versions of Python, you could have used threads or [Gevent](https://www.gevent.org/). But the code is way more complex to understand, debug, and think about.

In previous versions of NodeJS / Browser JavaScript, you would have used "callbacks". Which leads to "callback hell".

## Coroutines[¶](#coroutines "Permanent link")

**Coroutine** is just the very fancy term for the thing returned by an `async def` function. Python knows that it is something like a function, that it can start and that it will end at some point, but that it might be paused ‚è∏ internally too, whenever there is an `await` inside of it.

But all this functionality of using asynchronous code with `async` and `await` is many times summarized as using "coroutines". It is comparable to the main key feature of Go, the "Goroutines".

## Conclusion[¶](#conclusion "Permanent link")

Let's see the same phrase from above:

> Modern versions of Python have support for **"asynchronous code"** using something called **"coroutines"** , with **`async` and `await`** syntax.

That should make more sense now. ‚ú®

All that is what powers FastAPI (through Starlette) and what makes it have such an impressive performance.

## Very Technical Details[¶](#very-technical-details "Permanent link")

Warning

You can probably skip this.

These are very technical details of how **FastAPI** works underneath.

If you have quite some technical knowledge (coroutines, threads, blocking, etc.) and are curious about how FastAPI handles `async def` vs normal `def`, go ahead.

### Path operation functions[¶](#path-operation-functions "Permanent link")

When you declare a _path operation function_ with normal `def` instead of `async def`, it is run in an external threadpool that is then awaited, instead of being called directly (as it would block the server).

If you are coming from another async framework that does not work in the way described above and you are used to defining trivial compute-only _path operation functions_ with plain `def` for a tiny performance gain (about 100 nanoseconds), please note that in **FastAPI** the effect would be quite opposite. In these cases, it's better to use `async def` unless your _path operation functions_ use code that performs blocking I/O.

Still, in both situations, chances are that **FastAPI** will [still be faster](../#performance) than (or at least comparable to) your previous framework.

### Dependencies[¶](#dependencies "Permanent link")

The same applies for [dependencies](../tutorial/dependencies/). If a dependency is a standard `def` function instead of `async def`, it is run in the external threadpool.

### Sub-dependencies[¶](#sub-dependencies "Permanent link")

You can have multiple dependencies and [sub-dependencies](../tutorial/dependencies/sub-dependencies/) requiring each other (as parameters of the function definitions), some of them might be created with `async def` and some with normal `def`. It would still work, and the ones created with normal `def` would be called on an external thread (from the threadpool) instead of being "awaited".

### Other utility functions[¶](#other-utility-functions "Permanent link")

Any other utility function that you call directly can be created with normal `def` or `async def` and FastAPI won't affect the way you call it.

This is in contrast to the functions that FastAPI calls for you: _path operation functions_ and dependencies.

If your utility function is a normal function with `def`, it will be called directly (as you write it in your code), not in a threadpool, if the function is created with `async def` then you should `await` for that function when you call it in your code.

* * *

Again, these are very technical details that would probably be useful if you came searching for them.

Otherwise, you should be good with the guidelines from the section above: [In a hurry?](#in-a-hurry).
  *[**TL;DR:**]: too long; didn't read
  *[I/O]: Input/Output: disk reading or writing, network communications.
  *[CPU]: Central Processing Unit

---

###### Environment Variables¶

# Environment Variables[¶](#environment-variables "Permanent link")

Tip

If you already know what "environment variables" are and how to use them, feel free to skip this.

An environment variable (also known as "**env var** ") is a variable that lives **outside** of the Python code, in the **operating system** , and could be read by your Python code (or by other programs as well).

Environment variables could be useful for handling application **settings** , as part of the **installation** of Python, etc.

## Create and Use Env Vars[¶](#create-and-use-env-vars "Permanent link")

You can **create** and use environment variables in the **shell (terminal)** , without needing Python:

Linux, macOS, Windows BashWindows PowerShell
    
    
    // You could create an env var MY_NAME with
    $ export MY_NAME="Wade Wilson"
    
    // Then you could use it with other programs, like
    $ echo "Hello $MY_NAME"
    
    Hello Wade Wilson
    
    
    
    // Create an env var MY_NAME
    $ $Env:MY_NAME = "Wade Wilson"
    
    // Use it with other programs, like
    $ echo "Hello $Env:MY_NAME"
    
    Hello Wade Wilson
    

## Read env vars in Python[¶](#read-env-vars-in-python "Permanent link")

You could also create environment variables **outside** of Python, in the terminal (or with any other method), and then **read them in Python**.

For example you could have a file `main.py` with:
    
    
    import os
    
    name = os.getenv("MY_NAME", "World")
    print(f"Hello {name} from Python")
    

Tip

The second argument to [`os.getenv()`](https://docs.python.org/3.8/library/os.html#os.getenv) is the default value to return.

If not provided, it's `None` by default, here we provide `"World"` as the default value to use.

Then you could call that Python program:

Linux, macOS, Windows BashWindows PowerShell
    
    
    // Here we don't set the env var yet
    $ python main.py
    
    // As we didn't set the env var, we get the default value
    
    Hello World from Python
    
    // But if we create an environment variable first
    $ export MY_NAME="Wade Wilson"
    
    // And then call the program again
    $ python main.py
    
    // Now it can read the environment variable
    
    Hello Wade Wilson from Python
    
    
    
    // Here we don't set the env var yet
    $ python main.py
    
    // As we didn't set the env var, we get the default value
    
    Hello World from Python
    
    // But if we create an environment variable first
    $ $Env:MY_NAME = "Wade Wilson"
    
    // And then call the program again
    $ python main.py
    
    // Now it can read the environment variable
    
    Hello Wade Wilson from Python
    

As environment variables can be set outside of the code, but can be read by the code, and don't have to be stored (committed to `git`) with the rest of the files, it's common to use them for configurations or **settings**.

You can also create an environment variable only for a **specific program invocation** , that is only available to that program, and only for its duration.

To do that, create it right before the program itself, on the same line:
    
    
    // Create an env var MY_NAME in line for this program call
    $ MY_NAME="Wade Wilson" python main.py
    
    // Now it can read the environment variable
    
    Hello Wade Wilson from Python
    
    // The env var no longer exists afterwards
    $ python main.py
    
    Hello World from Python
    

Tip

You can read more about it at [The Twelve-Factor App: Config](https://12factor.net/config).

## Types and Validation[¶](#types-and-validation "Permanent link")

These environment variables can only handle **text strings** , as they are external to Python and have to be compatible with other programs and the rest of the system (and even with different operating systems, as Linux, Windows, macOS).

That means that **any value** read in Python from an environment variable **will be a`str`**, and any conversion to a different type or any validation has to be done in code.

You will learn more about using environment variables for handling **application settings** in the [Advanced User Guide - Settings and Environment Variables](../advanced/settings/).

## `PATH` Environment Variable[¶](#path-environment-variable "Permanent link")

There is a **special** environment variable called **`PATH`** that is used by the operating systems (Linux, macOS, Windows) to find programs to run.

The value of the variable `PATH` is a long string that is made of directories separated by a colon `:` on Linux and macOS, and by a semicolon `;` on Windows.

For example, the `PATH` environment variable could look like this:

Linux, macOSWindows
    
    
    /usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin
    

This means that the system should look for programs in the directories:

  * `/usr/local/bin`
  * `/usr/bin`
  * `/bin`
  * `/usr/sbin`
  * `/sbin`

    
    
    C:\Program Files\Python312\Scripts;C:\Program Files\Python312;C:\Windows\System32
    

This means that the system should look for programs in the directories:

  * `C:\Program Files\Python312\Scripts`
  * `C:\Program Files\Python312`
  * `C:\Windows\System32`

When you type a **command** in the terminal, the operating system **looks for** the program in **each of those directories** listed in the `PATH` environment variable.

For example, when you type `python` in the terminal, the operating system looks for a program called `python` in the **first directory** in that list.

If it finds it, then it will **use it**. Otherwise it keeps looking in the **other directories**.

### Installing Python and Updating the `PATH`[¶](#installing-python-and-updating-the-path "Permanent link")

When you install Python, you might be asked if you want to update the `PATH` environment variable.

Linux, macOSWindows

Let's say you install Python and it ends up in a directory `/opt/custompython/bin`.

If you say yes to update the `PATH` environment variable, then the installer will add `/opt/custompython/bin` to the `PATH` environment variable.

It could look like this:
    
    
    /usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/opt/custompython/bin
    

This way, when you type `python` in the terminal, the system will find the Python program in `/opt/custompython/bin` (the last directory) and use that one.

Let's say you install Python and it ends up in a directory `C:\opt\custompython\bin`.

If you say yes to update the `PATH` environment variable, then the installer will add `C:\opt\custompython\bin` to the `PATH` environment variable.
    
    
    C:\Program Files\Python312\Scripts;C:\Program Files\Python312;C:\Windows\System32;C:\opt\custompython\bin
    

This way, when you type `python` in the terminal, the system will find the Python program in `C:\opt\custompython\bin` (the last directory) and use that one.

So, if you type:
    
    
    $ python
    

Linux, macOSWindows

The system will **find** the `python` program in `/opt/custompython/bin` and run it.

It would be roughly equivalent to typing:
    
    
    $ /opt/custompython/bin/python
    

The system will **find** the `python` program in `C:\opt\custompython\bin\python` and run it.

It would be roughly equivalent to typing:
    
    
    $ C:\opt\custompython\bin\python
    

This information will be useful when learning about [Virtual Environments](../virtual-environments/).

## Conclusion[¶](#conclusion "Permanent link")

With this you should have a basic understanding of what **environment variables** are and how to use them in Python.

You can also read more about them in the [Wikipedia for Environment Variable](https://en.wikipedia.org/wiki/Environment_variable).

In many cases it's not very obvious how environment variables would be useful and applicable right away. But they keep showing up in many different scenarios when you are developing, so it's good to know about them.

For example, you will need this information in the next section, about [Virtual Environments](../virtual-environments/).

---

###### Virtual Environments¶

# Virtual Environments[¶](#virtual-environments "Permanent link")

When you work in Python projects you probably should use a **virtual environment** (or a similar mechanism) to isolate the packages you install for each project.

Info

If you already know about virtual environments, how to create them and use them, you might want to skip this section. ü§ì

Tip

A **virtual environment** is different than an **environment variable**.

An **environment variable** is a variable in the system that can be used by programs.

A **virtual environment** is a directory with some files in it.

Info

This page will teach you how to use **virtual environments** and how they work.

If you are ready to adopt a **tool that manages everything** for you (including installing Python), try [uv](https://github.com/astral-sh/uv).

## Create a Project[¶](#create-a-project "Permanent link")

First, create a directory for your project.

What I normally do is that I create a directory named `code` inside my home/user directory.

And inside of that I create one directory per project.
    
    
    // Go to the home directory
    $ cd
    // Create a directory for all your code projects
    $ mkdir code
    // Enter into that code directory
    $ cd code
    // Create a directory for this project
    $ mkdir awesome-project
    // Enter into that project directory
    $ cd awesome-project
    

## Create a Virtual Environment[¶](#create-a-virtual-environment "Permanent link")

When you start working on a Python project **for the first time** , create a virtual environment **inside your project**.

Tip

You only need to do this **once per project** , not every time you work.

`venv``uv`

To create a virtual environment, you can use the `venv` module that comes with Python.
    
    
    $ python -m venv .venv
    

What that command means

  * `python`: use the program called `python`
  * `-m`: call a module as a script, we'll tell it which module next
  * `venv`: use the module called `venv` that normally comes installed with Python
  * `.venv`: create the virtual environment in the new directory `.venv`

If you have [`uv`](https://github.com/astral-sh/uv) installed, you can use it to create a virtual environment.
    
    
    $ uv venv
    

Tip

By default, `uv` will create a virtual environment in a directory called `.venv`.

But you could customize it passing an additional argument with the directory name.

That command creates a new virtual environment in a directory called `.venv`.

`.venv` or other name

You could create the virtual environment in a different directory, but there's a convention of calling it `.venv`.

## Activate the Virtual Environment[¶](#activate-the-virtual-environment "Permanent link")

Activate the new virtual environment so that any Python command you run or package you install uses it.

Tip

Do this **every time** you start a **new terminal session** to work on the project.

Linux, macOSWindows PowerShellWindows Bash
    
    
    $ source .venv/bin/activate
    
    
    
    $ .venv\Scripts\Activate.ps1
    

Or if you use Bash for Windows (e.g. [Git Bash](https://gitforwindows.org/)):
    
    
    $ source .venv/Scripts/activate
    

Tip

Every time you install a **new package** in that environment, **activate** the environment again.

This makes sure that if you use a **terminal ( CLI) program** installed by that package, you use the one from your virtual environment and not any other that could be installed globally, probably with a different version than what you need.

## Check the Virtual Environment is Active[¶](#check-the-virtual-environment-is-active "Permanent link")

Check that the virtual environment is active (the previous command worked).

Tip

This is **optional** , but it's a good way to **check** that everything is working as expected and you are using the virtual environment you intended.

Linux, macOS, Windows BashWindows PowerShell
    
    
    $ which python
    
    /home/user/code/awesome-project/.venv/bin/python
    

If it shows the `python` binary at `.venv/bin/python`, inside of your project (in this case `awesome-project`), then it worked. üéâ
    
    
    $ Get-Command python
    
    C:\Users\user\code\awesome-project\.venv\Scripts\python
    

If it shows the `python` binary at `.venv\Scripts\python`, inside of your project (in this case `awesome-project`), then it worked. üéâ

## Upgrade `pip`[¶](#upgrade-pip "Permanent link")

Tip

If you use [`uv`](https://github.com/astral-sh/uv) you would use it to install things instead of `pip`, so you don't need to upgrade `pip`. üòé

If you are using `pip` to install packages (it comes by default with Python), you should **upgrade** it to the latest version.

Many exotic errors while installing a package are solved by just upgrading `pip` first.

Tip

You would normally do this **once** , right after you create the virtual environment.

Make sure the virtual environment is active (with the command above) and then run:
    
    
    $ python -m pip install --upgrade pip
    
    ---> 100%
    

Tip

Sometimes, you might get a **`No module named pip`** error when trying to upgrade pip.

If this happens, install and upgrade pip using the command below:
    
    
    $ python -m ensurepip --upgrade
    
    ---> 100%
    

This command will install pip if it is not already installed and also ensures that the installed version of pip is at least as recent as the one available in `ensurepip`.

## Add `.gitignore`[¶](#add-gitignore "Permanent link")

If you are using **Git** (you should), add a `.gitignore` file to exclude everything in your `.venv` from Git.

Tip

If you used [`uv`](https://github.com/astral-sh/uv) to create the virtual environment, it already did this for you, you can skip this step. üòé

Tip

Do this **once** , right after you create the virtual environment.
    
    
    $ echo "*" > .venv/.gitignore
    

What that command means

  * `echo "*"`: will "print" the text `*` in the terminal (the next part changes that a bit)
  * `>`: anything printed to the terminal by the command to the left of `>` should not be printed but instead written to the file that goes to the right of `>`
  * `.gitignore`: the name of the file where the text should be written

And `*` for Git means "everything". So, it will ignore everything in the `.venv` directory.

That command will create a file `.gitignore` with the content:
    
    
    *
    

## Install Packages[¶](#install-packages "Permanent link")

After activating the environment, you can install packages in it.

Tip

Do this **once** when installing or upgrading the packages your project needs.

If you need to upgrade a version or add a new package you would **do this again**.

### Install Packages Directly[¶](#install-packages-directly "Permanent link")

If you're in a hurry and don't want to use a file to declare your project's package requirements, you can install them directly.

Tip

It's a (very) good idea to put the packages and versions your program needs in a file (for example `requirements.txt` or `pyproject.toml`).

`pip``uv`
    
    
    $ pip install "fastapi[standard]"
    
    ---> 100%
    

If you have [`uv`](https://github.com/astral-sh/uv):
    
    
    $ uv pip install "fastapi[standard]"
    ---> 100%
    

### Install from `requirements.txt`[¶](#install-from-requirements-txt "Permanent link")

If you have a `requirements.txt`, you can now use it to install its packages.

`pip``uv`
    
    
    $ pip install -r requirements.txt
    ---> 100%
    

If you have [`uv`](https://github.com/astral-sh/uv):
    
    
    $ uv pip install -r requirements.txt
    ---> 100%
    

`requirements.txt`

A `requirements.txt` with some packages could look like:
    
    
    fastapi[standard]==0.113.0
    pydantic==2.8.0
    

## Run Your Program[¶](#run-your-program "Permanent link")

After you activated the virtual environment, you can run your program, and it will use the Python inside of your virtual environment with the packages you installed there.
    
    
    $ python main.py
    
    Hello World
    

## Configure Your Editor[¶](#configure-your-editor "Permanent link")

You would probably use an editor, make sure you configure it to use the same virtual environment you created (it will probably autodetect it) so that you can get autocompletion and inline errors.

For example:

  * [VS Code](https://code.visualstudio.com/docs/python/environments#_select-and-activate-an-environment)
  * [PyCharm](https://www.jetbrains.com/help/pycharm/creating-virtual-environment.html)

Tip

You normally have to do this only **once** , when you create the virtual environment.

## Deactivate the Virtual Environment[¶](#deactivate-the-virtual-environment "Permanent link")

Once you are done working on your project you can **deactivate** the virtual environment.
    
    
    $ deactivate
    

This way, when you run `python` it won't try to run it from that virtual environment with the packages installed there.

## Ready to Work[¶](#ready-to-work "Permanent link")

Now you're ready to start working on your project.

Tip

Do you want to understand what's all that above?

Continue reading. üëáü§ì

## Why Virtual Environments[¶](#why-virtual-environments "Permanent link")

To work with FastAPI you need to install [Python](https://www.python.org/).

After that, you would need to **install** FastAPI and any other **packages** you want to use.

To install packages you would normally use the `pip` command that comes with Python (or similar alternatives).

Nevertheless, if you just use `pip` directly, the packages would be installed in your **global Python environment** (the global installation of Python).

### The Problem[¶](#the-problem "Permanent link")

So, what's the problem with installing packages in the global Python environment?

At some point, you will probably end up writing many different programs that depend on **different packages**. And some of these projects you work on will depend on **different versions** of the same package. üò±

For example, you could create a project called `philosophers-stone`, this program depends on another package called **`harry`, using the version `1`**. So, you need to install `harry`.
    
    
    flowchart LR
        stone(philosophers-stone) -->|requires| harry-1[harry v1]

Then, at some point later, you create another project called `prisoner-of-azkaban`, and this project also depends on `harry`, but this project needs **`harry` version `3`**.
    
    
    flowchart LR
        azkaban(prisoner-of-azkaban) --> |requires| harry-3[harry v3]

But now the problem is, if you install the packages globally (in the global environment) instead of in a local **virtual environment** , you will have to choose which version of `harry` to install.

If you want to run `philosophers-stone` you will need to first install `harry` version `1`, for example with:
    
    
    $ pip install "harry==1"
    

And then you would end up with `harry` version `1` installed in your global Python environment.
    
    
    flowchart LR
        subgraph global[global env]
            harry-1[harry v1]
        end
        subgraph stone-project[philosophers-stone project]
            stone(philosophers-stone) -->|requires| harry-1
        end

But then if you want to run `prisoner-of-azkaban`, you will need to uninstall `harry` version `1` and install `harry` version `3` (or just installing version `3` would automatically uninstall version `1`).
    
    
    $ pip install "harry==3"
    

And then you would end up with `harry` version `3` installed in your global Python environment.

And if you try to run `philosophers-stone` again, there's a chance it would **not work** because it needs `harry` version `1`.
    
    
    flowchart LR
        subgraph global[global env]
            harry-1[<strike>harry v1</strike>]
            style harry-1 fill:#ccc,stroke-dasharray: 5 5
            harry-3[harry v3]
        end
        subgraph stone-project[philosophers-stone project]
            stone(philosophers-stone) -.-x|‚õîÔ∏è| harry-1
        end
        subgraph azkaban-project[prisoner-of-azkaban project]
            azkaban(prisoner-of-azkaban) --> |requires| harry-3
        end

Tip

It's very common in Python packages to try the best to **avoid breaking changes** in **new versions** , but it's better to be safe, and install newer versions intentionally and when you can run the tests to check everything is working correctly.

Now, imagine that with **many** other **packages** that all your **projects depend on**. That's very difficult to manage. And you would probably end up running some projects with some **incompatible versions** of the packages, and not knowing why something isn't working.

Also, depending on your operating system (e.g. Linux, Windows, macOS), it could have come with Python already installed. And in that case it probably had some packages pre-installed with some specific versions **needed by your system**. If you install packages in the global Python environment, you could end up **breaking** some of the programs that came with your operating system.

## Where are Packages Installed[¶](#where-are-packages-installed "Permanent link")

When you install Python, it creates some directories with some files in your computer.

Some of these directories are the ones in charge of having all the packages you install.

When you run:
    
    
    // Don't run this now, it's just an example ü§ì
    $ pip install "fastapi[standard]"
    ---> 100%
    

That will download a compressed file with the FastAPI code, normally from [PyPI](https://pypi.org/project/fastapi/).

It will also **download** files for other packages that FastAPI depends on.

Then it will **extract** all those files and put them in a directory in your computer.

By default, it will put those files downloaded and extracted in the directory that comes with your Python installation, that's the **global environment**.

## What are Virtual Environments[¶](#what-are-virtual-environments "Permanent link")

The solution to the problems of having all the packages in the global environment is to use a **virtual environment for each project** you work on.

A virtual environment is a **directory** , very similar to the global one, where you can install the packages for a project.

This way, each project will have its own virtual environment (`.venv` directory) with its own packages.
    
    
    flowchart TB
        subgraph stone-project[philosophers-stone project]
            stone(philosophers-stone) --->|requires| harry-1
            subgraph venv1[.venv]
                harry-1[harry v1]
            end
        end
        subgraph azkaban-project[prisoner-of-azkaban project]
            azkaban(prisoner-of-azkaban) --->|requires| harry-3
            subgraph venv2[.venv]
                harry-3[harry v3]
            end
        end
        stone-project ~~~ azkaban-project

## What Does Activating a Virtual Environment Mean[¶](#what-does-activating-a-virtual-environment-mean "Permanent link")

When you activate a virtual environment, for example with:

Linux, macOSWindows PowerShellWindows Bash
    
    
    $ source .venv/bin/activate
    
    
    
    $ .venv\Scripts\Activate.ps1
    

Or if you use Bash for Windows (e.g. [Git Bash](https://gitforwindows.org/)):
    
    
    $ source .venv/Scripts/activate
    

That command will create or modify some [environment variables](../environment-variables/) that will be available for the next commands.

One of those variables is the `PATH` variable.

Tip

You can learn more about the `PATH` environment variable in the [Environment Variables](../environment-variables/#path-environment-variable) section.

Activating a virtual environment adds its path `.venv/bin` (on Linux and macOS) or `.venv\Scripts` (on Windows) to the `PATH` environment variable.

Let's say that before activating the environment, the `PATH` variable looked like this:

Linux, macOSWindows
    
    
    /usr/bin:/bin:/usr/sbin:/sbin
    

That means that the system would look for programs in:

  * `/usr/bin`
  * `/bin`
  * `/usr/sbin`
  * `/sbin`

    
    
    C:\Windows\System32
    

That means that the system would look for programs in:

  * `C:\Windows\System32`

After activating the virtual environment, the `PATH` variable would look something like this:

Linux, macOSWindows
    
    
    /home/user/code/awesome-project/.venv/bin:/usr/bin:/bin:/usr/sbin:/sbin
    

That means that the system will now start looking first for programs in:
    
    
    /home/user/code/awesome-project/.venv/bin
    

before looking in the other directories.

So, when you type `python` in the terminal, the system will find the Python program in
    
    
    /home/user/code/awesome-project/.venv/bin/python
    

and use that one.
    
    
    C:\Users\user\code\awesome-project\.venv\Scripts;C:\Windows\System32
    

That means that the system will now start looking first for programs in:
    
    
    C:\Users\user\code\awesome-project\.venv\Scripts
    

before looking in the other directories.

So, when you type `python` in the terminal, the system will find the Python program in
    
    
    C:\Users\user\code\awesome-project\.venv\Scripts\python
    

and use that one.

An important detail is that it will put the virtual environment path at the **beginning** of the `PATH` variable. The system will find it **before** finding any other Python available. This way, when you run `python`, it will use the Python **from the virtual environment** instead of any other `python` (for example, a `python` from a global environment).

Activating a virtual environment also changes a couple of other things, but this is one of the most important things it does.

## Checking a Virtual Environment[¶](#checking-a-virtual-environment "Permanent link")

When you check if a virtual environment is active, for example with:

Linux, macOS, Windows BashWindows PowerShell
    
    
    $ which python
    
    /home/user/code/awesome-project/.venv/bin/python
    
    
    
    $ Get-Command python
    
    C:\Users\user\code\awesome-project\.venv\Scripts\python
    

That means that the `python` program that will be used is the one **in the virtual environment**.

You use `which` in Linux and macOS and `Get-Command` in Windows PowerShell.

The way that command works is that it will go and check in the `PATH` environment variable, going through **each path in order** , looking for the program called `python`. Once it finds it, it will **show you the path** to that program.

The most important part is that when you call `python`, that is the exact "`python`" that will be executed.

So, you can confirm if you are in the correct virtual environment.

Tip

It's easy to activate one virtual environment, get one Python, and then **go to another project**.

And the second project **wouldn't work** because you are using the **incorrect Python** , from a virtual environment for another project.

It's useful being able to check what `python` is being used. ü§ì

## Why Deactivate a Virtual Environment[¶](#why-deactivate-a-virtual-environment "Permanent link")

For example, you could be working on a project `philosophers-stone`, **activate that virtual environment** , install packages and work with that environment.

And then you want to work on **another project** `prisoner-of-azkaban`.

You go to that project:
    
    
    $ cd ~/code/prisoner-of-azkaban
    

If you don't deactivate the virtual environment for `philosophers-stone`, when you run `python` in the terminal, it will try to use the Python from `philosophers-stone`.
    
    
    $ cd ~/code/prisoner-of-azkaban
    
    $ python main.py
    
    // Error importing sirius, it's not installed üò±
    Traceback (most recent call last):
        File "main.py", line 1, in <module>
            import sirius
    

But if you deactivate the virtual environment and activate the new one for `prisoner-of-askaban` then when you run `python` it will use the Python from the virtual environment in `prisoner-of-azkaban`.
    
    
    $ cd ~/code/prisoner-of-azkaban
    
    // You don't need to be in the old directory to deactivate, you can do it wherever you are, even after going to the other project üòé
    $ deactivate
    
    // Activate the virtual environment in prisoner-of-azkaban/.venv üöÄ
    $ source .venv/bin/activate
    
    // Now when you run python, it will find the package sirius installed in this virtual environment ‚ú®
    $ python main.py
    
    I solemnly swear üê∫
    

## Alternatives[¶](#alternatives "Permanent link")

This is a simple guide to get you started and teach you how everything works **underneath**.

There are many **alternatives** to managing virtual environments, package dependencies (requirements), projects.

Once you are ready and want to use a tool to **manage the entire project** , packages dependencies, virtual environments, etc. I would suggest you try [uv](https://github.com/astral-sh/uv).

`uv` can do a lot of things, it can:

  * **Install Python** for you, including different versions
  * Manage the **virtual environment** for your projects
  * Install **packages**
  * Manage package **dependencies and versions** for your project
  * Make sure you have an **exact** set of packages and versions to install, including their dependencies, so that you can be sure that you can run your project in production exactly the same as in your computer while developing, this is called **locking**
  * And many other things

## Conclusion[¶](#conclusion "Permanent link")

If you read and understood all this, now **you know much more** about virtual environments than many developers out there. ü§ì

Knowing these details will most probably be useful in a future time when you are debugging something that seems complex, but you will know **how it all works underneath**. üòé
  *[inside your project]: there are other options, this is a simple guideline
  *[ CLI]: command line interface

---

###### Tutorial - User Guide¶

# Tutorial - User Guide[¶](#tutorial-user-guide "Permanent link")

This tutorial shows you how to use **FastAPI** with most of its features, step by step.

Each section gradually builds on the previous ones, but it's structured to separate topics, so that you can go directly to any specific one to solve your specific API needs.

It is also built to work as a future reference so you can come back and see exactly what you need.

## Run the code[¶](#run-the-code "Permanent link")

All the code blocks can be copied and used directly (they are actually tested Python files).

To run any of the examples, copy the code to a file `main.py`, and start `fastapi dev` with:
    
    
    $ <font color="#4E9A06">fastapi</font> dev <u style="text-decoration-style:solid">main.py</u>
    
      <span style="background-color:#009485"><font color="#D3D7CF"> FastAPI </font></span>  Starting development server üöÄ
    
                 Searching for package file structure from directories
                 with <font color="#3465A4">__init__.py</font> files
                 Importing from <font color="#75507B">/home/user/code/</font><font color="#AD7FA8">awesomeapp</font>
    
       <span style="background-color:#007166"><font color="#D3D7CF"> module </font></span>  üêç main.py
    
         <span style="background-color:#007166"><font color="#D3D7CF"> code </font></span>  Importing the FastAPI app object from the module with
                 the following code:
    
                 <u style="text-decoration-style:solid">from </u><u style="text-decoration-style:solid"><b>main</b></u><u style="text-decoration-style:solid"> import </u><u style="text-decoration-style:solid"><b>app</b></u>
    
          <span style="background-color:#007166"><font color="#D3D7CF"> app </font></span>  Using import string: <font color="#3465A4">main:app</font>
    
       <span style="background-color:#007166"><font color="#D3D7CF"> server </font></span>  Server started at <font color="#729FCF"><u style="text-decoration-style:solid">http://127.0.0.1:8000</u></font>
       <span style="background-color:#007166"><font color="#D3D7CF"> server </font></span>  Documentation at <font color="#729FCF"><u style="text-decoration-style:solid">http://127.0.0.1:8000/docs</u></font>
    
          <span style="background-color:#007166"><font color="#D3D7CF"> tip </font></span>  Running in development mode, for production use:
                 <b>fastapi run</b>
    
                 Logs:
    
         <span style="background-color:#007166"><font color="#D3D7CF"> INFO </font></span>  Will watch for changes in these directories:
                 <b>[</b><font color="#4E9A06">&apos;/home/user/code/awesomeapp&apos;</font><b>]</b>
         <span style="background-color:#007166"><font color="#D3D7CF"> INFO </font></span>  Uvicorn running on <font color="#729FCF"><u style="text-decoration-style:solid">http://127.0.0.1:8000</u></font> <b>(</b>Press CTRL+C
                 to quit<b>)</b>
         <span style="background-color:#007166"><font color="#D3D7CF"> INFO </font></span>  Started reloader process <b>[</b><font color="#34E2E2"><b>383138</b></font><b>]</b> using WatchFiles
         <span style="background-color:#007166"><font color="#D3D7CF"> INFO </font></span>  Started server process <b>[</b><font color="#34E2E2"><b>383153</b></font><b>]</b>
         <span style="background-color:#007166"><font color="#D3D7CF"> INFO </font></span>  Waiting for application startup.
         <span style="background-color:#007166"><font color="#D3D7CF"> INFO </font></span>  Application startup complete.
    

It is **HIGHLY encouraged** that you write or copy the code, edit it and run it locally.

Using it in your editor is what really shows you the benefits of FastAPI, seeing how little code you have to write, all the type checks, autocompletion, etc.

* * *

## Install FastAPI[¶](#install-fastapi "Permanent link")

The first step is to install FastAPI.

Make sure you create a [virtual environment](../virtual-environments/), activate it, and then **install FastAPI** :
    
    
    $ pip install "fastapi[standard]"
    
    ---> 100%
    

Note

When you install with `pip install "fastapi[standard]"` it comes with some default optional standard dependencies, including `fastapi-cloud-cli`, which allows you to deploy to [FastAPI Cloud](https://fastapicloud.com).

If you don't want to have those optional dependencies, you can instead install `pip install fastapi`.

If you want to install the standard dependencies but without the `fastapi-cloud-cli`, you can install with `pip install "fastapi[standard-no-fastapi-cloud-cli]"`.

## Advanced User Guide[¶](#advanced-user-guide "Permanent link")

There is also an **Advanced User Guide** that you can read later after this **Tutorial - User guide**.

The **Advanced User Guide** builds on this one, uses the same concepts, and teaches you some extra features.

But you should first read the **Tutorial - User Guide** (what you are reading right now).

It's designed so that you can build a complete application with just the **Tutorial - User Guide** , and then extend it in different ways, depending on your needs, using some of the additional ideas from the **Advanced User Guide**.

---

###### First Steps¶

# First Steps[¶](#first-steps "Permanent link")

The simplest FastAPI file could look like this:

Python 3.9+
    
    
    from fastapi import FastAPI
    
    app = FastAPI()
    
    
    @app.get("/")
    async def root():
        return {"message": "Hello World"}
    

Copy that to a file `main.py`.

Run the live server:
    
    
    $ <font color="#4E9A06">fastapi</font> dev <u style="text-decoration-style:solid">main.py</u>
    
      <span style="background-color:#009485"><font color="#D3D7CF"> FastAPI </font></span>  Starting development server üöÄ
    
                 Searching for package file structure from directories
                 with <font color="#3465A4">__init__.py</font> files
                 Importing from <font color="#75507B">/home/user/code/</font><font color="#AD7FA8">awesomeapp</font>
    
       <span style="background-color:#007166"><font color="#D3D7CF"> module </font></span>  üêç main.py
    
         <span style="background-color:#007166"><font color="#D3D7CF"> code </font></span>  Importing the FastAPI app object from the module with
                 the following code:
    
                 <u style="text-decoration-style:solid">from </u><u style="text-decoration-style:solid"><b>main</b></u><u style="text-decoration-style:solid"> import </u><u style="text-decoration-style:solid"><b>app</b></u>
    
          <span style="background-color:#007166"><font color="#D3D7CF"> app </font></span>  Using import string: <font color="#3465A4">main:app</font>
    
       <span style="background-color:#007166"><font color="#D3D7CF"> server </font></span>  Server started at <font color="#729FCF"><u style="text-decoration-style:solid">http://127.0.0.1:8000</u></font>
       <span style="background-color:#007166"><font color="#D3D7CF"> server </font></span>  Documentation at <font color="#729FCF"><u style="text-decoration-style:solid">http://127.0.0.1:8000/docs</u></font>
    
          <span style="background-color:#007166"><font color="#D3D7CF"> tip </font></span>  Running in development mode, for production use:
                 <b>fastapi run</b>
    
                 Logs:
    
         <span style="background-color:#007166"><font color="#D3D7CF"> INFO </font></span>  Will watch for changes in these directories:
                 <b>[</b><font color="#4E9A06">&apos;/home/user/code/awesomeapp&apos;</font><b>]</b>
         <span style="background-color:#007166"><font color="#D3D7CF"> INFO </font></span>  Uvicorn running on <font color="#729FCF"><u style="text-decoration-style:solid">http://127.0.0.1:8000</u></font> <b>(</b>Press CTRL+C
                 to quit<b>)</b>
         <span style="background-color:#007166"><font color="#D3D7CF"> INFO </font></span>  Started reloader process <b>[</b><font color="#34E2E2"><b>383138</b></font><b>]</b> using WatchFiles
         <span style="background-color:#007166"><font color="#D3D7CF"> INFO </font></span>  Started server process <b>[</b><font color="#34E2E2"><b>383153</b></font><b>]</b>
         <span style="background-color:#007166"><font color="#D3D7CF"> INFO </font></span>  Waiting for application startup.
         <span style="background-color:#007166"><font color="#D3D7CF"> INFO </font></span>  Application startup complete.
    

In the output, there's a line with something like:
    
    
    INFO:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
    

That line shows the URL where your app is being served, in your local machine.

### Check it[¶](#check-it "Permanent link")

Open your browser at <http://127.0.0.1:8000>.

You will see the JSON response as:
    
    
    {"message": "Hello World"}
    

### Interactive API docs[¶](#interactive-api-docs "Permanent link")

Now go to <http://127.0.0.1:8000/docs>.

You will see the automatic interactive API documentation (provided by [Swagger UI](https://github.com/swagger-api/swagger-ui)):

![Swagger UI](https://fastapi.tiangolo.com/img/index/index-01-swagger-ui-simple.png)

### Alternative API docs[¶](#alternative-api-docs "Permanent link")

And now, go to <http://127.0.0.1:8000/redoc>.

You will see the alternative automatic documentation (provided by [ReDoc](https://github.com/Rebilly/ReDoc)):

![ReDoc](https://fastapi.tiangolo.com/img/index/index-02-redoc-simple.png)

### OpenAPI[¶](#openapi "Permanent link")

**FastAPI** generates a "schema" with all your API using the **OpenAPI** standard for defining APIs.

#### "Schema"[¶](#schema "Permanent link")

A "schema" is a definition or description of something. Not the code that implements it, but just an abstract description.

#### API "schema"[¶](#api-schema "Permanent link")

In this case, [OpenAPI](https://github.com/OAI/OpenAPI-Specification) is a specification that dictates how to define a schema of your API.

This schema definition includes your API paths, the possible parameters they take, etc.

#### Data "schema"[¶](#data-schema "Permanent link")

The term "schema" might also refer to the shape of some data, like a JSON content.

In that case, it would mean the JSON attributes, and data types they have, etc.

#### OpenAPI and JSON Schema[¶](#openapi-and-json-schema "Permanent link")

OpenAPI defines an API schema for your API. And that schema includes definitions (or "schemas") of the data sent and received by your API using **JSON Schema** , the standard for JSON data schemas.

#### Check the `openapi.json`[¶](#check-the-openapi-json "Permanent link")

If you are curious about how the raw OpenAPI schema looks like, FastAPI automatically generates a JSON (schema) with the descriptions of all your API.

You can see it directly at: <http://127.0.0.1:8000/openapi.json>.

It will show a JSON starting with something like:
    
    
    {
        "openapi": "3.1.0",
        "info": {
            "title": "FastAPI",
            "version": "0.1.0"
        },
        "paths": {
            "/items/": {
                "get": {
                    "responses": {
                        "200": {
                            "description": "Successful Response",
                            "content": {
                                "application/json": {
    
    
    
    ...
    

#### What is OpenAPI for[¶](#what-is-openapi-for "Permanent link")

The OpenAPI schema is what powers the two interactive documentation systems included.

And there are dozens of alternatives, all based on OpenAPI. You could easily add any of those alternatives to your application built with **FastAPI**.

You could also use it to generate code automatically, for clients that communicate with your API. For example, frontend, mobile or IoT applications.

### Deploy your app (optional)[¶](#deploy-your-app-optional "Permanent link")

You can optionally deploy your FastAPI app to [FastAPI Cloud](https://fastapicloud.com), go and join the waiting list if you haven't. üöÄ

If you already have a **FastAPI Cloud** account (we invited you from the waiting list üòâ), you can deploy your application with one command.

Before deploying, make sure you are logged in:
    
    
    $ fastapi login
    
    You are logged in to FastAPI Cloud üöÄ
    

Then deploy your app:
    
    
    $ fastapi deploy
    
    Deploying to FastAPI Cloud...
    
    ‚úÖ Deployment successful!
    
    üêî Ready the chicken! Your app is ready at https://myapp.fastapicloud.dev
    

That's it! Now you can access your app at that URL. ‚ú®

## Recap, step by step[¶](#recap-step-by-step "Permanent link")

### Step 1: import `FastAPI`[¶](#step-1-import-fastapi "Permanent link")

Python 3.9+
    
    
    from fastapi import FastAPI
    
    app = FastAPI()
    
    
    @app.get("/")
    async def root():
        return {"message": "Hello World"}
    

`FastAPI` is a Python class that provides all the functionality for your API.

Technical Details

`FastAPI` is a class that inherits directly from `Starlette`.

You can use all the [Starlette](https://www.starlette.dev/) functionality with `FastAPI` too.

### Step 2: create a `FastAPI` "instance"[¶](#step-2-create-a-fastapi-instance "Permanent link")

Python 3.9+
    
    
    from fastapi import FastAPI
    
    app = FastAPI()
    
    
    @app.get("/")
    async def root():
        return {"message": "Hello World"}
    

Here the `app` variable will be an "instance" of the class `FastAPI`.

This will be the main point of interaction to create all your API.

### Step 3: create a _path operation_[¶](#step-3-create-a-path-operation "Permanent link")

#### Path[¶](#path "Permanent link")

"Path" here refers to the last part of the URL starting from the first `/`.

So, in a URL like:
    
    
    https://example.com/items/foo
    

...the path would be:
    
    
    /items/foo
    

Info

A "path" is also commonly called an "endpoint" or a "route".

While building an API, the "path" is the main way to separate "concerns" and "resources".

#### Operation[¶](#operation "Permanent link")

"Operation" here refers to one of the HTTP "methods".

One of:

  * `POST`
  * `GET`
  * `PUT`
  * `DELETE`

...and the more exotic ones:

  * `OPTIONS`
  * `HEAD`
  * `PATCH`
  * `TRACE`

In the HTTP protocol, you can communicate to each path using one (or more) of these "methods".

* * *

When building APIs, you normally use these specific HTTP methods to perform a specific action.

Normally you use:

  * `POST`: to create data.
  * `GET`: to read data.
  * `PUT`: to update data.
  * `DELETE`: to delete data.

So, in OpenAPI, each of the HTTP methods is called an "operation".

We are going to call them "**operations** " too.

#### Define a _path operation decorator_[¶](#define-a-path-operation-decorator "Permanent link")

Python 3.9+
    
    
    from fastapi import FastAPI
    
    app = FastAPI()
    
    
    @app.get("/")
    async def root():
        return {"message": "Hello World"}
    

The `@app.get("/")` tells **FastAPI** that the function right below is in charge of handling requests that go to:

  * the path `/`
  * using a `get` operation

`@decorator` Info

That `@something` syntax in Python is called a "decorator".

You put it on top of a function. Like a pretty decorative hat (I guess that's where the term came from).

A "decorator" takes the function below and does something with it.

In our case, this decorator tells **FastAPI** that the function below corresponds to the **path** `/` with an **operation** `get`.

It is the "**path operation decorator** ".

You can also use the other operations:

  * `@app.post()`
  * `@app.put()`
  * `@app.delete()`

And the more exotic ones:

  * `@app.options()`
  * `@app.head()`
  * `@app.patch()`
  * `@app.trace()`

Tip

You are free to use each operation (HTTP method) as you wish.

**FastAPI** doesn't enforce any specific meaning.

The information here is presented as a guideline, not a requirement.

For example, when using GraphQL you normally perform all the actions using only `POST` operations.

### Step 4: define the **path operation function**[¶](#step-4-define-the-path-operation-function "Permanent link")

This is our "**path operation function** ":

  * **path** : is `/`.
  * **operation** : is `get`.
  * **function** : is the function below the "decorator" (below `@app.get("/")`).

Python 3.9+
    
    
    from fastapi import FastAPI
    
    app = FastAPI()
    
    
    @app.get("/")
    async def root():
        return {"message": "Hello World"}
    

This is a Python function.

It will be called by **FastAPI** whenever it receives a request to the URL "`/`" using a `GET` operation.

In this case, it is an `async` function.

* * *

You could also define it as a normal function instead of `async def`:

Python 3.9+
    
    
    from fastapi import FastAPI
    
    app = FastAPI()
    
    
    @app.get("/")
    def root():
        return {"message": "Hello World"}
    

Note

If you don't know the difference, check the [Async: _"In a hurry?"_](../../async/#in-a-hurry).

### Step 5: return the content[¶](#step-5-return-the-content "Permanent link")

Python 3.9+
    
    
    from fastapi import FastAPI
    
    app = FastAPI()
    
    
    @app.get("/")
    async def root():
        return {"message": "Hello World"}
    

You can return a `dict`, `list`, singular values as `str`, `int`, etc.

You can also return Pydantic models (you'll see more about that later).

There are many other objects and models that will be automatically converted to JSON (including ORMs, etc). Try using your favorite ones, it's highly probable that they are already supported.

### Step 6: Deploy it[¶](#step-6-deploy-it "Permanent link")

Deploy your app to **[FastAPI Cloud](https://fastapicloud.com)** with one command: `fastapi deploy`. üéâ

#### About FastAPI Cloud[¶](#about-fastapi-cloud "Permanent link")

**[FastAPI Cloud](https://fastapicloud.com)** is built by the same author and team behind **FastAPI**.

It streamlines the process of **building** , **deploying** , and **accessing** an API with minimal effort.

It brings the same **developer experience** of building apps with FastAPI to **deploying** them to the cloud. üéâ

FastAPI Cloud is the primary sponsor and funding provider for the _FastAPI and friends_ open source projects. ‚ú®

#### Deploy to other cloud providers[¶](#deploy-to-other-cloud-providers "Permanent link")

FastAPI is open source and based on standards. You can deploy FastAPI apps to any cloud provider you choose.

Follow your cloud provider's guides to deploy FastAPI apps with them. ü§ì

## Recap[¶](#recap "Permanent link")

  * Import `FastAPI`.
  * Create an `app` instance.
  * Write a **path operation decorator** using decorators like `@app.get("/")`.
  * Define a **path operation function** ; for example, `def root(): ...`.
  * Run the development server using the command `fastapi dev`.
  * Optionally deploy your app with `fastapi deploy`.

  *[`get` operation]: an HTTP GET method

---

###### Path Parameters¶

# Path Parameters[¶](#path-parameters "Permanent link")

You can declare path "parameters" or "variables" with the same syntax used by Python format strings:

Python 3.9+
    
    
    from fastapi import FastAPI
    
    app = FastAPI()
    
    
    @app.get("/items/{item_id}")
    async def read_item(item_id):
        return {"item_id": item_id}
    

The value of the path parameter `item_id` will be passed to your function as the argument `item_id`.

So, if you run this example and go to <http://127.0.0.1:8000/items/foo>, you will see a response of:
    
    
    {"item_id":"foo"}
    

## Path parameters with types[¶](#path-parameters-with-types "Permanent link")

You can declare the type of a path parameter in the function, using standard Python type annotations:

Python 3.9+
    
    
    from fastapi import FastAPI
    
    app = FastAPI()
    
    
    @app.get("/items/{item_id}")
    async def read_item(item_id: int):
        return {"item_id": item_id}
    

In this case, `item_id` is declared to be an `int`.

Check

This will give you editor support inside of your function, with error checks, completion, etc.

## Data conversion[¶](#data-conversion "Permanent link")

If you run this example and open your browser at <http://127.0.0.1:8000/items/3>, you will see a response of:
    
    
    {"item_id":3}
    

Check

Notice that the value your function received (and returned) is `3`, as a Python `int`, not a string `"3"`.

So, with that type declaration, **FastAPI** gives you automatic request "parsing".

## Data validation[¶](#data-validation "Permanent link")

But if you go to the browser at <http://127.0.0.1:8000/items/foo>, you will see a nice HTTP error of:
    
    
    {
      "detail": [
        {
          "type": "int_parsing",
          "loc": [
            "path",
            "item_id"
          ],
          "msg": "Input should be a valid integer, unable to parse string as an integer",
          "input": "foo"
        }
      ]
    }
    

because the path parameter `item_id` had a value of `"foo"`, which is not an `int`.

The same error would appear if you provided a `float` instead of an `int`, as in: <http://127.0.0.1:8000/items/4.2>

Check

So, with the same Python type declaration, **FastAPI** gives you data validation.

Notice that the error also clearly states exactly the point where the validation didn't pass.

This is incredibly helpful while developing and debugging code that interacts with your API.

## Documentation[¶](#documentation "Permanent link")

And when you open your browser at <http://127.0.0.1:8000/docs>, you will see an automatic, interactive, API documentation like:

![](/img/tutorial/path-params/image01.png)

Check

Again, just with that same Python type declaration, **FastAPI** gives you automatic, interactive documentation (integrating Swagger UI).

Notice that the path parameter is declared to be an integer.

## Standards-based benefits, alternative documentation[¶](#standards-based-benefits-alternative-documentation "Permanent link")

And because the generated schema is from the [OpenAPI](https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.1.0.md) standard, there are many compatible tools.

Because of this, **FastAPI** itself provides an alternative API documentation (using ReDoc), which you can access at <http://127.0.0.1:8000/redoc>:

![](/img/tutorial/path-params/image02.png)

The same way, there are many compatible tools. Including code generation tools for many languages.

## Pydantic[¶](#pydantic "Permanent link")

All the data validation is performed under the hood by [Pydantic](https://docs.pydantic.dev/), so you get all the benefits from it. And you know you are in good hands.

You can use the same type declarations with `str`, `float`, `bool` and many other complex data types.

Several of these are explored in the next chapters of the tutorial.

## Order matters[¶](#order-matters "Permanent link")

When creating _path operations_ , you can find situations where you have a fixed path.

Like `/users/me`, let's say that it's to get data about the current user.

And then you can also have a path `/users/{user_id}` to get data about a specific user by some user ID.

Because _path operations_ are evaluated in order, you need to make sure that the path for `/users/me` is declared before the one for `/users/{user_id}`:

Python 3.9+
    
    
    from fastapi import FastAPI
    
    app = FastAPI()
    
    
    @app.get("/users/me")
    async def read_user_me():
        return {"user_id": "the current user"}
    
    
    @app.get("/users/{user_id}")
    async def read_user(user_id: str):
        return {"user_id": user_id}
    

Otherwise, the path for `/users/{user_id}` would match also for `/users/me`, "thinking" that it's receiving a parameter `user_id` with a value of `"me"`.

Similarly, you cannot redefine a path operation:

Python 3.9+
    
    
    from fastapi import FastAPI
    
    app = FastAPI()
    
    
    @app.get("/users")
    async def read_users():
        return ["Rick", "Morty"]
    
    
    @app.get("/users")
    async def read_users2():
        return ["Bean", "Elfo"]
    

The first one will always be used since the path matches first.

## Predefined values[¶](#predefined-values "Permanent link")

If you have a _path operation_ that receives a _path parameter_ , but you want the possible valid _path parameter_ values to be predefined, you can use a standard Python `Enum`.

### Create an `Enum` class[¶](#create-an-enum-class "Permanent link")

Import `Enum` and create a sub-class that inherits from `str` and from `Enum`.

By inheriting from `str` the API docs will be able to know that the values must be of type `string` and will be able to render correctly.

Then create class attributes with fixed values, which will be the available valid values:

Python 3.9+
    
    
    from enum import Enum
    
    from fastapi import FastAPI
    
    
    class ModelName(str, Enum):
        alexnet = "alexnet"
        resnet = "resnet"
        lenet = "lenet"
    
    
    app = FastAPI()
    
    
    @app.get("/models/{model_name}")
    async def get_model(model_name: ModelName):
        if model_name is ModelName.alexnet:
            return {"model_name": model_name, "message": "Deep Learning FTW!"}
    
        if model_name.value == "lenet":
            return {"model_name": model_name, "message": "LeCNN all the images"}
    
        return {"model_name": model_name, "message": "Have some residuals"}
    

Tip

If you are wondering, "AlexNet", "ResNet", and "LeNet" are just names of Machine Learning models.

### Declare a _path parameter_[¶](#declare-a-path-parameter "Permanent link")

Then create a _path parameter_ with a type annotation using the enum class you created (`ModelName`):

Python 3.9+
    
    
    from enum import Enum
    
    from fastapi import FastAPI
    
    
    class ModelName(str, Enum):
        alexnet = "alexnet"
        resnet = "resnet"
        lenet = "lenet"
    
    
    app = FastAPI()
    
    
    @app.get("/models/{model_name}")
    async def get_model(model_name: ModelName):
        if model_name is ModelName.alexnet:
            return {"model_name": model_name, "message": "Deep Learning FTW!"}
    
        if model_name.value == "lenet":
            return {"model_name": model_name, "message": "LeCNN all the images"}
    
        return {"model_name": model_name, "message": "Have some residuals"}
    

### Check the docs[¶](#check-the-docs "Permanent link")

Because the available values for the _path parameter_ are predefined, the interactive docs can show them nicely:

![](/img/tutorial/path-params/image03.png)

### Working with Python _enumerations_[¶](#working-with-python-enumerations "Permanent link")

The value of the _path parameter_ will be an _enumeration member_.

#### Compare _enumeration members_[¶](#compare-enumeration-members "Permanent link")

You can compare it with the _enumeration member_ in your created enum `ModelName`:

Python 3.9+
    
    
    from enum import Enum
    
    from fastapi import FastAPI
    
    
    class ModelName(str, Enum):
        alexnet = "alexnet"
        resnet = "resnet"
        lenet = "lenet"
    
    
    app = FastAPI()
    
    
    @app.get("/models/{model_name}")
    async def get_model(model_name: ModelName):
        if model_name is ModelName.alexnet:
            return {"model_name": model_name, "message": "Deep Learning FTW!"}
    
        if model_name.value == "lenet":
            return {"model_name": model_name, "message": "LeCNN all the images"}
    
        return {"model_name": model_name, "message": "Have some residuals"}
    

#### Get the _enumeration value_[¶](#get-the-enumeration-value "Permanent link")

You can get the actual value (a `str` in this case) using `model_name.value`, or in general, `your_enum_member.value`:

Python 3.9+
    
    
    from enum import Enum
    
    from fastapi import FastAPI
    
    
    class ModelName(str, Enum):
        alexnet = "alexnet"
        resnet = "resnet"
        lenet = "lenet"
    
    
    app = FastAPI()
    
    
    @app.get("/models/{model_name}")
    async def get_model(model_name: ModelName):
        if model_name is ModelName.alexnet:
            return {"model_name": model_name, "message": "Deep Learning FTW!"}
    
        if model_name.value == "lenet":
            return {"model_name": model_name, "message": "LeCNN all the images"}
    
        return {"model_name": model_name, "message": "Have some residuals"}
    

Tip

You could also access the value `"lenet"` with `ModelName.lenet.value`.

#### Return _enumeration members_[¶](#return-enumeration-members "Permanent link")

You can return _enum members_ from your _path operation_ , even nested in a JSON body (e.g. a `dict`).

They will be converted to their corresponding values (strings in this case) before returning them to the client:

Python 3.9+
    
    
    from enum import Enum
    
    from fastapi import FastAPI
    
    
    class ModelName(str, Enum):
        alexnet = "alexnet"
        resnet = "resnet"
        lenet = "lenet"
    
    
    app = FastAPI()
    
    
    @app.get("/models/{model_name}")
    async def get_model(model_name: ModelName):
        if model_name is ModelName.alexnet:
            return {"model_name": model_name, "message": "Deep Learning FTW!"}
    
        if model_name.value == "lenet":
            return {"model_name": model_name, "message": "LeCNN all the images"}
    
        return {"model_name": model_name, "message": "Have some residuals"}
    

In your client you will get a JSON response like:
    
    
    {
      "model_name": "alexnet",
      "message": "Deep Learning FTW!"
    }
    

## Path parameters containing paths[¶](#path-parameters-containing-paths "Permanent link")

Let's say you have a _path operation_ with a path `/files/{file_path}`.

But you need `file_path` itself to contain a _path_ , like `home/johndoe/myfile.txt`.

So, the URL for that file would be something like: `/files/home/johndoe/myfile.txt`.

### OpenAPI support[¶](#openapi-support "Permanent link")

OpenAPI doesn't support a way to declare a _path parameter_ to contain a _path_ inside, as that could lead to scenarios that are difficult to test and define.

Nevertheless, you can still do it in **FastAPI** , using one of the internal tools from Starlette.

And the docs would still work, although not adding any documentation telling that the parameter should contain a path.

### Path convertor[¶](#path-convertor "Permanent link")

Using an option directly from Starlette you can declare a _path parameter_ containing a _path_ using a URL like:
    
    
    /files/{file_path:path}
    

In this case, the name of the parameter is `file_path`, and the last part, `:path`, tells it that the parameter should match any _path_.

So, you can use it with:

Python 3.9+
    
    
    from fastapi import FastAPI
    
    app = FastAPI()
    
    
    @app.get("/files/{file_path:path}")
    async def read_file(file_path: str):
        return {"file_path": file_path}
    

Tip

You might need the parameter to contain `/home/johndoe/myfile.txt`, with a leading slash (`/`).

In that case, the URL would be: `/files//home/johndoe/myfile.txt`, with a double slash (`//`) between `files` and `home`.

## Recap[¶](#recap "Permanent link")

With **FastAPI** , by using short, intuitive and standard Python type declarations, you get:

  * Editor support: error checks, autocompletion, etc.
  * Data "parsing"
  * Data validation
  * API annotation and automatic documentation

And you only have to declare them once.

That's probably the main visible advantage of **FastAPI** compared to alternative frameworks (apart from the raw performance).
  *[conversion]: also known as: serialization, parsing, marshalling
  *["parsing"]: converting the string that comes from an HTTP request into Python data
  *[`Enum`]: Enumeration
  *[models]: Technically, Deep Learning model architectures
  *[parsing]: converting the string that comes from an HTTP request into Python data

---

###### Query Parameters¶

# Query Parameters[¶](#query-parameters "Permanent link")

When you declare other function parameters that are not part of the path parameters, they are automatically interpreted as "query" parameters.

Python 3.9+
    
    
    from fastapi import FastAPI
    
    app = FastAPI()
    
    fake_items_db = [{"item_name": "Foo"}, {"item_name": "Bar"}, {"item_name": "Baz"}]
    
    
    @app.get("/items/")
    async def read_item(skip: int = 0, limit: int = 10):
        return fake_items_db[skip : skip + limit]
    

The query is the set of key-value pairs that go after the `?` in a URL, separated by `&` characters.

For example, in the URL:
    
    
    http://127.0.0.1:8000/items/?skip=0&limit=10
    

...the query parameters are:

  * `skip`: with a value of `0`
  * `limit`: with a value of `10`

As they are part of the URL, they are "naturally" strings.

But when you declare them with Python types (in the example above, as `int`), they are converted to that type and validated against it.

All the same process that applied for path parameters also applies for query parameters:

  * Editor support (obviously)
  * Data "parsing"
  * Data validation
  * Automatic documentation

## Defaults[¶](#defaults "Permanent link")

As query parameters are not a fixed part of a path, they can be optional and can have default values.

In the example above they have default values of `skip=0` and `limit=10`.

So, going to the URL:
    
    
    http://127.0.0.1:8000/items/
    

would be the same as going to:
    
    
    http://127.0.0.1:8000/items/?skip=0&limit=10
    

But if you go to, for example:
    
    
    http://127.0.0.1:8000/items/?skip=20
    

The parameter values in your function will be:

  * `skip=20`: because you set it in the URL
  * `limit=10`: because that was the default value

## Optional parameters[¶](#optional-parameters "Permanent link")

The same way, you can declare optional query parameters, by setting their default to `None`:

Python 3.10+
    
    
    from fastapi import FastAPI
    
    app = FastAPI()
    
    
    @app.get("/items/{item_id}")
    async def read_item(item_id: str, q: str | None = None):
        if q:
            return {"item_id": item_id, "q": q}
        return {"item_id": item_id}
    

ü§ì Other versions and variants

Python 3.9+
    
    
    from typing import Union
    
    from fastapi import FastAPI
    
    app = FastAPI()
    
    
    @app.get("/items/{item_id}")
    async def read_item(item_id: str, q: Union[str, None] = None):
        if q:
            return {"item_id": item_id, "q": q}
        return {"item_id": item_id}
    

In this case, the function parameter `q` will be optional, and will be `None` by default.

Check

Also notice that **FastAPI** is smart enough to notice that the path parameter `item_id` is a path parameter and `q` is not, so, it's a query parameter.

## Query parameter type conversion[¶](#query-parameter-type-conversion "Permanent link")

You can also declare `bool` types, and they will be converted:

Python 3.10+
    
    
    from fastapi import FastAPI
    
    app = FastAPI()
    
    
    @app.get("/items/{item_id}")
    async def read_item(item_id: str, q: str | None = None, short: bool = False):
        item = {"item_id": item_id}
        if q:
            item.update({"q": q})
        if not short:
            item.update(
                {"description": "This is an amazing item that has a long description"}
            )
        return item
    

ü§ì Other versions and variants

Python 3.9+
    
    
    from typing import Union
    
    from fastapi import FastAPI
    
    app = FastAPI()
    
    
    @app.get("/items/{item_id}")
    async def read_item(item_id: str, q: Union[str, None] = None, short: bool = False):
        item = {"item_id": item_id}
        if q:
            item.update({"q": q})
        if not short:
            item.update(
                {"description": "This is an amazing item that has a long description"}
            )
        return item
    

In this case, if you go to:
    
    
    http://127.0.0.1:8000/items/foo?short=1
    

or
    
    
    http://127.0.0.1:8000/items/foo?short=True
    

or
    
    
    http://127.0.0.1:8000/items/foo?short=true
    

or
    
    
    http://127.0.0.1:8000/items/foo?short=on
    

or
    
    
    http://127.0.0.1:8000/items/foo?short=yes
    

or any other case variation (uppercase, first letter in uppercase, etc), your function will see the parameter `short` with a `bool` value of `True`. Otherwise as `False`.

## Multiple path and query parameters[¶](#multiple-path-and-query-parameters "Permanent link")

You can declare multiple path parameters and query parameters at the same time, **FastAPI** knows which is which.

And you don't have to declare them in any specific order.

They will be detected by name:

Python 3.10+
    
    
    from fastapi import FastAPI
    
    app = FastAPI()
    
    
    @app.get("/users/{user_id}/items/{item_id}")
    async def read_user_item(
        user_id: int, item_id: str, q: str | None = None, short: bool = False
    ):
        item = {"item_id": item_id, "owner_id": user_id}
        if q:
            item.update({"q": q})
        if not short:
            item.update(
                {"description": "This is an amazing item that has a long description"}
            )
        return item
    

ü§ì Other versions and variants

Python 3.9+
    
    
    from typing import Union
    
    from fastapi import FastAPI
    
    app = FastAPI()
    
    
    @app.get("/users/{user_id}/items/{item_id}")
    async def read_user_item(
        user_id: int, item_id: str, q: Union[str, None] = None, short: bool = False
    ):
        item = {"item_id": item_id, "owner_id": user_id}
        if q:
            item.update({"q": q})
        if not short:
            item.update(
                {"description": "This is an amazing item that has a long description"}
            )
        return item
    

## Required query parameters[¶](#required-query-parameters "Permanent link")

When you declare a default value for non-path parameters (for now, we have only seen query parameters), then it is not required.

If you don't want to add a specific value but just make it optional, set the default as `None`.

But when you want to make a query parameter required, you can just not declare any default value:

Python 3.9+
    
    
    from fastapi import FastAPI
    
    app = FastAPI()
    
    
    @app.get("/items/{item_id}")
    async def read_user_item(item_id: str, needy: str):
        item = {"item_id": item_id, "needy": needy}
        return item
    

Here the query parameter `needy` is a required query parameter of type `str`.

If you open in your browser a URL like:
    
    
    http://127.0.0.1:8000/items/foo-item
    

...without adding the required parameter `needy`, you will see an error like:
    
    
    {
      "detail": [
        {
          "type": "missing",
          "loc": [
            "query",
            "needy"
          ],
          "msg": "Field required",
          "input": null
        }
      ]
    }
    

As `needy` is a required parameter, you would need to set it in the URL:
    
    
    http://127.0.0.1:8000/items/foo-item?needy=sooooneedy
    

...this would work:
    
    
    {
        "item_id": "foo-item",
        "needy": "sooooneedy"
    }
    

And of course, you can define some parameters as required, some as having a default value, and some entirely optional:

Python 3.10+
    
    
    from fastapi import FastAPI
    
    app = FastAPI()
    
    
    @app.get("/items/{item_id}")
    async def read_user_item(
        item_id: str, needy: str, skip: int = 0, limit: int | None = None
    ):
        item = {"item_id": item_id, "needy": needy, "skip": skip, "limit": limit}
        return item
    

ü§ì Other versions and variants

Python 3.9+
    
    
    from typing import Union
    
    from fastapi import FastAPI
    
    app = FastAPI()
    
    
    @app.get("/items/{item_id}")
    async def read_user_item(
        item_id: str, needy: str, skip: int = 0, limit: Union[int, None] = None
    ):
        item = {"item_id": item_id, "needy": needy, "skip": skip, "limit": limit}
        return item
    

In this case, there are 3 query parameters:

  * `needy`, a required `str`.
  * `skip`, an `int` with a default value of `0`.
  * `limit`, an optional `int`.

Tip

You could also use `Enum`s the same way as with [Path Parameters](../path-params/#predefined-values).
  *["parsing"]: converting the string that comes from an HTTP request into Python data

---

###### Request Body¶

# Request Body[¶](#request-body "Permanent link")

When you need to send data from a client (let's say, a browser) to your API, you send it as a **request body**.

A **request** body is data sent by the client to your API. A **response** body is the data your API sends to the client.

Your API almost always has to send a **response** body. But clients don't necessarily need to send **request bodies** all the time, sometimes they only request a path, maybe with some query parameters, but don't send a body.

To declare a **request** body, you use [Pydantic](https://docs.pydantic.dev/) models with all their power and benefits.

Info

To send data, you should use one of: `POST` (the more common), `PUT`, `DELETE` or `PATCH`.

Sending a body with a `GET` request has an undefined behavior in the specifications, nevertheless, it is supported by FastAPI, only for very complex/extreme use cases.

As it is discouraged, the interactive docs with Swagger UI won't show the documentation for the body when using `GET`, and proxies in the middle might not support it.

## Import Pydantic's `BaseModel`[¶](#import-pydantics-basemodel "Permanent link")

First, you need to import `BaseModel` from `pydantic`:

Python 3.10+
    
    
    from fastapi import FastAPI
    from pydantic import BaseModel
    
    
    class Item(BaseModel):
        name: str
        description: str | None = None
        price: float
        tax: float | None = None
    
    
    app = FastAPI()
    
    
    @app.post("/items/")
    async def create_item(item: Item):
        return item
    

ü§ì Other versions and variants

Python 3.9+
    
    
    from typing import Union
    
    from fastapi import FastAPI
    from pydantic import BaseModel
    
    
    class Item(BaseModel):
        name: str
        description: Union[str, None] = None
        price: float
        tax: Union[float, None] = None
    
    
    app = FastAPI()
    
    
    @app.post("/items/")
    async def create_item(item: Item):
        return item
    

## Create your data model[¶](#create-your-data-model "Permanent link")

Then you declare your data model as a class that inherits from `BaseModel`.

Use standard Python types for all the attributes:

Python 3.10+
    
    
    from fastapi import FastAPI
    from pydantic import BaseModel
    
    
    class Item(BaseModel):
        name: str
        description: str | None = None
        price: float
        tax: float | None = None
    
    
    app = FastAPI()
    
    
    @app.post("/items/")
    async def create_item(item: Item):
        return item
    

ü§ì Other versions and variants

Python 3.9+
    
    
    from typing import Union
    
    from fastapi import FastAPI
    from pydantic import BaseModel
    
    
    class Item(BaseModel):
        name: str
        description: Union[str, None] = None
        price: float
        tax: Union[float, None] = None
    
    
    app = FastAPI()
    
    
    @app.post("/items/")
    async def create_item(item: Item):
        return item
    

The same as when declaring query parameters, when a model attribute has a default value, it is not required. Otherwise, it is required. Use `None` to make it just optional.

For example, this model above declares a JSON "`object`" (or Python `dict`) like:
    
    
    {
        "name": "Foo",
        "description": "An optional description",
        "price": 45.2,
        "tax": 3.5
    }
    

...as `description` and `tax` are optional (with a default value of `None`), this JSON "`object`" would also be valid:
    
    
    {
        "name": "Foo",
        "price": 45.2
    }
    

## Declare it as a parameter[¶](#declare-it-as-a-parameter "Permanent link")

To add it to your _path operation_ , declare it the same way you declared path and query parameters:

Python 3.10+
    
    
    from fastapi import FastAPI
    from pydantic import BaseModel
    
    
    class Item(BaseModel):
        name: str
        description: str | None = None
        price: float
        tax: float | None = None
    
    
    app = FastAPI()
    
    
    @app.post("/items/")
    async def create_item(item: Item):
        return item
    

ü§ì Other versions and variants

Python 3.9+
    
    
    from typing import Union
    
    from fastapi import FastAPI
    from pydantic import BaseModel
    
    
    class Item(BaseModel):
        name: str
        description: Union[str, None] = None
        price: float
        tax: Union[float, None] = None
    
    
    app = FastAPI()
    
    
    @app.post("/items/")
    async def create_item(item: Item):
        return item
    

...and declare its type as the model you created, `Item`.

## Results[¶](#results "Permanent link")

With just that Python type declaration, **FastAPI** will:

  * Read the body of the request as JSON.
  * Convert the corresponding types (if needed).
  * Validate the data.
    * If the data is invalid, it will return a nice and clear error, indicating exactly where and what was the incorrect data.
  * Give you the received data in the parameter `item`.
    * As you declared it in the function to be of type `Item`, you will also have all the editor support (completion, etc) for all of the attributes and their types.
  * Generate [JSON Schema](https://json-schema.org) definitions for your model, you can also use them anywhere else you like if it makes sense for your project.
  * Those schemas will be part of the generated OpenAPI schema, and used by the automatic documentation UIs.

## Automatic docs[¶](#automatic-docs "Permanent link")

The JSON Schemas of your models will be part of your OpenAPI generated schema, and will be shown in the interactive API docs:

![](/img/tutorial/body/image01.png)

And will also be used in the API docs inside each _path operation_ that needs them:

![](/img/tutorial/body/image02.png)

## Editor support[¶](#editor-support "Permanent link")

In your editor, inside your function you will get type hints and completion everywhere (this wouldn't happen if you received a `dict` instead of a Pydantic model):

![](/img/tutorial/body/image03.png)

You also get error checks for incorrect type operations:

![](/img/tutorial/body/image04.png)

This is not by chance, the whole framework was built around that design.

And it was thoroughly tested at the design phase, before any implementation, to ensure it would work with all the editors.

There were even some changes to Pydantic itself to support this.

The previous screenshots were taken with [Visual Studio Code](https://code.visualstudio.com).

But you would get the same editor support with [PyCharm](https://www.jetbrains.com/pycharm/) and most of the other Python editors:

![](/img/tutorial/body/image05.png)

Tip

If you use [PyCharm](https://www.jetbrains.com/pycharm/) as your editor, you can use the [Pydantic PyCharm Plugin](https://github.com/koxudaxi/pydantic-pycharm-plugin/).

It improves editor support for Pydantic models, with:

  * auto-completion
  * type checks
  * refactoring
  * searching
  * inspections

## Use the model[¶](#use-the-model "Permanent link")

Inside of the function, you can access all the attributes of the model object directly:

Python 3.10+
    
    
    from fastapi import FastAPI
    from pydantic import BaseModel
    
    
    class Item(BaseModel):
        name: str
        description: str | None = None
        price: float
        tax: float | None = None
    
    
    app = FastAPI()
    
    
    @app.post("/items/")
    async def create_item(item: Item):
        item_dict = item.model_dump()
        if item.tax is not None:
            price_with_tax = item.price + item.tax
            item_dict.update({"price_with_tax": price_with_tax})
        return item_dict
    

ü§ì Other versions and variants

Python 3.9+
    
    
    from typing import Union
    
    from fastapi import FastAPI
    from pydantic import BaseModel
    
    
    class Item(BaseModel):
        name: str
        description: Union[str, None] = None
        price: float
        tax: Union[float, None] = None
    
    
    app = FastAPI()
    
    
    @app.post("/items/")
    async def create_item(item: Item):
        item_dict = item.model_dump()
        if item.tax is not None:
            price_with_tax = item.price + item.tax
            item_dict.update({"price_with_tax": price_with_tax})
        return item_dict
    

## Request body + path parameters[¶](#request-body-path-parameters "Permanent link")

You can declare path parameters and request body at the same time.

**FastAPI** will recognize that the function parameters that match path parameters should be **taken from the path** , and that function parameters that are declared to be Pydantic models should be **taken from the request body**.

Python 3.10+
    
    
    from fastapi import FastAPI
    from pydantic import BaseModel
    
    
    class Item(BaseModel):
        name: str
        description: str | None = None
        price: float
        tax: float | None = None
    
    
    app = FastAPI()
    
    
    @app.put("/items/{item_id}")
    async def update_item(item_id: int, item: Item):
        return {"item_id": item_id, **item.model_dump()}
    

ü§ì Other versions and variants

Python 3.9+
    
    
    from typing import Union
    
    from fastapi import FastAPI
    from pydantic import BaseModel
    
    
    class Item(BaseModel):
        name: str
        description: Union[str, None] = None
        price: float
        tax: Union[float, None] = None
    
    
    app = FastAPI()
    
    
    @app.put("/items/{item_id}")
    async def update_item(item_id: int, item: Item):
        return {"item_id": item_id, **item.model_dump()}
    

## Request body + path + query parameters[¶](#request-body-path-query-parameters "Permanent link")

You can also declare **body** , **path** and **query** parameters, all at the same time.

**FastAPI** will recognize each of them and take the data from the correct place.

Python 3.10+
    
    
    from fastapi import FastAPI
    from pydantic import BaseModel
    
    
    class Item(BaseModel):
        name: str
        description: str | None = None
        price: float
        tax: float | None = None
    
    
    app = FastAPI()
    
    
    @app.put("/items/{item_id}")
    async def update_item(item_id: int, item: Item, q: str | None = None):
        result = {"item_id": item_id, **item.model_dump()}
        if q:
            result.update({"q": q})
        return result
    

ü§ì Other versions and variants

Python 3.9+
    
    
    from typing import Union
    
    from fastapi import FastAPI
    from pydantic import BaseModel
    
    
    class Item(BaseModel):
        name: str
        description: Union[str, None] = None
        price: float
        tax: Union[float, None] = None
    
    
    app = FastAPI()
    
    
    @app.put("/items/{item_id}")
    async def update_item(item_id: int, item: Item, q: Union[str, None] = None):
        result = {"item_id": item_id, **item.model_dump()}
        if q:
            result.update({"q": q})
        return result
    

The function parameters will be recognized as follows:

  * If the parameter is also declared in the **path** , it will be used as a path parameter.
  * If the parameter is of a **singular type** (like `int`, `float`, `str`, `bool`, etc) it will be interpreted as a **query** parameter.
  * If the parameter is declared to be of the type of a **Pydantic model** , it will be interpreted as a request **body**.

Note

FastAPI will know that the value of `q` is not required because of the default value `= None`.

The `str | None` (Python 3.10+) or `Union` in `Union[str, None]` (Python 3.9+) is not used by FastAPI to determine that the value is not required, it will know it's not required because it has a default value of `= None`.

But adding the type annotations will allow your editor to give you better support and detect errors.

## Without Pydantic[¶](#without-pydantic "Permanent link")

If you don't want to use Pydantic models, you can also use **Body** parameters. See the docs for [Body - Multiple Parameters: Singular values in body](../body-multiple-params/#singular-values-in-body).
  *[UIs]: User Interfaces

---

###### Query Parameters and String Validations¶

# Query Parameters and String Validations[¶](#query-parameters-and-string-validations "Permanent link")

**FastAPI** allows you to declare additional information and validation for your parameters.

Let's take this application as example:

Python 3.10+
    
    
    from fastapi import FastAPI
    
    app = FastAPI()
    
    
    @app.get("/items/")
    async def read_items(q: str | None = None):
        results = {"items": [{"item_id": "Foo"}, {"item_id": "Bar"}]}
        if q:
            results.update({"q": q})
        return results
    

ü§ì Other versions and variants

Python 3.9+
    
    
    from typing import Union
    
    from fastapi import FastAPI
    
    app = FastAPI()
    
    
    @app.get("/items/")
    async def read_items(q: Union[str, None] = None):
        results = {"items": [{"item_id": "Foo"}, {"item_id": "Bar"}]}
        if q:
            results.update({"q": q})
        return results
    

The query parameter `q` is of type `str | None`, that means that it's of type `str` but could also be `None`, and indeed, the default value is `None`, so FastAPI will know it's not required.

Note

FastAPI will know that the value of `q` is not required because of the default value `= None`.

Having `str | None` will allow your editor to give you better support and detect errors.

## Additional validation[¶](#additional-validation "Permanent link")

We are going to enforce that even though `q` is optional, whenever it is provided, **its length doesn't exceed 50 characters**.

### Import `Query` and `Annotated`[¶](#import-query-and-annotated "Permanent link")

To achieve that, first import:

  * `Query` from `fastapi`
  * `Annotated` from `typing`

Python 3.10+
    
    
    from typing import Annotated
    
    from fastapi import FastAPI, Query
    
    app = FastAPI()
    
    
    @app.get("/items/")
    async def read_items(q: Annotated[str | None, Query(max_length=50)] = None):
        results = {"items": [{"item_id": "Foo"}, {"item_id": "Bar"}]}
        if q:
            results.update({"q": q})
        return results
    

ü§ì Other versions and variants

Python 3.9+Python 3.10+ - non-AnnotatedPython 3.9+ - non-Annotated
    
    
    from typing import Annotated, Union
    
    from fastapi import FastAPI, Query
    
    app = FastAPI()
    
    
    @app.get("/items/")
    async def read_items(q: Annotated[Union[str, None], Query(max_length=50)] = None):
        results = {"items": [{"item_id": "Foo"}, {"item_id": "Bar"}]}
        if q:
            results.update({"q": q})
        return results
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import FastAPI, Query
    
    app = FastAPI()
    
    
    @app.get("/items/")
    async def read_items(q: str | None = Query(default=None, max_length=50)):
        results = {"items": [{"item_id": "Foo"}, {"item_id": "Bar"}]}
        if q:
            results.update({"q": q})
        return results
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from typing import Union
    
    from fastapi import FastAPI, Query
    
    app = FastAPI()
    
    
    @app.get("/items/")
    async def read_items(q: Union[str, None] = Query(default=None, max_length=50)):
        results = {"items": [{"item_id": "Foo"}, {"item_id": "Bar"}]}
        if q:
            results.update({"q": q})
        return results
    

Info

FastAPI added support for `Annotated` (and started recommending it) in version 0.95.0.

If you have an older version, you would get errors when trying to use `Annotated`.

Make sure you [Upgrade the FastAPI version](../../deployment/versions/#upgrading-the-fastapi-versions) to at least 0.95.1 before using `Annotated`.

## Use `Annotated` in the type for the `q` parameter[¶](#use-annotated-in-the-type-for-the-q-parameter "Permanent link")

Remember I told you before that `Annotated` can be used to add metadata to your parameters in the [Python Types Intro](../../python-types/#type-hints-with-metadata-annotations)?

Now it's the time to use it with FastAPI. üöÄ

We had this type annotation:

Python 3.10+Python 3.9+
    
    
    q: str | None = None
    
    
    
    q: Union[str, None] = None
    

What we will do is wrap that with `Annotated`, so it becomes:

Python 3.10+Python 3.9+
    
    
    q: Annotated[str | None] = None
    
    
    
    q: Annotated[Union[str, None]] = None
    

Both of those versions mean the same thing, `q` is a parameter that can be a `str` or `None`, and by default, it is `None`.

Now let's jump to the fun stuff. üéâ

## Add `Query` to `Annotated` in the `q` parameter[¶](#add-query-to-annotated-in-the-q-parameter "Permanent link")

Now that we have this `Annotated` where we can put more information (in this case some additional validation), add `Query` inside of `Annotated`, and set the parameter `max_length` to `50`:

Python 3.10+
    
    
    from typing import Annotated
    
    from fastapi import FastAPI, Query
    
    app = FastAPI()
    
    
    @app.get("/items/")
    async def read_items(q: Annotated[str | None, Query(max_length=50)] = None):
        results = {"items": [{"item_id": "Foo"}, {"item_id": "Bar"}]}
        if q:
            results.update({"q": q})
        return results
    

ü§ì Other versions and variants

Python 3.9+Python 3.10+ - non-AnnotatedPython 3.9+ - non-Annotated
    
    
    from typing import Annotated, Union
    
    from fastapi import FastAPI, Query
    
    app = FastAPI()
    
    
    @app.get("/items/")
    async def read_items(q: Annotated[Union[str, None], Query(max_length=50)] = None):
        results = {"items": [{"item_id": "Foo"}, {"item_id": "Bar"}]}
        if q:
            results.update({"q": q})
        return results
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import FastAPI, Query
    
    app = FastAPI()
    
    
    @app.get("/items/")
    async def read_items(q: str | None = Query(default=None, max_length=50)):
        results = {"items": [{"item_id": "Foo"}, {"item_id": "Bar"}]}
        if q:
            results.update({"q": q})
        return results
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from typing import Union
    
    from fastapi import FastAPI, Query
    
    app = FastAPI()
    
    
    @app.get("/items/")
    async def read_items(q: Union[str, None] = Query(default=None, max_length=50)):
        results = {"items": [{"item_id": "Foo"}, {"item_id": "Bar"}]}
        if q:
            results.update({"q": q})
        return results
    

Notice that the default value is still `None`, so the parameter is still optional.

But now, having `Query(max_length=50)` inside of `Annotated`, we are telling FastAPI that we want it to have **additional validation** for this value, we want it to have maximum 50 characters. üòé

Tip

Here we are using `Query()` because this is a **query parameter**. Later we will see others like `Path()`, `Body()`, `Header()`, and `Cookie()`, that also accept the same arguments as `Query()`.

FastAPI will now:

  * **Validate** the data making sure that the max length is 50 characters
  * Show a **clear error** for the client when the data is not valid
  * **Document** the parameter in the OpenAPI schema _path operation_ (so it will show up in the **automatic docs UI**)

## Alternative (old): `Query` as the default value[¶](#alternative-old-query-as-the-default-value "Permanent link")

Previous versions of FastAPI (before 0.95.0) required you to use `Query` as the default value of your parameter, instead of putting it in `Annotated`, there's a high chance that you will see code using it around, so I'll explain it to you.

Tip

For new code and whenever possible, use `Annotated` as explained above. There are multiple advantages (explained below) and no disadvantages. üç∞

This is how you would use `Query()` as the default value of your function parameter, setting the parameter `max_length` to 50:

Python 3.10+ - non-Annotated
    
    
    from fastapi import FastAPI, Query
    
    app = FastAPI()
    
    
    @app.get("/items/")
    async def read_items(q: str | None = Query(default=None, max_length=50)):
        results = {"items": [{"item_id": "Foo"}, {"item_id": "Bar"}]}
        if q:
            results.update({"q": q})
        return results
    

ü§ì Other versions and variants

Python 3.10+Python 3.9+Python 3.9+ - non-Annotated
    
    
    from typing import Annotated
    
    from fastapi import FastAPI, Query
    
    app = FastAPI()
    
    
    @app.get("/items/")
    async def read_items(q: Annotated[str | None, Query(max_length=50)] = None):
        results = {"items": [{"item_id": "Foo"}, {"item_id": "Bar"}]}
        if q:
            results.update({"q": q})
        return results
    
    
    
    from typing import Annotated, Union
    
    from fastapi import FastAPI, Query
    
    app = FastAPI()
    
    
    @app.get("/items/")
    async def read_items(q: Annotated[Union[str, None], Query(max_length=50)] = None):
        results = {"items": [{"item_id": "Foo"}, {"item_id": "Bar"}]}
        if q:
            results.update({"q": q})
        return results
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from typing import Union
    
    from fastapi import FastAPI, Query
    
    app = FastAPI()
    
    
    @app.get("/items/")
    async def read_items(q: Union[str, None] = Query(default=None, max_length=50)):
        results = {"items": [{"item_id": "Foo"}, {"item_id": "Bar"}]}
        if q:
            results.update({"q": q})
        return results
    

As in this case (without using `Annotated`) we have to replace the default value `None` in the function with `Query()`, we now need to set the default value with the parameter `Query(default=None)`, it serves the same purpose of defining that default value (at least for FastAPI).

So:
    
    
    q: str | None = Query(default=None)
    

...makes the parameter optional, with a default value of `None`, the same as:
    
    
    q: str | None = None
    

But the `Query` version declares it explicitly as being a query parameter.

Then, we can pass more parameters to `Query`. In this case, the `max_length` parameter that applies to strings:
    
    
    q: str | None = Query(default=None, max_length=50)
    

This will validate the data, show a clear error when the data is not valid, and document the parameter in the OpenAPI schema _path operation_.

### `Query` as the default value or in `Annotated`[¶](#query-as-the-default-value-or-in-annotated "Permanent link")

Keep in mind that when using `Query` inside of `Annotated` you cannot use the `default` parameter for `Query`.

Instead, use the actual default value of the function parameter. Otherwise, it would be inconsistent.

For example, this is not allowed:
    
    
    q: Annotated[str, Query(default="rick")] = "morty"
    

...because it's not clear if the default value should be `"rick"` or `"morty"`.

So, you would use (preferably):
    
    
    q: Annotated[str, Query()] = "rick"
    

...or in older code bases you will find:
    
    
    q: str = Query(default="rick")
    

### Advantages of `Annotated`[¶](#advantages-of-annotated "Permanent link")

**Using`Annotated` is recommended** instead of the default value in function parameters, it is **better** for multiple reasons. ü§ì

The **default** value of the **function parameter** is the **actual default** value, that's more intuitive with Python in general. üòå

You could **call** that same function in **other places** without FastAPI, and it would **work as expected**. If there's a **required** parameter (without a default value), your **editor** will let you know with an error, **Python** will also complain if you run it without passing the required parameter.

When you don't use `Annotated` and instead use the **(old) default value style** , if you call that function without FastAPI in **other places** , you have to **remember** to pass the arguments to the function for it to work correctly, otherwise the values will be different from what you expect (e.g. `QueryInfo` or something similar instead of `str`). And your editor won't complain, and Python won't complain running that function, only when the operations inside error out.

Because `Annotated` can have more than one metadata annotation, you could now even use the same function with other tools, like [Typer](https://typer.tiangolo.com/). üöÄ

## Add more validations[¶](#add-more-validations "Permanent link")

You can also add a parameter `min_length`:

Python 3.10+
    
    
    from typing import Annotated
    
    from fastapi import FastAPI, Query
    
    app = FastAPI()
    
    
    @app.get("/items/")
    async def read_items(
        q: Annotated[str | None, Query(min_length=3, max_length=50)] = None,
    ):
        results = {"items": [{"item_id": "Foo"}, {"item_id": "Bar"}]}
        if q:
            results.update({"q": q})
        return results
    

ü§ì Other versions and variants

Python 3.9+Python 3.10+ - non-AnnotatedPython 3.9+ - non-Annotated
    
    
    from typing import Annotated, Union
    
    from fastapi import FastAPI, Query
    
    app = FastAPI()
    
    
    @app.get("/items/")
    async def read_items(
        q: Annotated[Union[str, None], Query(min_length=3, max_length=50)] = None,
    ):
        results = {"items": [{"item_id": "Foo"}, {"item_id": "Bar"}]}
        if q:
            results.update({"q": q})
        return results
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import FastAPI, Query
    
    app = FastAPI()
    
    
    @app.get("/items/")
    async def read_items(q: str | None = Query(default=None, min_length=3, max_length=50)):
        results = {"items": [{"item_id": "Foo"}, {"item_id": "Bar"}]}
        if q:
            results.update({"q": q})
        return results
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from typing import Union
    
    from fastapi import FastAPI, Query
    
    app = FastAPI()
    
    
    @app.get("/items/")
    async def read_items(
        q: Union[str, None] = Query(default=None, min_length=3, max_length=50),
    ):
        results = {"items": [{"item_id": "Foo"}, {"item_id": "Bar"}]}
        if q:
            results.update({"q": q})
        return results
    

## Add regular expressions[¶](#add-regular-expressions "Permanent link")

You can define a regular expression `pattern` that the parameter should match:

Python 3.10+
    
    
    from typing import Annotated
    
    from fastapi import FastAPI, Query
    
    app = FastAPI()
    
    
    @app.get("/items/")
    async def read_items(
        q: Annotated[
            str | None, Query(min_length=3, max_length=50, pattern="^fixedquery$")
        ] = None,
    ):
        results = {"items": [{"item_id": "Foo"}, {"item_id": "Bar"}]}
        if q:
            results.update({"q": q})
        return results
    

ü§ì Other versions and variants

Python 3.9+Python 3.10+ - non-AnnotatedPython 3.9+ - non-Annotated
    
    
    from typing import Annotated, Union
    
    from fastapi import FastAPI, Query
    
    app = FastAPI()
    
    
    @app.get("/items/")
    async def read_items(
        q: Annotated[
            Union[str, None], Query(min_length=3, max_length=50, pattern="^fixedquery$")
        ] = None,
    ):
        results = {"items": [{"item_id": "Foo"}, {"item_id": "Bar"}]}
        if q:
            results.update({"q": q})
        return results
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import FastAPI, Query
    
    app = FastAPI()
    
    
    @app.get("/items/")
    async def read_items(
        q: str | None = Query(
            default=None, min_length=3, max_length=50, pattern="^fixedquery$"
        ),
    ):
        results = {"items": [{"item_id": "Foo"}, {"item_id": "Bar"}]}
        if q:
            results.update({"q": q})
        return results
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from typing import Union
    
    from fastapi import FastAPI, Query
    
    app = FastAPI()
    
    
    @app.get("/items/")
    async def read_items(
        q: Union[str, None] = Query(
            default=None, min_length=3, max_length=50, pattern="^fixedquery$"
        ),
    ):
        results = {"items": [{"item_id": "Foo"}, {"item_id": "Bar"}]}
        if q:
            results.update({"q": q})
        return results
    

This specific regular expression pattern checks that the received parameter value:

  * `^`: starts with the following characters, doesn't have characters before.
  * `fixedquery`: has the exact value `fixedquery`.
  * `$`: ends there, doesn't have any more characters after `fixedquery`.

If you feel lost with all these **"regular expression"** ideas, don't worry. They are a hard topic for many people. You can still do a lot of stuff without needing regular expressions yet.

Now you know that whenever you need them you can use them in **FastAPI**.

## Default values[¶](#default-values "Permanent link")

You can, of course, use default values other than `None`.

Let's say that you want to declare the `q` query parameter to have a `min_length` of `3`, and to have a default value of `"fixedquery"`:

Python 3.9+
    
    
    from typing import Annotated
    
    from fastapi import FastAPI, Query
    
    app = FastAPI()
    
    
    @app.get("/items/")
    async def read_items(q: Annotated[str, Query(min_length=3)] = "fixedquery"):
        results = {"items": [{"item_id": "Foo"}, {"item_id": "Bar"}]}
        if q:
            results.update({"q": q})
        return results
    

ü§ì Other versions and variants

Python 3.9+ - non-Annotated

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import FastAPI, Query
    
    app = FastAPI()
    
    
    @app.get("/items/")
    async def read_items(q: str = Query(default="fixedquery", min_length=3)):
        results = {"items": [{"item_id": "Foo"}, {"item_id": "Bar"}]}
        if q:
            results.update({"q": q})
        return results
    

Note

Having a default value of any type, including `None`, makes the parameter optional (not required).

## Required parameters[¶](#required-parameters "Permanent link")

When we don't need to declare more validations or metadata, we can make the `q` query parameter required just by not declaring a default value, like:
    
    
    q: str
    

instead of:
    
    
    q: str | None = None
    

But we are now declaring it with `Query`, for example like:
    
    
    q: Annotated[str | None, Query(min_length=3)] = None
    

So, when you need to declare a value as required while using `Query`, you can simply not declare a default value:

Python 3.9+
    
    
    from typing import Annotated
    
    from fastapi import FastAPI, Query
    
    app = FastAPI()
    
    
    @app.get("/items/")
    async def read_items(q: Annotated[str, Query(min_length=3)]):
        results = {"items": [{"item_id": "Foo"}, {"item_id": "Bar"}]}
        if q:
            results.update({"q": q})
        return results
    

ü§ì Other versions and variants

Python 3.9+ - non-Annotated

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import FastAPI, Query
    
    app = FastAPI()
    
    
    @app.get("/items/")
    async def read_items(q: str = Query(min_length=3)):
        results = {"items": [{"item_id": "Foo"}, {"item_id": "Bar"}]}
        if q:
            results.update({"q": q})
        return results
    

### Required, can be `None`[¶](#required-can-be-none "Permanent link")

You can declare that a parameter can accept `None`, but that it's still required. This would force clients to send a value, even if the value is `None`.

To do that, you can declare that `None` is a valid type but simply do not declare a default value:

Python 3.10+
    
    
    from typing import Annotated
    
    from fastapi import FastAPI, Query
    
    app = FastAPI()
    
    
    @app.get("/items/")
    async def read_items(q: Annotated[str | None, Query(min_length=3)]):
        results = {"items": [{"item_id": "Foo"}, {"item_id": "Bar"}]}
        if q:
            results.update({"q": q})
        return results
    

ü§ì Other versions and variants

Python 3.9+Python 3.10+ - non-AnnotatedPython 3.9+ - non-Annotated
    
    
    from typing import Annotated, Union
    
    from fastapi import FastAPI, Query
    
    app = FastAPI()
    
    
    @app.get("/items/")
    async def read_items(q: Annotated[Union[str, None], Query(min_length=3)]):
        results = {"items": [{"item_id": "Foo"}, {"item_id": "Bar"}]}
        if q:
            results.update({"q": q})
        return results
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import FastAPI, Query
    
    app = FastAPI()
    
    
    @app.get("/items/")
    async def read_items(q: str | None = Query(min_length=3)):
        results = {"items": [{"item_id": "Foo"}, {"item_id": "Bar"}]}
        if q:
            results.update({"q": q})
        return results
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from typing import Union
    
    from fastapi import FastAPI, Query
    
    app = FastAPI()
    
    
    @app.get("/items/")
    async def read_items(q: Union[str, None] = Query(min_length=3)):
        results = {"items": [{"item_id": "Foo"}, {"item_id": "Bar"}]}
        if q:
            results.update({"q": q})
        return results
    

## Query parameter list / multiple values[¶](#query-parameter-list-multiple-values "Permanent link")

When you define a query parameter explicitly with `Query` you can also declare it to receive a list of values, or said in another way, to receive multiple values.

For example, to declare a query parameter `q` that can appear multiple times in the URL, you can write:

Python 3.10+
    
    
    from typing import Annotated
    
    from fastapi import FastAPI, Query
    
    app = FastAPI()
    
    
    @app.get("/items/")
    async def read_items(q: Annotated[list[str] | None, Query()] = None):
        query_items = {"q": q}
        return query_items
    

ü§ì Other versions and variants

Python 3.9+Python 3.10+ - non-AnnotatedPython 3.9+ - non-Annotated
    
    
    from typing import Annotated, Union
    
    from fastapi import FastAPI, Query
    
    app = FastAPI()
    
    
    @app.get("/items/")
    async def read_items(q: Annotated[Union[list[str], None], Query()] = None):
        query_items = {"q": q}
        return query_items
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import FastAPI, Query
    
    app = FastAPI()
    
    
    @app.get("/items/")
    async def read_items(q: list[str] | None = Query(default=None)):
        query_items = {"q": q}
        return query_items
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from typing import Union
    
    from fastapi import FastAPI, Query
    
    app = FastAPI()
    
    
    @app.get("/items/")
    async def read_items(q: Union[list[str], None] = Query(default=None)):
        query_items = {"q": q}
        return query_items
    

Then, with a URL like:
    
    
    http://localhost:8000/items/?q=foo&q=bar
    

you would receive the multiple `q` _query parameters'_ values (`foo` and `bar`) in a Python `list` inside your _path operation function_ , in the _function parameter_ `q`.

So, the response to that URL would be:
    
    
    {
      "q": [
        "foo",
        "bar"
      ]
    }
    

Tip

To declare a query parameter with a type of `list`, like in the example above, you need to explicitly use `Query`, otherwise it would be interpreted as a request body.

The interactive API docs will update accordingly, to allow multiple values:

![](/img/tutorial/query-params-str-validations/image02.png)

### Query parameter list / multiple values with defaults[¶](#query-parameter-list-multiple-values-with-defaults "Permanent link")

You can also define a default `list` of values if none are provided:

Python 3.9+
    
    
    from typing import Annotated
    
    from fastapi import FastAPI, Query
    
    app = FastAPI()
    
    
    @app.get("/items/")
    async def read_items(q: Annotated[list[str], Query()] = ["foo", "bar"]):
        query_items = {"q": q}
        return query_items
    

ü§ì Other versions and variants

Python 3.9+ - non-Annotated

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import FastAPI, Query
    
    app = FastAPI()
    
    
    @app.get("/items/")
    async def read_items(q: list[str] = Query(default=["foo", "bar"])):
        query_items = {"q": q}
        return query_items
    

If you go to:
    
    
    http://localhost:8000/items/
    

the default of `q` will be: `["foo", "bar"]` and your response will be:
    
    
    {
      "q": [
        "foo",
        "bar"
      ]
    }
    

#### Using just `list`[¶](#using-just-list "Permanent link")

You can also use `list` directly instead of `list[str]`:

Python 3.9+
    
    
    from typing import Annotated
    
    from fastapi import FastAPI, Query
    
    app = FastAPI()
    
    
    @app.get("/items/")
    async def read_items(q: Annotated[list, Query()] = []):
        query_items = {"q": q}
        return query_items
    

ü§ì Other versions and variants

Python 3.9+ - non-Annotated

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import FastAPI, Query
    
    app = FastAPI()
    
    
    @app.get("/items/")
    async def read_items(q: list = Query(default=[])):
        query_items = {"q": q}
        return query_items
    

Note

Keep in mind that in this case, FastAPI won't check the contents of the list.

For example, `list[int]` would check (and document) that the contents of the list are integers. But `list` alone wouldn't.

## Declare more metadata[¶](#declare-more-metadata "Permanent link")

You can add more information about the parameter.

That information will be included in the generated OpenAPI and used by the documentation user interfaces and external tools.

Note

Keep in mind that different tools might have different levels of OpenAPI support.

Some of them might not show all the extra information declared yet, although in most of the cases, the missing feature is already planned for development.

You can add a `title`:

Python 3.10+
    
    
    from typing import Annotated
    
    from fastapi import FastAPI, Query
    
    app = FastAPI()
    
    
    @app.get("/items/")
    async def read_items(
        q: Annotated[str | None, Query(title="Query string", min_length=3)] = None,
    ):
        results = {"items": [{"item_id": "Foo"}, {"item_id": "Bar"}]}
        if q:
            results.update({"q": q})
        return results
    

ü§ì Other versions and variants

Python 3.9+Python 3.10+ - non-AnnotatedPython 3.9+ - non-Annotated
    
    
    from typing import Annotated, Union
    
    from fastapi import FastAPI, Query
    
    app = FastAPI()
    
    
    @app.get("/items/")
    async def read_items(
        q: Annotated[Union[str, None], Query(title="Query string", min_length=3)] = None,
    ):
        results = {"items": [{"item_id": "Foo"}, {"item_id": "Bar"}]}
        if q:
            results.update({"q": q})
        return results
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import FastAPI, Query
    
    app = FastAPI()
    
    
    @app.get("/items/")
    async def read_items(
        q: str | None = Query(default=None, title="Query string", min_length=3),
    ):
        results = {"items": [{"item_id": "Foo"}, {"item_id": "Bar"}]}
        if q:
            results.update({"q": q})
        return results
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from typing import Union
    
    from fastapi import FastAPI, Query
    
    app = FastAPI()
    
    
    @app.get("/items/")
    async def read_items(
        q: Union[str, None] = Query(default=None, title="Query string", min_length=3),
    ):
        results = {"items": [{"item_id": "Foo"}, {"item_id": "Bar"}]}
        if q:
            results.update({"q": q})
        return results
    

And a `description`:

Python 3.10+
    
    
    from typing import Annotated
    
    from fastapi import FastAPI, Query
    
    app = FastAPI()
    
    
    @app.get("/items/")
    async def read_items(
        q: Annotated[
            str | None,
            Query(
                title="Query string",
                description="Query string for the items to search in the database that have a good match",
                min_length=3,
            ),
        ] = None,
    ):
        results = {"items": [{"item_id": "Foo"}, {"item_id": "Bar"}]}
        if q:
            results.update({"q": q})
        return results
    

ü§ì Other versions and variants

Python 3.9+Python 3.10+ - non-AnnotatedPython 3.9+ - non-Annotated
    
    
    from typing import Annotated, Union
    
    from fastapi import FastAPI, Query
    
    app = FastAPI()
    
    
    @app.get("/items/")
    async def read_items(
        q: Annotated[
            Union[str, None],
            Query(
                title="Query string",
                description="Query string for the items to search in the database that have a good match",
                min_length=3,
            ),
        ] = None,
    ):
        results = {"items": [{"item_id": "Foo"}, {"item_id": "Bar"}]}
        if q:
            results.update({"q": q})
        return results
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import FastAPI, Query
    
    app = FastAPI()
    
    
    @app.get("/items/")
    async def read_items(
        q: str | None = Query(
            default=None,
            title="Query string",
            description="Query string for the items to search in the database that have a good match",
            min_length=3,
        ),
    ):
        results = {"items": [{"item_id": "Foo"}, {"item_id": "Bar"}]}
        if q:
            results.update({"q": q})
        return results
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from typing import Union
    
    from fastapi import FastAPI, Query
    
    app = FastAPI()
    
    
    @app.get("/items/")
    async def read_items(
        q: Union[str, None] = Query(
            default=None,
            title="Query string",
            description="Query string for the items to search in the database that have a good match",
            min_length=3,
        ),
    ):
        results = {"items": [{"item_id": "Foo"}, {"item_id": "Bar"}]}
        if q:
            results.update({"q": q})
        return results
    

## Alias parameters[¶](#alias-parameters "Permanent link")

Imagine that you want the parameter to be `item-query`.

Like in:
    
    
    http://127.0.0.1:8000/items/?item-query=foobaritems
    

But `item-query` is not a valid Python variable name.

The closest would be `item_query`.

But you still need it to be exactly `item-query`...

Then you can declare an `alias`, and that alias is what will be used to find the parameter value:

Python 3.10+
    
    
    from typing import Annotated
    
    from fastapi import FastAPI, Query
    
    app = FastAPI()
    
    
    @app.get("/items/")
    async def read_items(q: Annotated[str | None, Query(alias="item-query")] = None):
        results = {"items": [{"item_id": "Foo"}, {"item_id": "Bar"}]}
        if q:
            results.update({"q": q})
        return results
    

ü§ì Other versions and variants

Python 3.9+Python 3.10+ - non-AnnotatedPython 3.9+ - non-Annotated
    
    
    from typing import Annotated, Union
    
    from fastapi import FastAPI, Query
    
    app = FastAPI()
    
    
    @app.get("/items/")
    async def read_items(q: Annotated[Union[str, None], Query(alias="item-query")] = None):
        results = {"items": [{"item_id": "Foo"}, {"item_id": "Bar"}]}
        if q:
            results.update({"q": q})
        return results
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import FastAPI, Query
    
    app = FastAPI()
    
    
    @app.get("/items/")
    async def read_items(q: str | None = Query(default=None, alias="item-query")):
        results = {"items": [{"item_id": "Foo"}, {"item_id": "Bar"}]}
        if q:
            results.update({"q": q})
        return results
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from typing import Union
    
    from fastapi import FastAPI, Query
    
    app = FastAPI()
    
    
    @app.get("/items/")
    async def read_items(q: Union[str, None] = Query(default=None, alias="item-query")):
        results = {"items": [{"item_id": "Foo"}, {"item_id": "Bar"}]}
        if q:
            results.update({"q": q})
        return results
    

## Deprecating parameters[¶](#deprecating-parameters "Permanent link")

Now let's say you don't like this parameter anymore.

You have to leave it there a while because there are clients using it, but you want the docs to clearly show it as deprecated.

Then pass the parameter `deprecated=True` to `Query`:

Python 3.10+
    
    
    from typing import Annotated
    
    from fastapi import FastAPI, Query
    
    app = FastAPI()
    
    
    @app.get("/items/")
    async def read_items(
        q: Annotated[
            str | None,
            Query(
                alias="item-query",
                title="Query string",
                description="Query string for the items to search in the database that have a good match",
                min_length=3,
                max_length=50,
                pattern="^fixedquery$",
                deprecated=True,
            ),
        ] = None,
    ):
        results = {"items": [{"item_id": "Foo"}, {"item_id": "Bar"}]}
        if q:
            results.update({"q": q})
        return results
    

ü§ì Other versions and variants

Python 3.9+Python 3.10+ - non-AnnotatedPython 3.9+ - non-Annotated
    
    
    from typing import Annotated, Union
    
    from fastapi import FastAPI, Query
    
    app = FastAPI()
    
    
    @app.get("/items/")
    async def read_items(
        q: Annotated[
            Union[str, None],
            Query(
                alias="item-query",
                title="Query string",
                description="Query string for the items to search in the database that have a good match",
                min_length=3,
                max_length=50,
                pattern="^fixedquery$",
                deprecated=True,
            ),
        ] = None,
    ):
        results = {"items": [{"item_id": "Foo"}, {"item_id": "Bar"}]}
        if q:
            results.update({"q": q})
        return results
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import FastAPI, Query
    
    app = FastAPI()
    
    
    @app.get("/items/")
    async def read_items(
        q: str | None = Query(
            default=None,
            alias="item-query",
            title="Query string",
            description="Query string for the items to search in the database that have a good match",
            min_length=3,
            max_length=50,
            pattern="^fixedquery$",
            deprecated=True,
        ),
    ):
        results = {"items": [{"item_id": "Foo"}, {"item_id": "Bar"}]}
        if q:
            results.update({"q": q})
        return results
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from typing import Union
    
    from fastapi import FastAPI, Query
    
    app = FastAPI()
    
    
    @app.get("/items/")
    async def read_items(
        q: Union[str, None] = Query(
            default=None,
            alias="item-query",
            title="Query string",
            description="Query string for the items to search in the database that have a good match",
            min_length=3,
            max_length=50,
            pattern="^fixedquery$",
            deprecated=True,
        ),
    ):
        results = {"items": [{"item_id": "Foo"}, {"item_id": "Bar"}]}
        if q:
            results.update({"q": q})
        return results
    

The docs will show it like this:

![](/img/tutorial/query-params-str-validations/image01.png)

## Exclude parameters from OpenAPI[¶](#exclude-parameters-from-openapi "Permanent link")

To exclude a query parameter from the generated OpenAPI schema (and thus, from the automatic documentation systems), set the parameter `include_in_schema` of `Query` to `False`:

Python 3.10+
    
    
    from typing import Annotated
    
    from fastapi import FastAPI, Query
    
    app = FastAPI()
    
    
    @app.get("/items/")
    async def read_items(
        hidden_query: Annotated[str | None, Query(include_in_schema=False)] = None,
    ):
        if hidden_query:
            return {"hidden_query": hidden_query}
        else:
            return {"hidden_query": "Not found"}
    

ü§ì Other versions and variants

Python 3.9+Python 3.10+ - non-AnnotatedPython 3.9+ - non-Annotated
    
    
    from typing import Annotated, Union
    
    from fastapi import FastAPI, Query
    
    app = FastAPI()
    
    
    @app.get("/items/")
    async def read_items(
        hidden_query: Annotated[Union[str, None], Query(include_in_schema=False)] = None,
    ):
        if hidden_query:
            return {"hidden_query": hidden_query}
        else:
            return {"hidden_query": "Not found"}
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import FastAPI, Query
    
    app = FastAPI()
    
    
    @app.get("/items/")
    async def read_items(
        hidden_query: str | None = Query(default=None, include_in_schema=False),
    ):
        if hidden_query:
            return {"hidden_query": hidden_query}
        else:
            return {"hidden_query": "Not found"}
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from typing import Union
    
    from fastapi import FastAPI, Query
    
    app = FastAPI()
    
    
    @app.get("/items/")
    async def read_items(
        hidden_query: Union[str, None] = Query(default=None, include_in_schema=False),
    ):
        if hidden_query:
            return {"hidden_query": hidden_query}
        else:
            return {"hidden_query": "Not found"}
    

## Custom Validation[¶](#custom-validation "Permanent link")

There could be cases where you need to do some **custom validation** that can't be done with the parameters shown above.

In those cases, you can use a **custom validator function** that is applied after the normal validation (e.g. after validating that the value is a `str`).

You can achieve that using [Pydantic's `AfterValidator`](https://docs.pydantic.dev/latest/concepts/validators/#field-after-validator) inside of `Annotated`.

Tip

Pydantic also has [`BeforeValidator`](https://docs.pydantic.dev/latest/concepts/validators/#field-before-validator) and others. ü§ì

For example, this custom validator checks that the item ID starts with `isbn-` for an ISBN book number or with `imdb-` for an IMDB movie URL ID:

Python 3.10+
    
    
    import random
    from typing import Annotated
    
    from fastapi import FastAPI
    from pydantic import AfterValidator
    
    app = FastAPI()
    
    data = {
        "isbn-9781529046137": "The Hitchhiker's Guide to the Galaxy",
        "imdb-tt0371724": "The Hitchhiker's Guide to the Galaxy",
        "isbn-9781439512982": "Isaac Asimov: The Complete Stories, Vol. 2",
    }
    
    
    def check_valid_id(id: str):
        if not id.startswith(("isbn-", "imdb-")):
            raise ValueError('Invalid ID format, it must start with "isbn-" or "imdb-"')
        return id
    
    
    @app.get("/items/")
    async def read_items(
        id: Annotated[str | None, AfterValidator(check_valid_id)] = None,
    ):
        if id:
            item = data.get(id)
        else:
            id, item = random.choice(list(data.items()))
        return {"id": id, "name": item}
    

ü§ì Other versions and variants

Python 3.9+
    
    
    import random
    from typing import Annotated, Union
    
    from fastapi import FastAPI
    from pydantic import AfterValidator
    
    app = FastAPI()
    
    data = {
        "isbn-9781529046137": "The Hitchhiker's Guide to the Galaxy",
        "imdb-tt0371724": "The Hitchhiker's Guide to the Galaxy",
        "isbn-9781439512982": "Isaac Asimov: The Complete Stories, Vol. 2",
    }
    
    
    def check_valid_id(id: str):
        if not id.startswith(("isbn-", "imdb-")):
            raise ValueError('Invalid ID format, it must start with "isbn-" or "imdb-"')
        return id
    
    
    @app.get("/items/")
    async def read_items(
        id: Annotated[Union[str, None], AfterValidator(check_valid_id)] = None,
    ):
        if id:
            item = data.get(id)
        else:
            id, item = random.choice(list(data.items()))
        return {"id": id, "name": item}
    

Info

This is available with Pydantic version 2 or above. üòé

Tip

If you need to do any type of validation that requires communicating with any **external component** , like a database or another API, you should instead use **FastAPI Dependencies** , you will learn about them later.

These custom validators are for things that can be checked with **only** the **same data** provided in the request.

### Understand that Code[¶](#understand-that-code "Permanent link")

The important point is just using **`AfterValidator` with a function inside `Annotated`**. Feel free to skip this part. ü§∏

* * *

But if you're curious about this specific code example and you're still entertained, here are some extra details.

#### String with `value.startswith()`[¶](#string-with-value-startswith "Permanent link")

Did you notice? a string using `value.startswith()` can take a tuple, and it will check each value in the tuple:

Python 3.10+
    
    
    # Code above omitted üëÜ
    
    def check_valid_id(id: str):
        if not id.startswith(("isbn-", "imdb-")):
            raise ValueError('Invalid ID format, it must start with "isbn-" or "imdb-"')
        return id
    
    # Code below omitted üëá
    

üëÄ Full file preview

Python 3.10+
    
    
    import random
    from typing import Annotated
    
    from fastapi import FastAPI
    from pydantic import AfterValidator
    
    app = FastAPI()
    
    data = {
        "isbn-9781529046137": "The Hitchhiker's Guide to the Galaxy",
        "imdb-tt0371724": "The Hitchhiker's Guide to the Galaxy",
        "isbn-9781439512982": "Isaac Asimov: The Complete Stories, Vol. 2",
    }
    
    
    def check_valid_id(id: str):
        if not id.startswith(("isbn-", "imdb-")):
            raise ValueError('Invalid ID format, it must start with "isbn-" or "imdb-"')
        return id
    
    
    @app.get("/items/")
    async def read_items(
        id: Annotated[str | None, AfterValidator(check_valid_id)] = None,
    ):
        if id:
            item = data.get(id)
        else:
            id, item = random.choice(list(data.items()))
        return {"id": id, "name": item}
    

ü§ì Other versions and variants

Python 3.9+
    
    
    import random
    from typing import Annotated, Union
    
    from fastapi import FastAPI
    from pydantic import AfterValidator
    
    app = FastAPI()
    
    data = {
        "isbn-9781529046137": "The Hitchhiker's Guide to the Galaxy",
        "imdb-tt0371724": "The Hitchhiker's Guide to the Galaxy",
        "isbn-9781439512982": "Isaac Asimov: The Complete Stories, Vol. 2",
    }
    
    
    def check_valid_id(id: str):
        if not id.startswith(("isbn-", "imdb-")):
            raise ValueError('Invalid ID format, it must start with "isbn-" or "imdb-"')
        return id
    
    
    @app.get("/items/")
    async def read_items(
        id: Annotated[Union[str, None], AfterValidator(check_valid_id)] = None,
    ):
        if id:
            item = data.get(id)
        else:
            id, item = random.choice(list(data.items()))
        return {"id": id, "name": item}
    

#### A Random Item[¶](#a-random-item "Permanent link")

With `data.items()` we get an iterable object with tuples containing the key and value for each dictionary item.

We convert this iterable object into a proper `list` with `list(data.items())`.

Then with `random.choice()` we can get a **random value** from the list, so, we get a tuple with `(id, name)`. It will be something like `("imdb-tt0371724", "The Hitchhiker's Guide to the Galaxy")`.

Then we **assign those two values** of the tuple to the variables `id` and `name`.

So, if the user didn't provide an item ID, they will still receive a random suggestion.

...we do all this in a **single simple line**. ü§Ø Don't you love Python? üêç

Python 3.10+
    
    
    # Code above omitted üëÜ
    
    @app.get("/items/")
    async def read_items(
        id: Annotated[str | None, AfterValidator(check_valid_id)] = None,
    ):
        if id:
            item = data.get(id)
        else:
            id, item = random.choice(list(data.items()))
        return {"id": id, "name": item}
    

üëÄ Full file preview

Python 3.10+
    
    
    import random
    from typing import Annotated
    
    from fastapi import FastAPI
    from pydantic import AfterValidator
    
    app = FastAPI()
    
    data = {
        "isbn-9781529046137": "The Hitchhiker's Guide to the Galaxy",
        "imdb-tt0371724": "The Hitchhiker's Guide to the Galaxy",
        "isbn-9781439512982": "Isaac Asimov: The Complete Stories, Vol. 2",
    }
    
    
    def check_valid_id(id: str):
        if not id.startswith(("isbn-", "imdb-")):
            raise ValueError('Invalid ID format, it must start with "isbn-" or "imdb-"')
        return id
    
    
    @app.get("/items/")
    async def read_items(
        id: Annotated[str | None, AfterValidator(check_valid_id)] = None,
    ):
        if id:
            item = data.get(id)
        else:
            id, item = random.choice(list(data.items()))
        return {"id": id, "name": item}
    

ü§ì Other versions and variants

Python 3.9+
    
    
    import random
    from typing import Annotated, Union
    
    from fastapi import FastAPI
    from pydantic import AfterValidator
    
    app = FastAPI()
    
    data = {
        "isbn-9781529046137": "The Hitchhiker's Guide to the Galaxy",
        "imdb-tt0371724": "The Hitchhiker's Guide to the Galaxy",
        "isbn-9781439512982": "Isaac Asimov: The Complete Stories, Vol. 2",
    }
    
    
    def check_valid_id(id: str):
        if not id.startswith(("isbn-", "imdb-")):
            raise ValueError('Invalid ID format, it must start with "isbn-" or "imdb-"')
        return id
    
    
    @app.get("/items/")
    async def read_items(
        id: Annotated[Union[str, None], AfterValidator(check_valid_id)] = None,
    ):
        if id:
            item = data.get(id)
        else:
            id, item = random.choice(list(data.items()))
        return {"id": id, "name": item}
    

## Recap[¶](#recap "Permanent link")

You can declare additional validations and metadata for your parameters.

Generic validations and metadata:

  * `alias`
  * `title`
  * `description`
  * `deprecated`

Validations specific for strings:

  * `min_length`
  * `max_length`
  * `pattern`

Custom validations using `AfterValidator`.

In these examples you saw how to declare validations for `str` values.

See the next chapters to learn how to declare validations for other types, like numbers.
  *[0.95.0]: before 2023-03
  *[regular expression]: A regular expression, regex or regexp is a sequence of characters that define a search pattern for strings.
  *[deprecated]: obsolete, recommended not to use it
  *[ISBN]: ISBN means International Standard Book Number
  *[IMDB]: IMDB (Internet Movie Database) is a website with information about movies
  *[iterable object]: Something we can iterate on with a for loop, like a list, set, etc.

---

###### Path Parameters and Numeric Validations¶

# Path Parameters and Numeric Validations[¶](#path-parameters-and-numeric-validations "Permanent link")

In the same way that you can declare more validations and metadata for query parameters with `Query`, you can declare the same type of validations and metadata for path parameters with `Path`.

## Import `Path`[¶](#import-path "Permanent link")

First, import `Path` from `fastapi`, and import `Annotated`:

Python 3.10+
    
    
    from typing import Annotated
    
    from fastapi import FastAPI, Path, Query
    
    app = FastAPI()
    
    
    @app.get("/items/{item_id}")
    async def read_items(
        item_id: Annotated[int, Path(title="The ID of the item to get")],
        q: Annotated[str | None, Query(alias="item-query")] = None,
    ):
        results = {"item_id": item_id}
        if q:
            results.update({"q": q})
        return results
    

ü§ì Other versions and variants

Python 3.9+Python 3.10+ - non-AnnotatedPython 3.9+ - non-Annotated
    
    
    from typing import Annotated, Union
    
    from fastapi import FastAPI, Path, Query
    
    app = FastAPI()
    
    
    @app.get("/items/{item_id}")
    async def read_items(
        item_id: Annotated[int, Path(title="The ID of the item to get")],
        q: Annotated[Union[str, None], Query(alias="item-query")] = None,
    ):
        results = {"item_id": item_id}
        if q:
            results.update({"q": q})
        return results
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import FastAPI, Path, Query
    
    app = FastAPI()
    
    
    @app.get("/items/{item_id}")
    async def read_items(
        item_id: int = Path(title="The ID of the item to get"),
        q: str | None = Query(default=None, alias="item-query"),
    ):
        results = {"item_id": item_id}
        if q:
            results.update({"q": q})
        return results
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from typing import Union
    
    from fastapi import FastAPI, Path, Query
    
    app = FastAPI()
    
    
    @app.get("/items/{item_id}")
    async def read_items(
        item_id: int = Path(title="The ID of the item to get"),
        q: Union[str, None] = Query(default=None, alias="item-query"),
    ):
        results = {"item_id": item_id}
        if q:
            results.update({"q": q})
        return results
    

Info

FastAPI added support for `Annotated` (and started recommending it) in version 0.95.0.

If you have an older version, you would get errors when trying to use `Annotated`.

Make sure you [Upgrade the FastAPI version](../../deployment/versions/#upgrading-the-fastapi-versions) to at least 0.95.1 before using `Annotated`.

## Declare metadata[¶](#declare-metadata "Permanent link")

You can declare all the same parameters as for `Query`.

For example, to declare a `title` metadata value for the path parameter `item_id` you can type:

Python 3.10+
    
    
    from typing import Annotated
    
    from fastapi import FastAPI, Path, Query
    
    app = FastAPI()
    
    
    @app.get("/items/{item_id}")
    async def read_items(
        item_id: Annotated[int, Path(title="The ID of the item to get")],
        q: Annotated[str | None, Query(alias="item-query")] = None,
    ):
        results = {"item_id": item_id}
        if q:
            results.update({"q": q})
        return results
    

ü§ì Other versions and variants

Python 3.9+Python 3.10+ - non-AnnotatedPython 3.9+ - non-Annotated
    
    
    from typing import Annotated, Union
    
    from fastapi import FastAPI, Path, Query
    
    app = FastAPI()
    
    
    @app.get("/items/{item_id}")
    async def read_items(
        item_id: Annotated[int, Path(title="The ID of the item to get")],
        q: Annotated[Union[str, None], Query(alias="item-query")] = None,
    ):
        results = {"item_id": item_id}
        if q:
            results.update({"q": q})
        return results
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import FastAPI, Path, Query
    
    app = FastAPI()
    
    
    @app.get("/items/{item_id}")
    async def read_items(
        item_id: int = Path(title="The ID of the item to get"),
        q: str | None = Query(default=None, alias="item-query"),
    ):
        results = {"item_id": item_id}
        if q:
            results.update({"q": q})
        return results
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from typing import Union
    
    from fastapi import FastAPI, Path, Query
    
    app = FastAPI()
    
    
    @app.get("/items/{item_id}")
    async def read_items(
        item_id: int = Path(title="The ID of the item to get"),
        q: Union[str, None] = Query(default=None, alias="item-query"),
    ):
        results = {"item_id": item_id}
        if q:
            results.update({"q": q})
        return results
    

Note

A path parameter is always required as it has to be part of the path. Even if you declared it with `None` or set a default value, it would not affect anything, it would still be always required.

## Order the parameters as you need[¶](#order-the-parameters-as-you-need "Permanent link")

Tip

This is probably not as important or necessary if you use `Annotated`.

Let's say that you want to declare the query parameter `q` as a required `str`.

And you don't need to declare anything else for that parameter, so you don't really need to use `Query`.

But you still need to use `Path` for the `item_id` path parameter. And you don't want to use `Annotated` for some reason.

Python will complain if you put a value with a "default" before a value that doesn't have a "default".

But you can re-order them, and have the value without a default (the query parameter `q`) first.

It doesn't matter for **FastAPI**. It will detect the parameters by their names, types and default declarations (`Query`, `Path`, etc), it doesn't care about the order.

So, you can declare your function as:

Python 3.9+ - non-Annotated
    
    
    from fastapi import FastAPI, Path
    
    app = FastAPI()
    
    
    @app.get("/items/{item_id}")
    async def read_items(q: str, item_id: int = Path(title="The ID of the item to get")):
        results = {"item_id": item_id}
        if q:
            results.update({"q": q})
        return results
    

ü§ì Other versions and variants

Python 3.9+
    
    
    from typing import Annotated
    
    from fastapi import FastAPI, Path
    
    app = FastAPI()
    
    
    @app.get("/items/{item_id}")
    async def read_items(
        q: str, item_id: Annotated[int, Path(title="The ID of the item to get")]
    ):
        results = {"item_id": item_id}
        if q:
            results.update({"q": q})
        return results
    

But keep in mind that if you use `Annotated`, you won't have this problem, it won't matter as you're not using the function parameter default values for `Query()` or `Path()`.

Python 3.9+
    
    
    from typing import Annotated
    
    from fastapi import FastAPI, Path
    
    app = FastAPI()
    
    
    @app.get("/items/{item_id}")
    async def read_items(
        q: str, item_id: Annotated[int, Path(title="The ID of the item to get")]
    ):
        results = {"item_id": item_id}
        if q:
            results.update({"q": q})
        return results
    

ü§ì Other versions and variants

Python 3.9+ - non-Annotated

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import FastAPI, Path
    
    app = FastAPI()
    
    
    @app.get("/items/{item_id}")
    async def read_items(q: str, item_id: int = Path(title="The ID of the item to get")):
        results = {"item_id": item_id}
        if q:
            results.update({"q": q})
        return results
    

## Order the parameters as you need, tricks[¶](#order-the-parameters-as-you-need-tricks "Permanent link")

Tip

This is probably not as important or necessary if you use `Annotated`.

Here's a **small trick** that can be handy, but you won't need it often.

If you want to:

  * declare the `q` query parameter without a `Query` nor any default value
  * declare the path parameter `item_id` using `Path`
  * have them in a different order
  * not use `Annotated`

...Python has a little special syntax for that.

Pass `*`, as the first parameter of the function.

Python won't do anything with that `*`, but it will know that all the following parameters should be called as keyword arguments (key-value pairs), also known as `kwargs`. Even if they don't have a default value.

Python 3.9+ - non-Annotated
    
    
    from fastapi import FastAPI, Path
    
    app = FastAPI()
    
    
    @app.get("/items/{item_id}")
    async def read_items(*, item_id: int = Path(title="The ID of the item to get"), q: str):
        results = {"item_id": item_id}
        if q:
            results.update({"q": q})
        return results
    

ü§ì Other versions and variants

Python 3.9+
    
    
    from typing import Annotated
    
    from fastapi import FastAPI, Path
    
    app = FastAPI()
    
    
    @app.get("/items/{item_id}")
    async def read_items(
        item_id: Annotated[int, Path(title="The ID of the item to get")], q: str
    ):
        results = {"item_id": item_id}
        if q:
            results.update({"q": q})
        return results
    

### Better with `Annotated`[¶](#better-with-annotated "Permanent link")

Keep in mind that if you use `Annotated`, as you are not using function parameter default values, you won't have this problem, and you probably won't need to use `*`.

Python 3.9+
    
    
    from typing import Annotated
    
    from fastapi import FastAPI, Path
    
    app = FastAPI()
    
    
    @app.get("/items/{item_id}")
    async def read_items(
        item_id: Annotated[int, Path(title="The ID of the item to get")], q: str
    ):
        results = {"item_id": item_id}
        if q:
            results.update({"q": q})
        return results
    

ü§ì Other versions and variants

Python 3.9+ - non-Annotated

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import FastAPI, Path
    
    app = FastAPI()
    
    
    @app.get("/items/{item_id}")
    async def read_items(*, item_id: int = Path(title="The ID of the item to get"), q: str):
        results = {"item_id": item_id}
        if q:
            results.update({"q": q})
        return results
    

## Number validations: greater than or equal[¶](#number-validations-greater-than-or-equal "Permanent link")

With `Query` and `Path` (and others you'll see later) you can declare number constraints.

Here, with `ge=1`, `item_id` will need to be an integer number "`g`reater than or `e`qual" to `1`.

Python 3.9+
    
    
    from typing import Annotated
    
    from fastapi import FastAPI, Path
    
    app = FastAPI()
    
    
    @app.get("/items/{item_id}")
    async def read_items(
        item_id: Annotated[int, Path(title="The ID of the item to get", ge=1)], q: str
    ):
        results = {"item_id": item_id}
        if q:
            results.update({"q": q})
        return results
    

ü§ì Other versions and variants

Python 3.9+ - non-Annotated

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import FastAPI, Path
    
    app = FastAPI()
    
    
    @app.get("/items/{item_id}")
    async def read_items(
        *, item_id: int = Path(title="The ID of the item to get", ge=1), q: str
    ):
        results = {"item_id": item_id}
        if q:
            results.update({"q": q})
        return results
    

## Number validations: greater than and less than or equal[¶](#number-validations-greater-than-and-less-than-or-equal "Permanent link")

The same applies for:

  * `gt`: `g`reater `t`han
  * `le`: `l`ess than or `e`qual

Python 3.9+
    
    
    from typing import Annotated
    
    from fastapi import FastAPI, Path
    
    app = FastAPI()
    
    
    @app.get("/items/{item_id}")
    async def read_items(
        item_id: Annotated[int, Path(title="The ID of the item to get", gt=0, le=1000)],
        q: str,
    ):
        results = {"item_id": item_id}
        if q:
            results.update({"q": q})
        return results
    

ü§ì Other versions and variants

Python 3.9+ - non-Annotated

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import FastAPI, Path
    
    app = FastAPI()
    
    
    @app.get("/items/{item_id}")
    async def read_items(
        *,
        item_id: int = Path(title="The ID of the item to get", gt=0, le=1000),
        q: str,
    ):
        results = {"item_id": item_id}
        if q:
            results.update({"q": q})
        return results
    

## Number validations: floats, greater than and less than[¶](#number-validations-floats-greater-than-and-less-than "Permanent link")

Number validations also work for `float` values.

Here's where it becomes important to be able to declare `gt` and not just `ge`. As with it you can require, for example, that a value must be greater than `0`, even if it is less than `1`.

So, `0.5` would be a valid value. But `0.0` or `0` would not.

And the same for `lt`.

Python 3.9+
    
    
    from typing import Annotated
    
    from fastapi import FastAPI, Path, Query
    
    app = FastAPI()
    
    
    @app.get("/items/{item_id}")
    async def read_items(
        *,
        item_id: Annotated[int, Path(title="The ID of the item to get", ge=0, le=1000)],
        q: str,
        size: Annotated[float, Query(gt=0, lt=10.5)],
    ):
        results = {"item_id": item_id}
        if q:
            results.update({"q": q})
        if size:
            results.update({"size": size})
        return results
    

ü§ì Other versions and variants

Python 3.9+ - non-Annotated

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import FastAPI, Path, Query
    
    app = FastAPI()
    
    
    @app.get("/items/{item_id}")
    async def read_items(
        *,
        item_id: int = Path(title="The ID of the item to get", ge=0, le=1000),
        q: str,
        size: float = Query(gt=0, lt=10.5),
    ):
        results = {"item_id": item_id}
        if q:
            results.update({"q": q})
        if size:
            results.update({"size": size})
        return results
    

## Recap[¶](#recap "Permanent link")

With `Query`, `Path` (and others you haven't seen yet) you can declare metadata and string validations in the same ways as with [Query Parameters and String Validations](../query-params-str-validations/).

And you can also declare numeric validations:

  * `gt`: `g`reater `t`han
  * `ge`: `g`reater than or `e`qual
  * `lt`: `l`ess `t`han
  * `le`: `l`ess than or `e`qual

Info

`Query`, `Path`, and other classes you will see later are subclasses of a common `Param` class.

All of them share the same parameters for additional validation and metadata you have seen.

Technical Details

When you import `Query`, `Path` and others from `fastapi`, they are actually functions.

That when called, return instances of classes of the same name.

So, you import `Query`, which is a function. And when you call it, it returns an instance of a class also named `Query`.

These functions are there (instead of just using the classes directly) so that your editor doesn't mark errors about their types.

That way you can use your normal editor and coding tools without having to add custom configurations to disregard those errors.
  *[`kwargs`]: From: K-ey W-ord Arg-uments
  *[`gt`]: greater than
  *[`ge`]: greater than or equal
  *[`lt`]: less than

---

###### Query Parameter Models¶

# Query Parameter Models[¶](#query-parameter-models "Permanent link")

If you have a group of **query parameters** that are related, you can create a **Pydantic model** to declare them.

This would allow you to **re-use the model** in **multiple places** and also to declare validations and metadata for all the parameters at once. üòé

Note

This is supported since FastAPI version `0.115.0`. ü§ì

## Query Parameters with a Pydantic Model[¶](#query-parameters-with-a-pydantic-model "Permanent link")

Declare the **query parameters** that you need in a **Pydantic model** , and then declare the parameter as `Query`:

Python 3.10+
    
    
    from typing import Annotated, Literal
    
    from fastapi import FastAPI, Query
    from pydantic import BaseModel, Field
    
    app = FastAPI()
    
    
    class FilterParams(BaseModel):
        limit: int = Field(100, gt=0, le=100)
        offset: int = Field(0, ge=0)
        order_by: Literal["created_at", "updated_at"] = "created_at"
        tags: list[str] = []
    
    
    @app.get("/items/")
    async def read_items(filter_query: Annotated[FilterParams, Query()]):
        return filter_query
    

ü§ì Other versions and variants

Python 3.9+Python 3.10+ - non-AnnotatedPython 3.9+ - non-Annotated
    
    
    from typing import Annotated, Literal
    
    from fastapi import FastAPI, Query
    from pydantic import BaseModel, Field
    
    app = FastAPI()
    
    
    class FilterParams(BaseModel):
        limit: int = Field(100, gt=0, le=100)
        offset: int = Field(0, ge=0)
        order_by: Literal["created_at", "updated_at"] = "created_at"
        tags: list[str] = []
    
    
    @app.get("/items/")
    async def read_items(filter_query: Annotated[FilterParams, Query()]):
        return filter_query
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from typing import Literal
    
    from fastapi import FastAPI, Query
    from pydantic import BaseModel, Field
    
    app = FastAPI()
    
    
    class FilterParams(BaseModel):
        limit: int = Field(100, gt=0, le=100)
        offset: int = Field(0, ge=0)
        order_by: Literal["created_at", "updated_at"] = "created_at"
        tags: list[str] = []
    
    
    @app.get("/items/")
    async def read_items(filter_query: FilterParams = Query()):
        return filter_query
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from typing import Literal
    
    from fastapi import FastAPI, Query
    from pydantic import BaseModel, Field
    
    app = FastAPI()
    
    
    class FilterParams(BaseModel):
        limit: int = Field(100, gt=0, le=100)
        offset: int = Field(0, ge=0)
        order_by: Literal["created_at", "updated_at"] = "created_at"
        tags: list[str] = []
    
    
    @app.get("/items/")
    async def read_items(filter_query: FilterParams = Query()):
        return filter_query
    

**FastAPI** will **extract** the data for **each field** from the **query parameters** in the request and give you the Pydantic model you defined.

## Check the Docs[¶](#check-the-docs "Permanent link")

You can see the query parameters in the docs UI at `/docs`:

![](/img/tutorial/query-param-models/image01.png)

## Forbid Extra Query Parameters[¶](#forbid-extra-query-parameters "Permanent link")

In some special use cases (probably not very common), you might want to **restrict** the query parameters that you want to receive.

You can use Pydantic's model configuration to `forbid` any `extra` fields:

Python 3.10+
    
    
    from typing import Annotated, Literal
    
    from fastapi import FastAPI, Query
    from pydantic import BaseModel, Field
    
    app = FastAPI()
    
    
    class FilterParams(BaseModel):
        model_config = {"extra": "forbid"}
    
        limit: int = Field(100, gt=0, le=100)
        offset: int = Field(0, ge=0)
        order_by: Literal["created_at", "updated_at"] = "created_at"
        tags: list[str] = []
    
    
    @app.get("/items/")
    async def read_items(filter_query: Annotated[FilterParams, Query()]):
        return filter_query
    

ü§ì Other versions and variants

Python 3.9+Python 3.10+ - non-AnnotatedPython 3.9+ - non-Annotated
    
    
    from typing import Annotated, Literal
    
    from fastapi import FastAPI, Query
    from pydantic import BaseModel, Field
    
    app = FastAPI()
    
    
    class FilterParams(BaseModel):
        model_config = {"extra": "forbid"}
    
        limit: int = Field(100, gt=0, le=100)
        offset: int = Field(0, ge=0)
        order_by: Literal["created_at", "updated_at"] = "created_at"
        tags: list[str] = []
    
    
    @app.get("/items/")
    async def read_items(filter_query: Annotated[FilterParams, Query()]):
        return filter_query
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from typing import Literal
    
    from fastapi import FastAPI, Query
    from pydantic import BaseModel, Field
    
    app = FastAPI()
    
    
    class FilterParams(BaseModel):
        model_config = {"extra": "forbid"}
    
        limit: int = Field(100, gt=0, le=100)
        offset: int = Field(0, ge=0)
        order_by: Literal["created_at", "updated_at"] = "created_at"
        tags: list[str] = []
    
    
    @app.get("/items/")
    async def read_items(filter_query: FilterParams = Query()):
        return filter_query
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from typing import Literal
    
    from fastapi import FastAPI, Query
    from pydantic import BaseModel, Field
    
    app = FastAPI()
    
    
    class FilterParams(BaseModel):
        model_config = {"extra": "forbid"}
    
        limit: int = Field(100, gt=0, le=100)
        offset: int = Field(0, ge=0)
        order_by: Literal["created_at", "updated_at"] = "created_at"
        tags: list[str] = []
    
    
    @app.get("/items/")
    async def read_items(filter_query: FilterParams = Query()):
        return filter_query
    

If a client tries to send some **extra** data in the **query parameters** , they will receive an **error** response.

For example, if the client tries to send a `tool` query parameter with a value of `plumbus`, like:
    
    
    https://example.com/items/?limit=10&tool=plumbus
    

They will receive an **error** response telling them that the query parameter `tool` is not allowed:
    
    
    {
        "detail": [
            {
                "type": "extra_forbidden",
                "loc": ["query", "tool"],
                "msg": "Extra inputs are not permitted",
                "input": "plumbus"
            }
        ]
    }
    

## Summary[¶](#summary "Permanent link")

You can use **Pydantic models** to declare **query parameters** in **FastAPI**. üòé

Tip

Spoiler alert: you can also use Pydantic models to declare cookies and headers, but you will read about that later in the tutorial. ü§´

---

###### Body - Multiple Parameters¶

# Body - Multiple Parameters[¶](#body-multiple-parameters "Permanent link")

Now that we have seen how to use `Path` and `Query`, let's see more advanced uses of request body declarations.

## Mix `Path`, `Query` and body parameters[¶](#mix-path-query-and-body-parameters "Permanent link")

First, of course, you can mix `Path`, `Query` and request body parameter declarations freely and **FastAPI** will know what to do.

And you can also declare body parameters as optional, by setting the default to `None`:

Python 3.10+
    
    
    from typing import Annotated
    
    from fastapi import FastAPI, Path
    from pydantic import BaseModel
    
    app = FastAPI()
    
    
    class Item(BaseModel):
        name: str
        description: str | None = None
        price: float
        tax: float | None = None
    
    
    @app.put("/items/{item_id}")
    async def update_item(
        item_id: Annotated[int, Path(title="The ID of the item to get", ge=0, le=1000)],
        q: str | None = None,
        item: Item | None = None,
    ):
        results = {"item_id": item_id}
        if q:
            results.update({"q": q})
        if item:
            results.update({"item": item})
        return results
    

ü§ì Other versions and variants

Python 3.9+Python 3.10+ - non-AnnotatedPython 3.9+ - non-Annotated
    
    
    from typing import Annotated, Union
    
    from fastapi import FastAPI, Path
    from pydantic import BaseModel
    
    app = FastAPI()
    
    
    class Item(BaseModel):
        name: str
        description: Union[str, None] = None
        price: float
        tax: Union[float, None] = None
    
    
    @app.put("/items/{item_id}")
    async def update_item(
        item_id: Annotated[int, Path(title="The ID of the item to get", ge=0, le=1000)],
        q: Union[str, None] = None,
        item: Union[Item, None] = None,
    ):
        results = {"item_id": item_id}
        if q:
            results.update({"q": q})
        if item:
            results.update({"item": item})
        return results
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import FastAPI, Path
    from pydantic import BaseModel
    
    app = FastAPI()
    
    
    class Item(BaseModel):
        name: str
        description: str | None = None
        price: float
        tax: float | None = None
    
    
    @app.put("/items/{item_id}")
    async def update_item(
        *,
        item_id: int = Path(title="The ID of the item to get", ge=0, le=1000),
        q: str | None = None,
        item: Item | None = None,
    ):
        results = {"item_id": item_id}
        if q:
            results.update({"q": q})
        if item:
            results.update({"item": item})
        return results
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from typing import Union
    
    from fastapi import FastAPI, Path
    from pydantic import BaseModel
    
    app = FastAPI()
    
    
    class Item(BaseModel):
        name: str
        description: Union[str, None] = None
        price: float
        tax: Union[float, None] = None
    
    
    @app.put("/items/{item_id}")
    async def update_item(
        *,
        item_id: int = Path(title="The ID of the item to get", ge=0, le=1000),
        q: Union[str, None] = None,
        item: Union[Item, None] = None,
    ):
        results = {"item_id": item_id}
        if q:
            results.update({"q": q})
        if item:
            results.update({"item": item})
        return results
    

Note

Notice that, in this case, the `item` that would be taken from the body is optional. As it has a `None` default value.

## Multiple body parameters[¶](#multiple-body-parameters "Permanent link")

In the previous example, the _path operations_ would expect a JSON body with the attributes of an `Item`, like:
    
    
    {
        "name": "Foo",
        "description": "The pretender",
        "price": 42.0,
        "tax": 3.2
    }
    

But you can also declare multiple body parameters, e.g. `item` and `user`:

Python 3.10+
    
    
    from fastapi import FastAPI
    from pydantic import BaseModel
    
    app = FastAPI()
    
    
    class Item(BaseModel):
        name: str
        description: str | None = None
        price: float
        tax: float | None = None
    
    
    class User(BaseModel):
        username: str
        full_name: str | None = None
    
    
    @app.put("/items/{item_id}")
    async def update_item(item_id: int, item: Item, user: User):
        results = {"item_id": item_id, "item": item, "user": user}
        return results
    

ü§ì Other versions and variants

Python 3.9+
    
    
    from typing import Union
    
    from fastapi import FastAPI
    from pydantic import BaseModel
    
    app = FastAPI()
    
    
    class Item(BaseModel):
        name: str
        description: Union[str, None] = None
        price: float
        tax: Union[float, None] = None
    
    
    class User(BaseModel):
        username: str
        full_name: Union[str, None] = None
    
    
    @app.put("/items/{item_id}")
    async def update_item(item_id: int, item: Item, user: User):
        results = {"item_id": item_id, "item": item, "user": user}
        return results
    

In this case, **FastAPI** will notice that there is more than one body parameter in the function (there are two parameters that are Pydantic models).

So, it will then use the parameter names as keys (field names) in the body, and expect a body like:
    
    
    {
        "item": {
            "name": "Foo",
            "description": "The pretender",
            "price": 42.0,
            "tax": 3.2
        },
        "user": {
            "username": "dave",
            "full_name": "Dave Grohl"
        }
    }
    

Note

Notice that even though the `item` was declared the same way as before, it is now expected to be inside of the body with a key `item`.

**FastAPI** will do the automatic conversion from the request, so that the parameter `item` receives its specific content and the same for `user`.

It will perform the validation of the compound data, and will document it like that for the OpenAPI schema and automatic docs.

## Singular values in body[¶](#singular-values-in-body "Permanent link")

The same way there is a `Query` and `Path` to define extra data for query and path parameters, **FastAPI** provides an equivalent `Body`.

For example, extending the previous model, you could decide that you want to have another key `importance` in the same body, besides the `item` and `user`.

If you declare it as is, because it is a singular value, **FastAPI** will assume that it is a query parameter.

But you can instruct **FastAPI** to treat it as another body key using `Body`:

Python 3.10+
    
    
    from typing import Annotated
    
    from fastapi import Body, FastAPI
    from pydantic import BaseModel
    
    app = FastAPI()
    
    
    class Item(BaseModel):
        name: str
        description: str | None = None
        price: float
        tax: float | None = None
    
    
    class User(BaseModel):
        username: str
        full_name: str | None = None
    
    
    @app.put("/items/{item_id}")
    async def update_item(
        item_id: int, item: Item, user: User, importance: Annotated[int, Body()]
    ):
        results = {"item_id": item_id, "item": item, "user": user, "importance": importance}
        return results
    

ü§ì Other versions and variants

Python 3.9+Python 3.10+ - non-AnnotatedPython 3.9+ - non-Annotated
    
    
    from typing import Annotated, Union
    
    from fastapi import Body, FastAPI
    from pydantic import BaseModel
    
    app = FastAPI()
    
    
    class Item(BaseModel):
        name: str
        description: Union[str, None] = None
        price: float
        tax: Union[float, None] = None
    
    
    class User(BaseModel):
        username: str
        full_name: Union[str, None] = None
    
    
    @app.put("/items/{item_id}")
    async def update_item(
        item_id: int, item: Item, user: User, importance: Annotated[int, Body()]
    ):
        results = {"item_id": item_id, "item": item, "user": user, "importance": importance}
        return results
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import Body, FastAPI
    from pydantic import BaseModel
    
    app = FastAPI()
    
    
    class Item(BaseModel):
        name: str
        description: str | None = None
        price: float
        tax: float | None = None
    
    
    class User(BaseModel):
        username: str
        full_name: str | None = None
    
    
    @app.put("/items/{item_id}")
    async def update_item(item_id: int, item: Item, user: User, importance: int = Body()):
        results = {"item_id": item_id, "item": item, "user": user, "importance": importance}
        return results
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from typing import Union
    
    from fastapi import Body, FastAPI
    from pydantic import BaseModel
    
    app = FastAPI()
    
    
    class Item(BaseModel):
        name: str
        description: Union[str, None] = None
        price: float
        tax: Union[float, None] = None
    
    
    class User(BaseModel):
        username: str
        full_name: Union[str, None] = None
    
    
    @app.put("/items/{item_id}")
    async def update_item(item_id: int, item: Item, user: User, importance: int = Body()):
        results = {"item_id": item_id, "item": item, "user": user, "importance": importance}
        return results
    

In this case, **FastAPI** will expect a body like:
    
    
    {
        "item": {
            "name": "Foo",
            "description": "The pretender",
            "price": 42.0,
            "tax": 3.2
        },
        "user": {
            "username": "dave",
            "full_name": "Dave Grohl"
        },
        "importance": 5
    }
    

Again, it will convert the data types, validate, document, etc.

## Multiple body params and query[¶](#multiple-body-params-and-query "Permanent link")

Of course, you can also declare additional query parameters whenever you need, additional to any body parameters.

As, by default, singular values are interpreted as query parameters, you don't have to explicitly add a `Query`, you can just do:
    
    
    q: str | None = None
    

Or in Python 3.9:
    
    
    q: Union[str, None] = None
    

For example:

Python 3.10+
    
    
    from typing import Annotated
    
    from fastapi import Body, FastAPI
    from pydantic import BaseModel
    
    app = FastAPI()
    
    
    class Item(BaseModel):
        name: str
        description: str | None = None
        price: float
        tax: float | None = None
    
    
    class User(BaseModel):
        username: str
        full_name: str | None = None
    
    
    @app.put("/items/{item_id}")
    async def update_item(
        *,
        item_id: int,
        item: Item,
        user: User,
        importance: Annotated[int, Body(gt=0)],
        q: str | None = None,
    ):
        results = {"item_id": item_id, "item": item, "user": user, "importance": importance}
        if q:
            results.update({"q": q})
        return results
    

ü§ì Other versions and variants

Python 3.9+Python 3.10+ - non-AnnotatedPython 3.9+ - non-Annotated
    
    
    from typing import Annotated, Union
    
    from fastapi import Body, FastAPI
    from pydantic import BaseModel
    
    app = FastAPI()
    
    
    class Item(BaseModel):
        name: str
        description: Union[str, None] = None
        price: float
        tax: Union[float, None] = None
    
    
    class User(BaseModel):
        username: str
        full_name: Union[str, None] = None
    
    
    @app.put("/items/{item_id}")
    async def update_item(
        *,
        item_id: int,
        item: Item,
        user: User,
        importance: Annotated[int, Body(gt=0)],
        q: Union[str, None] = None,
    ):
        results = {"item_id": item_id, "item": item, "user": user, "importance": importance}
        if q:
            results.update({"q": q})
        return results
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import Body, FastAPI
    from pydantic import BaseModel
    
    app = FastAPI()
    
    
    class Item(BaseModel):
        name: str
        description: str | None = None
        price: float
        tax: float | None = None
    
    
    class User(BaseModel):
        username: str
        full_name: str | None = None
    
    
    @app.put("/items/{item_id}")
    async def update_item(
        *,
        item_id: int,
        item: Item,
        user: User,
        importance: int = Body(gt=0),
        q: str | None = None,
    ):
        results = {"item_id": item_id, "item": item, "user": user, "importance": importance}
        if q:
            results.update({"q": q})
        return results
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from typing import Union
    
    from fastapi import Body, FastAPI
    from pydantic import BaseModel
    
    app = FastAPI()
    
    
    class Item(BaseModel):
        name: str
        description: Union[str, None] = None
        price: float
        tax: Union[float, None] = None
    
    
    class User(BaseModel):
        username: str
        full_name: Union[str, None] = None
    
    
    @app.put("/items/{item_id}")
    async def update_item(
        *,
        item_id: int,
        item: Item,
        user: User,
        importance: int = Body(gt=0),
        q: Union[str, None] = None,
    ):
        results = {"item_id": item_id, "item": item, "user": user, "importance": importance}
        if q:
            results.update({"q": q})
        return results
    

Info

`Body` also has all the same extra validation and metadata parameters as `Query`, `Path` and others you will see later.

## Embed a single body parameter[¶](#embed-a-single-body-parameter "Permanent link")

Let's say you only have a single `item` body parameter from a Pydantic model `Item`.

By default, **FastAPI** will then expect its body directly.

But if you want it to expect a JSON with a key `item` and inside of it the model contents, as it does when you declare extra body parameters, you can use the special `Body` parameter `embed`:
    
    
    item: Item = Body(embed=True)
    

as in:

Python 3.10+
    
    
    from typing import Annotated
    
    from fastapi import Body, FastAPI
    from pydantic import BaseModel
    
    app = FastAPI()
    
    
    class Item(BaseModel):
        name: str
        description: str | None = None
        price: float
        tax: float | None = None
    
    
    @app.put("/items/{item_id}")
    async def update_item(item_id: int, item: Annotated[Item, Body(embed=True)]):
        results = {"item_id": item_id, "item": item}
        return results
    

ü§ì Other versions and variants

Python 3.9+Python 3.10+ - non-AnnotatedPython 3.9+ - non-Annotated
    
    
    from typing import Annotated, Union
    
    from fastapi import Body, FastAPI
    from pydantic import BaseModel
    
    app = FastAPI()
    
    
    class Item(BaseModel):
        name: str
        description: Union[str, None] = None
        price: float
        tax: Union[float, None] = None
    
    
    @app.put("/items/{item_id}")
    async def update_item(item_id: int, item: Annotated[Item, Body(embed=True)]):
        results = {"item_id": item_id, "item": item}
        return results
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import Body, FastAPI
    from pydantic import BaseModel
    
    app = FastAPI()
    
    
    class Item(BaseModel):
        name: str
        description: str | None = None
        price: float
        tax: float | None = None
    
    
    @app.put("/items/{item_id}")
    async def update_item(item_id: int, item: Item = Body(embed=True)):
        results = {"item_id": item_id, "item": item}
        return results
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from typing import Union
    
    from fastapi import Body, FastAPI
    from pydantic import BaseModel
    
    app = FastAPI()
    
    
    class Item(BaseModel):
        name: str
        description: Union[str, None] = None
        price: float
        tax: Union[float, None] = None
    
    
    @app.put("/items/{item_id}")
    async def update_item(item_id: int, item: Item = Body(embed=True)):
        results = {"item_id": item_id, "item": item}
        return results
    

In this case **FastAPI** will expect a body like:
    
    
    {
        "item": {
            "name": "Foo",
            "description": "The pretender",
            "price": 42.0,
            "tax": 3.2
        }
    }
    

instead of:
    
    
    {
        "name": "Foo",
        "description": "The pretender",
        "price": 42.0,
        "tax": 3.2
    }
    

## Recap[¶](#recap "Permanent link")

You can add multiple body parameters to your _path operation function_ , even though a request can only have a single body.

But **FastAPI** will handle it, give you the correct data in your function, and validate and document the correct schema in the _path operation_.

You can also declare singular values to be received as part of the body.

And you can instruct **FastAPI** to embed the body in a key even when there is only a single parameter declared.

---

###### Body - Fields¶

# Body - Fields[¶](#body-fields "Permanent link")

The same way you can declare additional validation and metadata in _path operation function_ parameters with `Query`, `Path` and `Body`, you can declare validation and metadata inside of Pydantic models using Pydantic's `Field`.

## Import `Field`[¶](#import-field "Permanent link")

First, you have to import it:

Python 3.10+
    
    
    from typing import Annotated
    
    from fastapi import Body, FastAPI
    from pydantic import BaseModel, Field
    
    app = FastAPI()
    
    
    class Item(BaseModel):
        name: str
        description: str | None = Field(
            default=None, title="The description of the item", max_length=300
        )
        price: float = Field(gt=0, description="The price must be greater than zero")
        tax: float | None = None
    
    
    @app.put("/items/{item_id}")
    async def update_item(item_id: int, item: Annotated[Item, Body(embed=True)]):
        results = {"item_id": item_id, "item": item}
        return results
    

ü§ì Other versions and variants

Python 3.9+Python 3.10+ - non-AnnotatedPython 3.9+ - non-Annotated
    
    
    from typing import Annotated, Union
    
    from fastapi import Body, FastAPI
    from pydantic import BaseModel, Field
    
    app = FastAPI()
    
    
    class Item(BaseModel):
        name: str
        description: Union[str, None] = Field(
            default=None, title="The description of the item", max_length=300
        )
        price: float = Field(gt=0, description="The price must be greater than zero")
        tax: Union[float, None] = None
    
    
    @app.put("/items/{item_id}")
    async def update_item(item_id: int, item: Annotated[Item, Body(embed=True)]):
        results = {"item_id": item_id, "item": item}
        return results
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import Body, FastAPI
    from pydantic import BaseModel, Field
    
    app = FastAPI()
    
    
    class Item(BaseModel):
        name: str
        description: str | None = Field(
            default=None, title="The description of the item", max_length=300
        )
        price: float = Field(gt=0, description="The price must be greater than zero")
        tax: float | None = None
    
    
    @app.put("/items/{item_id}")
    async def update_item(item_id: int, item: Item = Body(embed=True)):
        results = {"item_id": item_id, "item": item}
        return results
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from typing import Union
    
    from fastapi import Body, FastAPI
    from pydantic import BaseModel, Field
    
    app = FastAPI()
    
    
    class Item(BaseModel):
        name: str
        description: Union[str, None] = Field(
            default=None, title="The description of the item", max_length=300
        )
        price: float = Field(gt=0, description="The price must be greater than zero")
        tax: Union[float, None] = None
    
    
    @app.put("/items/{item_id}")
    async def update_item(item_id: int, item: Item = Body(embed=True)):
        results = {"item_id": item_id, "item": item}
        return results
    

Warning

Notice that `Field` is imported directly from `pydantic`, not from `fastapi` as are all the rest (`Query`, `Path`, `Body`, etc).

## Declare model attributes[¶](#declare-model-attributes "Permanent link")

You can then use `Field` with model attributes:

Python 3.10+
    
    
    from typing import Annotated
    
    from fastapi import Body, FastAPI
    from pydantic import BaseModel, Field
    
    app = FastAPI()
    
    
    class Item(BaseModel):
        name: str
        description: str | None = Field(
            default=None, title="The description of the item", max_length=300
        )
        price: float = Field(gt=0, description="The price must be greater than zero")
        tax: float | None = None
    
    
    @app.put("/items/{item_id}")
    async def update_item(item_id: int, item: Annotated[Item, Body(embed=True)]):
        results = {"item_id": item_id, "item": item}
        return results
    

ü§ì Other versions and variants

Python 3.9+Python 3.10+ - non-AnnotatedPython 3.9+ - non-Annotated
    
    
    from typing import Annotated, Union
    
    from fastapi import Body, FastAPI
    from pydantic import BaseModel, Field
    
    app = FastAPI()
    
    
    class Item(BaseModel):
        name: str
        description: Union[str, None] = Field(
            default=None, title="The description of the item", max_length=300
        )
        price: float = Field(gt=0, description="The price must be greater than zero")
        tax: Union[float, None] = None
    
    
    @app.put("/items/{item_id}")
    async def update_item(item_id: int, item: Annotated[Item, Body(embed=True)]):
        results = {"item_id": item_id, "item": item}
        return results
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import Body, FastAPI
    from pydantic import BaseModel, Field
    
    app = FastAPI()
    
    
    class Item(BaseModel):
        name: str
        description: str | None = Field(
            default=None, title="The description of the item", max_length=300
        )
        price: float = Field(gt=0, description="The price must be greater than zero")
        tax: float | None = None
    
    
    @app.put("/items/{item_id}")
    async def update_item(item_id: int, item: Item = Body(embed=True)):
        results = {"item_id": item_id, "item": item}
        return results
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from typing import Union
    
    from fastapi import Body, FastAPI
    from pydantic import BaseModel, Field
    
    app = FastAPI()
    
    
    class Item(BaseModel):
        name: str
        description: Union[str, None] = Field(
            default=None, title="The description of the item", max_length=300
        )
        price: float = Field(gt=0, description="The price must be greater than zero")
        tax: Union[float, None] = None
    
    
    @app.put("/items/{item_id}")
    async def update_item(item_id: int, item: Item = Body(embed=True)):
        results = {"item_id": item_id, "item": item}
        return results
    

`Field` works the same way as `Query`, `Path` and `Body`, it has all the same parameters, etc.

Technical Details

Actually, `Query`, `Path` and others you'll see next create objects of subclasses of a common `Param` class, which is itself a subclass of Pydantic's `FieldInfo` class.

And Pydantic's `Field` returns an instance of `FieldInfo` as well.

`Body` also returns objects of a subclass of `FieldInfo` directly. And there are others you will see later that are subclasses of the `Body` class.

Remember that when you import `Query`, `Path`, and others from `fastapi`, those are actually functions that return special classes.

Tip

Notice how each model's attribute with a type, default value and `Field` has the same structure as a _path operation function's_ parameter, with `Field` instead of `Path`, `Query` and `Body`.

## Add extra information[¶](#add-extra-information "Permanent link")

You can declare extra information in `Field`, `Query`, `Body`, etc. And it will be included in the generated JSON Schema.

You will learn more about adding extra information later in the docs, when learning to declare examples.

Warning

Extra keys passed to `Field` will also be present in the resulting OpenAPI schema for your application. As these keys may not necessarily be part of the OpenAPI specification, some OpenAPI tools, for example [the OpenAPI validator](https://validator.swagger.io/), may not work with your generated schema.

## Recap[¶](#recap "Permanent link")

You can use Pydantic's `Field` to declare extra validations and metadata for model attributes.

You can also use the extra keyword arguments to pass additional JSON Schema metadata.

---

###### Body - Nested Models¶

# Body - Nested Models[¶](#body-nested-models "Permanent link")

With **FastAPI** , you can define, validate, document, and use arbitrarily deeply nested models (thanks to Pydantic).

## List fields[¶](#list-fields "Permanent link")

You can define an attribute to be a subtype. For example, a Python `list`:

Python 3.10+
    
    
    from fastapi import FastAPI
    from pydantic import BaseModel
    
    app = FastAPI()
    
    
    class Item(BaseModel):
        name: str
        description: str | None = None
        price: float
        tax: float | None = None
        tags: list = []
    
    
    @app.put("/items/{item_id}")
    async def update_item(item_id: int, item: Item):
        results = {"item_id": item_id, "item": item}
        return results
    

ü§ì Other versions and variants

Python 3.9+
    
    
    from typing import Union
    
    from fastapi import FastAPI
    from pydantic import BaseModel
    
    app = FastAPI()
    
    
    class Item(BaseModel):
        name: str
        description: Union[str, None] = None
        price: float
        tax: Union[float, None] = None
        tags: list = []
    
    
    @app.put("/items/{item_id}")
    async def update_item(item_id: int, item: Item):
        results = {"item_id": item_id, "item": item}
        return results
    

This will make `tags` be a list, although it doesn't declare the type of the elements of the list.

## List fields with type parameter[¶](#list-fields-with-type-parameter "Permanent link")

But Python has a specific way to declare lists with internal types, or "type parameters":

### Declare a `list` with a type parameter[¶](#declare-a-list-with-a-type-parameter "Permanent link")

To declare types that have type parameters (internal types), like `list`, `dict`, `tuple`, pass the internal type(s) as "type parameters" using square brackets: `[` and `]`
    
    
    my_list: list[str]
    

That's all standard Python syntax for type declarations.

Use that same standard syntax for model attributes with internal types.

So, in our example, we can make `tags` be specifically a "list of strings":

Python 3.10+
    
    
    from fastapi import FastAPI
    from pydantic import BaseModel
    
    app = FastAPI()
    
    
    class Item(BaseModel):
        name: str
        description: str | None = None
        price: float
        tax: float | None = None
        tags: list[str] = []
    
    
    @app.put("/items/{item_id}")
    async def update_item(item_id: int, item: Item):
        results = {"item_id": item_id, "item": item}
        return results
    

ü§ì Other versions and variants

Python 3.9+
    
    
    from typing import Union
    
    from fastapi import FastAPI
    from pydantic import BaseModel
    
    app = FastAPI()
    
    
    class Item(BaseModel):
        name: str
        description: Union[str, None] = None
        price: float
        tax: Union[float, None] = None
        tags: list[str] = []
    
    
    @app.put("/items/{item_id}")
    async def update_item(item_id: int, item: Item):
        results = {"item_id": item_id, "item": item}
        return results
    

## Set types[¶](#set-types "Permanent link")

But then we think about it, and realize that tags shouldn't repeat, they would probably be unique strings.

And Python has a special data type for sets of unique items, the `set`.

Then we can declare `tags` as a set of strings:

Python 3.10+
    
    
    from fastapi import FastAPI
    from pydantic import BaseModel
    
    app = FastAPI()
    
    
    class Item(BaseModel):
        name: str
        description: str | None = None
        price: float
        tax: float | None = None
        tags: set[str] = set()
    
    
    @app.put("/items/{item_id}")
    async def update_item(item_id: int, item: Item):
        results = {"item_id": item_id, "item": item}
        return results
    

ü§ì Other versions and variants

Python 3.9+
    
    
    from typing import Union
    
    from fastapi import FastAPI
    from pydantic import BaseModel
    
    app = FastAPI()
    
    
    class Item(BaseModel):
        name: str
        description: Union[str, None] = None
        price: float
        tax: Union[float, None] = None
        tags: set[str] = set()
    
    
    @app.put("/items/{item_id}")
    async def update_item(item_id: int, item: Item):
        results = {"item_id": item_id, "item": item}
        return results
    

With this, even if you receive a request with duplicate data, it will be converted to a set of unique items.

And whenever you output that data, even if the source had duplicates, it will be output as a set of unique items.

And it will be annotated / documented accordingly too.

## Nested Models[¶](#nested-models "Permanent link")

Each attribute of a Pydantic model has a type.

But that type can itself be another Pydantic model.

So, you can declare deeply nested JSON "objects" with specific attribute names, types and validations.

All that, arbitrarily nested.

### Define a submodel[¶](#define-a-submodel "Permanent link")

For example, we can define an `Image` model:

Python 3.10+
    
    
    from fastapi import FastAPI
    from pydantic import BaseModel
    
    app = FastAPI()
    
    
    class Image(BaseModel):
        url: str
        name: str
    
    
    class Item(BaseModel):
        name: str
        description: str | None = None
        price: float
        tax: float | None = None
        tags: set[str] = set()
        image: Image | None = None
    
    
    @app.put("/items/{item_id}")
    async def update_item(item_id: int, item: Item):
        results = {"item_id": item_id, "item": item}
        return results
    

ü§ì Other versions and variants

Python 3.9+
    
    
    from typing import Union
    
    from fastapi import FastAPI
    from pydantic import BaseModel
    
    app = FastAPI()
    
    
    class Image(BaseModel):
        url: str
        name: str
    
    
    class Item(BaseModel):
        name: str
        description: Union[str, None] = None
        price: float
        tax: Union[float, None] = None
        tags: set[str] = set()
        image: Union[Image, None] = None
    
    
    @app.put("/items/{item_id}")
    async def update_item(item_id: int, item: Item):
        results = {"item_id": item_id, "item": item}
        return results
    

### Use the submodel as a type[¶](#use-the-submodel-as-a-type "Permanent link")

And then we can use it as the type of an attribute:

Python 3.10+
    
    
    from fastapi import FastAPI
    from pydantic import BaseModel
    
    app = FastAPI()
    
    
    class Image(BaseModel):
        url: str
        name: str
    
    
    class Item(BaseModel):
        name: str
        description: str | None = None
        price: float
        tax: float | None = None
        tags: set[str] = set()
        image: Image | None = None
    
    
    @app.put("/items/{item_id}")
    async def update_item(item_id: int, item: Item):
        results = {"item_id": item_id, "item": item}
        return results
    

ü§ì Other versions and variants

Python 3.9+
    
    
    from typing import Union
    
    from fastapi import FastAPI
    from pydantic import BaseModel
    
    app = FastAPI()
    
    
    class Image(BaseModel):
        url: str
        name: str
    
    
    class Item(BaseModel):
        name: str
        description: Union[str, None] = None
        price: float
        tax: Union[float, None] = None
        tags: set[str] = set()
        image: Union[Image, None] = None
    
    
    @app.put("/items/{item_id}")
    async def update_item(item_id: int, item: Item):
        results = {"item_id": item_id, "item": item}
        return results
    

This would mean that **FastAPI** would expect a body similar to:
    
    
    {
        "name": "Foo",
        "description": "The pretender",
        "price": 42.0,
        "tax": 3.2,
        "tags": ["rock", "metal", "bar"],
        "image": {
            "url": "http://example.com/baz.jpg",
            "name": "The Foo live"
        }
    }
    

Again, doing just that declaration, with **FastAPI** you get:

  * Editor support (completion, etc.), even for nested models
  * Data conversion
  * Data validation
  * Automatic documentation

## Special types and validation[¶](#special-types-and-validation "Permanent link")

Apart from normal singular types like `str`, `int`, `float`, etc. you can use more complex singular types that inherit from `str`.

To see all the options you have, checkout [Pydantic's Type Overview](https://docs.pydantic.dev/latest/concepts/types/). You will see some examples in the next chapter.

For example, as in the `Image` model we have a `url` field, we can declare it to be an instance of Pydantic's `HttpUrl` instead of a `str`:

Python 3.10+
    
    
    from fastapi import FastAPI
    from pydantic import BaseModel, HttpUrl
    
    app = FastAPI()
    
    
    class Image(BaseModel):
        url: HttpUrl
        name: str
    
    
    class Item(BaseModel):
        name: str
        description: str | None = None
        price: float
        tax: float | None = None
        tags: set[str] = set()
        image: Image | None = None
    
    
    @app.put("/items/{item_id}")
    async def update_item(item_id: int, item: Item):
        results = {"item_id": item_id, "item": item}
        return results
    

ü§ì Other versions and variants

Python 3.9+
    
    
    from typing import Union
    
    from fastapi import FastAPI
    from pydantic import BaseModel, HttpUrl
    
    app = FastAPI()
    
    
    class Image(BaseModel):
        url: HttpUrl
        name: str
    
    
    class Item(BaseModel):
        name: str
        description: Union[str, None] = None
        price: float
        tax: Union[float, None] = None
        tags: set[str] = set()
        image: Union[Image, None] = None
    
    
    @app.put("/items/{item_id}")
    async def update_item(item_id: int, item: Item):
        results = {"item_id": item_id, "item": item}
        return results
    

The string will be checked to be a valid URL, and documented in JSON Schema / OpenAPI as such.

## Attributes with lists of submodels[¶](#attributes-with-lists-of-submodels "Permanent link")

You can also use Pydantic models as subtypes of `list`, `set`, etc.:

Python 3.10+
    
    
    from fastapi import FastAPI
    from pydantic import BaseModel, HttpUrl
    
    app = FastAPI()
    
    
    class Image(BaseModel):
        url: HttpUrl
        name: str
    
    
    class Item(BaseModel):
        name: str
        description: str | None = None
        price: float
        tax: float | None = None
        tags: set[str] = set()
        images: list[Image] | None = None
    
    
    @app.put("/items/{item_id}")
    async def update_item(item_id: int, item: Item):
        results = {"item_id": item_id, "item": item}
        return results
    

ü§ì Other versions and variants

Python 3.9+
    
    
    from typing import Union
    
    from fastapi import FastAPI
    from pydantic import BaseModel, HttpUrl
    
    app = FastAPI()
    
    
    class Image(BaseModel):
        url: HttpUrl
        name: str
    
    
    class Item(BaseModel):
        name: str
        description: Union[str, None] = None
        price: float
        tax: Union[float, None] = None
        tags: set[str] = set()
        images: Union[list[Image], None] = None
    
    
    @app.put("/items/{item_id}")
    async def update_item(item_id: int, item: Item):
        results = {"item_id": item_id, "item": item}
        return results
    

This will expect (convert, validate, document, etc.) a JSON body like:
    
    
    {
        "name": "Foo",
        "description": "The pretender",
        "price": 42.0,
        "tax": 3.2,
        "tags": [
            "rock",
            "metal",
            "bar"
        ],
        "images": [
            {
                "url": "http://example.com/baz.jpg",
                "name": "The Foo live"
            },
            {
                "url": "http://example.com/dave.jpg",
                "name": "The Baz"
            }
        ]
    }
    

Info

Notice how the `images` key now has a list of image objects.

## Deeply nested models[¶](#deeply-nested-models "Permanent link")

You can define arbitrarily deeply nested models:

Python 3.10+
    
    
    from fastapi import FastAPI
    from pydantic import BaseModel, HttpUrl
    
    app = FastAPI()
    
    
    class Image(BaseModel):
        url: HttpUrl
        name: str
    
    
    class Item(BaseModel):
        name: str
        description: str | None = None
        price: float
        tax: float | None = None
        tags: set[str] = set()
        images: list[Image] | None = None
    
    
    class Offer(BaseModel):
        name: str
        description: str | None = None
        price: float
        items: list[Item]
    
    
    @app.post("/offers/")
    async def create_offer(offer: Offer):
        return offer
    

ü§ì Other versions and variants

Python 3.9+
    
    
    from typing import Union
    
    from fastapi import FastAPI
    from pydantic import BaseModel, HttpUrl
    
    app = FastAPI()
    
    
    class Image(BaseModel):
        url: HttpUrl
        name: str
    
    
    class Item(BaseModel):
        name: str
        description: Union[str, None] = None
        price: float
        tax: Union[float, None] = None
        tags: set[str] = set()
        images: Union[list[Image], None] = None
    
    
    class Offer(BaseModel):
        name: str
        description: Union[str, None] = None
        price: float
        items: list[Item]
    
    
    @app.post("/offers/")
    async def create_offer(offer: Offer):
        return offer
    

Info

Notice how `Offer` has a list of `Item`s, which in turn have an optional list of `Image`s

## Bodies of pure lists[¶](#bodies-of-pure-lists "Permanent link")

If the top level value of the JSON body you expect is a JSON `array` (a Python `list`), you can declare the type in the parameter of the function, the same as in Pydantic models:
    
    
    images: list[Image]
    

as in:

Python 3.9+
    
    
    from fastapi import FastAPI
    from pydantic import BaseModel, HttpUrl
    
    app = FastAPI()
    
    
    class Image(BaseModel):
        url: HttpUrl
        name: str
    
    
    @app.post("/images/multiple/")
    async def create_multiple_images(images: list[Image]):
        return images
    

## Editor support everywhere[¶](#editor-support-everywhere "Permanent link")

And you get editor support everywhere.

Even for items inside of lists:

![](/img/tutorial/body-nested-models/image01.png)

You couldn't get this kind of editor support if you were working directly with `dict` instead of Pydantic models.

But you don't have to worry about them either, incoming dicts are converted automatically and your output is converted automatically to JSON too.

## Bodies of arbitrary `dict`s[¶](#bodies-of-arbitrary-dicts "Permanent link")

You can also declare a body as a `dict` with keys of some type and values of some other type.

This way, you don't have to know beforehand what the valid field/attribute names are (as would be the case with Pydantic models).

This would be useful if you want to receive keys that you don't already know.

* * *

Another useful case is when you want to have keys of another type (e.g., `int`).

That's what we are going to see here.

In this case, you would accept any `dict` as long as it has `int` keys with `float` values:

Python 3.9+
    
    
    from fastapi import FastAPI
    
    app = FastAPI()
    
    
    @app.post("/index-weights/")
    async def create_index_weights(weights: dict[int, float]):
        return weights
    

Tip

Keep in mind that JSON only supports `str` as keys.

But Pydantic has automatic data conversion.

This means that, even though your API clients can only send strings as keys, as long as those strings contain pure integers, Pydantic will convert them and validate them.

And the `dict` you receive as `weights` will actually have `int` keys and `float` values.

## Recap[¶](#recap "Permanent link")

With **FastAPI** you have the maximum flexibility provided by Pydantic models, while keeping your code simple, short and elegant.

But with all the benefits:

  * Editor support (completion everywhere!)
  * Data conversion (a.k.a. parsing / serialization)
  * Data validation
  * Schema documentation
  * Automatic docs

---

###### Declare Request Example Data¶

# Declare Request Example Data[¶](#declare-request-example-data "Permanent link")

You can declare examples of the data your app can receive.

Here are several ways to do it.

## Extra JSON Schema data in Pydantic models[¶](#extra-json-schema-data-in-pydantic-models "Permanent link")

You can declare `examples` for a Pydantic model that will be added to the generated JSON Schema.

Python 3.10+
    
    
    from fastapi import FastAPI
    from pydantic import BaseModel
    
    app = FastAPI()
    
    
    class Item(BaseModel):
        name: str
        description: str | None = None
        price: float
        tax: float | None = None
    
        model_config = {
            "json_schema_extra": {
                "examples": [
                    {
                        "name": "Foo",
                        "description": "A very nice Item",
                        "price": 35.4,
                        "tax": 3.2,
                    }
                ]
            }
        }
    
    
    @app.put("/items/{item_id}")
    async def update_item(item_id: int, item: Item):
        results = {"item_id": item_id, "item": item}
        return results
    

ü§ì Other versions and variants

Python 3.9+
    
    
    from typing import Union
    
    from fastapi import FastAPI
    from pydantic import BaseModel
    
    app = FastAPI()
    
    
    class Item(BaseModel):
        name: str
        description: Union[str, None] = None
        price: float
        tax: Union[float, None] = None
    
        model_config = {
            "json_schema_extra": {
                "examples": [
                    {
                        "name": "Foo",
                        "description": "A very nice Item",
                        "price": 35.4,
                        "tax": 3.2,
                    }
                ]
            }
        }
    
    
    @app.put("/items/{item_id}")
    async def update_item(item_id: int, item: Item):
        results = {"item_id": item_id, "item": item}
        return results
    

That extra info will be added as-is to the output **JSON Schema** for that model, and it will be used in the API docs.

You can use the attribute `model_config` that takes a `dict` as described in [Pydantic's docs: Configuration](https://docs.pydantic.dev/latest/api/config/).

You can set `"json_schema_extra"` with a `dict` containing any additional data you would like to show up in the generated JSON Schema, including `examples`.

Tip

You could use the same technique to extend the JSON Schema and add your own custom extra info.

For example you could use it to add metadata for a frontend user interface, etc.

Info

OpenAPI 3.1.0 (used since FastAPI 0.99.0) added support for `examples`, which is part of the **JSON Schema** standard.

Before that, it only supported the keyword `example` with a single example. That is still supported by OpenAPI 3.1.0, but is deprecated and is not part of the JSON Schema standard. So you are encouraged to migrate `example` to `examples`. ü§ì

You can read more at the end of this page.

## `Field` additional arguments[¶](#field-additional-arguments "Permanent link")

When using `Field()` with Pydantic models, you can also declare additional `examples`:

Python 3.10+
    
    
    from fastapi import FastAPI
    from pydantic import BaseModel, Field
    
    app = FastAPI()
    
    
    class Item(BaseModel):
        name: str = Field(examples=["Foo"])
        description: str | None = Field(default=None, examples=["A very nice Item"])
        price: float = Field(examples=[35.4])
        tax: float | None = Field(default=None, examples=[3.2])
    
    
    @app.put("/items/{item_id}")
    async def update_item(item_id: int, item: Item):
        results = {"item_id": item_id, "item": item}
        return results
    

ü§ì Other versions and variants

Python 3.9+
    
    
    from typing import Union
    
    from fastapi import FastAPI
    from pydantic import BaseModel, Field
    
    app = FastAPI()
    
    
    class Item(BaseModel):
        name: str = Field(examples=["Foo"])
        description: Union[str, None] = Field(default=None, examples=["A very nice Item"])
        price: float = Field(examples=[35.4])
        tax: Union[float, None] = Field(default=None, examples=[3.2])
    
    
    @app.put("/items/{item_id}")
    async def update_item(item_id: int, item: Item):
        results = {"item_id": item_id, "item": item}
        return results
    

## `examples` in JSON Schema - OpenAPI[¶](#examples-in-json-schema-openapi "Permanent link")

When using any of:

  * `Path()`
  * `Query()`
  * `Header()`
  * `Cookie()`
  * `Body()`
  * `Form()`
  * `File()`

you can also declare a group of `examples` with additional information that will be added to their **JSON Schemas** inside of **OpenAPI**.

### `Body` with `examples`[¶](#body-with-examples "Permanent link")

Here we pass `examples` containing one example of the data expected in `Body()`:

Python 3.10+
    
    
    from typing import Annotated
    
    from fastapi import Body, FastAPI
    from pydantic import BaseModel
    
    app = FastAPI()
    
    
    class Item(BaseModel):
        name: str
        description: str | None = None
        price: float
        tax: float | None = None
    
    
    @app.put("/items/{item_id}")
    async def update_item(
        item_id: int,
        item: Annotated[
            Item,
            Body(
                examples=[
                    {
                        "name": "Foo",
                        "description": "A very nice Item",
                        "price": 35.4,
                        "tax": 3.2,
                    }
                ],
            ),
        ],
    ):
        results = {"item_id": item_id, "item": item}
        return results
    

ü§ì Other versions and variants

Python 3.9+Python 3.10+ - non-AnnotatedPython 3.9+ - non-Annotated
    
    
    from typing import Annotated, Union
    
    from fastapi import Body, FastAPI
    from pydantic import BaseModel
    
    app = FastAPI()
    
    
    class Item(BaseModel):
        name: str
        description: Union[str, None] = None
        price: float
        tax: Union[float, None] = None
    
    
    @app.put("/items/{item_id}")
    async def update_item(
        item_id: int,
        item: Annotated[
            Item,
            Body(
                examples=[
                    {
                        "name": "Foo",
                        "description": "A very nice Item",
                        "price": 35.4,
                        "tax": 3.2,
                    }
                ],
            ),
        ],
    ):
        results = {"item_id": item_id, "item": item}
        return results
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import Body, FastAPI
    from pydantic import BaseModel
    
    app = FastAPI()
    
    
    class Item(BaseModel):
        name: str
        description: str | None = None
        price: float
        tax: float | None = None
    
    
    @app.put("/items/{item_id}")
    async def update_item(
        item_id: int,
        item: Item = Body(
            examples=[
                {
                    "name": "Foo",
                    "description": "A very nice Item",
                    "price": 35.4,
                    "tax": 3.2,
                }
            ],
        ),
    ):
        results = {"item_id": item_id, "item": item}
        return results
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from typing import Union
    
    from fastapi import Body, FastAPI
    from pydantic import BaseModel
    
    app = FastAPI()
    
    
    class Item(BaseModel):
        name: str
        description: Union[str, None] = None
        price: float
        tax: Union[float, None] = None
    
    
    @app.put("/items/{item_id}")
    async def update_item(
        item_id: int,
        item: Item = Body(
            examples=[
                {
                    "name": "Foo",
                    "description": "A very nice Item",
                    "price": 35.4,
                    "tax": 3.2,
                }
            ],
        ),
    ):
        results = {"item_id": item_id, "item": item}
        return results
    

### Example in the docs UI[¶](#example-in-the-docs-ui "Permanent link")

With any of the methods above it would look like this in the `/docs`:

![](/img/tutorial/body-fields/image01.png)

### `Body` with multiple `examples`[¶](#body-with-multiple-examples "Permanent link")

You can of course also pass multiple `examples`:

Python 3.10+
    
    
    from typing import Annotated
    
    from fastapi import Body, FastAPI
    from pydantic import BaseModel
    
    app = FastAPI()
    
    
    class Item(BaseModel):
        name: str
        description: str | None = None
        price: float
        tax: float | None = None
    
    
    @app.put("/items/{item_id}")
    async def update_item(
        *,
        item_id: int,
        item: Annotated[
            Item,
            Body(
                examples=[
                    {
                        "name": "Foo",
                        "description": "A very nice Item",
                        "price": 35.4,
                        "tax": 3.2,
                    },
                    {
                        "name": "Bar",
                        "price": "35.4",
                    },
                    {
                        "name": "Baz",
                        "price": "thirty five point four",
                    },
                ],
            ),
        ],
    ):
        results = {"item_id": item_id, "item": item}
        return results
    

ü§ì Other versions and variants

Python 3.9+Python 3.10+ - non-AnnotatedPython 3.9+ - non-Annotated
    
    
    from typing import Annotated, Union
    
    from fastapi import Body, FastAPI
    from pydantic import BaseModel
    
    app = FastAPI()
    
    
    class Item(BaseModel):
        name: str
        description: Union[str, None] = None
        price: float
        tax: Union[float, None] = None
    
    
    @app.put("/items/{item_id}")
    async def update_item(
        *,
        item_id: int,
        item: Annotated[
            Item,
            Body(
                examples=[
                    {
                        "name": "Foo",
                        "description": "A very nice Item",
                        "price": 35.4,
                        "tax": 3.2,
                    },
                    {
                        "name": "Bar",
                        "price": "35.4",
                    },
                    {
                        "name": "Baz",
                        "price": "thirty five point four",
                    },
                ],
            ),
        ],
    ):
        results = {"item_id": item_id, "item": item}
        return results
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import Body, FastAPI
    from pydantic import BaseModel
    
    app = FastAPI()
    
    
    class Item(BaseModel):
        name: str
        description: str | None = None
        price: float
        tax: float | None = None
    
    
    @app.put("/items/{item_id}")
    async def update_item(
        *,
        item_id: int,
        item: Item = Body(
            examples=[
                {
                    "name": "Foo",
                    "description": "A very nice Item",
                    "price": 35.4,
                    "tax": 3.2,
                },
                {
                    "name": "Bar",
                    "price": "35.4",
                },
                {
                    "name": "Baz",
                    "price": "thirty five point four",
                },
            ],
        ),
    ):
        results = {"item_id": item_id, "item": item}
        return results
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from typing import Union
    
    from fastapi import Body, FastAPI
    from pydantic import BaseModel
    
    app = FastAPI()
    
    
    class Item(BaseModel):
        name: str
        description: Union[str, None] = None
        price: float
        tax: Union[float, None] = None
    
    
    @app.put("/items/{item_id}")
    async def update_item(
        *,
        item_id: int,
        item: Item = Body(
            examples=[
                {
                    "name": "Foo",
                    "description": "A very nice Item",
                    "price": 35.4,
                    "tax": 3.2,
                },
                {
                    "name": "Bar",
                    "price": "35.4",
                },
                {
                    "name": "Baz",
                    "price": "thirty five point four",
                },
            ],
        ),
    ):
        results = {"item_id": item_id, "item": item}
        return results
    

When you do this, the examples will be part of the internal **JSON Schema** for that body data.

Nevertheless, at the time of writing this, Swagger UI, the tool in charge of showing the docs UI, doesn't support showing multiple examples for the data in **JSON Schema**. But read below for a workaround.

### OpenAPI-specific `examples`[¶](#openapi-specific-examples "Permanent link")

Since before **JSON Schema** supported `examples` OpenAPI had support for a different field also called `examples`.

This **OpenAPI-specific** `examples` goes in another section in the OpenAPI specification. It goes in the **details for each _path operation_** , not inside each JSON Schema.

And Swagger UI has supported this particular `examples` field for a while. So, you can use it to **show** different **examples in the docs UI**.

The shape of this OpenAPI-specific field `examples` is a `dict` with **multiple examples** (instead of a `list`), each with extra information that will be added to **OpenAPI** too.

This doesn't go inside of each JSON Schema contained in OpenAPI, this goes outside, in the _path operation_ directly.

### Using the `openapi_examples` Parameter[¶](#using-the-openapi-examples-parameter "Permanent link")

You can declare the OpenAPI-specific `examples` in FastAPI with the parameter `openapi_examples` for:

  * `Path()`
  * `Query()`
  * `Header()`
  * `Cookie()`
  * `Body()`
  * `Form()`
  * `File()`

The keys of the `dict` identify each example, and each value is another `dict`.

Each specific example `dict` in the `examples` can contain:

  * `summary`: Short description for the example.
  * `description`: A long description that can contain Markdown text.
  * `value`: This is the actual example shown, e.g. a `dict`.
  * `externalValue`: alternative to `value`, a URL pointing to the example. Although this might not be supported by as many tools as `value`.

You can use it like this:

Python 3.10+
    
    
    from typing import Annotated
    
    from fastapi import Body, FastAPI
    from pydantic import BaseModel
    
    app = FastAPI()
    
    
    class Item(BaseModel):
        name: str
        description: str | None = None
        price: float
        tax: float | None = None
    
    
    @app.put("/items/{item_id}")
    async def update_item(
        *,
        item_id: int,
        item: Annotated[
            Item,
            Body(
                openapi_examples={
                    "normal": {
                        "summary": "A normal example",
                        "description": "A **normal** item works correctly.",
                        "value": {
                            "name": "Foo",
                            "description": "A very nice Item",
                            "price": 35.4,
                            "tax": 3.2,
                        },
                    },
                    "converted": {
                        "summary": "An example with converted data",
                        "description": "FastAPI can convert price `strings` to actual `numbers` automatically",
                        "value": {
                            "name": "Bar",
                            "price": "35.4",
                        },
                    },
                    "invalid": {
                        "summary": "Invalid data is rejected with an error",
                        "value": {
                            "name": "Baz",
                            "price": "thirty five point four",
                        },
                    },
                },
            ),
        ],
    ):
        results = {"item_id": item_id, "item": item}
        return results
    

ü§ì Other versions and variants

Python 3.9+Python 3.10+ - non-AnnotatedPython 3.9+ - non-Annotated
    
    
    from typing import Annotated, Union
    
    from fastapi import Body, FastAPI
    from pydantic import BaseModel
    
    app = FastAPI()
    
    
    class Item(BaseModel):
        name: str
        description: Union[str, None] = None
        price: float
        tax: Union[float, None] = None
    
    
    @app.put("/items/{item_id}")
    async def update_item(
        *,
        item_id: int,
        item: Annotated[
            Item,
            Body(
                openapi_examples={
                    "normal": {
                        "summary": "A normal example",
                        "description": "A **normal** item works correctly.",
                        "value": {
                            "name": "Foo",
                            "description": "A very nice Item",
                            "price": 35.4,
                            "tax": 3.2,
                        },
                    },
                    "converted": {
                        "summary": "An example with converted data",
                        "description": "FastAPI can convert price `strings` to actual `numbers` automatically",
                        "value": {
                            "name": "Bar",
                            "price": "35.4",
                        },
                    },
                    "invalid": {
                        "summary": "Invalid data is rejected with an error",
                        "value": {
                            "name": "Baz",
                            "price": "thirty five point four",
                        },
                    },
                },
            ),
        ],
    ):
        results = {"item_id": item_id, "item": item}
        return results
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import Body, FastAPI
    from pydantic import BaseModel
    
    app = FastAPI()
    
    
    class Item(BaseModel):
        name: str
        description: str | None = None
        price: float
        tax: float | None = None
    
    
    @app.put("/items/{item_id}")
    async def update_item(
        *,
        item_id: int,
        item: Item = Body(
            openapi_examples={
                "normal": {
                    "summary": "A normal example",
                    "description": "A **normal** item works correctly.",
                    "value": {
                        "name": "Foo",
                        "description": "A very nice Item",
                        "price": 35.4,
                        "tax": 3.2,
                    },
                },
                "converted": {
                    "summary": "An example with converted data",
                    "description": "FastAPI can convert price `strings` to actual `numbers` automatically",
                    "value": {
                        "name": "Bar",
                        "price": "35.4",
                    },
                },
                "invalid": {
                    "summary": "Invalid data is rejected with an error",
                    "value": {
                        "name": "Baz",
                        "price": "thirty five point four",
                    },
                },
            },
        ),
    ):
        results = {"item_id": item_id, "item": item}
        return results
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from typing import Union
    
    from fastapi import Body, FastAPI
    from pydantic import BaseModel
    
    app = FastAPI()
    
    
    class Item(BaseModel):
        name: str
        description: Union[str, None] = None
        price: float
        tax: Union[float, None] = None
    
    
    @app.put("/items/{item_id}")
    async def update_item(
        *,
        item_id: int,
        item: Item = Body(
            openapi_examples={
                "normal": {
                    "summary": "A normal example",
                    "description": "A **normal** item works correctly.",
                    "value": {
                        "name": "Foo",
                        "description": "A very nice Item",
                        "price": 35.4,
                        "tax": 3.2,
                    },
                },
                "converted": {
                    "summary": "An example with converted data",
                    "description": "FastAPI can convert price `strings` to actual `numbers` automatically",
                    "value": {
                        "name": "Bar",
                        "price": "35.4",
                    },
                },
                "invalid": {
                    "summary": "Invalid data is rejected with an error",
                    "value": {
                        "name": "Baz",
                        "price": "thirty five point four",
                    },
                },
            },
        ),
    ):
        results = {"item_id": item_id, "item": item}
        return results
    

### OpenAPI Examples in the Docs UI[¶](#openapi-examples-in-the-docs-ui "Permanent link")

With `openapi_examples` added to `Body()` the `/docs` would look like:

![](/img/tutorial/body-fields/image02.png)

## Technical Details[¶](#technical-details "Permanent link")

Tip

If you are already using **FastAPI** version **0.99.0 or above** , you can probably **skip** these details.

They are more relevant for older versions, before OpenAPI 3.1.0 was available.

You can consider this a brief OpenAPI and JSON Schema **history lesson**. ü§ì

Warning

These are very technical details about the standards **JSON Schema** and **OpenAPI**.

If the ideas above already work for you, that might be enough, and you probably don't need these details, feel free to skip them.

Before OpenAPI 3.1.0, OpenAPI used an older and modified version of **JSON Schema**.

JSON Schema didn't have `examples`, so OpenAPI added its own `example` field to its own modified version.

OpenAPI also added `example` and `examples` fields to other parts of the specification:

  * [`Parameter Object` (in the specification)](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#parameter-object) that was used by FastAPI's:
    * `Path()`
    * `Query()`
    * `Header()`
    * `Cookie()`
  * [`Request Body Object`, in the field `content`, on the `Media Type Object` (in the specification)](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#media-type-object) that was used by FastAPI's:
    * `Body()`
    * `File()`
    * `Form()`

Info

This old OpenAPI-specific `examples` parameter is now `openapi_examples` since FastAPI `0.103.0`.

### JSON Schema's `examples` field[¶](#json-schemas-examples-field "Permanent link")

But then JSON Schema added an [`examples`](https://json-schema.org/draft/2019-09/json-schema-validation.html#rfc.section.9.5) field to a new version of the specification.

And then the new OpenAPI 3.1.0 was based on the latest version (JSON Schema 2020-12) that included this new field `examples`.

And now this new `examples` field takes precedence over the old single (and custom) `example` field, that is now deprecated.

This new `examples` field in JSON Schema is **just a`list`** of examples, not a dict with extra metadata as in the other places in OpenAPI (described above).

Info

Even after OpenAPI 3.1.0 was released with this new simpler integration with JSON Schema, for a while, Swagger UI, the tool that provides the automatic docs, didn't support OpenAPI 3.1.0 (it does since version 5.0.0 üéâ).

Because of that, versions of FastAPI previous to 0.99.0 still used versions of OpenAPI lower than 3.1.0.

### Pydantic and FastAPI `examples`[¶](#pydantic-and-fastapi-examples "Permanent link")

When you add `examples` inside a Pydantic model, using `schema_extra` or `Field(examples=["something"])` that example is added to the **JSON Schema** for that Pydantic model.

And that **JSON Schema** of the Pydantic model is included in the **OpenAPI** of your API, and then it's used in the docs UI.

In versions of FastAPI before 0.99.0 (0.99.0 and above use the newer OpenAPI 3.1.0) when you used `example` or `examples` with any of the other utilities (`Query()`, `Body()`, etc.) those examples were not added to the JSON Schema that describes that data (not even to OpenAPI's own version of JSON Schema), they were added directly to the _path operation_ declaration in OpenAPI (outside the parts of OpenAPI that use JSON Schema).

But now that FastAPI 0.99.0 and above uses OpenAPI 3.1.0, that uses JSON Schema 2020-12, and Swagger UI 5.0.0 and above, everything is more consistent and the examples are included in JSON Schema.

### Swagger UI and OpenAPI-specific `examples`[¶](#swagger-ui-and-openapi-specific-examples "Permanent link")

Now, as Swagger UI didn't support multiple JSON Schema examples (as of 2023-08-26), users didn't have a way to show multiple examples in the docs.

To solve that, FastAPI `0.103.0` **added support** for declaring the same old **OpenAPI-specific** `examples` field with the new parameter `openapi_examples`. ü§ì

### Summary[¶](#summary "Permanent link")

I used to say I didn't like history that much... and look at me now giving "tech history" lessons. üòÖ

In short, **upgrade to FastAPI 0.99.0 or above** , and things are much **simpler, consistent, and intuitive** , and you don't have to know all these historic details. üòé
  *[time of writing this]: 2023-08-26

---

###### Extra Data Types¶

# Extra Data Types[¶](#extra-data-types "Permanent link")

Up to now, you have been using common data types, like:

  * `int`
  * `float`
  * `str`
  * `bool`

But you can also use more complex data types.

And you will still have the same features as seen up to now:

  * Great editor support.
  * Data conversion from incoming requests.
  * Data conversion for response data.
  * Data validation.
  * Automatic annotation and documentation.

## Other data types[¶](#other-data-types "Permanent link")

Here are some of the additional data types you can use:

  * `UUID`:
    * A standard "Universally Unique Identifier", common as an ID in many databases and systems.
    * In requests and responses will be represented as a `str`.
  * `datetime.datetime`:
    * A Python `datetime.datetime`.
    * In requests and responses will be represented as a `str` in ISO 8601 format, like: `2008-09-15T15:53:00+05:00`.
  * `datetime.date`:
    * Python `datetime.date`.
    * In requests and responses will be represented as a `str` in ISO 8601 format, like: `2008-09-15`.
  * `datetime.time`:
    * A Python `datetime.time`.
    * In requests and responses will be represented as a `str` in ISO 8601 format, like: `14:23:55.003`.
  * `datetime.timedelta`:
    * A Python `datetime.timedelta`.
    * In requests and responses will be represented as a `float` of total seconds.
    * Pydantic also allows representing it as a "ISO 8601 time diff encoding", [see the docs for more info](https://docs.pydantic.dev/latest/concepts/serialization/#custom-serializers).
  * `frozenset`:
    * In requests and responses, treated the same as a `set`:
      * In requests, a list will be read, eliminating duplicates and converting it to a `set`.
      * In responses, the `set` will be converted to a `list`.
      * The generated schema will specify that the `set` values are unique (using JSON Schema's `uniqueItems`).
  * `bytes`:
    * Standard Python `bytes`.
    * In requests and responses will be treated as `str`.
    * The generated schema will specify that it's a `str` with `binary` "format".
  * `Decimal`:
    * Standard Python `Decimal`.
    * In requests and responses, handled the same as a `float`.
  * You can check all the valid Pydantic data types here: [Pydantic data types](https://docs.pydantic.dev/latest/usage/types/types/).

## Example[¶](#example "Permanent link")

Here's an example _path operation_ with parameters using some of the above types.

Python 3.10+
    
    
    from datetime import datetime, time, timedelta
    from typing import Annotated
    from uuid import UUID
    
    from fastapi import Body, FastAPI
    
    app = FastAPI()
    
    
    @app.put("/items/{item_id}")
    async def read_items(
        item_id: UUID,
        start_datetime: Annotated[datetime, Body()],
        end_datetime: Annotated[datetime, Body()],
        process_after: Annotated[timedelta, Body()],
        repeat_at: Annotated[time | None, Body()] = None,
    ):
        start_process = start_datetime + process_after
        duration = end_datetime - start_process
        return {
            "item_id": item_id,
            "start_datetime": start_datetime,
            "end_datetime": end_datetime,
            "process_after": process_after,
            "repeat_at": repeat_at,
            "start_process": start_process,
            "duration": duration,
        }
    

ü§ì Other versions and variants

Python 3.9+Python 3.10+ - non-AnnotatedPython 3.9+ - non-Annotated
    
    
    from datetime import datetime, time, timedelta
    from typing import Annotated, Union
    from uuid import UUID
    
    from fastapi import Body, FastAPI
    
    app = FastAPI()
    
    
    @app.put("/items/{item_id}")
    async def read_items(
        item_id: UUID,
        start_datetime: Annotated[datetime, Body()],
        end_datetime: Annotated[datetime, Body()],
        process_after: Annotated[timedelta, Body()],
        repeat_at: Annotated[Union[time, None], Body()] = None,
    ):
        start_process = start_datetime + process_after
        duration = end_datetime - start_process
        return {
            "item_id": item_id,
            "start_datetime": start_datetime,
            "end_datetime": end_datetime,
            "process_after": process_after,
            "repeat_at": repeat_at,
            "start_process": start_process,
            "duration": duration,
        }
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from datetime import datetime, time, timedelta
    from uuid import UUID
    
    from fastapi import Body, FastAPI
    
    app = FastAPI()
    
    
    @app.put("/items/{item_id}")
    async def read_items(
        item_id: UUID,
        start_datetime: datetime = Body(),
        end_datetime: datetime = Body(),
        process_after: timedelta = Body(),
        repeat_at: time | None = Body(default=None),
    ):
        start_process = start_datetime + process_after
        duration = end_datetime - start_process
        return {
            "item_id": item_id,
            "start_datetime": start_datetime,
            "end_datetime": end_datetime,
            "process_after": process_after,
            "repeat_at": repeat_at,
            "start_process": start_process,
            "duration": duration,
        }
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from datetime import datetime, time, timedelta
    from typing import Union
    from uuid import UUID
    
    from fastapi import Body, FastAPI
    
    app = FastAPI()
    
    
    @app.put("/items/{item_id}")
    async def read_items(
        item_id: UUID,
        start_datetime: datetime = Body(),
        end_datetime: datetime = Body(),
        process_after: timedelta = Body(),
        repeat_at: Union[time, None] = Body(default=None),
    ):
        start_process = start_datetime + process_after
        duration = end_datetime - start_process
        return {
            "item_id": item_id,
            "start_datetime": start_datetime,
            "end_datetime": end_datetime,
            "process_after": process_after,
            "repeat_at": repeat_at,
            "start_process": start_process,
            "duration": duration,
        }
    

Note that the parameters inside the function have their natural data type, and you can, for example, perform normal date manipulations, like:

Python 3.10+
    
    
    from datetime import datetime, time, timedelta
    from typing import Annotated
    from uuid import UUID
    
    from fastapi import Body, FastAPI
    
    app = FastAPI()
    
    
    @app.put("/items/{item_id}")
    async def read_items(
        item_id: UUID,
        start_datetime: Annotated[datetime, Body()],
        end_datetime: Annotated[datetime, Body()],
        process_after: Annotated[timedelta, Body()],
        repeat_at: Annotated[time | None, Body()] = None,
    ):
        start_process = start_datetime + process_after
        duration = end_datetime - start_process
        return {
            "item_id": item_id,
            "start_datetime": start_datetime,
            "end_datetime": end_datetime,
            "process_after": process_after,
            "repeat_at": repeat_at,
            "start_process": start_process,
            "duration": duration,
        }
    

ü§ì Other versions and variants

Python 3.9+Python 3.10+ - non-AnnotatedPython 3.9+ - non-Annotated
    
    
    from datetime import datetime, time, timedelta
    from typing import Annotated, Union
    from uuid import UUID
    
    from fastapi import Body, FastAPI
    
    app = FastAPI()
    
    
    @app.put("/items/{item_id}")
    async def read_items(
        item_id: UUID,
        start_datetime: Annotated[datetime, Body()],
        end_datetime: Annotated[datetime, Body()],
        process_after: Annotated[timedelta, Body()],
        repeat_at: Annotated[Union[time, None], Body()] = None,
    ):
        start_process = start_datetime + process_after
        duration = end_datetime - start_process
        return {
            "item_id": item_id,
            "start_datetime": start_datetime,
            "end_datetime": end_datetime,
            "process_after": process_after,
            "repeat_at": repeat_at,
            "start_process": start_process,
            "duration": duration,
        }
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from datetime import datetime, time, timedelta
    from uuid import UUID
    
    from fastapi import Body, FastAPI
    
    app = FastAPI()
    
    
    @app.put("/items/{item_id}")
    async def read_items(
        item_id: UUID,
        start_datetime: datetime = Body(),
        end_datetime: datetime = Body(),
        process_after: timedelta = Body(),
        repeat_at: time | None = Body(default=None),
    ):
        start_process = start_datetime + process_after
        duration = end_datetime - start_process
        return {
            "item_id": item_id,
            "start_datetime": start_datetime,
            "end_datetime": end_datetime,
            "process_after": process_after,
            "repeat_at": repeat_at,
            "start_process": start_process,
            "duration": duration,
        }
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from datetime import datetime, time, timedelta
    from typing import Union
    from uuid import UUID
    
    from fastapi import Body, FastAPI
    
    app = FastAPI()
    
    
    @app.put("/items/{item_id}")
    async def read_items(
        item_id: UUID,
        start_datetime: datetime = Body(),
        end_datetime: datetime = Body(),
        process_after: timedelta = Body(),
        repeat_at: Union[time, None] = Body(default=None),
    ):
        start_process = start_datetime + process_after
        duration = end_datetime - start_process
        return {
            "item_id": item_id,
            "start_datetime": start_datetime,
            "end_datetime": end_datetime,
            "process_after": process_after,
            "repeat_at": repeat_at,
            "start_process": start_process,
            "duration": duration,
        }

---

###### Cookie Parameters¶

# Cookie Parameters[¶](#cookie-parameters "Permanent link")

You can define Cookie parameters the same way you define `Query` and `Path` parameters.

## Import `Cookie`[¶](#import-cookie "Permanent link")

First import `Cookie`:

Python 3.10+
    
    
    from typing import Annotated
    
    from fastapi import Cookie, FastAPI
    
    app = FastAPI()
    
    
    @app.get("/items/")
    async def read_items(ads_id: Annotated[str | None, Cookie()] = None):
        return {"ads_id": ads_id}
    

ü§ì Other versions and variants

Python 3.9+Python 3.10+ - non-AnnotatedPython 3.9+ - non-Annotated
    
    
    from typing import Annotated, Union
    
    from fastapi import Cookie, FastAPI
    
    app = FastAPI()
    
    
    @app.get("/items/")
    async def read_items(ads_id: Annotated[Union[str, None], Cookie()] = None):
        return {"ads_id": ads_id}
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import Cookie, FastAPI
    
    app = FastAPI()
    
    
    @app.get("/items/")
    async def read_items(ads_id: str | None = Cookie(default=None)):
        return {"ads_id": ads_id}
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from typing import Union
    
    from fastapi import Cookie, FastAPI
    
    app = FastAPI()
    
    
    @app.get("/items/")
    async def read_items(ads_id: Union[str, None] = Cookie(default=None)):
        return {"ads_id": ads_id}
    

## Declare `Cookie` parameters[¶](#declare-cookie-parameters "Permanent link")

Then declare the cookie parameters using the same structure as with `Path` and `Query`.

You can define the default value as well as all the extra validation or annotation parameters:

Python 3.10+
    
    
    from typing import Annotated
    
    from fastapi import Cookie, FastAPI
    
    app = FastAPI()
    
    
    @app.get("/items/")
    async def read_items(ads_id: Annotated[str | None, Cookie()] = None):
        return {"ads_id": ads_id}
    

ü§ì Other versions and variants

Python 3.9+Python 3.10+ - non-AnnotatedPython 3.9+ - non-Annotated
    
    
    from typing import Annotated, Union
    
    from fastapi import Cookie, FastAPI
    
    app = FastAPI()
    
    
    @app.get("/items/")
    async def read_items(ads_id: Annotated[Union[str, None], Cookie()] = None):
        return {"ads_id": ads_id}
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import Cookie, FastAPI
    
    app = FastAPI()
    
    
    @app.get("/items/")
    async def read_items(ads_id: str | None = Cookie(default=None)):
        return {"ads_id": ads_id}
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from typing import Union
    
    from fastapi import Cookie, FastAPI
    
    app = FastAPI()
    
    
    @app.get("/items/")
    async def read_items(ads_id: Union[str, None] = Cookie(default=None)):
        return {"ads_id": ads_id}
    

Technical Details

`Cookie` is a "sister" class of `Path` and `Query`. It also inherits from the same common `Param` class.

But remember that when you import `Query`, `Path`, `Cookie` and others from `fastapi`, those are actually functions that return special classes.

Info

To declare cookies, you need to use `Cookie`, because otherwise the parameters would be interpreted as query parameters.

Info

Have in mind that, as **browsers handle cookies** in special ways and behind the scenes, they **don't** easily allow **JavaScript** to touch them.

If you go to the **API docs UI** at `/docs` you will be able to see the **documentation** for cookies for your _path operations_.

But even if you **fill the data** and click "Execute", because the docs UI works with **JavaScript** , the cookies won't be sent, and you will see an **error** message as if you didn't write any values.

## Recap[¶](#recap "Permanent link")

Declare cookies with `Cookie`, using the same common pattern as `Query` and `Path`.

---

###### Header Parameters¶

# Header Parameters[¶](#header-parameters "Permanent link")

You can define Header parameters the same way you define `Query`, `Path` and `Cookie` parameters.

## Import `Header`[¶](#import-header "Permanent link")

First import `Header`:

Python 3.10+
    
    
    from typing import Annotated
    
    from fastapi import FastAPI, Header
    
    app = FastAPI()
    
    
    @app.get("/items/")
    async def read_items(user_agent: Annotated[str | None, Header()] = None):
        return {"User-Agent": user_agent}
    

ü§ì Other versions and variants

Python 3.9+Python 3.10+ - non-AnnotatedPython 3.9+ - non-Annotated
    
    
    from typing import Annotated, Union
    
    from fastapi import FastAPI, Header
    
    app = FastAPI()
    
    
    @app.get("/items/")
    async def read_items(user_agent: Annotated[Union[str, None], Header()] = None):
        return {"User-Agent": user_agent}
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import FastAPI, Header
    
    app = FastAPI()
    
    
    @app.get("/items/")
    async def read_items(user_agent: str | None = Header(default=None)):
        return {"User-Agent": user_agent}
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from typing import Union
    
    from fastapi import FastAPI, Header
    
    app = FastAPI()
    
    
    @app.get("/items/")
    async def read_items(user_agent: Union[str, None] = Header(default=None)):
        return {"User-Agent": user_agent}
    

## Declare `Header` parameters[¶](#declare-header-parameters "Permanent link")

Then declare the header parameters using the same structure as with `Path`, `Query` and `Cookie`.

You can define the default value as well as all the extra validation or annotation parameters:

Python 3.10+
    
    
    from typing import Annotated
    
    from fastapi import FastAPI, Header
    
    app = FastAPI()
    
    
    @app.get("/items/")
    async def read_items(user_agent: Annotated[str | None, Header()] = None):
        return {"User-Agent": user_agent}
    

ü§ì Other versions and variants

Python 3.9+Python 3.10+ - non-AnnotatedPython 3.9+ - non-Annotated
    
    
    from typing import Annotated, Union
    
    from fastapi import FastAPI, Header
    
    app = FastAPI()
    
    
    @app.get("/items/")
    async def read_items(user_agent: Annotated[Union[str, None], Header()] = None):
        return {"User-Agent": user_agent}
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import FastAPI, Header
    
    app = FastAPI()
    
    
    @app.get("/items/")
    async def read_items(user_agent: str | None = Header(default=None)):
        return {"User-Agent": user_agent}
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from typing import Union
    
    from fastapi import FastAPI, Header
    
    app = FastAPI()
    
    
    @app.get("/items/")
    async def read_items(user_agent: Union[str, None] = Header(default=None)):
        return {"User-Agent": user_agent}
    

Technical Details

`Header` is a "sister" class of `Path`, `Query` and `Cookie`. It also inherits from the same common `Param` class.

But remember that when you import `Query`, `Path`, `Header`, and others from `fastapi`, those are actually functions that return special classes.

Info

To declare headers, you need to use `Header`, because otherwise the parameters would be interpreted as query parameters.

## Automatic conversion[¶](#automatic-conversion "Permanent link")

`Header` has a little extra functionality on top of what `Path`, `Query` and `Cookie` provide.

Most of the standard headers are separated by a "hyphen" character, also known as the "minus symbol" (`-`).

But a variable like `user-agent` is invalid in Python.

So, by default, `Header` will convert the parameter names characters from underscore (`_`) to hyphen (`-`) to extract and document the headers.

Also, HTTP headers are case-insensitive, so, you can declare them with standard Python style (also known as "snake_case").

So, you can use `user_agent` as you normally would in Python code, instead of needing to capitalize the first letters as `User_Agent` or something similar.

If for some reason you need to disable automatic conversion of underscores to hyphens, set the parameter `convert_underscores` of `Header` to `False`:

Python 3.10+
    
    
    from typing import Annotated
    
    from fastapi import FastAPI, Header
    
    app = FastAPI()
    
    
    @app.get("/items/")
    async def read_items(
        strange_header: Annotated[str | None, Header(convert_underscores=False)] = None,
    ):
        return {"strange_header": strange_header}
    

ü§ì Other versions and variants

Python 3.9+Python 3.10+ - non-AnnotatedPython 3.9+ - non-Annotated
    
    
    from typing import Annotated, Union
    
    from fastapi import FastAPI, Header
    
    app = FastAPI()
    
    
    @app.get("/items/")
    async def read_items(
        strange_header: Annotated[
            Union[str, None], Header(convert_underscores=False)
        ] = None,
    ):
        return {"strange_header": strange_header}
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import FastAPI, Header
    
    app = FastAPI()
    
    
    @app.get("/items/")
    async def read_items(
        strange_header: str | None = Header(default=None, convert_underscores=False),
    ):
        return {"strange_header": strange_header}
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from typing import Union
    
    from fastapi import FastAPI, Header
    
    app = FastAPI()
    
    
    @app.get("/items/")
    async def read_items(
        strange_header: Union[str, None] = Header(default=None, convert_underscores=False),
    ):
        return {"strange_header": strange_header}
    

Warning

Before setting `convert_underscores` to `False`, bear in mind that some HTTP proxies and servers disallow the usage of headers with underscores.

## Duplicate headers[¶](#duplicate-headers "Permanent link")

It is possible to receive duplicate headers. That means, the same header with multiple values.

You can define those cases using a list in the type declaration.

You will receive all the values from the duplicate header as a Python `list`.

For example, to declare a header of `X-Token` that can appear more than once, you can write:

Python 3.10+
    
    
    from typing import Annotated
    
    from fastapi import FastAPI, Header
    
    app = FastAPI()
    
    
    @app.get("/items/")
    async def read_items(x_token: Annotated[list[str] | None, Header()] = None):
        return {"X-Token values": x_token}
    

ü§ì Other versions and variants

Python 3.9+Python 3.10+ - non-AnnotatedPython 3.9+ - non-Annotated
    
    
    from typing import Annotated, Union
    
    from fastapi import FastAPI, Header
    
    app = FastAPI()
    
    
    @app.get("/items/")
    async def read_items(x_token: Annotated[Union[list[str], None], Header()] = None):
        return {"X-Token values": x_token}
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import FastAPI, Header
    
    app = FastAPI()
    
    
    @app.get("/items/")
    async def read_items(x_token: list[str] | None = Header(default=None)):
        return {"X-Token values": x_token}
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from typing import Union
    
    from fastapi import FastAPI, Header
    
    app = FastAPI()
    
    
    @app.get("/items/")
    async def read_items(x_token: Union[list[str], None] = Header(default=None)):
        return {"X-Token values": x_token}
    

If you communicate with that _path operation_ sending two HTTP headers like:
    
    
    X-Token: foo
    X-Token: bar
    

The response would be like:
    
    
    {
        "X-Token values": [
            "bar",
            "foo"
        ]
    }
    

## Recap[¶](#recap "Permanent link")

Declare headers with `Header`, using the same common pattern as `Query`, `Path` and `Cookie`.

And don't worry about underscores in your variables, **FastAPI** will take care of converting them.

---

###### Cookie Parameter Models¶

# Cookie Parameter Models[¶](#cookie-parameter-models "Permanent link")

If you have a group of **cookies** that are related, you can create a **Pydantic model** to declare them. üç™

This would allow you to **re-use the model** in **multiple places** and also to declare validations and metadata for all the parameters at once. üòé

Note

This is supported since FastAPI version `0.115.0`. ü§ì

Tip

This same technique applies to `Query`, `Cookie`, and `Header`. üòé

## Cookies with a Pydantic Model[¶](#cookies-with-a-pydantic-model "Permanent link")

Declare the **cookie** parameters that you need in a **Pydantic model** , and then declare the parameter as `Cookie`:

Python 3.10+
    
    
    from typing import Annotated
    
    from fastapi import Cookie, FastAPI
    from pydantic import BaseModel
    
    app = FastAPI()
    
    
    class Cookies(BaseModel):
        session_id: str
        fatebook_tracker: str | None = None
        googall_tracker: str | None = None
    
    
    @app.get("/items/")
    async def read_items(cookies: Annotated[Cookies, Cookie()]):
        return cookies
    

ü§ì Other versions and variants

Python 3.9+Python 3.10+ - non-AnnotatedPython 3.9+ - non-Annotated
    
    
    from typing import Annotated, Union
    
    from fastapi import Cookie, FastAPI
    from pydantic import BaseModel
    
    app = FastAPI()
    
    
    class Cookies(BaseModel):
        session_id: str
        fatebook_tracker: Union[str, None] = None
        googall_tracker: Union[str, None] = None
    
    
    @app.get("/items/")
    async def read_items(cookies: Annotated[Cookies, Cookie()]):
        return cookies
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import Cookie, FastAPI
    from pydantic import BaseModel
    
    app = FastAPI()
    
    
    class Cookies(BaseModel):
        session_id: str
        fatebook_tracker: str | None = None
        googall_tracker: str | None = None
    
    
    @app.get("/items/")
    async def read_items(cookies: Cookies = Cookie()):
        return cookies
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from typing import Union
    
    from fastapi import Cookie, FastAPI
    from pydantic import BaseModel
    
    app = FastAPI()
    
    
    class Cookies(BaseModel):
        session_id: str
        fatebook_tracker: Union[str, None] = None
        googall_tracker: Union[str, None] = None
    
    
    @app.get("/items/")
    async def read_items(cookies: Cookies = Cookie()):
        return cookies
    

**FastAPI** will **extract** the data for **each field** from the **cookies** received in the request and give you the Pydantic model you defined.

## Check the Docs[¶](#check-the-docs "Permanent link")

You can see the defined cookies in the docs UI at `/docs`:

![](/img/tutorial/cookie-param-models/image01.png)

Info

Have in mind that, as **browsers handle cookies** in special ways and behind the scenes, they **don't** easily allow **JavaScript** to touch them.

If you go to the **API docs UI** at `/docs` you will be able to see the **documentation** for cookies for your _path operations_.

But even if you **fill the data** and click "Execute", because the docs UI works with **JavaScript** , the cookies won't be sent, and you will see an **error** message as if you didn't write any values.

## Forbid Extra Cookies[¶](#forbid-extra-cookies "Permanent link")

In some special use cases (probably not very common), you might want to **restrict** the cookies that you want to receive.

Your API now has the power to control its own cookie consent. ü§™üç™

You can use Pydantic's model configuration to `forbid` any `extra` fields:

Python 3.10+
    
    
    from typing import Annotated
    
    from fastapi import Cookie, FastAPI
    from pydantic import BaseModel
    
    app = FastAPI()
    
    
    class Cookies(BaseModel):
        model_config = {"extra": "forbid"}
    
        session_id: str
        fatebook_tracker: str | None = None
        googall_tracker: str | None = None
    
    
    @app.get("/items/")
    async def read_items(cookies: Annotated[Cookies, Cookie()]):
        return cookies
    

ü§ì Other versions and variants

Python 3.9+Python 3.10+ - non-AnnotatedPython 3.9+ - non-Annotated
    
    
    from typing import Annotated, Union
    
    from fastapi import Cookie, FastAPI
    from pydantic import BaseModel
    
    app = FastAPI()
    
    
    class Cookies(BaseModel):
        model_config = {"extra": "forbid"}
    
        session_id: str
        fatebook_tracker: Union[str, None] = None
        googall_tracker: Union[str, None] = None
    
    
    @app.get("/items/")
    async def read_items(cookies: Annotated[Cookies, Cookie()]):
        return cookies
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import Cookie, FastAPI
    from pydantic import BaseModel
    
    app = FastAPI()
    
    
    class Cookies(BaseModel):
        model_config = {"extra": "forbid"}
    
        session_id: str
        fatebook_tracker: str | None = None
        googall_tracker: str | None = None
    
    
    @app.get("/items/")
    async def read_items(cookies: Cookies = Cookie()):
        return cookies
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from typing import Union
    
    from fastapi import Cookie, FastAPI
    from pydantic import BaseModel
    
    app = FastAPI()
    
    
    class Cookies(BaseModel):
        model_config = {"extra": "forbid"}
    
        session_id: str
        fatebook_tracker: Union[str, None] = None
        googall_tracker: Union[str, None] = None
    
    
    @app.get("/items/")
    async def read_items(cookies: Cookies = Cookie()):
        return cookies
    

If a client tries to send some **extra cookies** , they will receive an **error** response.

Poor cookie banners with all their effort to get your consent for the API to reject it. üç™

For example, if the client tries to send a `santa_tracker` cookie with a value of `good-list-please`, the client will receive an **error** response telling them that the `santa_tracker` cookie is not allowed:
    
    
    {
        "detail": [
            {
                "type": "extra_forbidden",
                "loc": ["cookie", "santa_tracker"],
                "msg": "Extra inputs are not permitted",
                "input": "good-list-please",
            }
        ]
    }
    

## Summary[¶](#summary "Permanent link")

You can use **Pydantic models** to declare **cookies** in **FastAPI**. üòé
  *[cookie consent]: This is a joke, just in case. It has nothing to do with cookie consents, but it's funny that even the API can now reject the poor cookies. Have a cookie. üç™
  *[API to reject it]: This is another joke. Don't pay attention to me. Have some coffee for your cookie. ‚òï
  *[cookie is not allowed]: Santa disapproves the lack of cookies. üéÖ Okay, no more cookie jokes.
  *[**cookies**]: Have a last cookie before you go. üç™

---

###### Header Parameter Models¶

# Header Parameter Models[¶](#header-parameter-models "Permanent link")

If you have a group of related **header parameters** , you can create a **Pydantic model** to declare them.

This would allow you to **re-use the model** in **multiple places** and also to declare validations and metadata for all the parameters at once. üòé

Note

This is supported since FastAPI version `0.115.0`. ü§ì

## Header Parameters with a Pydantic Model[¶](#header-parameters-with-a-pydantic-model "Permanent link")

Declare the **header parameters** that you need in a **Pydantic model** , and then declare the parameter as `Header`:

Python 3.10+
    
    
    from typing import Annotated
    
    from fastapi import FastAPI, Header
    from pydantic import BaseModel
    
    app = FastAPI()
    
    
    class CommonHeaders(BaseModel):
        host: str
        save_data: bool
        if_modified_since: str | None = None
        traceparent: str | None = None
        x_tag: list[str] = []
    
    
    @app.get("/items/")
    async def read_items(headers: Annotated[CommonHeaders, Header()]):
        return headers
    

ü§ì Other versions and variants

Python 3.9+Python 3.10+ - non-AnnotatedPython 3.9+ - non-Annotated
    
    
    from typing import Annotated, Union
    
    from fastapi import FastAPI, Header
    from pydantic import BaseModel
    
    app = FastAPI()
    
    
    class CommonHeaders(BaseModel):
        host: str
        save_data: bool
        if_modified_since: Union[str, None] = None
        traceparent: Union[str, None] = None
        x_tag: list[str] = []
    
    
    @app.get("/items/")
    async def read_items(headers: Annotated[CommonHeaders, Header()]):
        return headers
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import FastAPI, Header
    from pydantic import BaseModel
    
    app = FastAPI()
    
    
    class CommonHeaders(BaseModel):
        host: str
        save_data: bool
        if_modified_since: str | None = None
        traceparent: str | None = None
        x_tag: list[str] = []
    
    
    @app.get("/items/")
    async def read_items(headers: CommonHeaders = Header()):
        return headers
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from typing import Union
    
    from fastapi import FastAPI, Header
    from pydantic import BaseModel
    
    app = FastAPI()
    
    
    class CommonHeaders(BaseModel):
        host: str
        save_data: bool
        if_modified_since: Union[str, None] = None
        traceparent: Union[str, None] = None
        x_tag: list[str] = []
    
    
    @app.get("/items/")
    async def read_items(headers: CommonHeaders = Header()):
        return headers
    

**FastAPI** will **extract** the data for **each field** from the **headers** in the request and give you the Pydantic model you defined.

## Check the Docs[¶](#check-the-docs "Permanent link")

You can see the required headers in the docs UI at `/docs`:

![](/img/tutorial/header-param-models/image01.png)

## Forbid Extra Headers[¶](#forbid-extra-headers "Permanent link")

In some special use cases (probably not very common), you might want to **restrict** the headers that you want to receive.

You can use Pydantic's model configuration to `forbid` any `extra` fields:

Python 3.10+
    
    
    from typing import Annotated
    
    from fastapi import FastAPI, Header
    from pydantic import BaseModel
    
    app = FastAPI()
    
    
    class CommonHeaders(BaseModel):
        model_config = {"extra": "forbid"}
    
        host: str
        save_data: bool
        if_modified_since: str | None = None
        traceparent: str | None = None
        x_tag: list[str] = []
    
    
    @app.get("/items/")
    async def read_items(headers: Annotated[CommonHeaders, Header()]):
        return headers
    

ü§ì Other versions and variants

Python 3.9+Python 3.10+ - non-AnnotatedPython 3.9+ - non-Annotated
    
    
    from typing import Annotated, Union
    
    from fastapi import FastAPI, Header
    from pydantic import BaseModel
    
    app = FastAPI()
    
    
    class CommonHeaders(BaseModel):
        model_config = {"extra": "forbid"}
    
        host: str
        save_data: bool
        if_modified_since: Union[str, None] = None
        traceparent: Union[str, None] = None
        x_tag: list[str] = []
    
    
    @app.get("/items/")
    async def read_items(headers: Annotated[CommonHeaders, Header()]):
        return headers
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import FastAPI, Header
    from pydantic import BaseModel
    
    app = FastAPI()
    
    
    class CommonHeaders(BaseModel):
        model_config = {"extra": "forbid"}
    
        host: str
        save_data: bool
        if_modified_since: str | None = None
        traceparent: str | None = None
        x_tag: list[str] = []
    
    
    @app.get("/items/")
    async def read_items(headers: CommonHeaders = Header()):
        return headers
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from typing import Union
    
    from fastapi import FastAPI, Header
    from pydantic import BaseModel
    
    app = FastAPI()
    
    
    class CommonHeaders(BaseModel):
        model_config = {"extra": "forbid"}
    
        host: str
        save_data: bool
        if_modified_since: Union[str, None] = None
        traceparent: Union[str, None] = None
        x_tag: list[str] = []
    
    
    @app.get("/items/")
    async def read_items(headers: CommonHeaders = Header()):
        return headers
    

If a client tries to send some **extra headers** , they will receive an **error** response.

For example, if the client tries to send a `tool` header with a value of `plumbus`, they will receive an **error** response telling them that the header parameter `tool` is not allowed:
    
    
    {
        "detail": [
            {
                "type": "extra_forbidden",
                "loc": ["header", "tool"],
                "msg": "Extra inputs are not permitted",
                "input": "plumbus",
            }
        ]
    }
    

## Disable Convert Underscores[¶](#disable-convert-underscores "Permanent link")

The same way as with regular header parameters, when you have underscore characters in the parameter names, they are **automatically converted to hyphens**.

For example, if you have a header parameter `save_data` in the code, the expected HTTP header will be `save-data`, and it will show up like that in the docs.

If for some reason you need to disable this automatic conversion, you can do it as well for Pydantic models for header parameters.

Python 3.10+
    
    
    from typing import Annotated
    
    from fastapi import FastAPI, Header
    from pydantic import BaseModel
    
    app = FastAPI()
    
    
    class CommonHeaders(BaseModel):
        host: str
        save_data: bool
        if_modified_since: str | None = None
        traceparent: str | None = None
        x_tag: list[str] = []
    
    
    @app.get("/items/")
    async def read_items(
        headers: Annotated[CommonHeaders, Header(convert_underscores=False)],
    ):
        return headers
    

ü§ì Other versions and variants

Python 3.9+Python 3.10+ - non-AnnotatedPython 3.9+ - non-Annotated
    
    
    from typing import Annotated, Union
    
    from fastapi import FastAPI, Header
    from pydantic import BaseModel
    
    app = FastAPI()
    
    
    class CommonHeaders(BaseModel):
        host: str
        save_data: bool
        if_modified_since: Union[str, None] = None
        traceparent: Union[str, None] = None
        x_tag: list[str] = []
    
    
    @app.get("/items/")
    async def read_items(
        headers: Annotated[CommonHeaders, Header(convert_underscores=False)],
    ):
        return headers
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import FastAPI, Header
    from pydantic import BaseModel
    
    app = FastAPI()
    
    
    class CommonHeaders(BaseModel):
        host: str
        save_data: bool
        if_modified_since: str | None = None
        traceparent: str | None = None
        x_tag: list[str] = []
    
    
    @app.get("/items/")
    async def read_items(headers: CommonHeaders = Header(convert_underscores=False)):
        return headers
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from typing import Union
    
    from fastapi import FastAPI, Header
    from pydantic import BaseModel
    
    app = FastAPI()
    
    
    class CommonHeaders(BaseModel):
        host: str
        save_data: bool
        if_modified_since: Union[str, None] = None
        traceparent: Union[str, None] = None
        x_tag: list[str] = []
    
    
    @app.get("/items/")
    async def read_items(headers: CommonHeaders = Header(convert_underscores=False)):
        return headers
    

Warning

Before setting `convert_underscores` to `False`, bear in mind that some HTTP proxies and servers disallow the usage of headers with underscores.

## Summary[¶](#summary "Permanent link")

You can use **Pydantic models** to declare **headers** in **FastAPI**. üòé

---

###### Response Model - Return Type¶

# Response Model - Return Type[¶](#response-model-return-type "Permanent link")

You can declare the type used for the response by annotating the _path operation function_ **return type**.

You can use **type annotations** the same way you would for input data in function **parameters** , you can use Pydantic models, lists, dictionaries, scalar values like integers, booleans, etc.

Python 3.10+
    
    
    from fastapi import FastAPI
    from pydantic import BaseModel
    
    app = FastAPI()
    
    
    class Item(BaseModel):
        name: str
        description: str | None = None
        price: float
        tax: float | None = None
        tags: list[str] = []
    
    
    @app.post("/items/")
    async def create_item(item: Item) -> Item:
        return item
    
    
    @app.get("/items/")
    async def read_items() -> list[Item]:
        return [
            Item(name="Portal Gun", price=42.0),
            Item(name="Plumbus", price=32.0),
        ]
    

ü§ì Other versions and variants

Python 3.9+
    
    
    from typing import Union
    
    from fastapi import FastAPI
    from pydantic import BaseModel
    
    app = FastAPI()
    
    
    class Item(BaseModel):
        name: str
        description: Union[str, None] = None
        price: float
        tax: Union[float, None] = None
        tags: list[str] = []
    
    
    @app.post("/items/")
    async def create_item(item: Item) -> Item:
        return item
    
    
    @app.get("/items/")
    async def read_items() -> list[Item]:
        return [
            Item(name="Portal Gun", price=42.0),
            Item(name="Plumbus", price=32.0),
        ]
    

FastAPI will use this return type to:

  * **Validate** the returned data.
    * If the data is invalid (e.g. you are missing a field), it means that _your_ app code is broken, not returning what it should, and it will return a server error instead of returning incorrect data. This way you and your clients can be certain that they will receive the data and the data shape expected.
  * Add a **JSON Schema** for the response, in the OpenAPI _path operation_.
    * This will be used by the **automatic docs**.
    * It will also be used by automatic client code generation tools.

But most importantly:

  * It will **limit and filter** the output data to what is defined in the return type.
    * This is particularly important for **security** , we'll see more of that below.

## `response_model` Parameter[¶](#response-model-parameter "Permanent link")

There are some cases where you need or want to return some data that is not exactly what the type declares.

For example, you could want to **return a dictionary** or a database object, but **declare it as a Pydantic model**. This way the Pydantic model would do all the data documentation, validation, etc. for the object that you returned (e.g. a dictionary or database object).

If you added the return type annotation, tools and editors would complain with a (correct) error telling you that your function is returning a type (e.g. a dict) that is different from what you declared (e.g. a Pydantic model).

In those cases, you can use the _path operation decorator_ parameter `response_model` instead of the return type.

You can use the `response_model` parameter in any of the _path operations_ :

  * `@app.get()`
  * `@app.post()`
  * `@app.put()`
  * `@app.delete()`
  * etc.

Python 3.10+
    
    
    from typing import Any
    
    from fastapi import FastAPI
    from pydantic import BaseModel
    
    app = FastAPI()
    
    
    class Item(BaseModel):
        name: str
        description: str | None = None
        price: float
        tax: float | None = None
        tags: list[str] = []
    
    
    @app.post("/items/", response_model=Item)
    async def create_item(item: Item) -> Any:
        return item
    
    
    @app.get("/items/", response_model=list[Item])
    async def read_items() -> Any:
        return [
            {"name": "Portal Gun", "price": 42.0},
            {"name": "Plumbus", "price": 32.0},
        ]
    

ü§ì Other versions and variants

Python 3.9+
    
    
    from typing import Any, Union
    
    from fastapi import FastAPI
    from pydantic import BaseModel
    
    app = FastAPI()
    
    
    class Item(BaseModel):
        name: str
        description: Union[str, None] = None
        price: float
        tax: Union[float, None] = None
        tags: list[str] = []
    
    
    @app.post("/items/", response_model=Item)
    async def create_item(item: Item) -> Any:
        return item
    
    
    @app.get("/items/", response_model=list[Item])
    async def read_items() -> Any:
        return [
            {"name": "Portal Gun", "price": 42.0},
            {"name": "Plumbus", "price": 32.0},
        ]
    

Note

Notice that `response_model` is a parameter of the "decorator" method (`get`, `post`, etc). Not of your _path operation function_ , like all the parameters and body.

`response_model` receives the same type you would declare for a Pydantic model field, so, it can be a Pydantic model, but it can also be, e.g. a `list` of Pydantic models, like `List[Item]`.

FastAPI will use this `response_model` to do all the data documentation, validation, etc. and also to **convert and filter the output data** to its type declaration.

Tip

If you have strict type checks in your editor, mypy, etc, you can declare the function return type as `Any`.

That way you tell the editor that you are intentionally returning anything. But FastAPI will still do the data documentation, validation, filtering, etc. with the `response_model`.

### `response_model` Priority[¶](#response-model-priority "Permanent link")

If you declare both a return type and a `response_model`, the `response_model` will take priority and be used by FastAPI.

This way you can add correct type annotations to your functions even when you are returning a type different than the response model, to be used by the editor and tools like mypy. And still you can have FastAPI do the data validation, documentation, etc. using the `response_model`.

You can also use `response_model=None` to disable creating a response model for that _path operation_ , you might need to do it if you are adding type annotations for things that are not valid Pydantic fields, you will see an example of that in one of the sections below.

## Return the same input data[¶](#return-the-same-input-data "Permanent link")

Here we are declaring a `UserIn` model, it will contain a plaintext password:

Python 3.10+
    
    
    from fastapi import FastAPI
    from pydantic import BaseModel, EmailStr
    
    app = FastAPI()
    
    
    class UserIn(BaseModel):
        username: str
        password: str
        email: EmailStr
        full_name: str | None = None
    
    
    # Don't do this in production!
    @app.post("/user/")
    async def create_user(user: UserIn) -> UserIn:
        return user
    

ü§ì Other versions and variants

Python 3.9+
    
    
    from typing import Union
    
    from fastapi import FastAPI
    from pydantic import BaseModel, EmailStr
    
    app = FastAPI()
    
    
    class UserIn(BaseModel):
        username: str
        password: str
        email: EmailStr
        full_name: Union[str, None] = None
    
    
    # Don't do this in production!
    @app.post("/user/")
    async def create_user(user: UserIn) -> UserIn:
        return user
    

Info

To use `EmailStr`, first install [`email-validator`](https://github.com/JoshData/python-email-validator).

Make sure you create a [virtual environment](../../virtual-environments/), activate it, and then install it, for example:
    
    
    $ pip install email-validator
    

or with:
    
    
    $ pip install "pydantic[email]"
    

And we are using this model to declare our input and the same model to declare our output:

Python 3.10+
    
    
    from fastapi import FastAPI
    from pydantic import BaseModel, EmailStr
    
    app = FastAPI()
    
    
    class UserIn(BaseModel):
        username: str
        password: str
        email: EmailStr
        full_name: str | None = None
    
    
    # Don't do this in production!
    @app.post("/user/")
    async def create_user(user: UserIn) -> UserIn:
        return user
    

ü§ì Other versions and variants

Python 3.9+
    
    
    from typing import Union
    
    from fastapi import FastAPI
    from pydantic import BaseModel, EmailStr
    
    app = FastAPI()
    
    
    class UserIn(BaseModel):
        username: str
        password: str
        email: EmailStr
        full_name: Union[str, None] = None
    
    
    # Don't do this in production!
    @app.post("/user/")
    async def create_user(user: UserIn) -> UserIn:
        return user
    

Now, whenever a browser is creating a user with a password, the API will return the same password in the response.

In this case, it might not be a problem, because it's the same user sending the password.

But if we use the same model for another _path operation_ , we could be sending our user's passwords to every client.

Danger

Never store the plain password of a user or send it in a response like this, unless you know all the caveats and you know what you are doing.

## Add an output model[¶](#add-an-output-model "Permanent link")

We can instead create an input model with the plaintext password and an output model without it:

Python 3.10+
    
    
    from typing import Any
    
    from fastapi import FastAPI
    from pydantic import BaseModel, EmailStr
    
    app = FastAPI()
    
    
    class UserIn(BaseModel):
        username: str
        password: str
        email: EmailStr
        full_name: str | None = None
    
    
    class UserOut(BaseModel):
        username: str
        email: EmailStr
        full_name: str | None = None
    
    
    @app.post("/user/", response_model=UserOut)
    async def create_user(user: UserIn) -> Any:
        return user
    

ü§ì Other versions and variants

Python 3.9+
    
    
    from typing import Any, Union
    
    from fastapi import FastAPI
    from pydantic import BaseModel, EmailStr
    
    app = FastAPI()
    
    
    class UserIn(BaseModel):
        username: str
        password: str
        email: EmailStr
        full_name: Union[str, None] = None
    
    
    class UserOut(BaseModel):
        username: str
        email: EmailStr
        full_name: Union[str, None] = None
    
    
    @app.post("/user/", response_model=UserOut)
    async def create_user(user: UserIn) -> Any:
        return user
    

Here, even though our _path operation function_ is returning the same input user that contains the password:

Python 3.10+
    
    
    from typing import Any
    
    from fastapi import FastAPI
    from pydantic import BaseModel, EmailStr
    
    app = FastAPI()
    
    
    class UserIn(BaseModel):
        username: str
        password: str
        email: EmailStr
        full_name: str | None = None
    
    
    class UserOut(BaseModel):
        username: str
        email: EmailStr
        full_name: str | None = None
    
    
    @app.post("/user/", response_model=UserOut)
    async def create_user(user: UserIn) -> Any:
        return user
    

ü§ì Other versions and variants

Python 3.9+
    
    
    from typing import Any, Union
    
    from fastapi import FastAPI
    from pydantic import BaseModel, EmailStr
    
    app = FastAPI()
    
    
    class UserIn(BaseModel):
        username: str
        password: str
        email: EmailStr
        full_name: Union[str, None] = None
    
    
    class UserOut(BaseModel):
        username: str
        email: EmailStr
        full_name: Union[str, None] = None
    
    
    @app.post("/user/", response_model=UserOut)
    async def create_user(user: UserIn) -> Any:
        return user
    

...we declared the `response_model` to be our model `UserOut`, that doesn't include the password:

Python 3.10+
    
    
    from typing import Any
    
    from fastapi import FastAPI
    from pydantic import BaseModel, EmailStr
    
    app = FastAPI()
    
    
    class UserIn(BaseModel):
        username: str
        password: str
        email: EmailStr
        full_name: str | None = None
    
    
    class UserOut(BaseModel):
        username: str
        email: EmailStr
        full_name: str | None = None
    
    
    @app.post("/user/", response_model=UserOut)
    async def create_user(user: UserIn) -> Any:
        return user
    

ü§ì Other versions and variants

Python 3.9+
    
    
    from typing import Any, Union
    
    from fastapi import FastAPI
    from pydantic import BaseModel, EmailStr
    
    app = FastAPI()
    
    
    class UserIn(BaseModel):
        username: str
        password: str
        email: EmailStr
        full_name: Union[str, None] = None
    
    
    class UserOut(BaseModel):
        username: str
        email: EmailStr
        full_name: Union[str, None] = None
    
    
    @app.post("/user/", response_model=UserOut)
    async def create_user(user: UserIn) -> Any:
        return user
    

So, **FastAPI** will take care of filtering out all the data that is not declared in the output model (using Pydantic).

### `response_model` or Return Type[¶](#response-model-or-return-type "Permanent link")

In this case, because the two models are different, if we annotated the function return type as `UserOut`, the editor and tools would complain that we are returning an invalid type, as those are different classes.

That's why in this example we have to declare it in the `response_model` parameter.

...but continue reading below to see how to overcome that.

## Return Type and Data Filtering[¶](#return-type-and-data-filtering "Permanent link")

Let's continue from the previous example. We wanted to **annotate the function with one type** , but we wanted to be able to return from the function something that actually includes **more data**.

We want FastAPI to keep **filtering** the data using the response model. So that even though the function returns more data, the response will only include the fields declared in the response model.

In the previous example, because the classes were different, we had to use the `response_model` parameter. But that also means that we don't get the support from the editor and tools checking the function return type.

But in most of the cases where we need to do something like this, we want the model just to **filter/remove** some of the data as in this example.

And in those cases, we can use classes and inheritance to take advantage of function **type annotations** to get better support in the editor and tools, and still get the FastAPI **data filtering**.

Python 3.10+
    
    
    from fastapi import FastAPI
    from pydantic import BaseModel, EmailStr
    
    app = FastAPI()
    
    
    class BaseUser(BaseModel):
        username: str
        email: EmailStr
        full_name: str | None = None
    
    
    class UserIn(BaseUser):
        password: str
    
    
    @app.post("/user/")
    async def create_user(user: UserIn) -> BaseUser:
        return user
    

ü§ì Other versions and variants

Python 3.9+
    
    
    from typing import Union
    
    from fastapi import FastAPI
    from pydantic import BaseModel, EmailStr
    
    app = FastAPI()
    
    
    class BaseUser(BaseModel):
        username: str
        email: EmailStr
        full_name: Union[str, None] = None
    
    
    class UserIn(BaseUser):
        password: str
    
    
    @app.post("/user/")
    async def create_user(user: UserIn) -> BaseUser:
        return user
    

With this, we get tooling support, from editors and mypy as this code is correct in terms of types, but we also get the data filtering from FastAPI.

How does this work? Let's check that out. ü§ì

### Type Annotations and Tooling[¶](#type-annotations-and-tooling "Permanent link")

First let's see how editors, mypy and other tools would see this.

`BaseUser` has the base fields. Then `UserIn` inherits from `BaseUser` and adds the `password` field, so, it will include all the fields from both models.

We annotate the function return type as `BaseUser`, but we are actually returning a `UserIn` instance.

The editor, mypy, and other tools won't complain about this because, in typing terms, `UserIn` is a subclass of `BaseUser`, which means it's a _valid_ type when what is expected is anything that is a `BaseUser`.

### FastAPI Data Filtering[¶](#fastapi-data-filtering "Permanent link")

Now, for FastAPI, it will see the return type and make sure that what you return includes **only** the fields that are declared in the type.

FastAPI does several things internally with Pydantic to make sure that those same rules of class inheritance are not used for the returned data filtering, otherwise you could end up returning much more data than what you expected.

This way, you can get the best of both worlds: type annotations with **tooling support** and **data filtering**.

## See it in the docs[¶](#see-it-in-the-docs "Permanent link")

When you see the automatic docs, you can check that the input model and output model will both have their own JSON Schema:

![](/img/tutorial/response-model/image01.png)

And both models will be used for the interactive API documentation:

![](/img/tutorial/response-model/image02.png)

## Other Return Type Annotations[¶](#other-return-type-annotations "Permanent link")

There might be cases where you return something that is not a valid Pydantic field and you annotate it in the function, only to get the support provided by tooling (the editor, mypy, etc).

### Return a Response Directly[¶](#return-a-response-directly "Permanent link")

The most common case would be [returning a Response directly as explained later in the advanced docs](../../advanced/response-directly/).

Python 3.9+
    
    
    from fastapi import FastAPI, Response
    from fastapi.responses import JSONResponse, RedirectResponse
    
    app = FastAPI()
    
    
    @app.get("/portal")
    async def get_portal(teleport: bool = False) -> Response:
        if teleport:
            return RedirectResponse(url="https://www.youtube.com/watch?v=dQw4w9WgXcQ")
        return JSONResponse(content={"message": "Here's your interdimensional portal."})
    

This simple case is handled automatically by FastAPI because the return type annotation is the class (or a subclass of) `Response`.

And tools will also be happy because both `RedirectResponse` and `JSONResponse` are subclasses of `Response`, so the type annotation is correct.

### Annotate a Response Subclass[¶](#annotate-a-response-subclass "Permanent link")

You can also use a subclass of `Response` in the type annotation:

Python 3.9+
    
    
    from fastapi import FastAPI
    from fastapi.responses import RedirectResponse
    
    app = FastAPI()
    
    
    @app.get("/teleport")
    async def get_teleport() -> RedirectResponse:
        return RedirectResponse(url="https://www.youtube.com/watch?v=dQw4w9WgXcQ")
    

This will also work because `RedirectResponse` is a subclass of `Response`, and FastAPI will automatically handle this simple case.

### Invalid Return Type Annotations[¶](#invalid-return-type-annotations "Permanent link")

But when you return some other arbitrary object that is not a valid Pydantic type (e.g. a database object) and you annotate it like that in the function, FastAPI will try to create a Pydantic response model from that type annotation, and will fail.

The same would happen if you had something like a union between different types where one or more of them are not valid Pydantic types, for example this would fail üí•:

Python 3.10+
    
    
    from fastapi import FastAPI, Response
    from fastapi.responses import RedirectResponse
    
    app = FastAPI()
    
    
    @app.get("/portal")
    async def get_portal(teleport: bool = False) -> Response | dict:
        if teleport:
            return RedirectResponse(url="https://www.youtube.com/watch?v=dQw4w9WgXcQ")
        return {"message": "Here's your interdimensional portal."}
    

ü§ì Other versions and variants

Python 3.9+
    
    
    from typing import Union
    
    from fastapi import FastAPI, Response
    from fastapi.responses import RedirectResponse
    
    app = FastAPI()
    
    
    @app.get("/portal")
    async def get_portal(teleport: bool = False) -> Union[Response, dict]:
        if teleport:
            return RedirectResponse(url="https://www.youtube.com/watch?v=dQw4w9WgXcQ")
        return {"message": "Here's your interdimensional portal."}
    

...this fails because the type annotation is not a Pydantic type and is not just a single `Response` class or subclass, it's a union (any of the two) between a `Response` and a `dict`.

### Disable Response Model[¶](#disable-response-model "Permanent link")

Continuing from the example above, you might not want to have the default data validation, documentation, filtering, etc. that is performed by FastAPI.

But you might want to still keep the return type annotation in the function to get the support from tools like editors and type checkers (e.g. mypy).

In this case, you can disable the response model generation by setting `response_model=None`:

Python 3.10+
    
    
    from fastapi import FastAPI, Response
    from fastapi.responses import RedirectResponse
    
    app = FastAPI()
    
    
    @app.get("/portal", response_model=None)
    async def get_portal(teleport: bool = False) -> Response | dict:
        if teleport:
            return RedirectResponse(url="https://www.youtube.com/watch?v=dQw4w9WgXcQ")
        return {"message": "Here's your interdimensional portal."}
    

ü§ì Other versions and variants

Python 3.9+
    
    
    from typing import Union
    
    from fastapi import FastAPI, Response
    from fastapi.responses import RedirectResponse
    
    app = FastAPI()
    
    
    @app.get("/portal", response_model=None)
    async def get_portal(teleport: bool = False) -> Union[Response, dict]:
        if teleport:
            return RedirectResponse(url="https://www.youtube.com/watch?v=dQw4w9WgXcQ")
        return {"message": "Here's your interdimensional portal."}
    

This will make FastAPI skip the response model generation and that way you can have any return type annotations you need without it affecting your FastAPI application. ü§ì

## Response Model encoding parameters[¶](#response-model-encoding-parameters "Permanent link")

Your response model could have default values, like:

Python 3.10+
    
    
    from fastapi import FastAPI
    from pydantic import BaseModel
    
    app = FastAPI()
    
    
    class Item(BaseModel):
        name: str
        description: str | None = None
        price: float
        tax: float = 10.5
        tags: list[str] = []
    
    
    items = {
        "foo": {"name": "Foo", "price": 50.2},
        "bar": {"name": "Bar", "description": "The bartenders", "price": 62, "tax": 20.2},
        "baz": {"name": "Baz", "description": None, "price": 50.2, "tax": 10.5, "tags": []},
    }
    
    
    @app.get("/items/{item_id}", response_model=Item, response_model_exclude_unset=True)
    async def read_item(item_id: str):
        return items[item_id]
    

ü§ì Other versions and variants

Python 3.9+
    
    
    from typing import Union
    
    from fastapi import FastAPI
    from pydantic import BaseModel
    
    app = FastAPI()
    
    
    class Item(BaseModel):
        name: str
        description: Union[str, None] = None
        price: float
        tax: float = 10.5
        tags: list[str] = []
    
    
    items = {
        "foo": {"name": "Foo", "price": 50.2},
        "bar": {"name": "Bar", "description": "The bartenders", "price": 62, "tax": 20.2},
        "baz": {"name": "Baz", "description": None, "price": 50.2, "tax": 10.5, "tags": []},
    }
    
    
    @app.get("/items/{item_id}", response_model=Item, response_model_exclude_unset=True)
    async def read_item(item_id: str):
        return items[item_id]
    

  * `description: Union[str, None] = None` (or `str | None = None` in Python 3.10) has a default of `None`.
  * `tax: float = 10.5` has a default of `10.5`.
  * `tags: List[str] = []` has a default of an empty list: `[]`.

but you might want to omit them from the result if they were not actually stored.

For example, if you have models with many optional attributes in a NoSQL database, but you don't want to send very long JSON responses full of default values.

### Use the `response_model_exclude_unset` parameter[¶](#use-the-response-model-exclude-unset-parameter "Permanent link")

You can set the _path operation decorator_ parameter `response_model_exclude_unset=True`:

Python 3.10+
    
    
    from fastapi import FastAPI
    from pydantic import BaseModel
    
    app = FastAPI()
    
    
    class Item(BaseModel):
        name: str
        description: str | None = None
        price: float
        tax: float = 10.5
        tags: list[str] = []
    
    
    items = {
        "foo": {"name": "Foo", "price": 50.2},
        "bar": {"name": "Bar", "description": "The bartenders", "price": 62, "tax": 20.2},
        "baz": {"name": "Baz", "description": None, "price": 50.2, "tax": 10.5, "tags": []},
    }
    
    
    @app.get("/items/{item_id}", response_model=Item, response_model_exclude_unset=True)
    async def read_item(item_id: str):
        return items[item_id]
    

ü§ì Other versions and variants

Python 3.9+
    
    
    from typing import Union
    
    from fastapi import FastAPI
    from pydantic import BaseModel
    
    app = FastAPI()
    
    
    class Item(BaseModel):
        name: str
        description: Union[str, None] = None
        price: float
        tax: float = 10.5
        tags: list[str] = []
    
    
    items = {
        "foo": {"name": "Foo", "price": 50.2},
        "bar": {"name": "Bar", "description": "The bartenders", "price": 62, "tax": 20.2},
        "baz": {"name": "Baz", "description": None, "price": 50.2, "tax": 10.5, "tags": []},
    }
    
    
    @app.get("/items/{item_id}", response_model=Item, response_model_exclude_unset=True)
    async def read_item(item_id: str):
        return items[item_id]
    

and those default values won't be included in the response, only the values actually set.

So, if you send a request to that _path operation_ for the item with ID `foo`, the response (not including default values) will be:
    
    
    {
        "name": "Foo",
        "price": 50.2
    }
    

Info

You can also use:

  * `response_model_exclude_defaults=True`
  * `response_model_exclude_none=True`

as described in [the Pydantic docs](https://docs.pydantic.dev/1.10/usage/exporting_models/#modeldict) for `exclude_defaults` and `exclude_none`.

#### Data with values for fields with defaults[¶](#data-with-values-for-fields-with-defaults "Permanent link")

But if your data has values for the model's fields with default values, like the item with ID `bar`:
    
    
    {
        "name": "Bar",
        "description": "The bartenders",
        "price": 62,
        "tax": 20.2
    }
    

they will be included in the response.

#### Data with the same values as the defaults[¶](#data-with-the-same-values-as-the-defaults "Permanent link")

If the data has the same values as the default ones, like the item with ID `baz`:
    
    
    {
        "name": "Baz",
        "description": None,
        "price": 50.2,
        "tax": 10.5,
        "tags": []
    }
    

FastAPI is smart enough (actually, Pydantic is smart enough) to realize that, even though `description`, `tax`, and `tags` have the same values as the defaults, they were set explicitly (instead of taken from the defaults).

So, they will be included in the JSON response.

Tip

Notice that the default values can be anything, not only `None`.

They can be a list (`[]`), a `float` of `10.5`, etc.

### `response_model_include` and `response_model_exclude`[¶](#response-model-include-and-response-model-exclude "Permanent link")

You can also use the _path operation decorator_ parameters `response_model_include` and `response_model_exclude`.

They take a `set` of `str` with the name of the attributes to include (omitting the rest) or to exclude (including the rest).

This can be used as a quick shortcut if you have only one Pydantic model and want to remove some data from the output.

Tip

But it is still recommended to use the ideas above, using multiple classes, instead of these parameters.

This is because the JSON Schema generated in your app's OpenAPI (and the docs) will still be the one for the complete model, even if you use `response_model_include` or `response_model_exclude` to omit some attributes.

This also applies to `response_model_by_alias` that works similarly.

Python 3.10+
    
    
    from fastapi import FastAPI
    from pydantic import BaseModel
    
    app = FastAPI()
    
    
    class Item(BaseModel):
        name: str
        description: str | None = None
        price: float
        tax: float = 10.5
    
    
    items = {
        "foo": {"name": "Foo", "price": 50.2},
        "bar": {"name": "Bar", "description": "The Bar fighters", "price": 62, "tax": 20.2},
        "baz": {
            "name": "Baz",
            "description": "There goes my baz",
            "price": 50.2,
            "tax": 10.5,
        },
    }
    
    
    @app.get(
        "/items/{item_id}/name",
        response_model=Item,
        response_model_include={"name", "description"},
    )
    async def read_item_name(item_id: str):
        return items[item_id]
    
    
    @app.get("/items/{item_id}/public", response_model=Item, response_model_exclude={"tax"})
    async def read_item_public_data(item_id: str):
        return items[item_id]
    

ü§ì Other versions and variants

Python 3.9+
    
    
    from typing import Union
    
    from fastapi import FastAPI
    from pydantic import BaseModel
    
    app = FastAPI()
    
    
    class Item(BaseModel):
        name: str
        description: Union[str, None] = None
        price: float
        tax: float = 10.5
    
    
    items = {
        "foo": {"name": "Foo", "price": 50.2},
        "bar": {"name": "Bar", "description": "The Bar fighters", "price": 62, "tax": 20.2},
        "baz": {
            "name": "Baz",
            "description": "There goes my baz",
            "price": 50.2,
            "tax": 10.5,
        },
    }
    
    
    @app.get(
        "/items/{item_id}/name",
        response_model=Item,
        response_model_include={"name", "description"},
    )
    async def read_item_name(item_id: str):
        return items[item_id]
    
    
    @app.get("/items/{item_id}/public", response_model=Item, response_model_exclude={"tax"})
    async def read_item_public_data(item_id: str):
        return items[item_id]
    

Tip

The syntax `{"name", "description"}` creates a `set` with those two values.

It is equivalent to `set(["name", "description"])`.

#### Using `list`s instead of `set`s[¶](#using-lists-instead-of-sets "Permanent link")

If you forget to use a `set` and use a `list` or `tuple` instead, FastAPI will still convert it to a `set` and it will work correctly:

Python 3.10+
    
    
    from fastapi import FastAPI
    from pydantic import BaseModel
    
    app = FastAPI()
    
    
    class Item(BaseModel):
        name: str
        description: str | None = None
        price: float
        tax: float = 10.5
    
    
    items = {
        "foo": {"name": "Foo", "price": 50.2},
        "bar": {"name": "Bar", "description": "The Bar fighters", "price": 62, "tax": 20.2},
        "baz": {
            "name": "Baz",
            "description": "There goes my baz",
            "price": 50.2,
            "tax": 10.5,
        },
    }
    
    
    @app.get(
        "/items/{item_id}/name",
        response_model=Item,
        response_model_include=["name", "description"],
    )
    async def read_item_name(item_id: str):
        return items[item_id]
    
    
    @app.get("/items/{item_id}/public", response_model=Item, response_model_exclude=["tax"])
    async def read_item_public_data(item_id: str):
        return items[item_id]
    

ü§ì Other versions and variants

Python 3.9+
    
    
    from typing import Union
    
    from fastapi import FastAPI
    from pydantic import BaseModel
    
    app = FastAPI()
    
    
    class Item(BaseModel):
        name: str
        description: Union[str, None] = None
        price: float
        tax: float = 10.5
    
    
    items = {
        "foo": {"name": "Foo", "price": 50.2},
        "bar": {"name": "Bar", "description": "The Bar fighters", "price": 62, "tax": 20.2},
        "baz": {
            "name": "Baz",
            "description": "There goes my baz",
            "price": 50.2,
            "tax": 10.5,
        },
    }
    
    
    @app.get(
        "/items/{item_id}/name",
        response_model=Item,
        response_model_include=["name", "description"],
    )
    async def read_item_name(item_id: str):
        return items[item_id]
    
    
    @app.get("/items/{item_id}/public", response_model=Item, response_model_exclude=["tax"])
    async def read_item_public_data(item_id: str):
        return items[item_id]
    

## Recap[¶](#recap "Permanent link")

Use the _path operation decorator's_ parameter `response_model` to define response models and especially to ensure private data is filtered out.

Use `response_model_exclude_unset` to return only the values explicitly set.
  *[union]: A union between multiple types means "any of these types".

---

###### Extra Models¶

# Extra Models[¶](#extra-models "Permanent link")

Continuing with the previous example, it will be common to have more than one related model.

This is especially the case for user models, because:

  * The **input model** needs to be able to have a password.
  * The **output model** should not have a password.
  * The **database model** would probably need to have a hashed password.

Danger

Never store user's plaintext passwords. Always store a "secure hash" that you can then verify.

If you don't know, you will learn what a "password hash" is in the [security chapters](../security/simple-oauth2/#password-hashing).

## Multiple models[¶](#multiple-models "Permanent link")

Here's a general idea of how the models could look like with their password fields and the places where they are used:

Python 3.10+
    
    
    from fastapi import FastAPI
    from pydantic import BaseModel, EmailStr
    
    app = FastAPI()
    
    
    class UserIn(BaseModel):
        username: str
        password: str
        email: EmailStr
        full_name: str | None = None
    
    
    class UserOut(BaseModel):
        username: str
        email: EmailStr
        full_name: str | None = None
    
    
    class UserInDB(BaseModel):
        username: str
        hashed_password: str
        email: EmailStr
        full_name: str | None = None
    
    
    def fake_password_hasher(raw_password: str):
        return "supersecret" + raw_password
    
    
    def fake_save_user(user_in: UserIn):
        hashed_password = fake_password_hasher(user_in.password)
        user_in_db = UserInDB(**user_in.model_dump(), hashed_password=hashed_password)
        print("User saved! ..not really")
        return user_in_db
    
    
    @app.post("/user/", response_model=UserOut)
    async def create_user(user_in: UserIn):
        user_saved = fake_save_user(user_in)
        return user_saved
    

ü§ì Other versions and variants

Python 3.9+
    
    
    from typing import Union
    
    from fastapi import FastAPI
    from pydantic import BaseModel, EmailStr
    
    app = FastAPI()
    
    
    class UserIn(BaseModel):
        username: str
        password: str
        email: EmailStr
        full_name: Union[str, None] = None
    
    
    class UserOut(BaseModel):
        username: str
        email: EmailStr
        full_name: Union[str, None] = None
    
    
    class UserInDB(BaseModel):
        username: str
        hashed_password: str
        email: EmailStr
        full_name: Union[str, None] = None
    
    
    def fake_password_hasher(raw_password: str):
        return "supersecret" + raw_password
    
    
    def fake_save_user(user_in: UserIn):
        hashed_password = fake_password_hasher(user_in.password)
        user_in_db = UserInDB(**user_in.model_dump(), hashed_password=hashed_password)
        print("User saved! ..not really")
        return user_in_db
    
    
    @app.post("/user/", response_model=UserOut)
    async def create_user(user_in: UserIn):
        user_saved = fake_save_user(user_in)
        return user_saved
    

### About `**user_in.model_dump()`[¶](#about-user-in-model-dump "Permanent link")

#### Pydantic's `.model_dump()`[¶](#pydantics-model-dump "Permanent link")

`user_in` is a Pydantic model of class `UserIn`.

Pydantic models have a `.model_dump()` method that returns a `dict` with the model's data.

So, if we create a Pydantic object `user_in` like:
    
    
    user_in = UserIn(username="john", password="secret", email="john.doe@example.com")
    

and then we call:
    
    
    user_dict = user_in.model_dump()
    

we now have a `dict` with the data in the variable `user_dict` (it's a `dict` instead of a Pydantic model object).

And if we call:
    
    
    print(user_dict)
    

we would get a Python `dict` with:
    
    
    {
        'username': 'john',
        'password': 'secret',
        'email': 'john.doe@example.com',
        'full_name': None,
    }
    

#### Unpacking a `dict`[¶](#unpacking-a-dict "Permanent link")

If we take a `dict` like `user_dict` and pass it to a function (or class) with `**user_dict`, Python will "unpack" it. It will pass the keys and values of the `user_dict` directly as key-value arguments.

So, continuing with the `user_dict` from above, writing:
    
    
    UserInDB(**user_dict)
    

would result in something equivalent to:
    
    
    UserInDB(
        username="john",
        password="secret",
        email="john.doe@example.com",
        full_name=None,
    )
    

Or more exactly, using `user_dict` directly, with whatever contents it might have in the future:
    
    
    UserInDB(
        username = user_dict["username"],
        password = user_dict["password"],
        email = user_dict["email"],
        full_name = user_dict["full_name"],
    )
    

#### A Pydantic model from the contents of another[¶](#a-pydantic-model-from-the-contents-of-another "Permanent link")

As in the example above we got `user_dict` from `user_in.model_dump()`, this code:
    
    
    user_dict = user_in.model_dump()
    UserInDB(**user_dict)
    

would be equivalent to:
    
    
    UserInDB(**user_in.model_dump())
    

...because `user_in.model_dump()` is a `dict`, and then we make Python "unpack" it by passing it to `UserInDB` prefixed with `**`.

So, we get a Pydantic model from the data in another Pydantic model.

#### Unpacking a `dict` and extra keywords[¶](#unpacking-a-dict-and-extra-keywords "Permanent link")

And then adding the extra keyword argument `hashed_password=hashed_password`, like in:
    
    
    UserInDB(**user_in.model_dump(), hashed_password=hashed_password)
    

...ends up being like:
    
    
    UserInDB(
        username = user_dict["username"],
        password = user_dict["password"],
        email = user_dict["email"],
        full_name = user_dict["full_name"],
        hashed_password = hashed_password,
    )
    

Warning

The supporting additional functions `fake_password_hasher` and `fake_save_user` are just to demo a possible flow of the data, but they of course are not providing any real security.

## Reduce duplication[¶](#reduce-duplication "Permanent link")

Reducing code duplication is one of the core ideas in **FastAPI**.

As code duplication increments the chances of bugs, security issues, code desynchronization issues (when you update in one place but not in the others), etc.

And these models are all sharing a lot of the data and duplicating attribute names and types.

We could do better.

We can declare a `UserBase` model that serves as a base for our other models. And then we can make subclasses of that model that inherit its attributes (type declarations, validation, etc).

All the data conversion, validation, documentation, etc. will still work as normally.

That way, we can declare just the differences between the models (with plaintext `password`, with `hashed_password` and without password):

Python 3.10+
    
    
    from fastapi import FastAPI
    from pydantic import BaseModel, EmailStr
    
    app = FastAPI()
    
    
    class UserBase(BaseModel):
        username: str
        email: EmailStr
        full_name: str | None = None
    
    
    class UserIn(UserBase):
        password: str
    
    
    class UserOut(UserBase):
        pass
    
    
    class UserInDB(UserBase):
        hashed_password: str
    
    
    def fake_password_hasher(raw_password: str):
        return "supersecret" + raw_password
    
    
    def fake_save_user(user_in: UserIn):
        hashed_password = fake_password_hasher(user_in.password)
        user_in_db = UserInDB(**user_in.model_dump(), hashed_password=hashed_password)
        print("User saved! ..not really")
        return user_in_db
    
    
    @app.post("/user/", response_model=UserOut)
    async def create_user(user_in: UserIn):
        user_saved = fake_save_user(user_in)
        return user_saved
    

ü§ì Other versions and variants

Python 3.9+
    
    
    from typing import Union
    
    from fastapi import FastAPI
    from pydantic import BaseModel, EmailStr
    
    app = FastAPI()
    
    
    class UserBase(BaseModel):
        username: str
        email: EmailStr
        full_name: Union[str, None] = None
    
    
    class UserIn(UserBase):
        password: str
    
    
    class UserOut(UserBase):
        pass
    
    
    class UserInDB(UserBase):
        hashed_password: str
    
    
    def fake_password_hasher(raw_password: str):
        return "supersecret" + raw_password
    
    
    def fake_save_user(user_in: UserIn):
        hashed_password = fake_password_hasher(user_in.password)
        user_in_db = UserInDB(**user_in.model_dump(), hashed_password=hashed_password)
        print("User saved! ..not really")
        return user_in_db
    
    
    @app.post("/user/", response_model=UserOut)
    async def create_user(user_in: UserIn):
        user_saved = fake_save_user(user_in)
        return user_saved
    

## `Union` or `anyOf`[¶](#union-or-anyof "Permanent link")

You can declare a response to be the `Union` of two or more types, that means, that the response would be any of them.

It will be defined in OpenAPI with `anyOf`.

To do that, use the standard Python type hint [`typing.Union`](https://docs.python.org/3/library/typing.html#typing.Union):

Note

When defining a [`Union`](https://docs.pydantic.dev/latest/concepts/types/#unions), include the most specific type first, followed by the less specific type. In the example below, the more specific `PlaneItem` comes before `CarItem` in `Union[PlaneItem, CarItem]`.

Python 3.10+
    
    
    from typing import Union
    
    from fastapi import FastAPI
    from pydantic import BaseModel
    
    app = FastAPI()
    
    
    class BaseItem(BaseModel):
        description: str
        type: str
    
    
    class CarItem(BaseItem):
        type: str = "car"
    
    
    class PlaneItem(BaseItem):
        type: str = "plane"
        size: int
    
    
    items = {
        "item1": {"description": "All my friends drive a low rider", "type": "car"},
        "item2": {
            "description": "Music is my aeroplane, it's my aeroplane",
            "type": "plane",
            "size": 5,
        },
    }
    
    
    @app.get("/items/{item_id}", response_model=Union[PlaneItem, CarItem])
    async def read_item(item_id: str):
        return items[item_id]
    

ü§ì Other versions and variants

Python 3.9+
    
    
    from typing import Union
    
    from fastapi import FastAPI
    from pydantic import BaseModel
    
    app = FastAPI()
    
    
    class BaseItem(BaseModel):
        description: str
        type: str
    
    
    class CarItem(BaseItem):
        type: str = "car"
    
    
    class PlaneItem(BaseItem):
        type: str = "plane"
        size: int
    
    
    items = {
        "item1": {"description": "All my friends drive a low rider", "type": "car"},
        "item2": {
            "description": "Music is my aeroplane, it's my aeroplane",
            "type": "plane",
            "size": 5,
        },
    }
    
    
    @app.get("/items/{item_id}", response_model=Union[PlaneItem, CarItem])
    async def read_item(item_id: str):
        return items[item_id]
    

### `Union` in Python 3.10[¶](#union-in-python-3-10 "Permanent link")

In this example we pass `Union[PlaneItem, CarItem]` as the value of the argument `response_model`.

Because we are passing it as a **value to an argument** instead of putting it in a **type annotation** , we have to use `Union` even in Python 3.10.

If it was in a type annotation we could have used the vertical bar, as:
    
    
    some_variable: PlaneItem | CarItem
    

But if we put that in the assignment `response_model=PlaneItem | CarItem` we would get an error, because Python would try to perform an **invalid operation** between `PlaneItem` and `CarItem` instead of interpreting that as a type annotation.

## List of models[¶](#list-of-models "Permanent link")

The same way, you can declare responses of lists of objects.

For that, use the standard Python `typing.List` (or just `list` in Python 3.9 and above):

Python 3.9+
    
    
    from fastapi import FastAPI
    from pydantic import BaseModel
    
    app = FastAPI()
    
    
    class Item(BaseModel):
        name: str
        description: str
    
    
    items = [
        {"name": "Foo", "description": "There comes my hero"},
        {"name": "Red", "description": "It's my aeroplane"},
    ]
    
    
    @app.get("/items/", response_model=list[Item])
    async def read_items():
        return items
    

## Response with arbitrary `dict`[¶](#response-with-arbitrary-dict "Permanent link")

You can also declare a response using a plain arbitrary `dict`, declaring just the type of the keys and values, without using a Pydantic model.

This is useful if you don't know the valid field/attribute names (that would be needed for a Pydantic model) beforehand.

In this case, you can use `typing.Dict` (or just `dict` in Python 3.9 and above):

Python 3.9+
    
    
    from fastapi import FastAPI
    
    app = FastAPI()
    
    
    @app.get("/keyword-weights/", response_model=dict[str, float])
    async def read_keyword_weights():
        return {"foo": 2.3, "bar": 3.4}
    

## Recap[¶](#recap "Permanent link")

Use multiple Pydantic models and inherit freely for each case.

You don't need to have a single data model per entity if that entity must be able to have different "states". As the case with the user "entity" with a state including `password`, `password_hash` and no password.

---

###### Response Status Code¶

# Response Status Code[¶](#response-status-code "Permanent link")

The same way you can specify a response model, you can also declare the HTTP status code used for the response with the parameter `status_code` in any of the _path operations_ :

  * `@app.get()`
  * `@app.post()`
  * `@app.put()`
  * `@app.delete()`
  * etc.

Python 3.9+
    
    
    from fastapi import FastAPI
    
    app = FastAPI()
    
    
    @app.post("/items/", status_code=201)
    async def create_item(name: str):
        return {"name": name}
    

Note

Notice that `status_code` is a parameter of the "decorator" method (`get`, `post`, etc). Not of your _path operation function_ , like all the parameters and body.

The `status_code` parameter receives a number with the HTTP status code.

Info

`status_code` can alternatively also receive an `IntEnum`, such as Python's [`http.HTTPStatus`](https://docs.python.org/3/library/http.html#http.HTTPStatus).

It will:

  * Return that status code in the response.
  * Document it as such in the OpenAPI schema (and so, in the user interfaces):

![](/img/tutorial/response-status-code/image01.png)

Note

Some response codes (see the next section) indicate that the response does not have a body.

FastAPI knows this, and will produce OpenAPI docs that state there is no response body.

## About HTTP status codes[¶](#about-http-status-codes "Permanent link")

Note

If you already know what HTTP status codes are, skip to the next section.

In HTTP, you send a numeric status code of 3 digits as part of the response.

These status codes have a name associated to recognize them, but the important part is the number.

In short:

  * `100 - 199` are for "Information". You rarely use them directly. Responses with these status codes cannot have a body.
  * **`200 - 299`** are for "Successful" responses. These are the ones you would use the most.
    * `200` is the default status code, which means everything was "OK".
    * Another example would be `201`, "Created". It is commonly used after creating a new record in the database.
    * A special case is `204`, "No Content". This response is used when there is no content to return to the client, and so the response must not have a body.
  * **`300 - 399`** are for "Redirection". Responses with these status codes may or may not have a body, except for `304`, "Not Modified", which must not have one.
  * **`400 - 499`** are for "Client error" responses. These are the second type you would probably use the most.
    * An example is `404`, for a "Not Found" response.
    * For generic errors from the client, you can just use `400`.
  * `500 - 599` are for server errors. You almost never use them directly. When something goes wrong at some part in your application code, or server, it will automatically return one of these status codes.

Tip

To know more about each status code and which code is for what, check the [MDN documentation about HTTP status codes](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status).

## Shortcut to remember the names[¶](#shortcut-to-remember-the-names "Permanent link")

Let's see the previous example again:

Python 3.9+
    
    
    from fastapi import FastAPI
    
    app = FastAPI()
    
    
    @app.post("/items/", status_code=201)
    async def create_item(name: str):
        return {"name": name}
    

`201` is the status code for "Created".

But you don't have to memorize what each of these codes mean.

You can use the convenience variables from `fastapi.status`.

Python 3.9+
    
    
    from fastapi import FastAPI, status
    
    app = FastAPI()
    
    
    @app.post("/items/", status_code=status.HTTP_201_CREATED)
    async def create_item(name: str):
        return {"name": name}
    

They are just a convenience, they hold the same number, but that way you can use the editor's autocomplete to find them:

![](/img/tutorial/response-status-code/image02.png)

Technical Details

You could also use `from starlette import status`.

**FastAPI** provides the same `starlette.status` as `fastapi.status` just as a convenience for you, the developer. But it comes directly from Starlette.

## Changing the default[¶](#changing-the-default "Permanent link")

Later, in the [Advanced User Guide](../../advanced/response-change-status-code/), you will see how to return a different status code than the default you are declaring here.
  *[MDN]: Mozilla Developer Network

---

###### Form Data¶

# Form Data[¶](#form-data "Permanent link")

When you need to receive form fields instead of JSON, you can use `Form`.

Info

To use forms, first install [`python-multipart`](https://github.com/Kludex/python-multipart).

Make sure you create a [virtual environment](../../virtual-environments/), activate it, and then install it, for example:
    
    
    $ pip install python-multipart
    

## Import `Form`[¶](#import-form "Permanent link")

Import `Form` from `fastapi`:

Python 3.9+
    
    
    from typing import Annotated
    
    from fastapi import FastAPI, Form
    
    app = FastAPI()
    
    
    @app.post("/login/")
    async def login(username: Annotated[str, Form()], password: Annotated[str, Form()]):
        return {"username": username}
    

ü§ì Other versions and variants

Python 3.9+ - non-Annotated

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import FastAPI, Form
    
    app = FastAPI()
    
    
    @app.post("/login/")
    async def login(username: str = Form(), password: str = Form()):
        return {"username": username}
    

## Define `Form` parameters[¶](#define-form-parameters "Permanent link")

Create form parameters the same way you would for `Body` or `Query`:

Python 3.9+
    
    
    from typing import Annotated
    
    from fastapi import FastAPI, Form
    
    app = FastAPI()
    
    
    @app.post("/login/")
    async def login(username: Annotated[str, Form()], password: Annotated[str, Form()]):
        return {"username": username}
    

ü§ì Other versions and variants

Python 3.9+ - non-Annotated

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import FastAPI, Form
    
    app = FastAPI()
    
    
    @app.post("/login/")
    async def login(username: str = Form(), password: str = Form()):
        return {"username": username}
    

For example, in one of the ways the OAuth2 specification can be used (called "password flow") it is required to send a `username` and `password` as form fields.

The spec requires the fields to be exactly named `username` and `password`, and to be sent as form fields, not JSON.

With `Form` you can declare the same configurations as with `Body` (and `Query`, `Path`, `Cookie`), including validation, examples, an alias (e.g. `user-name` instead of `username`), etc.

Info

`Form` is a class that inherits directly from `Body`.

Tip

To declare form bodies, you need to use `Form` explicitly, because without it the parameters would be interpreted as query parameters or body (JSON) parameters.

## About "Form Fields"[¶](#about-form-fields "Permanent link")

The way HTML forms (`<form></form>`) sends the data to the server normally uses a "special" encoding for that data, it's different from JSON.

**FastAPI** will make sure to read that data from the right place instead of JSON.

Technical Details

Data from forms is normally encoded using the "media type" `application/x-www-form-urlencoded`.

But when the form includes files, it is encoded as `multipart/form-data`. You'll read about handling files in the next chapter.

If you want to read more about these encodings and form fields, head to the [MDN web docs for `POST`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/POST).

Warning

You can declare multiple `Form` parameters in a _path operation_ , but you can't also declare `Body` fields that you expect to receive as JSON, as the request will have the body encoded using `application/x-www-form-urlencoded` instead of `application/json`.

This is not a limitation of **FastAPI** , it's part of the HTTP protocol.

## Recap[¶](#recap "Permanent link")

Use `Form` to declare form data input parameters.
  *[spec]: specification
  *[MDN]: Mozilla Developer Network

---

###### Form Models¶

# Form Models[¶](#form-models "Permanent link")

You can use **Pydantic models** to declare **form fields** in FastAPI.

Info

To use forms, first install [`python-multipart`](https://github.com/Kludex/python-multipart).

Make sure you create a [virtual environment](../../virtual-environments/), activate it, and then install it, for example:
    
    
    $ pip install python-multipart
    

Note

This is supported since FastAPI version `0.113.0`. ü§ì

## Pydantic Models for Forms[¶](#pydantic-models-for-forms "Permanent link")

You just need to declare a **Pydantic model** with the fields you want to receive as **form fields** , and then declare the parameter as `Form`:

Python 3.9+
    
    
    from typing import Annotated
    
    from fastapi import FastAPI, Form
    from pydantic import BaseModel
    
    app = FastAPI()
    
    
    class FormData(BaseModel):
        username: str
        password: str
    
    
    @app.post("/login/")
    async def login(data: Annotated[FormData, Form()]):
        return data
    

ü§ì Other versions and variants

Python 3.9+ - non-Annotated

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import FastAPI, Form
    from pydantic import BaseModel
    
    app = FastAPI()
    
    
    class FormData(BaseModel):
        username: str
        password: str
    
    
    @app.post("/login/")
    async def login(data: FormData = Form()):
        return data
    

**FastAPI** will **extract** the data for **each field** from the **form data** in the request and give you the Pydantic model you defined.

## Check the Docs[¶](#check-the-docs "Permanent link")

You can verify it in the docs UI at `/docs`:

![](/img/tutorial/request-form-models/image01.png)

## Forbid Extra Form Fields[¶](#forbid-extra-form-fields "Permanent link")

In some special use cases (probably not very common), you might want to **restrict** the form fields to only those declared in the Pydantic model. And **forbid** any **extra** fields.

Note

This is supported since FastAPI version `0.114.0`. ü§ì

You can use Pydantic's model configuration to `forbid` any `extra` fields:

Python 3.9+
    
    
    from typing import Annotated
    
    from fastapi import FastAPI, Form
    from pydantic import BaseModel
    
    app = FastAPI()
    
    
    class FormData(BaseModel):
        username: str
        password: str
        model_config = {"extra": "forbid"}
    
    
    @app.post("/login/")
    async def login(data: Annotated[FormData, Form()]):
        return data
    

ü§ì Other versions and variants

Python 3.9+ - non-Annotated

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import FastAPI, Form
    from pydantic import BaseModel
    
    app = FastAPI()
    
    
    class FormData(BaseModel):
        username: str
        password: str
        model_config = {"extra": "forbid"}
    
    
    @app.post("/login/")
    async def login(data: FormData = Form()):
        return data
    

If a client tries to send some extra data, they will receive an **error** response.

For example, if the client tries to send the form fields:

  * `username`: `Rick`
  * `password`: `Portal Gun`
  * `extra`: `Mr. Poopybutthole`

They will receive an error response telling them that the field `extra` is not allowed:
    
    
    {
        "detail": [
            {
                "type": "extra_forbidden",
                "loc": ["body", "extra"],
                "msg": "Extra inputs are not permitted",
                "input": "Mr. Poopybutthole"
            }
        ]
    }
    

## Summary[¶](#summary "Permanent link")

You can use Pydantic models to declare form fields in FastAPI. üòé

---

###### Request Files¶

# Request Files[¶](#request-files "Permanent link")

You can define files to be uploaded by the client using `File`.

Info

To receive uploaded files, first install [`python-multipart`](https://github.com/Kludex/python-multipart).

Make sure you create a [virtual environment](../../virtual-environments/), activate it, and then install it, for example:
    
    
    $ pip install python-multipart
    

This is because uploaded files are sent as "form data".

## Import `File`[¶](#import-file "Permanent link")

Import `File` and `UploadFile` from `fastapi`:

Python 3.9+
    
    
    from typing import Annotated
    
    from fastapi import FastAPI, File, UploadFile
    
    app = FastAPI()
    
    
    @app.post("/files/")
    async def create_file(file: Annotated[bytes, File()]):
        return {"file_size": len(file)}
    
    
    @app.post("/uploadfile/")
    async def create_upload_file(file: UploadFile):
        return {"filename": file.filename}
    

ü§ì Other versions and variants

Python 3.9+ - non-Annotated

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import FastAPI, File, UploadFile
    
    app = FastAPI()
    
    
    @app.post("/files/")
    async def create_file(file: bytes = File()):
        return {"file_size": len(file)}
    
    
    @app.post("/uploadfile/")
    async def create_upload_file(file: UploadFile):
        return {"filename": file.filename}
    

## Define `File` Parameters[¶](#define-file-parameters "Permanent link")

Create file parameters the same way you would for `Body` or `Form`:

Python 3.9+
    
    
    from typing import Annotated
    
    from fastapi import FastAPI, File, UploadFile
    
    app = FastAPI()
    
    
    @app.post("/files/")
    async def create_file(file: Annotated[bytes, File()]):
        return {"file_size": len(file)}
    
    
    @app.post("/uploadfile/")
    async def create_upload_file(file: UploadFile):
        return {"filename": file.filename}
    

ü§ì Other versions and variants

Python 3.9+ - non-Annotated

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import FastAPI, File, UploadFile
    
    app = FastAPI()
    
    
    @app.post("/files/")
    async def create_file(file: bytes = File()):
        return {"file_size": len(file)}
    
    
    @app.post("/uploadfile/")
    async def create_upload_file(file: UploadFile):
        return {"filename": file.filename}
    

Info

`File` is a class that inherits directly from `Form`.

But remember that when you import `Query`, `Path`, `File` and others from `fastapi`, those are actually functions that return special classes.

Tip

To declare File bodies, you need to use `File`, because otherwise the parameters would be interpreted as query parameters or body (JSON) parameters.

The files will be uploaded as "form data".

If you declare the type of your _path operation function_ parameter as `bytes`, **FastAPI** will read the file for you and you will receive the contents as `bytes`.

Keep in mind that this means that the whole contents will be stored in memory. This will work well for small files.

But there are several cases in which you might benefit from using `UploadFile`.

## File Parameters with `UploadFile`[¶](#file-parameters-with-uploadfile "Permanent link")

Define a file parameter with a type of `UploadFile`:

Python 3.9+
    
    
    from typing import Annotated
    
    from fastapi import FastAPI, File, UploadFile
    
    app = FastAPI()
    
    
    @app.post("/files/")
    async def create_file(file: Annotated[bytes, File()]):
        return {"file_size": len(file)}
    
    
    @app.post("/uploadfile/")
    async def create_upload_file(file: UploadFile):
        return {"filename": file.filename}
    

ü§ì Other versions and variants

Python 3.9+ - non-Annotated

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import FastAPI, File, UploadFile
    
    app = FastAPI()
    
    
    @app.post("/files/")
    async def create_file(file: bytes = File()):
        return {"file_size": len(file)}
    
    
    @app.post("/uploadfile/")
    async def create_upload_file(file: UploadFile):
        return {"filename": file.filename}
    

Using `UploadFile` has several advantages over `bytes`:

  * You don't have to use `File()` in the default value of the parameter.
  * It uses a "spooled" file:
    * A file stored in memory up to a maximum size limit, and after passing this limit it will be stored in disk.
  * This means that it will work well for large files like images, videos, large binaries, etc. without consuming all the memory.
  * You can get metadata from the uploaded file.
  * It has a [file-like](https://docs.python.org/3/glossary.html#term-file-like-object) `async` interface.
  * It exposes an actual Python [`SpooledTemporaryFile`](https://docs.python.org/3/library/tempfile.html#tempfile.SpooledTemporaryFile) object that you can pass directly to other libraries that expect a file-like object.

### `UploadFile`[¶](#uploadfile "Permanent link")

`UploadFile` has the following attributes:

  * `filename`: A `str` with the original file name that was uploaded (e.g. `myimage.jpg`).
  * `content_type`: A `str` with the content type (MIME type / media type) (e.g. `image/jpeg`).
  * `file`: A [`SpooledTemporaryFile`](https://docs.python.org/3/library/tempfile.html#tempfile.SpooledTemporaryFile) (a [file-like](https://docs.python.org/3/glossary.html#term-file-like-object) object). This is the actual Python file object that you can pass directly to other functions or libraries that expect a "file-like" object.

`UploadFile` has the following `async` methods. They all call the corresponding file methods underneath (using the internal `SpooledTemporaryFile`).

  * `write(data)`: Writes `data` (`str` or `bytes`) to the file.
  * `read(size)`: Reads `size` (`int`) bytes/characters of the file.
  * `seek(offset)`: Goes to the byte position `offset` (`int`) in the file.
    * E.g., `await myfile.seek(0)` would go to the start of the file.
    * This is especially useful if you run `await myfile.read()` once and then need to read the contents again.
  * `close()`: Closes the file.

As all these methods are `async` methods, you need to "await" them.

For example, inside of an `async` _path operation function_ you can get the contents with:
    
    
    contents = await myfile.read()
    

If you are inside of a normal `def` _path operation function_ , you can access the `UploadFile.file` directly, for example:
    
    
    contents = myfile.file.read()
    

`async` Technical Details

When you use the `async` methods, **FastAPI** runs the file methods in a threadpool and awaits for them.

Starlette Technical Details

**FastAPI** 's `UploadFile` inherits directly from **Starlette** 's `UploadFile`, but adds some necessary parts to make it compatible with **Pydantic** and the other parts of FastAPI.

## What is "Form Data"[¶](#what-is-form-data "Permanent link")

The way HTML forms (`<form></form>`) sends the data to the server normally uses a "special" encoding for that data, it's different from JSON.

**FastAPI** will make sure to read that data from the right place instead of JSON.

Technical Details

Data from forms is normally encoded using the "media type" `application/x-www-form-urlencoded` when it doesn't include files.

But when the form includes files, it is encoded as `multipart/form-data`. If you use `File`, **FastAPI** will know it has to get the files from the correct part of the body.

If you want to read more about these encodings and form fields, head to the [MDN web docs for `POST`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/POST).

Warning

You can declare multiple `File` and `Form` parameters in a _path operation_ , but you can't also declare `Body` fields that you expect to receive as JSON, as the request will have the body encoded using `multipart/form-data` instead of `application/json`.

This is not a limitation of **FastAPI** , it's part of the HTTP protocol.

## Optional File Upload[¶](#optional-file-upload "Permanent link")

You can make a file optional by using standard type annotations and setting a default value of `None`:

Python 3.10+
    
    
    from typing import Annotated
    
    from fastapi import FastAPI, File, UploadFile
    
    app = FastAPI()
    
    
    @app.post("/files/")
    async def create_file(file: Annotated[bytes | None, File()] = None):
        if not file:
            return {"message": "No file sent"}
        else:
            return {"file_size": len(file)}
    
    
    @app.post("/uploadfile/")
    async def create_upload_file(file: UploadFile | None = None):
        if not file:
            return {"message": "No upload file sent"}
        else:
            return {"filename": file.filename}
    

ü§ì Other versions and variants

Python 3.9+Python 3.10+ - non-AnnotatedPython 3.9+ - non-Annotated
    
    
    from typing import Annotated, Union
    
    from fastapi import FastAPI, File, UploadFile
    
    app = FastAPI()
    
    
    @app.post("/files/")
    async def create_file(file: Annotated[Union[bytes, None], File()] = None):
        if not file:
            return {"message": "No file sent"}
        else:
            return {"file_size": len(file)}
    
    
    @app.post("/uploadfile/")
    async def create_upload_file(file: Union[UploadFile, None] = None):
        if not file:
            return {"message": "No upload file sent"}
        else:
            return {"filename": file.filename}
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import FastAPI, File, UploadFile
    
    app = FastAPI()
    
    
    @app.post("/files/")
    async def create_file(file: bytes | None = File(default=None)):
        if not file:
            return {"message": "No file sent"}
        else:
            return {"file_size": len(file)}
    
    
    @app.post("/uploadfile/")
    async def create_upload_file(file: UploadFile | None = None):
        if not file:
            return {"message": "No upload file sent"}
        else:
            return {"filename": file.filename}
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from typing import Union
    
    from fastapi import FastAPI, File, UploadFile
    
    app = FastAPI()
    
    
    @app.post("/files/")
    async def create_file(file: Union[bytes, None] = File(default=None)):
        if not file:
            return {"message": "No file sent"}
        else:
            return {"file_size": len(file)}
    
    
    @app.post("/uploadfile/")
    async def create_upload_file(file: Union[UploadFile, None] = None):
        if not file:
            return {"message": "No upload file sent"}
        else:
            return {"filename": file.filename}
    

## `UploadFile` with Additional Metadata[¶](#uploadfile-with-additional-metadata "Permanent link")

You can also use `File()` with `UploadFile`, for example, to set additional metadata:

Python 3.9+
    
    
    from typing import Annotated
    
    from fastapi import FastAPI, File, UploadFile
    
    app = FastAPI()
    
    
    @app.post("/files/")
    async def create_file(file: Annotated[bytes, File(description="A file read as bytes")]):
        return {"file_size": len(file)}
    
    
    @app.post("/uploadfile/")
    async def create_upload_file(
        file: Annotated[UploadFile, File(description="A file read as UploadFile")],
    ):
        return {"filename": file.filename}
    

ü§ì Other versions and variants

Python 3.9+ - non-Annotated

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import FastAPI, File, UploadFile
    
    app = FastAPI()
    
    
    @app.post("/files/")
    async def create_file(file: bytes = File(description="A file read as bytes")):
        return {"file_size": len(file)}
    
    
    @app.post("/uploadfile/")
    async def create_upload_file(
        file: UploadFile = File(description="A file read as UploadFile"),
    ):
        return {"filename": file.filename}
    

## Multiple File Uploads[¶](#multiple-file-uploads "Permanent link")

It's possible to upload several files at the same time.

They would be associated to the same "form field" sent using "form data".

To use that, declare a list of `bytes` or `UploadFile`:

Python 3.9+
    
    
    from typing import Annotated
    
    from fastapi import FastAPI, File, UploadFile
    from fastapi.responses import HTMLResponse
    
    app = FastAPI()
    
    
    @app.post("/files/")
    async def create_files(files: Annotated[list[bytes], File()]):
        return {"file_sizes": [len(file) for file in files]}
    
    
    @app.post("/uploadfiles/")
    async def create_upload_files(files: list[UploadFile]):
        return {"filenames": [file.filename for file in files]}
    
    
    @app.get("/")
    async def main():
        content = """
    <body>
    <form action="/files/" enctype="multipart/form-data" method="post">
    <input name="files" type="file" multiple>
    <input type="submit">
    </form>
    <form action="/uploadfiles/" enctype="multipart/form-data" method="post">
    <input name="files" type="file" multiple>
    <input type="submit">
    </form>
    </body>
        """
        return HTMLResponse(content=content)
    

ü§ì Other versions and variants

Python 3.9+ - non-Annotated

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import FastAPI, File, UploadFile
    from fastapi.responses import HTMLResponse
    
    app = FastAPI()
    
    
    @app.post("/files/")
    async def create_files(files: list[bytes] = File()):
        return {"file_sizes": [len(file) for file in files]}
    
    
    @app.post("/uploadfiles/")
    async def create_upload_files(files: list[UploadFile]):
        return {"filenames": [file.filename for file in files]}
    
    
    @app.get("/")
    async def main():
        content = """
    <body>
    <form action="/files/" enctype="multipart/form-data" method="post">
    <input name="files" type="file" multiple>
    <input type="submit">
    </form>
    <form action="/uploadfiles/" enctype="multipart/form-data" method="post">
    <input name="files" type="file" multiple>
    <input type="submit">
    </form>
    </body>
        """
        return HTMLResponse(content=content)
    

You will receive, as declared, a `list` of `bytes` or `UploadFile`s.

Technical Details

You could also use `from starlette.responses import HTMLResponse`.

**FastAPI** provides the same `starlette.responses` as `fastapi.responses` just as a convenience for you, the developer. But most of the available responses come directly from Starlette.

### Multiple File Uploads with Additional Metadata[¶](#multiple-file-uploads-with-additional-metadata "Permanent link")

And the same way as before, you can use `File()` to set additional parameters, even for `UploadFile`:

Python 3.9+
    
    
    from typing import Annotated
    
    from fastapi import FastAPI, File, UploadFile
    from fastapi.responses import HTMLResponse
    
    app = FastAPI()
    
    
    @app.post("/files/")
    async def create_files(
        files: Annotated[list[bytes], File(description="Multiple files as bytes")],
    ):
        return {"file_sizes": [len(file) for file in files]}
    
    
    @app.post("/uploadfiles/")
    async def create_upload_files(
        files: Annotated[
            list[UploadFile], File(description="Multiple files as UploadFile")
        ],
    ):
        return {"filenames": [file.filename for file in files]}
    
    
    @app.get("/")
    async def main():
        content = """
    <body>
    <form action="/files/" enctype="multipart/form-data" method="post">
    <input name="files" type="file" multiple>
    <input type="submit">
    </form>
    <form action="/uploadfiles/" enctype="multipart/form-data" method="post">
    <input name="files" type="file" multiple>
    <input type="submit">
    </form>
    </body>
        """
        return HTMLResponse(content=content)
    

ü§ì Other versions and variants

Python 3.9+ - non-Annotated

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import FastAPI, File, UploadFile
    from fastapi.responses import HTMLResponse
    
    app = FastAPI()
    
    
    @app.post("/files/")
    async def create_files(
        files: list[bytes] = File(description="Multiple files as bytes"),
    ):
        return {"file_sizes": [len(file) for file in files]}
    
    
    @app.post("/uploadfiles/")
    async def create_upload_files(
        files: list[UploadFile] = File(description="Multiple files as UploadFile"),
    ):
        return {"filenames": [file.filename for file in files]}
    
    
    @app.get("/")
    async def main():
        content = """
    <body>
    <form action="/files/" enctype="multipart/form-data" method="post">
    <input name="files" type="file" multiple>
    <input type="submit">
    </form>
    <form action="/uploadfiles/" enctype="multipart/form-data" method="post">
    <input name="files" type="file" multiple>
    <input type="submit">
    </form>
    </body>
        """
        return HTMLResponse(content=content)
    

## Recap[¶](#recap "Permanent link")

Use `File`, `bytes`, and `UploadFile` to declare files to be uploaded in the request, sent as form data.
  *[MDN]: Mozilla Developer Network

---

###### Request Forms and Files¶

# Request Forms and Files[¶](#request-forms-and-files "Permanent link")

You can define files and form fields at the same time using `File` and `Form`.

Info

To receive uploaded files and/or form data, first install [`python-multipart`](https://github.com/Kludex/python-multipart).

Make sure you create a [virtual environment](../../virtual-environments/), activate it, and then install it, for example:
    
    
    $ pip install python-multipart
    

## Import `File` and `Form`[¶](#import-file-and-form "Permanent link")

Python 3.9+
    
    
    from typing import Annotated
    
    from fastapi import FastAPI, File, Form, UploadFile
    
    app = FastAPI()
    
    
    @app.post("/files/")
    async def create_file(
        file: Annotated[bytes, File()],
        fileb: Annotated[UploadFile, File()],
        token: Annotated[str, Form()],
    ):
        return {
            "file_size": len(file),
            "token": token,
            "fileb_content_type": fileb.content_type,
        }
    

ü§ì Other versions and variants

Python 3.9+ - non-Annotated

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import FastAPI, File, Form, UploadFile
    
    app = FastAPI()
    
    
    @app.post("/files/")
    async def create_file(
        file: bytes = File(), fileb: UploadFile = File(), token: str = Form()
    ):
        return {
            "file_size": len(file),
            "token": token,
            "fileb_content_type": fileb.content_type,
        }
    

## Define `File` and `Form` parameters[¶](#define-file-and-form-parameters "Permanent link")

Create file and form parameters the same way you would for `Body` or `Query`:

Python 3.9+
    
    
    from typing import Annotated
    
    from fastapi import FastAPI, File, Form, UploadFile
    
    app = FastAPI()
    
    
    @app.post("/files/")
    async def create_file(
        file: Annotated[bytes, File()],
        fileb: Annotated[UploadFile, File()],
        token: Annotated[str, Form()],
    ):
        return {
            "file_size": len(file),
            "token": token,
            "fileb_content_type": fileb.content_type,
        }
    

ü§ì Other versions and variants

Python 3.9+ - non-Annotated

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import FastAPI, File, Form, UploadFile
    
    app = FastAPI()
    
    
    @app.post("/files/")
    async def create_file(
        file: bytes = File(), fileb: UploadFile = File(), token: str = Form()
    ):
        return {
            "file_size": len(file),
            "token": token,
            "fileb_content_type": fileb.content_type,
        }
    

The files and form fields will be uploaded as form data and you will receive the files and form fields.

And you can declare some of the files as `bytes` and some as `UploadFile`.

Warning

You can declare multiple `File` and `Form` parameters in a _path operation_ , but you can't also declare `Body` fields that you expect to receive as JSON, as the request will have the body encoded using `multipart/form-data` instead of `application/json`.

This is not a limitation of **FastAPI** , it's part of the HTTP protocol.

## Recap[¶](#recap "Permanent link")

Use `File` and `Form` together when you need to receive data and files in the same request.

---

###### Handling Errors¶

# Handling Errors[¶](#handling-errors "Permanent link")

There are many situations in which you need to notify an error to a client that is using your API.

This client could be a browser with a frontend, a code from someone else, an IoT device, etc.

You could need to tell the client that:

  * The client doesn't have enough privileges for that operation.
  * The client doesn't have access to that resource.
  * The item the client was trying to access doesn't exist.
  * etc.

In these cases, you would normally return an **HTTP status code** in the range of **400** (from 400 to 499).

This is similar to the 200 HTTP status codes (from 200 to 299). Those "200" status codes mean that somehow there was a "success" in the request.

The status codes in the 400 range mean that there was an error from the client.

Remember all those **"404 Not Found"** errors (and jokes)?

## Use `HTTPException`[¶](#use-httpexception "Permanent link")

To return HTTP responses with errors to the client you use `HTTPException`.

### Import `HTTPException`[¶](#import-httpexception "Permanent link")

Python 3.9+
    
    
    from fastapi import FastAPI, HTTPException
    
    app = FastAPI()
    
    items = {"foo": "The Foo Wrestlers"}
    
    
    @app.get("/items/{item_id}")
    async def read_item(item_id: str):
        if item_id not in items:
            raise HTTPException(status_code=404, detail="Item not found")
        return {"item": items[item_id]}
    

### Raise an `HTTPException` in your code[¶](#raise-an-httpexception-in-your-code "Permanent link")

`HTTPException` is a normal Python exception with additional data relevant for APIs.

Because it's a Python exception, you don't `return` it, you `raise` it.

This also means that if you are inside a utility function that you are calling inside of your _path operation function_ , and you raise the `HTTPException` from inside of that utility function, it won't run the rest of the code in the _path operation function_ , it will terminate that request right away and send the HTTP error from the `HTTPException` to the client.

The benefit of raising an exception over returning a value will be more evident in the section about Dependencies and Security.

In this example, when the client requests an item by an ID that doesn't exist, raise an exception with a status code of `404`:

Python 3.9+
    
    
    from fastapi import FastAPI, HTTPException
    
    app = FastAPI()
    
    items = {"foo": "The Foo Wrestlers"}
    
    
    @app.get("/items/{item_id}")
    async def read_item(item_id: str):
        if item_id not in items:
            raise HTTPException(status_code=404, detail="Item not found")
        return {"item": items[item_id]}
    

### The resulting response[¶](#the-resulting-response "Permanent link")

If the client requests `http://example.com/items/foo` (an `item_id` `"foo"`), that client will receive an HTTP status code of 200, and a JSON response of:
    
    
    {
      "item": "The Foo Wrestlers"
    }
    

But if the client requests `http://example.com/items/bar` (a non-existent `item_id` `"bar"`), that client will receive an HTTP status code of 404 (the "not found" error), and a JSON response of:
    
    
    {
      "detail": "Item not found"
    }
    

Tip

When raising an `HTTPException`, you can pass any value that can be converted to JSON as the parameter `detail`, not only `str`.

You could pass a `dict`, a `list`, etc.

They are handled automatically by **FastAPI** and converted to JSON.

## Add custom headers[¶](#add-custom-headers "Permanent link")

There are some situations in where it's useful to be able to add custom headers to the HTTP error. For example, for some types of security.

You probably won't need to use it directly in your code.

But in case you needed it for an advanced scenario, you can add custom headers:

Python 3.9+
    
    
    from fastapi import FastAPI, HTTPException
    
    app = FastAPI()
    
    items = {"foo": "The Foo Wrestlers"}
    
    
    @app.get("/items-header/{item_id}")
    async def read_item_header(item_id: str):
        if item_id not in items:
            raise HTTPException(
                status_code=404,
                detail="Item not found",
                headers={"X-Error": "There goes my error"},
            )
        return {"item": items[item_id]}
    

## Install custom exception handlers[¶](#install-custom-exception-handlers "Permanent link")

You can add custom exception handlers with [the same exception utilities from Starlette](https://www.starlette.dev/exceptions/).

Let's say you have a custom exception `UnicornException` that you (or a library you use) might `raise`.

And you want to handle this exception globally with FastAPI.

You could add a custom exception handler with `@app.exception_handler()`:

Python 3.9+
    
    
    from fastapi import FastAPI, Request
    from fastapi.responses import JSONResponse
    
    
    class UnicornException(Exception):
        def __init__(self, name: str):
            self.name = name
    
    
    app = FastAPI()
    
    
    @app.exception_handler(UnicornException)
    async def unicorn_exception_handler(request: Request, exc: UnicornException):
        return JSONResponse(
            status_code=418,
            content={"message": f"Oops! {exc.name} did something. There goes a rainbow..."},
        )
    
    
    @app.get("/unicorns/{name}")
    async def read_unicorn(name: str):
        if name == "yolo":
            raise UnicornException(name=name)
        return {"unicorn_name": name}
    

Here, if you request `/unicorns/yolo`, the _path operation_ will `raise` a `UnicornException`.

But it will be handled by the `unicorn_exception_handler`.

So, you will receive a clean error, with an HTTP status code of `418` and a JSON content of:
    
    
    {"message": "Oops! yolo did something. There goes a rainbow..."}
    

Technical Details

You could also use `from starlette.requests import Request` and `from starlette.responses import JSONResponse`.

**FastAPI** provides the same `starlette.responses` as `fastapi.responses` just as a convenience for you, the developer. But most of the available responses come directly from Starlette. The same with `Request`.

## Override the default exception handlers[¶](#override-the-default-exception-handlers "Permanent link")

**FastAPI** has some default exception handlers.

These handlers are in charge of returning the default JSON responses when you `raise` an `HTTPException` and when the request has invalid data.

You can override these exception handlers with your own.

### Override request validation exceptions[¶](#override-request-validation-exceptions "Permanent link")

When a request contains invalid data, **FastAPI** internally raises a `RequestValidationError`.

And it also includes a default exception handler for it.

To override it, import the `RequestValidationError` and use it with `@app.exception_handler(RequestValidationError)` to decorate the exception handler.

The exception handler will receive a `Request` and the exception.

Python 3.9+
    
    
    from fastapi import FastAPI, HTTPException
    from fastapi.exceptions import RequestValidationError
    from fastapi.responses import PlainTextResponse
    from starlette.exceptions import HTTPException as StarletteHTTPException
    
    app = FastAPI()
    
    
    @app.exception_handler(StarletteHTTPException)
    async def http_exception_handler(request, exc):
        return PlainTextResponse(str(exc.detail), status_code=exc.status_code)
    
    
    @app.exception_handler(RequestValidationError)
    async def validation_exception_handler(request, exc: RequestValidationError):
        message = "Validation errors:"
        for error in exc.errors():
            message += f"\nField: {error['loc']}, Error: {error['msg']}"
        return PlainTextResponse(message, status_code=400)
    
    
    @app.get("/items/{item_id}")
    async def read_item(item_id: int):
        if item_id == 3:
            raise HTTPException(status_code=418, detail="Nope! I don't like 3.")
        return {"item_id": item_id}
    

Now, if you go to `/items/foo`, instead of getting the default JSON error with:
    
    
    {
        "detail": [
            {
                "loc": [
                    "path",
                    "item_id"
                ],
                "msg": "value is not a valid integer",
                "type": "type_error.integer"
            }
        ]
    }
    

you will get a text version, with:
    
    
    Validation errors:
    Field: ('path', 'item_id'), Error: Input should be a valid integer, unable to parse string as an integer
    

### Override the `HTTPException` error handler[¶](#override-the-httpexception-error-handler "Permanent link")

The same way, you can override the `HTTPException` handler.

For example, you could want to return a plain text response instead of JSON for these errors:

Python 3.9+
    
    
    from fastapi import FastAPI, HTTPException
    from fastapi.exceptions import RequestValidationError
    from fastapi.responses import PlainTextResponse
    from starlette.exceptions import HTTPException as StarletteHTTPException
    
    app = FastAPI()
    
    
    @app.exception_handler(StarletteHTTPException)
    async def http_exception_handler(request, exc):
        return PlainTextResponse(str(exc.detail), status_code=exc.status_code)
    
    
    @app.exception_handler(RequestValidationError)
    async def validation_exception_handler(request, exc: RequestValidationError):
        message = "Validation errors:"
        for error in exc.errors():
            message += f"\nField: {error['loc']}, Error: {error['msg']}"
        return PlainTextResponse(message, status_code=400)
    
    
    @app.get("/items/{item_id}")
    async def read_item(item_id: int):
        if item_id == 3:
            raise HTTPException(status_code=418, detail="Nope! I don't like 3.")
        return {"item_id": item_id}
    

Technical Details

You could also use `from starlette.responses import PlainTextResponse`.

**FastAPI** provides the same `starlette.responses` as `fastapi.responses` just as a convenience for you, the developer. But most of the available responses come directly from Starlette.

Warning

Have in mind that the `RequestValidationError` contains the information of the file name and line where the validation error happens so that you can show it in your logs with the relevant information if you want to.

But that means that if you just convert it to a string and return that information directly, you could be leaking a bit of information about your system, that's why here the code extracts and shows each error independently.

### Use the `RequestValidationError` body[¶](#use-the-requestvalidationerror-body "Permanent link")

The `RequestValidationError` contains the `body` it received with invalid data.

You could use it while developing your app to log the body and debug it, return it to the user, etc.

Python 3.9+
    
    
    from fastapi import FastAPI, Request
    from fastapi.encoders import jsonable_encoder
    from fastapi.exceptions import RequestValidationError
    from fastapi.responses import JSONResponse
    from pydantic import BaseModel
    
    app = FastAPI()
    
    
    @app.exception_handler(RequestValidationError)
    async def validation_exception_handler(request: Request, exc: RequestValidationError):
        return JSONResponse(
            status_code=422,
            content=jsonable_encoder({"detail": exc.errors(), "body": exc.body}),
        )
    
    
    class Item(BaseModel):
        title: str
        size: int
    
    
    @app.post("/items/")
    async def create_item(item: Item):
        return item
    

Now try sending an invalid item like:
    
    
    {
      "title": "towel",
      "size": "XL"
    }
    

You will receive a response telling you that the data is invalid containing the received body:
    
    
    {
      "detail": [
        {
          "loc": [
            "body",
            "size"
          ],
          "msg": "value is not a valid integer",
          "type": "type_error.integer"
        }
      ],
      "body": {
        "title": "towel",
        "size": "XL"
      }
    }
    

#### FastAPI's `HTTPException` vs Starlette's `HTTPException`[¶](#fastapis-httpexception-vs-starlettes-httpexception "Permanent link")

**FastAPI** has its own `HTTPException`.

And **FastAPI** 's `HTTPException` error class inherits from Starlette's `HTTPException` error class.

The only difference is that **FastAPI** 's `HTTPException` accepts any JSON-able data for the `detail` field, while Starlette's `HTTPException` only accepts strings for it.

So, you can keep raising **FastAPI** 's `HTTPException` as normally in your code.

But when you register an exception handler, you should register it for Starlette's `HTTPException`.

This way, if any part of Starlette's internal code, or a Starlette extension or plug-in, raises a Starlette `HTTPException`, your handler will be able to catch and handle it.

In this example, to be able to have both `HTTPException`s in the same code, Starlette's exceptions is renamed to `StarletteHTTPException`:
    
    
    from starlette.exceptions import HTTPException as StarletteHTTPException
    

### Reuse **FastAPI** 's exception handlers[¶](#reuse-fastapis-exception-handlers "Permanent link")

If you want to use the exception along with the same default exception handlers from **FastAPI** , you can import and reuse the default exception handlers from `fastapi.exception_handlers`:

Python 3.9+
    
    
    from fastapi import FastAPI, HTTPException
    from fastapi.exception_handlers import (
        http_exception_handler,
        request_validation_exception_handler,
    )
    from fastapi.exceptions import RequestValidationError
    from starlette.exceptions import HTTPException as StarletteHTTPException
    
    app = FastAPI()
    
    
    @app.exception_handler(StarletteHTTPException)
    async def custom_http_exception_handler(request, exc):
        print(f"OMG! An HTTP error!: {repr(exc)}")
        return await http_exception_handler(request, exc)
    
    
    @app.exception_handler(RequestValidationError)
    async def validation_exception_handler(request, exc):
        print(f"OMG! The client sent invalid data!: {exc}")
        return await request_validation_exception_handler(request, exc)
    
    
    @app.get("/items/{item_id}")
    async def read_item(item_id: int):
        if item_id == 3:
            raise HTTPException(status_code=418, detail="Nope! I don't like 3.")
        return {"item_id": item_id}
    

In this example you are just printing the error with a very expressive message, but you get the idea. You can use the exception and then just reuse the default exception handlers.

---

###### Path Operation Configuration¶

# Path Operation Configuration[¶](#path-operation-configuration "Permanent link")

There are several parameters that you can pass to your _path operation decorator_ to configure it.

Warning

Notice that these parameters are passed directly to the _path operation decorator_ , not to your _path operation function_.

## Response Status Code[¶](#response-status-code "Permanent link")

You can define the (HTTP) `status_code` to be used in the response of your _path operation_.

You can pass directly the `int` code, like `404`.

But if you don't remember what each number code is for, you can use the shortcut constants in `status`:

Python 3.10+
    
    
    from fastapi import FastAPI, status
    from pydantic import BaseModel
    
    app = FastAPI()
    
    
    class Item(BaseModel):
        name: str
        description: str | None = None
        price: float
        tax: float | None = None
        tags: set[str] = set()
    
    
    @app.post("/items/", status_code=status.HTTP_201_CREATED)
    async def create_item(item: Item) -> Item:
        return item
    

ü§ì Other versions and variants

Python 3.9+
    
    
    from typing import Union
    
    from fastapi import FastAPI, status
    from pydantic import BaseModel
    
    app = FastAPI()
    
    
    class Item(BaseModel):
        name: str
        description: Union[str, None] = None
        price: float
        tax: Union[float, None] = None
        tags: set[str] = set()
    
    
    @app.post("/items/", status_code=status.HTTP_201_CREATED)
    async def create_item(item: Item) -> Item:
        return item
    

That status code will be used in the response and will be added to the OpenAPI schema.

Technical Details

You could also use `from starlette import status`.

**FastAPI** provides the same `starlette.status` as `fastapi.status` just as a convenience for you, the developer. But it comes directly from Starlette.

## Tags[¶](#tags "Permanent link")

You can add tags to your _path operation_ , pass the parameter `tags` with a `list` of `str` (commonly just one `str`):

Python 3.10+
    
    
    from fastapi import FastAPI
    from pydantic import BaseModel
    
    app = FastAPI()
    
    
    class Item(BaseModel):
        name: str
        description: str | None = None
        price: float
        tax: float | None = None
        tags: set[str] = set()
    
    
    @app.post("/items/", tags=["items"])
    async def create_item(item: Item) -> Item:
        return item
    
    
    @app.get("/items/", tags=["items"])
    async def read_items():
        return [{"name": "Foo", "price": 42}]
    
    
    @app.get("/users/", tags=["users"])
    async def read_users():
        return [{"username": "johndoe"}]
    

ü§ì Other versions and variants

Python 3.9+
    
    
    from typing import Union
    
    from fastapi import FastAPI
    from pydantic import BaseModel
    
    app = FastAPI()
    
    
    class Item(BaseModel):
        name: str
        description: Union[str, None] = None
        price: float
        tax: Union[float, None] = None
        tags: set[str] = set()
    
    
    @app.post("/items/", tags=["items"])
    async def create_item(item: Item) -> Item:
        return item
    
    
    @app.get("/items/", tags=["items"])
    async def read_items():
        return [{"name": "Foo", "price": 42}]
    
    
    @app.get("/users/", tags=["users"])
    async def read_users():
        return [{"username": "johndoe"}]
    

They will be added to the OpenAPI schema and used by the automatic documentation interfaces:

![](/img/tutorial/path-operation-configuration/image01.png)

### Tags with Enums[¶](#tags-with-enums "Permanent link")

If you have a big application, you might end up accumulating **several tags** , and you would want to make sure you always use the **same tag** for related _path operations_.

In these cases, it could make sense to store the tags in an `Enum`.

**FastAPI** supports that the same way as with plain strings:

Python 3.9+
    
    
    from enum import Enum
    
    from fastapi import FastAPI
    
    app = FastAPI()
    
    
    class Tags(Enum):
        items = "items"
        users = "users"
    
    
    @app.get("/items/", tags=[Tags.items])
    async def get_items():
        return ["Portal gun", "Plumbus"]
    
    
    @app.get("/users/", tags=[Tags.users])
    async def read_users():
        return ["Rick", "Morty"]
    

## Summary and description[¶](#summary-and-description "Permanent link")

You can add a `summary` and `description`:

Python 3.10+
    
    
    from fastapi import FastAPI
    from pydantic import BaseModel
    
    app = FastAPI()
    
    
    class Item(BaseModel):
        name: str
        description: str | None = None
        price: float
        tax: float | None = None
        tags: set[str] = set()
    
    
    @app.post(
        "/items/",
        summary="Create an item",
        description="Create an item with all the information, name, description, price, tax and a set of unique tags",
    )
    async def create_item(item: Item) -> Item:
        return item
    

ü§ì Other versions and variants

Python 3.9+
    
    
    from typing import Union
    
    from fastapi import FastAPI
    from pydantic import BaseModel
    
    app = FastAPI()
    
    
    class Item(BaseModel):
        name: str
        description: Union[str, None] = None
        price: float
        tax: Union[float, None] = None
        tags: set[str] = set()
    
    
    @app.post(
        "/items/",
        summary="Create an item",
        description="Create an item with all the information, name, description, price, tax and a set of unique tags",
    )
    async def create_item(item: Item) -> Item:
        return item
    

## Description from docstring[¶](#description-from-docstring "Permanent link")

As descriptions tend to be long and cover multiple lines, you can declare the _path operation_ description in the function docstring and **FastAPI** will read it from there.

You can write [Markdown](https://en.wikipedia.org/wiki/Markdown) in the docstring, it will be interpreted and displayed correctly (taking into account docstring indentation).

Python 3.10+
    
    
    from fastapi import FastAPI
    from pydantic import BaseModel
    
    app = FastAPI()
    
    
    class Item(BaseModel):
        name: str
        description: str | None = None
        price: float
        tax: float | None = None
        tags: set[str] = set()
    
    
    @app.post("/items/", summary="Create an item")
    async def create_item(item: Item) -> Item:
        """
        Create an item with all the information:
    
        - **name**: each item must have a name
        - **description**: a long description
        - **price**: required
        - **tax**: if the item doesn't have tax, you can omit this
        - **tags**: a set of unique tag strings for this item
        """
        return item
    

ü§ì Other versions and variants

Python 3.9+
    
    
    from typing import Union
    
    from fastapi import FastAPI
    from pydantic import BaseModel
    
    app = FastAPI()
    
    
    class Item(BaseModel):
        name: str
        description: Union[str, None] = None
        price: float
        tax: Union[float, None] = None
        tags: set[str] = set()
    
    
    @app.post("/items/", summary="Create an item")
    async def create_item(item: Item) -> Item:
        """
        Create an item with all the information:
    
        - **name**: each item must have a name
        - **description**: a long description
        - **price**: required
        - **tax**: if the item doesn't have tax, you can omit this
        - **tags**: a set of unique tag strings for this item
        """
        return item
    

It will be used in the interactive docs:

![](/img/tutorial/path-operation-configuration/image02.png)

## Response description[¶](#response-description "Permanent link")

You can specify the response description with the parameter `response_description`:

Python 3.10+
    
    
    from fastapi import FastAPI
    from pydantic import BaseModel
    
    app = FastAPI()
    
    
    class Item(BaseModel):
        name: str
        description: str | None = None
        price: float
        tax: float | None = None
        tags: set[str] = set()
    
    
    @app.post(
        "/items/",
        summary="Create an item",
        response_description="The created item",
    )
    async def create_item(item: Item) -> Item:
        """
        Create an item with all the information:
    
        - **name**: each item must have a name
        - **description**: a long description
        - **price**: required
        - **tax**: if the item doesn't have tax, you can omit this
        - **tags**: a set of unique tag strings for this item
        """
        return item
    

ü§ì Other versions and variants

Python 3.9+
    
    
    from typing import Union
    
    from fastapi import FastAPI
    from pydantic import BaseModel
    
    app = FastAPI()
    
    
    class Item(BaseModel):
        name: str
        description: Union[str, None] = None
        price: float
        tax: Union[float, None] = None
        tags: set[str] = set()
    
    
    @app.post(
        "/items/",
        summary="Create an item",
        response_description="The created item",
    )
    async def create_item(item: Item) -> Item:
        """
        Create an item with all the information:
    
        - **name**: each item must have a name
        - **description**: a long description
        - **price**: required
        - **tax**: if the item doesn't have tax, you can omit this
        - **tags**: a set of unique tag strings for this item
        """
        return item
    

Info

Notice that `response_description` refers specifically to the response, the `description` refers to the _path operation_ in general.

Check

OpenAPI specifies that each _path operation_ requires a response description.

So, if you don't provide one, **FastAPI** will automatically generate one of "Successful response".

![](/img/tutorial/path-operation-configuration/image03.png)

## Deprecate a _path operation_[¶](#deprecate-a-path-operation "Permanent link")

If you need to mark a _path operation_ as deprecated, but without removing it, pass the parameter `deprecated`:

Python 3.9+
    
    
    from fastapi import FastAPI
    
    app = FastAPI()
    
    
    @app.get("/items/", tags=["items"])
    async def read_items():
        return [{"name": "Foo", "price": 42}]
    
    
    @app.get("/users/", tags=["users"])
    async def read_users():
        return [{"username": "johndoe"}]
    
    
    @app.get("/elements/", tags=["items"], deprecated=True)
    async def read_elements():
        return [{"item_id": "Foo"}]
    

It will be clearly marked as deprecated in the interactive docs:

![](/img/tutorial/path-operation-configuration/image04.png)

Check how deprecated and non-deprecated _path operations_ look like:

![](/img/tutorial/path-operation-configuration/image05.png)

## Recap[¶](#recap "Permanent link")

You can configure and add metadata for your _path operations_ easily by passing parameters to the _path operation decorators_.
  *[docstring]: a multi-line string as the first expression inside a function (not assigned to any variable) used for documentation
  *[deprecated]: obsolete, recommended not to use it

---

###### JSON Compatible Encoder¶

# JSON Compatible Encoder[¶](#json-compatible-encoder "Permanent link")

There are some cases where you might need to convert a data type (like a Pydantic model) to something compatible with JSON (like a `dict`, `list`, etc).

For example, if you need to store it in a database.

For that, **FastAPI** provides a `jsonable_encoder()` function.

## Using the `jsonable_encoder`[¶](#using-the-jsonable-encoder "Permanent link")

Let's imagine that you have a database `fake_db` that only receives JSON compatible data.

For example, it doesn't receive `datetime` objects, as those are not compatible with JSON.

So, a `datetime` object would have to be converted to a `str` containing the data in [ISO format](https://en.wikipedia.org/wiki/ISO_8601).

The same way, this database wouldn't receive a Pydantic model (an object with attributes), only a `dict`.

You can use `jsonable_encoder` for that.

It receives an object, like a Pydantic model, and returns a JSON compatible version:

Python 3.10+
    
    
    from datetime import datetime
    
    from fastapi import FastAPI
    from fastapi.encoders import jsonable_encoder
    from pydantic import BaseModel
    
    fake_db = {}
    
    
    class Item(BaseModel):
        title: str
        timestamp: datetime
        description: str | None = None
    
    
    app = FastAPI()
    
    
    @app.put("/items/{id}")
    def update_item(id: str, item: Item):
        json_compatible_item_data = jsonable_encoder(item)
        fake_db[id] = json_compatible_item_data
    

ü§ì Other versions and variants

Python 3.9+
    
    
    from datetime import datetime
    from typing import Union
    
    from fastapi import FastAPI
    from fastapi.encoders import jsonable_encoder
    from pydantic import BaseModel
    
    fake_db = {}
    
    
    class Item(BaseModel):
        title: str
        timestamp: datetime
        description: Union[str, None] = None
    
    
    app = FastAPI()
    
    
    @app.put("/items/{id}")
    def update_item(id: str, item: Item):
        json_compatible_item_data = jsonable_encoder(item)
        fake_db[id] = json_compatible_item_data
    

In this example, it would convert the Pydantic model to a `dict`, and the `datetime` to a `str`.

The result of calling it is something that can be encoded with the Python standard [`json.dumps()`](https://docs.python.org/3/library/json.html#json.dumps).

It doesn't return a large `str` containing the data in JSON format (as a string). It returns a Python standard data structure (e.g. a `dict`) with values and sub-values that are all compatible with JSON.

Note

`jsonable_encoder` is actually used by **FastAPI** internally to convert data. But it is useful in many other scenarios.

---

###### Body - Updates¶

# Body - Updates[¶](#body-updates "Permanent link")

## Update replacing with `PUT`[¶](#update-replacing-with-put "Permanent link")

To update an item you can use the [HTTP `PUT`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/PUT) operation.

You can use the `jsonable_encoder` to convert the input data to data that can be stored as JSON (e.g. with a NoSQL database). For example, converting `datetime` to `str`.

Python 3.10+
    
    
    from fastapi import FastAPI
    from fastapi.encoders import jsonable_encoder
    from pydantic import BaseModel
    
    app = FastAPI()
    
    
    class Item(BaseModel):
        name: str | None = None
        description: str | None = None
        price: float | None = None
        tax: float = 10.5
        tags: list[str] = []
    
    
    items = {
        "foo": {"name": "Foo", "price": 50.2},
        "bar": {"name": "Bar", "description": "The bartenders", "price": 62, "tax": 20.2},
        "baz": {"name": "Baz", "description": None, "price": 50.2, "tax": 10.5, "tags": []},
    }
    
    
    @app.get("/items/{item_id}", response_model=Item)
    async def read_item(item_id: str):
        return items[item_id]
    
    
    @app.put("/items/{item_id}", response_model=Item)
    async def update_item(item_id: str, item: Item):
        update_item_encoded = jsonable_encoder(item)
        items[item_id] = update_item_encoded
        return update_item_encoded
    

ü§ì Other versions and variants

Python 3.9+
    
    
    from typing import Union
    
    from fastapi import FastAPI
    from fastapi.encoders import jsonable_encoder
    from pydantic import BaseModel
    
    app = FastAPI()
    
    
    class Item(BaseModel):
        name: Union[str, None] = None
        description: Union[str, None] = None
        price: Union[float, None] = None
        tax: float = 10.5
        tags: list[str] = []
    
    
    items = {
        "foo": {"name": "Foo", "price": 50.2},
        "bar": {"name": "Bar", "description": "The bartenders", "price": 62, "tax": 20.2},
        "baz": {"name": "Baz", "description": None, "price": 50.2, "tax": 10.5, "tags": []},
    }
    
    
    @app.get("/items/{item_id}", response_model=Item)
    async def read_item(item_id: str):
        return items[item_id]
    
    
    @app.put("/items/{item_id}", response_model=Item)
    async def update_item(item_id: str, item: Item):
        update_item_encoded = jsonable_encoder(item)
        items[item_id] = update_item_encoded
        return update_item_encoded
    

`PUT` is used to receive data that should replace the existing data.

### Warning about replacing[¶](#warning-about-replacing "Permanent link")

That means that if you want to update the item `bar` using `PUT` with a body containing:
    
    
    {
        "name": "Barz",
        "price": 3,
        "description": None,
    }
    

because it doesn't include the already stored attribute `"tax": 20.2`, the input model would take the default value of `"tax": 10.5`.

And the data would be saved with that "new" `tax` of `10.5`.

## Partial updates with `PATCH`[¶](#partial-updates-with-patch "Permanent link")

You can also use the [HTTP `PATCH`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/PATCH) operation to _partially_ update data.

This means that you can send only the data that you want to update, leaving the rest intact.

Note

`PATCH` is less commonly used and known than `PUT`.

And many teams use only `PUT`, even for partial updates.

You are **free** to use them however you want, **FastAPI** doesn't impose any restrictions.

But this guide shows you, more or less, how they are intended to be used.

### Using Pydantic's `exclude_unset` parameter[¶](#using-pydantics-exclude-unset-parameter "Permanent link")

If you want to receive partial updates, it's very useful to use the parameter `exclude_unset` in Pydantic's model's `.model_dump()`.

Like `item.model_dump(exclude_unset=True)`.

That would generate a `dict` with only the data that was set when creating the `item` model, excluding default values.

Then you can use this to generate a `dict` with only the data that was set (sent in the request), omitting default values:

Python 3.10+
    
    
    from fastapi import FastAPI
    from fastapi.encoders import jsonable_encoder
    from pydantic import BaseModel
    
    app = FastAPI()
    
    
    class Item(BaseModel):
        name: str | None = None
        description: str | None = None
        price: float | None = None
        tax: float = 10.5
        tags: list[str] = []
    
    
    items = {
        "foo": {"name": "Foo", "price": 50.2},
        "bar": {"name": "Bar", "description": "The bartenders", "price": 62, "tax": 20.2},
        "baz": {"name": "Baz", "description": None, "price": 50.2, "tax": 10.5, "tags": []},
    }
    
    
    @app.get("/items/{item_id}", response_model=Item)
    async def read_item(item_id: str):
        return items[item_id]
    
    
    @app.patch("/items/{item_id}")
    async def update_item(item_id: str, item: Item) -> Item:
        stored_item_data = items[item_id]
        stored_item_model = Item(**stored_item_data)
        update_data = item.model_dump(exclude_unset=True)
        updated_item = stored_item_model.model_copy(update=update_data)
        items[item_id] = jsonable_encoder(updated_item)
        return updated_item
    

ü§ì Other versions and variants

Python 3.9+
    
    
    from typing import Union
    
    from fastapi import FastAPI
    from fastapi.encoders import jsonable_encoder
    from pydantic import BaseModel
    
    app = FastAPI()
    
    
    class Item(BaseModel):
        name: Union[str, None] = None
        description: Union[str, None] = None
        price: Union[float, None] = None
        tax: float = 10.5
        tags: list[str] = []
    
    
    items = {
        "foo": {"name": "Foo", "price": 50.2},
        "bar": {"name": "Bar", "description": "The bartenders", "price": 62, "tax": 20.2},
        "baz": {"name": "Baz", "description": None, "price": 50.2, "tax": 10.5, "tags": []},
    }
    
    
    @app.get("/items/{item_id}", response_model=Item)
    async def read_item(item_id: str):
        return items[item_id]
    
    
    @app.patch("/items/{item_id}")
    async def update_item(item_id: str, item: Item) -> Item:
        stored_item_data = items[item_id]
        stored_item_model = Item(**stored_item_data)
        update_data = item.model_dump(exclude_unset=True)
        updated_item = stored_item_model.model_copy(update=update_data)
        items[item_id] = jsonable_encoder(updated_item)
        return updated_item
    

### Using Pydantic's `update` parameter[¶](#using-pydantics-update-parameter "Permanent link")

Now, you can create a copy of the existing model using `.model_copy()`, and pass the `update` parameter with a `dict` containing the data to update.

Like `stored_item_model.model_copy(update=update_data)`:

Python 3.10+
    
    
    from fastapi import FastAPI
    from fastapi.encoders import jsonable_encoder
    from pydantic import BaseModel
    
    app = FastAPI()
    
    
    class Item(BaseModel):
        name: str | None = None
        description: str | None = None
        price: float | None = None
        tax: float = 10.5
        tags: list[str] = []
    
    
    items = {
        "foo": {"name": "Foo", "price": 50.2},
        "bar": {"name": "Bar", "description": "The bartenders", "price": 62, "tax": 20.2},
        "baz": {"name": "Baz", "description": None, "price": 50.2, "tax": 10.5, "tags": []},
    }
    
    
    @app.get("/items/{item_id}", response_model=Item)
    async def read_item(item_id: str):
        return items[item_id]
    
    
    @app.patch("/items/{item_id}")
    async def update_item(item_id: str, item: Item) -> Item:
        stored_item_data = items[item_id]
        stored_item_model = Item(**stored_item_data)
        update_data = item.model_dump(exclude_unset=True)
        updated_item = stored_item_model.model_copy(update=update_data)
        items[item_id] = jsonable_encoder(updated_item)
        return updated_item
    

ü§ì Other versions and variants

Python 3.9+
    
    
    from typing import Union
    
    from fastapi import FastAPI
    from fastapi.encoders import jsonable_encoder
    from pydantic import BaseModel
    
    app = FastAPI()
    
    
    class Item(BaseModel):
        name: Union[str, None] = None
        description: Union[str, None] = None
        price: Union[float, None] = None
        tax: float = 10.5
        tags: list[str] = []
    
    
    items = {
        "foo": {"name": "Foo", "price": 50.2},
        "bar": {"name": "Bar", "description": "The bartenders", "price": 62, "tax": 20.2},
        "baz": {"name": "Baz", "description": None, "price": 50.2, "tax": 10.5, "tags": []},
    }
    
    
    @app.get("/items/{item_id}", response_model=Item)
    async def read_item(item_id: str):
        return items[item_id]
    
    
    @app.patch("/items/{item_id}")
    async def update_item(item_id: str, item: Item) -> Item:
        stored_item_data = items[item_id]
        stored_item_model = Item(**stored_item_data)
        update_data = item.model_dump(exclude_unset=True)
        updated_item = stored_item_model.model_copy(update=update_data)
        items[item_id] = jsonable_encoder(updated_item)
        return updated_item
    

### Partial updates recap[¶](#partial-updates-recap "Permanent link")

In summary, to apply partial updates you would:

  * (Optionally) use `PATCH` instead of `PUT`.
  * Retrieve the stored data.
  * Put that data in a Pydantic model.
  * Generate a `dict` without default values from the input model (using `exclude_unset`).
    * This way you can update only the values actually set by the user, instead of overriding values already stored with default values in your model.
  * Create a copy of the stored model, updating its attributes with the received partial updates (using the `update` parameter).
  * Convert the copied model to something that can be stored in your DB (for example, using the `jsonable_encoder`).
    * This is comparable to using the model's `.model_dump()` method again, but it makes sure (and converts) the values to data types that can be converted to JSON, for example, `datetime` to `str`.
  * Save the data to your DB.
  * Return the updated model.

Python 3.10+
    
    
    from fastapi import FastAPI
    from fastapi.encoders import jsonable_encoder
    from pydantic import BaseModel
    
    app = FastAPI()
    
    
    class Item(BaseModel):
        name: str | None = None
        description: str | None = None
        price: float | None = None
        tax: float = 10.5
        tags: list[str] = []
    
    
    items = {
        "foo": {"name": "Foo", "price": 50.2},
        "bar": {"name": "Bar", "description": "The bartenders", "price": 62, "tax": 20.2},
        "baz": {"name": "Baz", "description": None, "price": 50.2, "tax": 10.5, "tags": []},
    }
    
    
    @app.get("/items/{item_id}", response_model=Item)
    async def read_item(item_id: str):
        return items[item_id]
    
    
    @app.patch("/items/{item_id}")
    async def update_item(item_id: str, item: Item) -> Item:
        stored_item_data = items[item_id]
        stored_item_model = Item(**stored_item_data)
        update_data = item.model_dump(exclude_unset=True)
        updated_item = stored_item_model.model_copy(update=update_data)
        items[item_id] = jsonable_encoder(updated_item)
        return updated_item
    

ü§ì Other versions and variants

Python 3.9+
    
    
    from typing import Union
    
    from fastapi import FastAPI
    from fastapi.encoders import jsonable_encoder
    from pydantic import BaseModel
    
    app = FastAPI()
    
    
    class Item(BaseModel):
        name: Union[str, None] = None
        description: Union[str, None] = None
        price: Union[float, None] = None
        tax: float = 10.5
        tags: list[str] = []
    
    
    items = {
        "foo": {"name": "Foo", "price": 50.2},
        "bar": {"name": "Bar", "description": "The bartenders", "price": 62, "tax": 20.2},
        "baz": {"name": "Baz", "description": None, "price": 50.2, "tax": 10.5, "tags": []},
    }
    
    
    @app.get("/items/{item_id}", response_model=Item)
    async def read_item(item_id: str):
        return items[item_id]
    
    
    @app.patch("/items/{item_id}")
    async def update_item(item_id: str, item: Item) -> Item:
        stored_item_data = items[item_id]
        stored_item_model = Item(**stored_item_data)
        update_data = item.model_dump(exclude_unset=True)
        updated_item = stored_item_model.model_copy(update=update_data)
        items[item_id] = jsonable_encoder(updated_item)
        return updated_item
    

Tip

You can actually use this same technique with an HTTP `PUT` operation.

But the example here uses `PATCH` because it was created for these use cases.

Note

Notice that the input model is still validated.

So, if you want to receive partial updates that can omit all the attributes, you need to have a model with all the attributes marked as optional (with default values or `None`).

To distinguish from the models with all optional values for **updates** and models with required values for **creation** , you can use the ideas described in [Extra Models](../extra-models/).

---

###### Dependencies¶

# Dependencies[¶](#dependencies "Permanent link")

**FastAPI** has a very powerful but intuitive **Dependency Injection** system.

It is designed to be very simple to use, and to make it very easy for any developer to integrate other components with **FastAPI**.

## What is "Dependency Injection"[¶](#what-is-dependency-injection "Permanent link")

**"Dependency Injection"** means, in programming, that there is a way for your code (in this case, your _path operation functions_) to declare things that it requires to work and use: "dependencies".

And then, that system (in this case **FastAPI**) will take care of doing whatever is needed to provide your code with those needed dependencies ("inject" the dependencies).

This is very useful when you need to:

  * Have shared logic (the same code logic again and again).
  * Share database connections.
  * Enforce security, authentication, role requirements, etc.
  * And many other things...

All these, while minimizing code repetition.

## First Steps[¶](#first-steps "Permanent link")

Let's see a very simple example. It will be so simple that it is not very useful, for now.

But this way we can focus on how the **Dependency Injection** system works.

### Create a dependency, or "dependable"[¶](#create-a-dependency-or-dependable "Permanent link")

Let's first focus on the dependency.

It is just a function that can take all the same parameters that a _path operation function_ can take:

Python 3.10+
    
    
    from typing import Annotated
    
    from fastapi import Depends, FastAPI
    
    app = FastAPI()
    
    
    async def common_parameters(q: str | None = None, skip: int = 0, limit: int = 100):
        return {"q": q, "skip": skip, "limit": limit}
    
    
    @app.get("/items/")
    async def read_items(commons: Annotated[dict, Depends(common_parameters)]):
        return commons
    
    
    @app.get("/users/")
    async def read_users(commons: Annotated[dict, Depends(common_parameters)]):
        return commons
    

ü§ì Other versions and variants

Python 3.9+Python 3.10+ - non-AnnotatedPython 3.9+ - non-Annotated
    
    
    from typing import Annotated, Union
    
    from fastapi import Depends, FastAPI
    
    app = FastAPI()
    
    
    async def common_parameters(
        q: Union[str, None] = None, skip: int = 0, limit: int = 100
    ):
        return {"q": q, "skip": skip, "limit": limit}
    
    
    @app.get("/items/")
    async def read_items(commons: Annotated[dict, Depends(common_parameters)]):
        return commons
    
    
    @app.get("/users/")
    async def read_users(commons: Annotated[dict, Depends(common_parameters)]):
        return commons
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import Depends, FastAPI
    
    app = FastAPI()
    
    
    async def common_parameters(q: str | None = None, skip: int = 0, limit: int = 100):
        return {"q": q, "skip": skip, "limit": limit}
    
    
    @app.get("/items/")
    async def read_items(commons: dict = Depends(common_parameters)):
        return commons
    
    
    @app.get("/users/")
    async def read_users(commons: dict = Depends(common_parameters)):
        return commons
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from typing import Union
    
    from fastapi import Depends, FastAPI
    
    app = FastAPI()
    
    
    async def common_parameters(
        q: Union[str, None] = None, skip: int = 0, limit: int = 100
    ):
        return {"q": q, "skip": skip, "limit": limit}
    
    
    @app.get("/items/")
    async def read_items(commons: dict = Depends(common_parameters)):
        return commons
    
    
    @app.get("/users/")
    async def read_users(commons: dict = Depends(common_parameters)):
        return commons
    

That's it.

**2 lines**.

And it has the same shape and structure that all your _path operation functions_ have.

You can think of it as a _path operation function_ without the "decorator" (without the `@app.get("/some-path")`).

And it can return anything you want.

In this case, this dependency expects:

  * An optional query parameter `q` that is a `str`.
  * An optional query parameter `skip` that is an `int`, and by default is `0`.
  * An optional query parameter `limit` that is an `int`, and by default is `100`.

And then it just returns a `dict` containing those values.

Info

FastAPI added support for `Annotated` (and started recommending it) in version 0.95.0.

If you have an older version, you would get errors when trying to use `Annotated`.

Make sure you [Upgrade the FastAPI version](../../deployment/versions/#upgrading-the-fastapi-versions) to at least 0.95.1 before using `Annotated`.

### Import `Depends`[¶](#import-depends "Permanent link")

Python 3.10+
    
    
    from typing import Annotated
    
    from fastapi import Depends, FastAPI
    
    app = FastAPI()
    
    
    async def common_parameters(q: str | None = None, skip: int = 0, limit: int = 100):
        return {"q": q, "skip": skip, "limit": limit}
    
    
    @app.get("/items/")
    async def read_items(commons: Annotated[dict, Depends(common_parameters)]):
        return commons
    
    
    @app.get("/users/")
    async def read_users(commons: Annotated[dict, Depends(common_parameters)]):
        return commons
    

ü§ì Other versions and variants

Python 3.9+Python 3.10+ - non-AnnotatedPython 3.9+ - non-Annotated
    
    
    from typing import Annotated, Union
    
    from fastapi import Depends, FastAPI
    
    app = FastAPI()
    
    
    async def common_parameters(
        q: Union[str, None] = None, skip: int = 0, limit: int = 100
    ):
        return {"q": q, "skip": skip, "limit": limit}
    
    
    @app.get("/items/")
    async def read_items(commons: Annotated[dict, Depends(common_parameters)]):
        return commons
    
    
    @app.get("/users/")
    async def read_users(commons: Annotated[dict, Depends(common_parameters)]):
        return commons
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import Depends, FastAPI
    
    app = FastAPI()
    
    
    async def common_parameters(q: str | None = None, skip: int = 0, limit: int = 100):
        return {"q": q, "skip": skip, "limit": limit}
    
    
    @app.get("/items/")
    async def read_items(commons: dict = Depends(common_parameters)):
        return commons
    
    
    @app.get("/users/")
    async def read_users(commons: dict = Depends(common_parameters)):
        return commons
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from typing import Union
    
    from fastapi import Depends, FastAPI
    
    app = FastAPI()
    
    
    async def common_parameters(
        q: Union[str, None] = None, skip: int = 0, limit: int = 100
    ):
        return {"q": q, "skip": skip, "limit": limit}
    
    
    @app.get("/items/")
    async def read_items(commons: dict = Depends(common_parameters)):
        return commons
    
    
    @app.get("/users/")
    async def read_users(commons: dict = Depends(common_parameters)):
        return commons
    

### Declare the dependency, in the "dependant"[¶](#declare-the-dependency-in-the-dependant "Permanent link")

The same way you use `Body`, `Query`, etc. with your _path operation function_ parameters, use `Depends` with a new parameter:

Python 3.10+
    
    
    from typing import Annotated
    
    from fastapi import Depends, FastAPI
    
    app = FastAPI()
    
    
    async def common_parameters(q: str | None = None, skip: int = 0, limit: int = 100):
        return {"q": q, "skip": skip, "limit": limit}
    
    
    @app.get("/items/")
    async def read_items(commons: Annotated[dict, Depends(common_parameters)]):
        return commons
    
    
    @app.get("/users/")
    async def read_users(commons: Annotated[dict, Depends(common_parameters)]):
        return commons
    

ü§ì Other versions and variants

Python 3.9+Python 3.10+ - non-AnnotatedPython 3.9+ - non-Annotated
    
    
    from typing import Annotated, Union
    
    from fastapi import Depends, FastAPI
    
    app = FastAPI()
    
    
    async def common_parameters(
        q: Union[str, None] = None, skip: int = 0, limit: int = 100
    ):
        return {"q": q, "skip": skip, "limit": limit}
    
    
    @app.get("/items/")
    async def read_items(commons: Annotated[dict, Depends(common_parameters)]):
        return commons
    
    
    @app.get("/users/")
    async def read_users(commons: Annotated[dict, Depends(common_parameters)]):
        return commons
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import Depends, FastAPI
    
    app = FastAPI()
    
    
    async def common_parameters(q: str | None = None, skip: int = 0, limit: int = 100):
        return {"q": q, "skip": skip, "limit": limit}
    
    
    @app.get("/items/")
    async def read_items(commons: dict = Depends(common_parameters)):
        return commons
    
    
    @app.get("/users/")
    async def read_users(commons: dict = Depends(common_parameters)):
        return commons
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from typing import Union
    
    from fastapi import Depends, FastAPI
    
    app = FastAPI()
    
    
    async def common_parameters(
        q: Union[str, None] = None, skip: int = 0, limit: int = 100
    ):
        return {"q": q, "skip": skip, "limit": limit}
    
    
    @app.get("/items/")
    async def read_items(commons: dict = Depends(common_parameters)):
        return commons
    
    
    @app.get("/users/")
    async def read_users(commons: dict = Depends(common_parameters)):
        return commons
    

Although you use `Depends` in the parameters of your function the same way you use `Body`, `Query`, etc, `Depends` works a bit differently.

You only give `Depends` a single parameter.

This parameter must be something like a function.

You **don't call it** directly (don't add the parenthesis at the end), you just pass it as a parameter to `Depends()`.

And that function takes parameters in the same way that _path operation functions_ do.

Tip

You'll see what other "things", apart from functions, can be used as dependencies in the next chapter.

Whenever a new request arrives, **FastAPI** will take care of:

  * Calling your dependency ("dependable") function with the correct parameters.
  * Get the result from your function.
  * Assign that result to the parameter in your _path operation function_.

    
    
    graph TB
    
    common_parameters(["common_parameters"])
    read_items["/items/"]
    read_users["/users/"]
    
    common_parameters --> read_items
    common_parameters --> read_users

This way you write shared code once and **FastAPI** takes care of calling it for your _path operations_.

Check

Notice that you don't have to create a special class and pass it somewhere to **FastAPI** to "register" it or anything similar.

You just pass it to `Depends` and **FastAPI** knows how to do the rest.

## Share `Annotated` dependencies[¶](#share-annotated-dependencies "Permanent link")

In the examples above, you see that there's a tiny bit of **code duplication**.

When you need to use the `common_parameters()` dependency, you have to write the whole parameter with the type annotation and `Depends()`:
    
    
    commons: Annotated[dict, Depends(common_parameters)]
    

But because we are using `Annotated`, we can store that `Annotated` value in a variable and use it in multiple places:

Python 3.10+
    
    
    from typing import Annotated
    
    from fastapi import Depends, FastAPI
    
    app = FastAPI()
    
    
    async def common_parameters(q: str | None = None, skip: int = 0, limit: int = 100):
        return {"q": q, "skip": skip, "limit": limit}
    
    
    CommonsDep = Annotated[dict, Depends(common_parameters)]
    
    
    @app.get("/items/")
    async def read_items(commons: CommonsDep):
        return commons
    
    
    @app.get("/users/")
    async def read_users(commons: CommonsDep):
        return commons
    

ü§ì Other versions and variants

Python 3.9+
    
    
    from typing import Annotated, Union
    
    from fastapi import Depends, FastAPI
    
    app = FastAPI()
    
    
    async def common_parameters(
        q: Union[str, None] = None, skip: int = 0, limit: int = 100
    ):
        return {"q": q, "skip": skip, "limit": limit}
    
    
    CommonsDep = Annotated[dict, Depends(common_parameters)]
    
    
    @app.get("/items/")
    async def read_items(commons: CommonsDep):
        return commons
    
    
    @app.get("/users/")
    async def read_users(commons: CommonsDep):
        return commons
    

Tip

This is just standard Python, it's called a "type alias", it's actually not specific to **FastAPI**.

But because **FastAPI** is based on the Python standards, including `Annotated`, you can use this trick in your code. üòé

The dependencies will keep working as expected, and the **best part** is that the **type information will be preserved** , which means that your editor will be able to keep providing you with **autocompletion** , **inline errors** , etc. The same for other tools like `mypy`.

This will be especially useful when you use it in a **large code base** where you use **the same dependencies** over and over again in **many _path operations_**.

## To `async` or not to `async`[¶](#to-async-or-not-to-async "Permanent link")

As dependencies will also be called by **FastAPI** (the same as your _path operation functions_), the same rules apply while defining your functions.

You can use `async def` or normal `def`.

And you can declare dependencies with `async def` inside of normal `def` _path operation functions_ , or `def` dependencies inside of `async def` _path operation functions_ , etc.

It doesn't matter. **FastAPI** will know what to do.

Note

If you don't know, check the [Async: _"In a hurry?"_](../../async/#in-a-hurry) section about `async` and `await` in the docs.

## Integrated with OpenAPI[¶](#integrated-with-openapi "Permanent link")

All the request declarations, validations and requirements of your dependencies (and sub-dependencies) will be integrated in the same OpenAPI schema.

So, the interactive docs will have all the information from these dependencies too:

![](/img/tutorial/dependencies/image01.png)

## Simple usage[¶](#simple-usage "Permanent link")

If you look at it, _path operation functions_ are declared to be used whenever a _path_ and _operation_ matches, and then **FastAPI** takes care of calling the function with the correct parameters, extracting the data from the request.

Actually, all (or most) of the web frameworks work in this same way.

You never call those functions directly. They are called by your framework (in this case, **FastAPI**).

With the Dependency Injection system, you can also tell **FastAPI** that your _path operation function_ also "depends" on something else that should be executed before your _path operation function_ , and **FastAPI** will take care of executing it and "injecting" the results.

Other common terms for this same idea of "dependency injection" are:

  * resources
  * providers
  * services
  * injectables
  * components

## **FastAPI** plug-ins[¶](#fastapi-plug-ins "Permanent link")

Integrations and "plug-ins" can be built using the **Dependency Injection** system. But in fact, there is actually **no need to create "plug-ins"** , as by using dependencies it's possible to declare an infinite number of integrations and interactions that become available to your _path operation functions_.

And dependencies can be created in a very simple and intuitive way that allows you to just import the Python packages you need, and integrate them with your API functions in a couple of lines of code, _literally_.

You will see examples of this in the next chapters, about relational and NoSQL databases, security, etc.

## **FastAPI** compatibility[¶](#fastapi-compatibility "Permanent link")

The simplicity of the dependency injection system makes **FastAPI** compatible with:

  * all the relational databases
  * NoSQL databases
  * external packages
  * external APIs
  * authentication and authorization systems
  * API usage monitoring systems
  * response data injection systems
  * etc.

## Simple and Powerful[¶](#simple-and-powerful "Permanent link")

Although the hierarchical dependency injection system is very simple to define and use, it's still very powerful.

You can define dependencies that in turn can define dependencies themselves.

In the end, a hierarchical tree of dependencies is built, and the **Dependency Injection** system takes care of solving all these dependencies for you (and their sub-dependencies) and providing (injecting) the results at each step.

For example, let's say you have 4 API endpoints (_path operations_):

  * `/items/public/`
  * `/items/private/`
  * `/users/{user_id}/activate`
  * `/items/pro/`

then you could add different permission requirements for each of them just with dependencies and sub-dependencies:
    
    
    graph TB
    
    current_user(["current_user"])
    active_user(["active_user"])
    admin_user(["admin_user"])
    paying_user(["paying_user"])
    
    public["/items/public/"]
    private["/items/private/"]
    activate_user["/users/{user_id}/activate"]
    pro_items["/items/pro/"]
    
    current_user --> active_user
    active_user --> admin_user
    active_user --> paying_user
    
    current_user --> public
    active_user --> private
    admin_user --> activate_user
    paying_user --> pro_items

## Integrated with **OpenAPI**[¶](#integrated-with-openapi_1 "Permanent link")

All these dependencies, while declaring their requirements, also add parameters, validations, etc. to your _path operations_.

**FastAPI** will take care of adding it all to the OpenAPI schema, so that it is shown in the interactive documentation systems.
  *[Dependency Injection]: also known as components, resources, providers, services, injectables

---

###### Classes as Dependencies¶

# Classes as Dependencies[¶](#classes-as-dependencies "Permanent link")

Before diving deeper into the **Dependency Injection** system, let's upgrade the previous example.

## A `dict` from the previous example[¶](#a-dict-from-the-previous-example "Permanent link")

In the previous example, we were returning a `dict` from our dependency ("dependable"):

Python 3.10+
    
    
    from typing import Annotated
    
    from fastapi import Depends, FastAPI
    
    app = FastAPI()
    
    
    async def common_parameters(q: str | None = None, skip: int = 0, limit: int = 100):
        return {"q": q, "skip": skip, "limit": limit}
    
    
    @app.get("/items/")
    async def read_items(commons: Annotated[dict, Depends(common_parameters)]):
        return commons
    
    
    @app.get("/users/")
    async def read_users(commons: Annotated[dict, Depends(common_parameters)]):
        return commons
    

ü§ì Other versions and variants

Python 3.9+Python 3.10+ - non-AnnotatedPython 3.9+ - non-Annotated
    
    
    from typing import Annotated, Union
    
    from fastapi import Depends, FastAPI
    
    app = FastAPI()
    
    
    async def common_parameters(
        q: Union[str, None] = None, skip: int = 0, limit: int = 100
    ):
        return {"q": q, "skip": skip, "limit": limit}
    
    
    @app.get("/items/")
    async def read_items(commons: Annotated[dict, Depends(common_parameters)]):
        return commons
    
    
    @app.get("/users/")
    async def read_users(commons: Annotated[dict, Depends(common_parameters)]):
        return commons
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import Depends, FastAPI
    
    app = FastAPI()
    
    
    async def common_parameters(q: str | None = None, skip: int = 0, limit: int = 100):
        return {"q": q, "skip": skip, "limit": limit}
    
    
    @app.get("/items/")
    async def read_items(commons: dict = Depends(common_parameters)):
        return commons
    
    
    @app.get("/users/")
    async def read_users(commons: dict = Depends(common_parameters)):
        return commons
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from typing import Union
    
    from fastapi import Depends, FastAPI
    
    app = FastAPI()
    
    
    async def common_parameters(
        q: Union[str, None] = None, skip: int = 0, limit: int = 100
    ):
        return {"q": q, "skip": skip, "limit": limit}
    
    
    @app.get("/items/")
    async def read_items(commons: dict = Depends(common_parameters)):
        return commons
    
    
    @app.get("/users/")
    async def read_users(commons: dict = Depends(common_parameters)):
        return commons
    

But then we get a `dict` in the parameter `commons` of the _path operation function_.

And we know that editors can't provide a lot of support (like completion) for `dict`s, because they can't know their keys and value types.

We can do better...

## What makes a dependency[¶](#what-makes-a-dependency "Permanent link")

Up to now you have seen dependencies declared as functions.

But that's not the only way to declare dependencies (although it would probably be the more common).

The key factor is that a dependency should be a "callable".

A "**callable** " in Python is anything that Python can "call" like a function.

So, if you have an object `something` (that might _not_ be a function) and you can "call" it (execute it) like:
    
    
    something()
    

or
    
    
    something(some_argument, some_keyword_argument="foo")
    

then it is a "callable".

## Classes as dependencies[¶](#classes-as-dependencies_1 "Permanent link")

You might notice that to create an instance of a Python class, you use that same syntax.

For example:
    
    
    class Cat:
        def __init__(self, name: str):
            self.name = name
    
    
    fluffy = Cat(name="Mr Fluffy")
    

In this case, `fluffy` is an instance of the class `Cat`.

And to create `fluffy`, you are "calling" `Cat`.

So, a Python class is also a **callable**.

Then, in **FastAPI** , you could use a Python class as a dependency.

What FastAPI actually checks is that it is a "callable" (function, class or anything else) and the parameters defined.

If you pass a "callable" as a dependency in **FastAPI** , it will analyze the parameters for that "callable", and process them in the same way as the parameters for a _path operation function_. Including sub-dependencies.

That also applies to callables with no parameters at all. The same as it would be for _path operation functions_ with no parameters.

Then, we can change the dependency "dependable" `common_parameters` from above to the class `CommonQueryParams`:

Python 3.10+
    
    
    from typing import Annotated
    
    from fastapi import Depends, FastAPI
    
    app = FastAPI()
    
    
    fake_items_db = [{"item_name": "Foo"}, {"item_name": "Bar"}, {"item_name": "Baz"}]
    
    
    class CommonQueryParams:
        def __init__(self, q: str | None = None, skip: int = 0, limit: int = 100):
            self.q = q
            self.skip = skip
            self.limit = limit
    
    
    @app.get("/items/")
    async def read_items(commons: Annotated[CommonQueryParams, Depends(CommonQueryParams)]):
        response = {}
        if commons.q:
            response.update({"q": commons.q})
        items = fake_items_db[commons.skip : commons.skip + commons.limit]
        response.update({"items": items})
        return response
    

ü§ì Other versions and variants

Python 3.9+Python 3.10+ - non-AnnotatedPython 3.9+ - non-Annotated
    
    
    from typing import Annotated, Union
    
    from fastapi import Depends, FastAPI
    
    app = FastAPI()
    
    
    fake_items_db = [{"item_name": "Foo"}, {"item_name": "Bar"}, {"item_name": "Baz"}]
    
    
    class CommonQueryParams:
        def __init__(self, q: Union[str, None] = None, skip: int = 0, limit: int = 100):
            self.q = q
            self.skip = skip
            self.limit = limit
    
    
    @app.get("/items/")
    async def read_items(commons: Annotated[CommonQueryParams, Depends(CommonQueryParams)]):
        response = {}
        if commons.q:
            response.update({"q": commons.q})
        items = fake_items_db[commons.skip : commons.skip + commons.limit]
        response.update({"items": items})
        return response
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import Depends, FastAPI
    
    app = FastAPI()
    
    
    fake_items_db = [{"item_name": "Foo"}, {"item_name": "Bar"}, {"item_name": "Baz"}]
    
    
    class CommonQueryParams:
        def __init__(self, q: str | None = None, skip: int = 0, limit: int = 100):
            self.q = q
            self.skip = skip
            self.limit = limit
    
    
    @app.get("/items/")
    async def read_items(commons: CommonQueryParams = Depends(CommonQueryParams)):
        response = {}
        if commons.q:
            response.update({"q": commons.q})
        items = fake_items_db[commons.skip : commons.skip + commons.limit]
        response.update({"items": items})
        return response
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from typing import Union
    
    from fastapi import Depends, FastAPI
    
    app = FastAPI()
    
    
    fake_items_db = [{"item_name": "Foo"}, {"item_name": "Bar"}, {"item_name": "Baz"}]
    
    
    class CommonQueryParams:
        def __init__(self, q: Union[str, None] = None, skip: int = 0, limit: int = 100):
            self.q = q
            self.skip = skip
            self.limit = limit
    
    
    @app.get("/items/")
    async def read_items(commons: CommonQueryParams = Depends(CommonQueryParams)):
        response = {}
        if commons.q:
            response.update({"q": commons.q})
        items = fake_items_db[commons.skip : commons.skip + commons.limit]
        response.update({"items": items})
        return response
    

Pay attention to the `__init__` method used to create the instance of the class:

Python 3.10+
    
    
    from typing import Annotated
    
    from fastapi import Depends, FastAPI
    
    app = FastAPI()
    
    
    fake_items_db = [{"item_name": "Foo"}, {"item_name": "Bar"}, {"item_name": "Baz"}]
    
    
    class CommonQueryParams:
        def __init__(self, q: str | None = None, skip: int = 0, limit: int = 100):
            self.q = q
            self.skip = skip
            self.limit = limit
    
    
    @app.get("/items/")
    async def read_items(commons: Annotated[CommonQueryParams, Depends(CommonQueryParams)]):
        response = {}
        if commons.q:
            response.update({"q": commons.q})
        items = fake_items_db[commons.skip : commons.skip + commons.limit]
        response.update({"items": items})
        return response
    

ü§ì Other versions and variants

Python 3.9+Python 3.10+ - non-AnnotatedPython 3.9+ - non-Annotated
    
    
    from typing import Annotated, Union
    
    from fastapi import Depends, FastAPI
    
    app = FastAPI()
    
    
    fake_items_db = [{"item_name": "Foo"}, {"item_name": "Bar"}, {"item_name": "Baz"}]
    
    
    class CommonQueryParams:
        def __init__(self, q: Union[str, None] = None, skip: int = 0, limit: int = 100):
            self.q = q
            self.skip = skip
            self.limit = limit
    
    
    @app.get("/items/")
    async def read_items(commons: Annotated[CommonQueryParams, Depends(CommonQueryParams)]):
        response = {}
        if commons.q:
            response.update({"q": commons.q})
        items = fake_items_db[commons.skip : commons.skip + commons.limit]
        response.update({"items": items})
        return response
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import Depends, FastAPI
    
    app = FastAPI()
    
    
    fake_items_db = [{"item_name": "Foo"}, {"item_name": "Bar"}, {"item_name": "Baz"}]
    
    
    class CommonQueryParams:
        def __init__(self, q: str | None = None, skip: int = 0, limit: int = 100):
            self.q = q
            self.skip = skip
            self.limit = limit
    
    
    @app.get("/items/")
    async def read_items(commons: CommonQueryParams = Depends(CommonQueryParams)):
        response = {}
        if commons.q:
            response.update({"q": commons.q})
        items = fake_items_db[commons.skip : commons.skip + commons.limit]
        response.update({"items": items})
        return response
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from typing import Union
    
    from fastapi import Depends, FastAPI
    
    app = FastAPI()
    
    
    fake_items_db = [{"item_name": "Foo"}, {"item_name": "Bar"}, {"item_name": "Baz"}]
    
    
    class CommonQueryParams:
        def __init__(self, q: Union[str, None] = None, skip: int = 0, limit: int = 100):
            self.q = q
            self.skip = skip
            self.limit = limit
    
    
    @app.get("/items/")
    async def read_items(commons: CommonQueryParams = Depends(CommonQueryParams)):
        response = {}
        if commons.q:
            response.update({"q": commons.q})
        items = fake_items_db[commons.skip : commons.skip + commons.limit]
        response.update({"items": items})
        return response
    

...it has the same parameters as our previous `common_parameters`:

Python 3.10+
    
    
    from typing import Annotated
    
    from fastapi import Depends, FastAPI
    
    app = FastAPI()
    
    
    async def common_parameters(q: str | None = None, skip: int = 0, limit: int = 100):
        return {"q": q, "skip": skip, "limit": limit}
    
    
    @app.get("/items/")
    async def read_items(commons: Annotated[dict, Depends(common_parameters)]):
        return commons
    
    
    @app.get("/users/")
    async def read_users(commons: Annotated[dict, Depends(common_parameters)]):
        return commons
    

ü§ì Other versions and variants

Python 3.9+Python 3.10+ - non-AnnotatedPython 3.9+ - non-Annotated
    
    
    from typing import Annotated, Union
    
    from fastapi import Depends, FastAPI
    
    app = FastAPI()
    
    
    async def common_parameters(
        q: Union[str, None] = None, skip: int = 0, limit: int = 100
    ):
        return {"q": q, "skip": skip, "limit": limit}
    
    
    @app.get("/items/")
    async def read_items(commons: Annotated[dict, Depends(common_parameters)]):
        return commons
    
    
    @app.get("/users/")
    async def read_users(commons: Annotated[dict, Depends(common_parameters)]):
        return commons
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import Depends, FastAPI
    
    app = FastAPI()
    
    
    async def common_parameters(q: str | None = None, skip: int = 0, limit: int = 100):
        return {"q": q, "skip": skip, "limit": limit}
    
    
    @app.get("/items/")
    async def read_items(commons: dict = Depends(common_parameters)):
        return commons
    
    
    @app.get("/users/")
    async def read_users(commons: dict = Depends(common_parameters)):
        return commons
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from typing import Union
    
    from fastapi import Depends, FastAPI
    
    app = FastAPI()
    
    
    async def common_parameters(
        q: Union[str, None] = None, skip: int = 0, limit: int = 100
    ):
        return {"q": q, "skip": skip, "limit": limit}
    
    
    @app.get("/items/")
    async def read_items(commons: dict = Depends(common_parameters)):
        return commons
    
    
    @app.get("/users/")
    async def read_users(commons: dict = Depends(common_parameters)):
        return commons
    

Those parameters are what **FastAPI** will use to "solve" the dependency.

In both cases, it will have:

  * An optional `q` query parameter that is a `str`.
  * A `skip` query parameter that is an `int`, with a default of `0`.
  * A `limit` query parameter that is an `int`, with a default of `100`.

In both cases the data will be converted, validated, documented on the OpenAPI schema, etc.

## Use it[¶](#use-it "Permanent link")

Now you can declare your dependency using this class.

Python 3.10+
    
    
    from typing import Annotated
    
    from fastapi import Depends, FastAPI
    
    app = FastAPI()
    
    
    fake_items_db = [{"item_name": "Foo"}, {"item_name": "Bar"}, {"item_name": "Baz"}]
    
    
    class CommonQueryParams:
        def __init__(self, q: str | None = None, skip: int = 0, limit: int = 100):
            self.q = q
            self.skip = skip
            self.limit = limit
    
    
    @app.get("/items/")
    async def read_items(commons: Annotated[CommonQueryParams, Depends(CommonQueryParams)]):
        response = {}
        if commons.q:
            response.update({"q": commons.q})
        items = fake_items_db[commons.skip : commons.skip + commons.limit]
        response.update({"items": items})
        return response
    

ü§ì Other versions and variants

Python 3.9+Python 3.10+ - non-AnnotatedPython 3.9+ - non-Annotated
    
    
    from typing import Annotated, Union
    
    from fastapi import Depends, FastAPI
    
    app = FastAPI()
    
    
    fake_items_db = [{"item_name": "Foo"}, {"item_name": "Bar"}, {"item_name": "Baz"}]
    
    
    class CommonQueryParams:
        def __init__(self, q: Union[str, None] = None, skip: int = 0, limit: int = 100):
            self.q = q
            self.skip = skip
            self.limit = limit
    
    
    @app.get("/items/")
    async def read_items(commons: Annotated[CommonQueryParams, Depends(CommonQueryParams)]):
        response = {}
        if commons.q:
            response.update({"q": commons.q})
        items = fake_items_db[commons.skip : commons.skip + commons.limit]
        response.update({"items": items})
        return response
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import Depends, FastAPI
    
    app = FastAPI()
    
    
    fake_items_db = [{"item_name": "Foo"}, {"item_name": "Bar"}, {"item_name": "Baz"}]
    
    
    class CommonQueryParams:
        def __init__(self, q: str | None = None, skip: int = 0, limit: int = 100):
            self.q = q
            self.skip = skip
            self.limit = limit
    
    
    @app.get("/items/")
    async def read_items(commons: CommonQueryParams = Depends(CommonQueryParams)):
        response = {}
        if commons.q:
            response.update({"q": commons.q})
        items = fake_items_db[commons.skip : commons.skip + commons.limit]
        response.update({"items": items})
        return response
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from typing import Union
    
    from fastapi import Depends, FastAPI
    
    app = FastAPI()
    
    
    fake_items_db = [{"item_name": "Foo"}, {"item_name": "Bar"}, {"item_name": "Baz"}]
    
    
    class CommonQueryParams:
        def __init__(self, q: Union[str, None] = None, skip: int = 0, limit: int = 100):
            self.q = q
            self.skip = skip
            self.limit = limit
    
    
    @app.get("/items/")
    async def read_items(commons: CommonQueryParams = Depends(CommonQueryParams)):
        response = {}
        if commons.q:
            response.update({"q": commons.q})
        items = fake_items_db[commons.skip : commons.skip + commons.limit]
        response.update({"items": items})
        return response
    

**FastAPI** calls the `CommonQueryParams` class. This creates an "instance" of that class and the instance will be passed as the parameter `commons` to your function.

## Type annotation vs `Depends`[¶](#type-annotation-vs-depends "Permanent link")

Notice how we write `CommonQueryParams` twice in the above code:

Python 3.9+Python 3.9+ non-Annotated
    
    
    commons: Annotated[CommonQueryParams, Depends(CommonQueryParams)]
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    commons: CommonQueryParams = Depends(CommonQueryParams)
    

The last `CommonQueryParams`, in:
    
    
    ... Depends(CommonQueryParams)
    

...is what **FastAPI** will actually use to know what is the dependency.

It is from this one that FastAPI will extract the declared parameters and that is what FastAPI will actually call.

* * *

In this case, the first `CommonQueryParams`, in:

Python 3.9+Python 3.9+ non-Annotated
    
    
    commons: Annotated[CommonQueryParams, ...
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    commons: CommonQueryParams ...
    

...doesn't have any special meaning for **FastAPI**. FastAPI won't use it for data conversion, validation, etc. (as it is using the `Depends(CommonQueryParams)` for that).

You could actually write just:

Python 3.9+Python 3.9+ non-Annotated
    
    
    commons: Annotated[Any, Depends(CommonQueryParams)]
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    commons = Depends(CommonQueryParams)
    

...as in:

Python 3.10+
    
    
    from typing import Annotated, Any
    
    from fastapi import Depends, FastAPI
    
    app = FastAPI()
    
    
    fake_items_db = [{"item_name": "Foo"}, {"item_name": "Bar"}, {"item_name": "Baz"}]
    
    
    class CommonQueryParams:
        def __init__(self, q: str | None = None, skip: int = 0, limit: int = 100):
            self.q = q
            self.skip = skip
            self.limit = limit
    
    
    @app.get("/items/")
    async def read_items(commons: Annotated[Any, Depends(CommonQueryParams)]):
        response = {}
        if commons.q:
            response.update({"q": commons.q})
        items = fake_items_db[commons.skip : commons.skip + commons.limit]
        response.update({"items": items})
        return response
    

ü§ì Other versions and variants

Python 3.9+Python 3.10+ - non-AnnotatedPython 3.9+ - non-Annotated
    
    
    from typing import Annotated, Any, Union
    
    from fastapi import Depends, FastAPI
    
    app = FastAPI()
    
    
    fake_items_db = [{"item_name": "Foo"}, {"item_name": "Bar"}, {"item_name": "Baz"}]
    
    
    class CommonQueryParams:
        def __init__(self, q: Union[str, None] = None, skip: int = 0, limit: int = 100):
            self.q = q
            self.skip = skip
            self.limit = limit
    
    
    @app.get("/items/")
    async def read_items(commons: Annotated[Any, Depends(CommonQueryParams)]):
        response = {}
        if commons.q:
            response.update({"q": commons.q})
        items = fake_items_db[commons.skip : commons.skip + commons.limit]
        response.update({"items": items})
        return response
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import Depends, FastAPI
    
    app = FastAPI()
    
    
    fake_items_db = [{"item_name": "Foo"}, {"item_name": "Bar"}, {"item_name": "Baz"}]
    
    
    class CommonQueryParams:
        def __init__(self, q: str | None = None, skip: int = 0, limit: int = 100):
            self.q = q
            self.skip = skip
            self.limit = limit
    
    
    @app.get("/items/")
    async def read_items(commons=Depends(CommonQueryParams)):
        response = {}
        if commons.q:
            response.update({"q": commons.q})
        items = fake_items_db[commons.skip : commons.skip + commons.limit]
        response.update({"items": items})
        return response
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from typing import Union
    
    from fastapi import Depends, FastAPI
    
    app = FastAPI()
    
    
    fake_items_db = [{"item_name": "Foo"}, {"item_name": "Bar"}, {"item_name": "Baz"}]
    
    
    class CommonQueryParams:
        def __init__(self, q: Union[str, None] = None, skip: int = 0, limit: int = 100):
            self.q = q
            self.skip = skip
            self.limit = limit
    
    
    @app.get("/items/")
    async def read_items(commons=Depends(CommonQueryParams)):
        response = {}
        if commons.q:
            response.update({"q": commons.q})
        items = fake_items_db[commons.skip : commons.skip + commons.limit]
        response.update({"items": items})
        return response
    

But declaring the type is encouraged as that way your editor will know what will be passed as the parameter `commons`, and then it can help you with code completion, type checks, etc:

![](/img/tutorial/dependencies/image02.png)

## Shortcut[¶](#shortcut "Permanent link")

But you see that we are having some code repetition here, writing `CommonQueryParams` twice:

Python 3.9+Python 3.9+ non-Annotated
    
    
    commons: Annotated[CommonQueryParams, Depends(CommonQueryParams)]
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    commons: CommonQueryParams = Depends(CommonQueryParams)
    

**FastAPI** provides a shortcut for these cases, in where the dependency is _specifically_ a class that **FastAPI** will "call" to create an instance of the class itself.

For those specific cases, you can do the following:

Instead of writing:

Python 3.9+Python 3.9+ non-Annotated
    
    
    commons: Annotated[CommonQueryParams, Depends(CommonQueryParams)]
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    commons: CommonQueryParams = Depends(CommonQueryParams)
    

...you write:

Python 3.9+Python 3.9+ non-Annotated
    
    
    commons: Annotated[CommonQueryParams, Depends()]
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    commons: CommonQueryParams = Depends()
    

You declare the dependency as the type of the parameter, and you use `Depends()` without any parameter, instead of having to write the full class _again_ inside of `Depends(CommonQueryParams)`.

The same example would then look like:

Python 3.10+
    
    
    from typing import Annotated
    
    from fastapi import Depends, FastAPI
    
    app = FastAPI()
    
    
    fake_items_db = [{"item_name": "Foo"}, {"item_name": "Bar"}, {"item_name": "Baz"}]
    
    
    class CommonQueryParams:
        def __init__(self, q: str | None = None, skip: int = 0, limit: int = 100):
            self.q = q
            self.skip = skip
            self.limit = limit
    
    
    @app.get("/items/")
    async def read_items(commons: Annotated[CommonQueryParams, Depends()]):
        response = {}
        if commons.q:
            response.update({"q": commons.q})
        items = fake_items_db[commons.skip : commons.skip + commons.limit]
        response.update({"items": items})
        return response
    

ü§ì Other versions and variants

Python 3.9+Python 3.10+ - non-AnnotatedPython 3.9+ - non-Annotated
    
    
    from typing import Annotated, Union
    
    from fastapi import Depends, FastAPI
    
    app = FastAPI()
    
    
    fake_items_db = [{"item_name": "Foo"}, {"item_name": "Bar"}, {"item_name": "Baz"}]
    
    
    class CommonQueryParams:
        def __init__(self, q: Union[str, None] = None, skip: int = 0, limit: int = 100):
            self.q = q
            self.skip = skip
            self.limit = limit
    
    
    @app.get("/items/")
    async def read_items(commons: Annotated[CommonQueryParams, Depends()]):
        response = {}
        if commons.q:
            response.update({"q": commons.q})
        items = fake_items_db[commons.skip : commons.skip + commons.limit]
        response.update({"items": items})
        return response
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import Depends, FastAPI
    
    app = FastAPI()
    
    
    fake_items_db = [{"item_name": "Foo"}, {"item_name": "Bar"}, {"item_name": "Baz"}]
    
    
    class CommonQueryParams:
        def __init__(self, q: str | None = None, skip: int = 0, limit: int = 100):
            self.q = q
            self.skip = skip
            self.limit = limit
    
    
    @app.get("/items/")
    async def read_items(commons: CommonQueryParams = Depends()):
        response = {}
        if commons.q:
            response.update({"q": commons.q})
        items = fake_items_db[commons.skip : commons.skip + commons.limit]
        response.update({"items": items})
        return response
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from typing import Union
    
    from fastapi import Depends, FastAPI
    
    app = FastAPI()
    
    
    fake_items_db = [{"item_name": "Foo"}, {"item_name": "Bar"}, {"item_name": "Baz"}]
    
    
    class CommonQueryParams:
        def __init__(self, q: Union[str, None] = None, skip: int = 0, limit: int = 100):
            self.q = q
            self.skip = skip
            self.limit = limit
    
    
    @app.get("/items/")
    async def read_items(commons: CommonQueryParams = Depends()):
        response = {}
        if commons.q:
            response.update({"q": commons.q})
        items = fake_items_db[commons.skip : commons.skip + commons.limit]
        response.update({"items": items})
        return response
    

...and **FastAPI** will know what to do.

Tip

If that seems more confusing than helpful, disregard it, you don't _need_ it.

It is just a shortcut. Because **FastAPI** cares about helping you minimize code repetition.

---

###### Sub-dependencies¶

# Sub-dependencies[¶](#sub-dependencies "Permanent link")

You can create dependencies that have **sub-dependencies**.

They can be as **deep** as you need them to be.

**FastAPI** will take care of solving them.

## First dependency "dependable"[¶](#first-dependency-dependable "Permanent link")

You could create a first dependency ("dependable") like:

Python 3.10+
    
    
    from typing import Annotated
    
    from fastapi import Cookie, Depends, FastAPI
    
    app = FastAPI()
    
    
    def query_extractor(q: str | None = None):
        return q
    
    
    def query_or_cookie_extractor(
        q: Annotated[str, Depends(query_extractor)],
        last_query: Annotated[str | None, Cookie()] = None,
    ):
        if not q:
            return last_query
        return q
    
    
    @app.get("/items/")
    async def read_query(
        query_or_default: Annotated[str, Depends(query_or_cookie_extractor)],
    ):
        return {"q_or_cookie": query_or_default}
    

ü§ì Other versions and variants

Python 3.9+Python 3.10+ - non-AnnotatedPython 3.9+ - non-Annotated
    
    
    from typing import Annotated, Union
    
    from fastapi import Cookie, Depends, FastAPI
    
    app = FastAPI()
    
    
    def query_extractor(q: Union[str, None] = None):
        return q
    
    
    def query_or_cookie_extractor(
        q: Annotated[str, Depends(query_extractor)],
        last_query: Annotated[Union[str, None], Cookie()] = None,
    ):
        if not q:
            return last_query
        return q
    
    
    @app.get("/items/")
    async def read_query(
        query_or_default: Annotated[str, Depends(query_or_cookie_extractor)],
    ):
        return {"q_or_cookie": query_or_default}
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import Cookie, Depends, FastAPI
    
    app = FastAPI()
    
    
    def query_extractor(q: str | None = None):
        return q
    
    
    def query_or_cookie_extractor(
        q: str = Depends(query_extractor), last_query: str | None = Cookie(default=None)
    ):
        if not q:
            return last_query
        return q
    
    
    @app.get("/items/")
    async def read_query(query_or_default: str = Depends(query_or_cookie_extractor)):
        return {"q_or_cookie": query_or_default}
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from typing import Union
    
    from fastapi import Cookie, Depends, FastAPI
    
    app = FastAPI()
    
    
    def query_extractor(q: Union[str, None] = None):
        return q
    
    
    def query_or_cookie_extractor(
        q: str = Depends(query_extractor),
        last_query: Union[str, None] = Cookie(default=None),
    ):
        if not q:
            return last_query
        return q
    
    
    @app.get("/items/")
    async def read_query(query_or_default: str = Depends(query_or_cookie_extractor)):
        return {"q_or_cookie": query_or_default}
    

It declares an optional query parameter `q` as a `str`, and then it just returns it.

This is quite simple (not very useful), but will help us focus on how the sub-dependencies work.

## Second dependency, "dependable" and "dependant"[¶](#second-dependency-dependable-and-dependant "Permanent link")

Then you can create another dependency function (a "dependable") that at the same time declares a dependency of its own (so it is a "dependant" too):

Python 3.10+
    
    
    from typing import Annotated
    
    from fastapi import Cookie, Depends, FastAPI
    
    app = FastAPI()
    
    
    def query_extractor(q: str | None = None):
        return q
    
    
    def query_or_cookie_extractor(
        q: Annotated[str, Depends(query_extractor)],
        last_query: Annotated[str | None, Cookie()] = None,
    ):
        if not q:
            return last_query
        return q
    
    
    @app.get("/items/")
    async def read_query(
        query_or_default: Annotated[str, Depends(query_or_cookie_extractor)],
    ):
        return {"q_or_cookie": query_or_default}
    

ü§ì Other versions and variants

Python 3.9+Python 3.10+ - non-AnnotatedPython 3.9+ - non-Annotated
    
    
    from typing import Annotated, Union
    
    from fastapi import Cookie, Depends, FastAPI
    
    app = FastAPI()
    
    
    def query_extractor(q: Union[str, None] = None):
        return q
    
    
    def query_or_cookie_extractor(
        q: Annotated[str, Depends(query_extractor)],
        last_query: Annotated[Union[str, None], Cookie()] = None,
    ):
        if not q:
            return last_query
        return q
    
    
    @app.get("/items/")
    async def read_query(
        query_or_default: Annotated[str, Depends(query_or_cookie_extractor)],
    ):
        return {"q_or_cookie": query_or_default}
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import Cookie, Depends, FastAPI
    
    app = FastAPI()
    
    
    def query_extractor(q: str | None = None):
        return q
    
    
    def query_or_cookie_extractor(
        q: str = Depends(query_extractor), last_query: str | None = Cookie(default=None)
    ):
        if not q:
            return last_query
        return q
    
    
    @app.get("/items/")
    async def read_query(query_or_default: str = Depends(query_or_cookie_extractor)):
        return {"q_or_cookie": query_or_default}
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from typing import Union
    
    from fastapi import Cookie, Depends, FastAPI
    
    app = FastAPI()
    
    
    def query_extractor(q: Union[str, None] = None):
        return q
    
    
    def query_or_cookie_extractor(
        q: str = Depends(query_extractor),
        last_query: Union[str, None] = Cookie(default=None),
    ):
        if not q:
            return last_query
        return q
    
    
    @app.get("/items/")
    async def read_query(query_or_default: str = Depends(query_or_cookie_extractor)):
        return {"q_or_cookie": query_or_default}
    

Let's focus on the parameters declared:

  * Even though this function is a dependency ("dependable") itself, it also declares another dependency (it "depends" on something else).
    * It depends on the `query_extractor`, and assigns the value returned by it to the parameter `q`.
  * It also declares an optional `last_query` cookie, as a `str`.
    * If the user didn't provide any query `q`, we use the last query used, which we saved to a cookie before.

## Use the dependency[¶](#use-the-dependency "Permanent link")

Then we can use the dependency with:

Python 3.10+
    
    
    from typing import Annotated
    
    from fastapi import Cookie, Depends, FastAPI
    
    app = FastAPI()
    
    
    def query_extractor(q: str | None = None):
        return q
    
    
    def query_or_cookie_extractor(
        q: Annotated[str, Depends(query_extractor)],
        last_query: Annotated[str | None, Cookie()] = None,
    ):
        if not q:
            return last_query
        return q
    
    
    @app.get("/items/")
    async def read_query(
        query_or_default: Annotated[str, Depends(query_or_cookie_extractor)],
    ):
        return {"q_or_cookie": query_or_default}
    

ü§ì Other versions and variants

Python 3.9+Python 3.10+ - non-AnnotatedPython 3.9+ - non-Annotated
    
    
    from typing import Annotated, Union
    
    from fastapi import Cookie, Depends, FastAPI
    
    app = FastAPI()
    
    
    def query_extractor(q: Union[str, None] = None):
        return q
    
    
    def query_or_cookie_extractor(
        q: Annotated[str, Depends(query_extractor)],
        last_query: Annotated[Union[str, None], Cookie()] = None,
    ):
        if not q:
            return last_query
        return q
    
    
    @app.get("/items/")
    async def read_query(
        query_or_default: Annotated[str, Depends(query_or_cookie_extractor)],
    ):
        return {"q_or_cookie": query_or_default}
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import Cookie, Depends, FastAPI
    
    app = FastAPI()
    
    
    def query_extractor(q: str | None = None):
        return q
    
    
    def query_or_cookie_extractor(
        q: str = Depends(query_extractor), last_query: str | None = Cookie(default=None)
    ):
        if not q:
            return last_query
        return q
    
    
    @app.get("/items/")
    async def read_query(query_or_default: str = Depends(query_or_cookie_extractor)):
        return {"q_or_cookie": query_or_default}
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from typing import Union
    
    from fastapi import Cookie, Depends, FastAPI
    
    app = FastAPI()
    
    
    def query_extractor(q: Union[str, None] = None):
        return q
    
    
    def query_or_cookie_extractor(
        q: str = Depends(query_extractor),
        last_query: Union[str, None] = Cookie(default=None),
    ):
        if not q:
            return last_query
        return q
    
    
    @app.get("/items/")
    async def read_query(query_or_default: str = Depends(query_or_cookie_extractor)):
        return {"q_or_cookie": query_or_default}
    

Info

Notice that we are only declaring one dependency in the _path operation function_ , the `query_or_cookie_extractor`.

But **FastAPI** will know that it has to solve `query_extractor` first, to pass the results of that to `query_or_cookie_extractor` while calling it.
    
    
    graph TB
    
    query_extractor(["query_extractor"])
    query_or_cookie_extractor(["query_or_cookie_extractor"])
    
    read_query["/items/"]
    
    query_extractor --> query_or_cookie_extractor --> read_query

## Using the same dependency multiple times[¶](#using-the-same-dependency-multiple-times "Permanent link")

If one of your dependencies is declared multiple times for the same _path operation_ , for example, multiple dependencies have a common sub-dependency, **FastAPI** will know to call that sub-dependency only once per request.

And it will save the returned value in a "cache" and pass it to all the "dependants" that need it in that specific request, instead of calling the dependency multiple times for the same request.

In an advanced scenario where you know you need the dependency to be called at every step (possibly multiple times) in the same request instead of using the "cached" value, you can set the parameter `use_cache=False` when using `Depends`:

Python 3.9+Python 3.9+ non-Annotated
    
    
    async def needy_dependency(fresh_value: Annotated[str, Depends(get_value, use_cache=False)]):
        return {"fresh_value": fresh_value}
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    async def needy_dependency(fresh_value: str = Depends(get_value, use_cache=False)):
        return {"fresh_value": fresh_value}
    

## Recap[¶](#recap "Permanent link")

Apart from all the fancy words used here, the **Dependency Injection** system is quite simple.

Just functions that look the same as the _path operation functions_.

But still, it is very powerful, and allows you to declare arbitrarily deeply nested dependency "graphs" (trees).

Tip

All this might not seem as useful with these simple examples.

But you will see how useful it is in the chapters about **security**.

And you will also see the amounts of code it will save you.
  *["cache"]: A utility/system to store computed/generated values, to reuse them instead of computing them again.

---

###### Dependencies in path operation decorators¶

# Dependencies in path operation decorators[¶](#dependencies-in-path-operation-decorators "Permanent link")

In some cases you don't really need the return value of a dependency inside your _path operation function_.

Or the dependency doesn't return a value.

But you still need it to be executed/solved.

For those cases, instead of declaring a _path operation function_ parameter with `Depends`, you can add a `list` of `dependencies` to the _path operation decorator_.

## Add `dependencies` to the _path operation decorator_[¶](#add-dependencies-to-the-path-operation-decorator "Permanent link")

The _path operation decorator_ receives an optional argument `dependencies`.

It should be a `list` of `Depends()`:

Python 3.9+
    
    
    from typing import Annotated
    
    from fastapi import Depends, FastAPI, Header, HTTPException
    
    app = FastAPI()
    
    
    async def verify_token(x_token: Annotated[str, Header()]):
        if x_token != "fake-super-secret-token":
            raise HTTPException(status_code=400, detail="X-Token header invalid")
    
    
    async def verify_key(x_key: Annotated[str, Header()]):
        if x_key != "fake-super-secret-key":
            raise HTTPException(status_code=400, detail="X-Key header invalid")
        return x_key
    
    
    @app.get("/items/", dependencies=[Depends(verify_token), Depends(verify_key)])
    async def read_items():
        return [{"item": "Foo"}, {"item": "Bar"}]
    

ü§ì Other versions and variants

Python 3.9+ - non-Annotated

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import Depends, FastAPI, Header, HTTPException
    
    app = FastAPI()
    
    
    async def verify_token(x_token: str = Header()):
        if x_token != "fake-super-secret-token":
            raise HTTPException(status_code=400, detail="X-Token header invalid")
    
    
    async def verify_key(x_key: str = Header()):
        if x_key != "fake-super-secret-key":
            raise HTTPException(status_code=400, detail="X-Key header invalid")
        return x_key
    
    
    @app.get("/items/", dependencies=[Depends(verify_token), Depends(verify_key)])
    async def read_items():
        return [{"item": "Foo"}, {"item": "Bar"}]
    

These dependencies will be executed/solved the same way as normal dependencies. But their value (if they return any) won't be passed to your _path operation function_.

Tip

Some editors check for unused function parameters, and show them as errors.

Using these `dependencies` in the _path operation decorator_ you can make sure they are executed while avoiding editor/tooling errors.

It might also help avoid confusion for new developers that see an unused parameter in your code and could think it's unnecessary.

Info

In this example we use invented custom headers `X-Key` and `X-Token`.

But in real cases, when implementing security, you would get more benefits from using the integrated [Security utilities (the next chapter)](../../security/).

## Dependencies errors and return values[¶](#dependencies-errors-and-return-values "Permanent link")

You can use the same dependency _functions_ you use normally.

### Dependency requirements[¶](#dependency-requirements "Permanent link")

They can declare request requirements (like headers) or other sub-dependencies:

Python 3.9+
    
    
    from typing import Annotated
    
    from fastapi import Depends, FastAPI, Header, HTTPException
    
    app = FastAPI()
    
    
    async def verify_token(x_token: Annotated[str, Header()]):
        if x_token != "fake-super-secret-token":
            raise HTTPException(status_code=400, detail="X-Token header invalid")
    
    
    async def verify_key(x_key: Annotated[str, Header()]):
        if x_key != "fake-super-secret-key":
            raise HTTPException(status_code=400, detail="X-Key header invalid")
        return x_key
    
    
    @app.get("/items/", dependencies=[Depends(verify_token), Depends(verify_key)])
    async def read_items():
        return [{"item": "Foo"}, {"item": "Bar"}]
    

ü§ì Other versions and variants

Python 3.9+ - non-Annotated

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import Depends, FastAPI, Header, HTTPException
    
    app = FastAPI()
    
    
    async def verify_token(x_token: str = Header()):
        if x_token != "fake-super-secret-token":
            raise HTTPException(status_code=400, detail="X-Token header invalid")
    
    
    async def verify_key(x_key: str = Header()):
        if x_key != "fake-super-secret-key":
            raise HTTPException(status_code=400, detail="X-Key header invalid")
        return x_key
    
    
    @app.get("/items/", dependencies=[Depends(verify_token), Depends(verify_key)])
    async def read_items():
        return [{"item": "Foo"}, {"item": "Bar"}]
    

### Raise exceptions[¶](#raise-exceptions "Permanent link")

These dependencies can `raise` exceptions, the same as normal dependencies:

Python 3.9+
    
    
    from typing import Annotated
    
    from fastapi import Depends, FastAPI, Header, HTTPException
    
    app = FastAPI()
    
    
    async def verify_token(x_token: Annotated[str, Header()]):
        if x_token != "fake-super-secret-token":
            raise HTTPException(status_code=400, detail="X-Token header invalid")
    
    
    async def verify_key(x_key: Annotated[str, Header()]):
        if x_key != "fake-super-secret-key":
            raise HTTPException(status_code=400, detail="X-Key header invalid")
        return x_key
    
    
    @app.get("/items/", dependencies=[Depends(verify_token), Depends(verify_key)])
    async def read_items():
        return [{"item": "Foo"}, {"item": "Bar"}]
    

ü§ì Other versions and variants

Python 3.9+ - non-Annotated

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import Depends, FastAPI, Header, HTTPException
    
    app = FastAPI()
    
    
    async def verify_token(x_token: str = Header()):
        if x_token != "fake-super-secret-token":
            raise HTTPException(status_code=400, detail="X-Token header invalid")
    
    
    async def verify_key(x_key: str = Header()):
        if x_key != "fake-super-secret-key":
            raise HTTPException(status_code=400, detail="X-Key header invalid")
        return x_key
    
    
    @app.get("/items/", dependencies=[Depends(verify_token), Depends(verify_key)])
    async def read_items():
        return [{"item": "Foo"}, {"item": "Bar"}]
    

### Return values[¶](#return-values "Permanent link")

And they can return values or not, the values won't be used.

So, you can reuse a normal dependency (that returns a value) you already use somewhere else, and even though the value won't be used, the dependency will be executed:

Python 3.9+
    
    
    from typing import Annotated
    
    from fastapi import Depends, FastAPI, Header, HTTPException
    
    app = FastAPI()
    
    
    async def verify_token(x_token: Annotated[str, Header()]):
        if x_token != "fake-super-secret-token":
            raise HTTPException(status_code=400, detail="X-Token header invalid")
    
    
    async def verify_key(x_key: Annotated[str, Header()]):
        if x_key != "fake-super-secret-key":
            raise HTTPException(status_code=400, detail="X-Key header invalid")
        return x_key
    
    
    @app.get("/items/", dependencies=[Depends(verify_token), Depends(verify_key)])
    async def read_items():
        return [{"item": "Foo"}, {"item": "Bar"}]
    

ü§ì Other versions and variants

Python 3.9+ - non-Annotated

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import Depends, FastAPI, Header, HTTPException
    
    app = FastAPI()
    
    
    async def verify_token(x_token: str = Header()):
        if x_token != "fake-super-secret-token":
            raise HTTPException(status_code=400, detail="X-Token header invalid")
    
    
    async def verify_key(x_key: str = Header()):
        if x_key != "fake-super-secret-key":
            raise HTTPException(status_code=400, detail="X-Key header invalid")
        return x_key
    
    
    @app.get("/items/", dependencies=[Depends(verify_token), Depends(verify_key)])
    async def read_items():
        return [{"item": "Foo"}, {"item": "Bar"}]
    

## Dependencies for a group of _path operations_[¶](#dependencies-for-a-group-of-path-operations "Permanent link")

Later, when reading about how to structure bigger applications ([Bigger Applications - Multiple Files](../../bigger-applications/)), possibly with multiple files, you will learn how to declare a single `dependencies` parameter for a group of _path operations_.

## Global Dependencies[¶](#global-dependencies "Permanent link")

Next we will see how to add dependencies to the whole `FastAPI` application, so that they apply to each _path operation_.

---

###### Global Dependencies¶

# Global Dependencies[¶](#global-dependencies "Permanent link")

For some types of applications you might want to add dependencies to the whole application.

Similar to the way you can [add `dependencies` to the _path operation decorators_](../dependencies-in-path-operation-decorators/), you can add them to the `FastAPI` application.

In that case, they will be applied to all the _path operations_ in the application:

Python 3.9+
    
    
    from typing import Annotated
    
    from fastapi import Depends, FastAPI, Header, HTTPException
    
    
    async def verify_token(x_token: Annotated[str, Header()]):
        if x_token != "fake-super-secret-token":
            raise HTTPException(status_code=400, detail="X-Token header invalid")
    
    
    async def verify_key(x_key: Annotated[str, Header()]):
        if x_key != "fake-super-secret-key":
            raise HTTPException(status_code=400, detail="X-Key header invalid")
        return x_key
    
    
    app = FastAPI(dependencies=[Depends(verify_token), Depends(verify_key)])
    
    
    @app.get("/items/")
    async def read_items():
        return [{"item": "Portal Gun"}, {"item": "Plumbus"}]
    
    
    @app.get("/users/")
    async def read_users():
        return [{"username": "Rick"}, {"username": "Morty"}]
    

ü§ì Other versions and variants

Python 3.9+ - non-Annotated

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import Depends, FastAPI, Header, HTTPException
    
    
    async def verify_token(x_token: str = Header()):
        if x_token != "fake-super-secret-token":
            raise HTTPException(status_code=400, detail="X-Token header invalid")
    
    
    async def verify_key(x_key: str = Header()):
        if x_key != "fake-super-secret-key":
            raise HTTPException(status_code=400, detail="X-Key header invalid")
        return x_key
    
    
    app = FastAPI(dependencies=[Depends(verify_token), Depends(verify_key)])
    
    
    @app.get("/items/")
    async def read_items():
        return [{"item": "Portal Gun"}, {"item": "Plumbus"}]
    
    
    @app.get("/users/")
    async def read_users():
        return [{"username": "Rick"}, {"username": "Morty"}]
    

And all the ideas in the section about [adding `dependencies` to the _path operation decorators_](../dependencies-in-path-operation-decorators/) still apply, but in this case, to all of the _path operations_ in the app.

## Dependencies for groups of _path operations_[¶](#dependencies-for-groups-of-path-operations "Permanent link")

Later, when reading about how to structure bigger applications ([Bigger Applications - Multiple Files](../../bigger-applications/)), possibly with multiple files, you will learn how to declare a single `dependencies` parameter for a group of _path operations_.

---

###### Dependencies with yield¶

# Dependencies with yield[¶](#dependencies-with-yield "Permanent link")

FastAPI supports dependencies that do some extra steps after finishing.

To do this, use `yield` instead of `return`, and write the extra steps (code) after.

Tip

Make sure to use `yield` one single time per dependency.

Technical Details

Any function that is valid to use with:

  * [`@contextlib.contextmanager`](https://docs.python.org/3/library/contextlib.html#contextlib.contextmanager) or
  * [`@contextlib.asynccontextmanager`](https://docs.python.org/3/library/contextlib.html#contextlib.asynccontextmanager)

would be valid to use as a **FastAPI** dependency.

In fact, FastAPI uses those two decorators internally.

## A database dependency with `yield`[¶](#a-database-dependency-with-yield "Permanent link")

For example, you could use this to create a database session and close it after finishing.

Only the code prior to and including the `yield` statement is executed before creating a response:

Python 3.9+
    
    
    async def get_db():
        db = DBSession()
        try:
            yield db
        finally:
            db.close()
    

The yielded value is what is injected into _path operations_ and other dependencies:

Python 3.9+
    
    
    async def get_db():
        db = DBSession()
        try:
            yield db
        finally:
            db.close()
    

The code following the `yield` statement is executed after the response:

Python 3.9+
    
    
    async def get_db():
        db = DBSession()
        try:
            yield db
        finally:
            db.close()
    

Tip

You can use `async` or regular functions.

**FastAPI** will do the right thing with each, the same as with normal dependencies.

## A dependency with `yield` and `try`[¶](#a-dependency-with-yield-and-try "Permanent link")

If you use a `try` block in a dependency with `yield`, you'll receive any exception that was thrown when using the dependency.

For example, if some code at some point in the middle, in another dependency or in a _path operation_ , made a database transaction "rollback" or created any other exception, you would receive the exception in your dependency.

So, you can look for that specific exception inside the dependency with `except SomeException`.

In the same way, you can use `finally` to make sure the exit steps are executed, no matter if there was an exception or not.

Python 3.9+
    
    
    async def get_db():
        db = DBSession()
        try:
            yield db
        finally:
            db.close()
    

## Sub-dependencies with `yield`[¶](#sub-dependencies-with-yield "Permanent link")

You can have sub-dependencies and "trees" of sub-dependencies of any size and shape, and any or all of them can use `yield`.

**FastAPI** will make sure that the "exit code" in each dependency with `yield` is run in the correct order.

For example, `dependency_c` can have a dependency on `dependency_b`, and `dependency_b` on `dependency_a`:

Python 3.9+
    
    
    from typing import Annotated
    
    from fastapi import Depends
    
    
    async def dependency_a():
        dep_a = generate_dep_a()
        try:
            yield dep_a
        finally:
            dep_a.close()
    
    
    async def dependency_b(dep_a: Annotated[DepA, Depends(dependency_a)]):
        dep_b = generate_dep_b()
        try:
            yield dep_b
        finally:
            dep_b.close(dep_a)
    
    
    async def dependency_c(dep_b: Annotated[DepB, Depends(dependency_b)]):
        dep_c = generate_dep_c()
        try:
            yield dep_c
        finally:
            dep_c.close(dep_b)
    

ü§ì Other versions and variants

Python 3.9+ - non-Annotated

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import Depends
    
    
    async def dependency_a():
        dep_a = generate_dep_a()
        try:
            yield dep_a
        finally:
            dep_a.close()
    
    
    async def dependency_b(dep_a=Depends(dependency_a)):
        dep_b = generate_dep_b()
        try:
            yield dep_b
        finally:
            dep_b.close(dep_a)
    
    
    async def dependency_c(dep_b=Depends(dependency_b)):
        dep_c = generate_dep_c()
        try:
            yield dep_c
        finally:
            dep_c.close(dep_b)
    

And all of them can use `yield`.

In this case `dependency_c`, to execute its exit code, needs the value from `dependency_b` (here named `dep_b`) to still be available.

And, in turn, `dependency_b` needs the value from `dependency_a` (here named `dep_a`) to be available for its exit code.

Python 3.9+
    
    
    from typing import Annotated
    
    from fastapi import Depends
    
    
    async def dependency_a():
        dep_a = generate_dep_a()
        try:
            yield dep_a
        finally:
            dep_a.close()
    
    
    async def dependency_b(dep_a: Annotated[DepA, Depends(dependency_a)]):
        dep_b = generate_dep_b()
        try:
            yield dep_b
        finally:
            dep_b.close(dep_a)
    
    
    async def dependency_c(dep_b: Annotated[DepB, Depends(dependency_b)]):
        dep_c = generate_dep_c()
        try:
            yield dep_c
        finally:
            dep_c.close(dep_b)
    

ü§ì Other versions and variants

Python 3.9+ - non-Annotated

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import Depends
    
    
    async def dependency_a():
        dep_a = generate_dep_a()
        try:
            yield dep_a
        finally:
            dep_a.close()
    
    
    async def dependency_b(dep_a=Depends(dependency_a)):
        dep_b = generate_dep_b()
        try:
            yield dep_b
        finally:
            dep_b.close(dep_a)
    
    
    async def dependency_c(dep_b=Depends(dependency_b)):
        dep_c = generate_dep_c()
        try:
            yield dep_c
        finally:
            dep_c.close(dep_b)
    

The same way, you could have some dependencies with `yield` and some other dependencies with `return`, and have some of those depend on some of the others.

And you could have a single dependency that requires several other dependencies with `yield`, etc.

You can have any combinations of dependencies that you want.

**FastAPI** will make sure everything is run in the correct order.

Technical Details

This works thanks to Python's [Context Managers](https://docs.python.org/3/library/contextlib.html).

**FastAPI** uses them internally to achieve this.

## Dependencies with `yield` and `HTTPException`[¶](#dependencies-with-yield-and-httpexception "Permanent link")

You saw that you can use dependencies with `yield` and have `try` blocks that try to execute some code and then run some exit code after `finally`.

You can also use `except` to catch the exception that was raised and do something with it.

For example, you can raise a different exception, like `HTTPException`.

Tip

This is a somewhat advanced technique, and in most of the cases you won't really need it, as you can raise exceptions (including `HTTPException`) from inside of the rest of your application code, for example, in the _path operation function_.

But it's there for you if you need it. ü§ì

Python 3.9+
    
    
    from typing import Annotated
    
    from fastapi import Depends, FastAPI, HTTPException
    
    app = FastAPI()
    
    
    data = {
        "plumbus": {"description": "Freshly pickled plumbus", "owner": "Morty"},
        "portal-gun": {"description": "Gun to create portals", "owner": "Rick"},
    }
    
    
    class OwnerError(Exception):
        pass
    
    
    def get_username():
        try:
            yield "Rick"
        except OwnerError as e:
            raise HTTPException(status_code=400, detail=f"Owner error: {e}")
    
    
    @app.get("/items/{item_id}")
    def get_item(item_id: str, username: Annotated[str, Depends(get_username)]):
        if item_id not in data:
            raise HTTPException(status_code=404, detail="Item not found")
        item = data[item_id]
        if item["owner"] != username:
            raise OwnerError(username)
        return item
    

ü§ì Other versions and variants

Python 3.9+ - non-Annotated

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import Depends, FastAPI, HTTPException
    
    app = FastAPI()
    
    
    data = {
        "plumbus": {"description": "Freshly pickled plumbus", "owner": "Morty"},
        "portal-gun": {"description": "Gun to create portals", "owner": "Rick"},
    }
    
    
    class OwnerError(Exception):
        pass
    
    
    def get_username():
        try:
            yield "Rick"
        except OwnerError as e:
            raise HTTPException(status_code=400, detail=f"Owner error: {e}")
    
    
    @app.get("/items/{item_id}")
    def get_item(item_id: str, username: str = Depends(get_username)):
        if item_id not in data:
            raise HTTPException(status_code=404, detail="Item not found")
        item = data[item_id]
        if item["owner"] != username:
            raise OwnerError(username)
        return item
    

If you want to catch exceptions and create a custom response based on that, create a [Custom Exception Handler](../../handling-errors/#install-custom-exception-handlers).

## Dependencies with `yield` and `except`[¶](#dependencies-with-yield-and-except "Permanent link")

If you catch an exception using `except` in a dependency with `yield` and you don't raise it again (or raise a new exception), FastAPI won't be able to notice there was an exception, the same way that would happen with regular Python:

Python 3.9+
    
    
    from typing import Annotated
    
    from fastapi import Depends, FastAPI, HTTPException
    
    app = FastAPI()
    
    
    class InternalError(Exception):
        pass
    
    
    def get_username():
        try:
            yield "Rick"
        except InternalError:
            print("Oops, we didn't raise again, Britney üò±")
    
    
    @app.get("/items/{item_id}")
    def get_item(item_id: str, username: Annotated[str, Depends(get_username)]):
        if item_id == "portal-gun":
            raise InternalError(
                f"The portal gun is too dangerous to be owned by {username}"
            )
        if item_id != "plumbus":
            raise HTTPException(
                status_code=404, detail="Item not found, there's only a plumbus here"
            )
        return item_id
    

ü§ì Other versions and variants

Python 3.9+ - non-Annotated

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import Depends, FastAPI, HTTPException
    
    app = FastAPI()
    
    
    class InternalError(Exception):
        pass
    
    
    def get_username():
        try:
            yield "Rick"
        except InternalError:
            print("Oops, we didn't raise again, Britney üò±")
    
    
    @app.get("/items/{item_id}")
    def get_item(item_id: str, username: str = Depends(get_username)):
        if item_id == "portal-gun":
            raise InternalError(
                f"The portal gun is too dangerous to be owned by {username}"
            )
        if item_id != "plumbus":
            raise HTTPException(
                status_code=404, detail="Item not found, there's only a plumbus here"
            )
        return item_id
    

In this case, the client will see an _HTTP 500 Internal Server Error_ response as it should, given that we are not raising an `HTTPException` or similar, but the server will **not have any logs** or any other indication of what was the error. üò±

### Always `raise` in Dependencies with `yield` and `except`[¶](#always-raise-in-dependencies-with-yield-and-except "Permanent link")

If you catch an exception in a dependency with `yield`, unless you are raising another `HTTPException` or similar, **you should re-raise the original exception**.

You can re-raise the same exception using `raise`:

Python 3.9+
    
    
    from typing import Annotated
    
    from fastapi import Depends, FastAPI, HTTPException
    
    app = FastAPI()
    
    
    class InternalError(Exception):
        pass
    
    
    def get_username():
        try:
            yield "Rick"
        except InternalError:
            print("We don't swallow the internal error here, we raise again üòé")
            raise
    
    
    @app.get("/items/{item_id}")
    def get_item(item_id: str, username: Annotated[str, Depends(get_username)]):
        if item_id == "portal-gun":
            raise InternalError(
                f"The portal gun is too dangerous to be owned by {username}"
            )
        if item_id != "plumbus":
            raise HTTPException(
                status_code=404, detail="Item not found, there's only a plumbus here"
            )
        return item_id
    

ü§ì Other versions and variants

Python 3.9+ - non-Annotated

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import Depends, FastAPI, HTTPException
    
    app = FastAPI()
    
    
    class InternalError(Exception):
        pass
    
    
    def get_username():
        try:
            yield "Rick"
        except InternalError:
            print("We don't swallow the internal error here, we raise again üòé")
            raise
    
    
    @app.get("/items/{item_id}")
    def get_item(item_id: str, username: str = Depends(get_username)):
        if item_id == "portal-gun":
            raise InternalError(
                f"The portal gun is too dangerous to be owned by {username}"
            )
        if item_id != "plumbus":
            raise HTTPException(
                status_code=404, detail="Item not found, there's only a plumbus here"
            )
        return item_id
    

Now the client will get the same _HTTP 500 Internal Server Error_ response, but the server will have our custom `InternalError` in the logs. üòé

## Execution of dependencies with `yield`[¶](#execution-of-dependencies-with-yield "Permanent link")

The sequence of execution is more or less like this diagram. Time flows from top to bottom. And each column is one of the parts interacting or executing code.
    
    
    sequenceDiagram
    
    participant client as Client
    participant handler as Exception handler
    participant dep as Dep with yield
    participant operation as Path Operation
    participant tasks as Background tasks
    
        Note over client,operation: Can raise exceptions, including HTTPException
        client ->> dep: Start request
        Note over dep: Run code up to yield
        opt raise Exception
            dep -->> handler: Raise Exception
            handler -->> client: HTTP error response
        end
        dep ->> operation: Run dependency, e.g. DB session
        opt raise
            operation -->> dep: Raise Exception (e.g. HTTPException)
            opt handle
                dep -->> dep: Can catch exception, raise a new HTTPException, raise other exception
            end
            handler -->> client: HTTP error response
        end
    
        operation ->> client: Return response to client
        Note over client,operation: Response is already sent, can't change it anymore
        opt Tasks
            operation -->> tasks: Send background tasks
        end
        opt Raise other exception
            tasks -->> tasks: Handle exceptions in the background task code
        end

Info

Only **one response** will be sent to the client. It might be one of the error responses or it will be the response from the _path operation_.

After one of those responses is sent, no other response can be sent.

Tip

If you raise any exception in the code from the _path operation function_ , it will be passed to the dependencies with yield, including `HTTPException`. In most cases you will want to re-raise that same exception or a new one from the dependency with `yield` to make sure it's properly handled.

## Early exit and `scope`[¶](#early-exit-and-scope "Permanent link")

Normally the exit code of dependencies with `yield` is executed **after the response** is sent to the client.

But if you know that you won't need to use the dependency after returning from the _path operation function_ , you can use `Depends(scope="function")` to tell FastAPI that it should close the dependency after the _path operation function_ returns, but **before** the **response is sent**.

Python 3.9+
    
    
    from typing import Annotated
    
    from fastapi import Depends, FastAPI
    
    app = FastAPI()
    
    
    def get_username():
        try:
            yield "Rick"
        finally:
            print("Cleanup up before response is sent")
    
    
    @app.get("/users/me")
    def get_user_me(username: Annotated[str, Depends(get_username, scope="function")]):
        return username
    

ü§ì Other versions and variants

Python 3.9+ - non-Annotated

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import Depends, FastAPI
    
    app = FastAPI()
    
    
    def get_username():
        try:
            yield "Rick"
        finally:
            print("Cleanup up before response is sent")
    
    
    @app.get("/users/me")
    def get_user_me(username: str = Depends(get_username, scope="function")):
        return username
    

`Depends()` receives a `scope` parameter that can be:

  * `"function"`: start the dependency before the _path operation function_ that handles the request, end the dependency after the _path operation function_ ends, but **before** the response is sent back to the client. So, the dependency function will be executed **around** the _path operation**function**_.
  * `"request"`: start the dependency before the _path operation function_ that handles the request (similar to when using `"function"`), but end **after** the response is sent back to the client. So, the dependency function will be executed **around** the **request** and response cycle.

If not specified and the dependency has `yield`, it will have a `scope` of `"request"` by default.

### `scope` for sub-dependencies[¶](#scope-for-sub-dependencies "Permanent link")

When you declare a dependency with a `scope="request"` (the default), any sub-dependency needs to also have a `scope` of `"request"`.

But a dependency with `scope` of `"function"` can have dependencies with `scope` of `"function"` and `scope` of `"request"`.

This is because any dependency needs to be able to run its exit code before the sub-dependencies, as it might need to still use them during its exit code.
    
    
    sequenceDiagram
    
    participant client as Client
    participant dep_req as Dep scope="request"
    participant dep_func as Dep scope="function"
    participant operation as Path Operation
    
        client ->> dep_req: Start request
        Note over dep_req: Run code up to yield
        dep_req ->> dep_func: Pass dependency
        Note over dep_func: Run code up to yield
        dep_func ->> operation: Run path operation with dependency
        operation ->> dep_func: Return from path operation
        Note over dep_func: Run code after yield
        Note over dep_func: ‚úÖ Dependency closed
        dep_func ->> client: Send response to client
        Note over client: Response sent
        Note over dep_req: Run code after yield
        Note over dep_req: ‚úÖ Dependency closed

## Dependencies with `yield`, `HTTPException`, `except` and Background Tasks[¶](#dependencies-with-yield-httpexception-except-and-background-tasks "Permanent link")

Dependencies with `yield` have evolved over time to cover different use cases and fix some issues.

If you want to see what has changed in different versions of FastAPI, you can read more about it in the advanced guide, in [Advanced Dependencies - Dependencies with `yield`, `HTTPException`, `except` and Background Tasks](../../../advanced/advanced-dependencies/#dependencies-with-yield-httpexception-except-and-background-tasks).

## Context Managers[¶](#context-managers "Permanent link")

### What are "Context Managers"[¶](#what-are-context-managers "Permanent link")

"Context Managers" are any of those Python objects that you can use in a `with` statement.

For example, [you can use `with` to read a file](https://docs.python.org/3/tutorial/inputoutput.html#reading-and-writing-files):
    
    
    with open("./somefile.txt") as f:
        contents = f.read()
        print(contents)
    

Underneath, the `open("./somefile.txt")` creates an object that is called a "Context Manager".

When the `with` block finishes, it makes sure to close the file, even if there were exceptions.

When you create a dependency with `yield`, **FastAPI** will internally create a context manager for it, and combine it with some other related tools.

### Using context managers in dependencies with `yield`[¶](#using-context-managers-in-dependencies-with-yield "Permanent link")

Warning

This is, more or less, an "advanced" idea.

If you are just starting with **FastAPI** you might want to skip it for now.

In Python, you can create Context Managers by [creating a class with two methods: `__enter__()` and `__exit__()`](https://docs.python.org/3/reference/datamodel.html#context-managers).

You can also use them inside of **FastAPI** dependencies with `yield` by using `with` or `async with` statements inside of the dependency function:

Python 3.9+
    
    
    class MySuperContextManager:
        def __init__(self):
            self.db = DBSession()
    
        def __enter__(self):
            return self.db
    
        def __exit__(self, exc_type, exc_value, traceback):
            self.db.close()
    
    
    async def get_db():
        with MySuperContextManager() as db:
            yield db
    

Tip

Another way to create a context manager is with:

  * [`@contextlib.contextmanager`](https://docs.python.org/3/library/contextlib.html#contextlib.contextmanager) or
  * [`@contextlib.asynccontextmanager`](https://docs.python.org/3/library/contextlib.html#contextlib.asynccontextmanager)

using them to decorate a function with a single `yield`.

That's what **FastAPI** uses internally for dependencies with `yield`.

But you don't have to use the decorators for FastAPI dependencies (and you shouldn't).

FastAPI will do it for you internally.
  *[extra steps after finishing]: sometimes also called "exit code", "cleanup code", "teardown code", "closing code", "context manager exit code", etc.

---

###### Security¶

# Security[¶](#security "Permanent link")

There are many ways to handle security, authentication and authorization.

And it normally is a complex and "difficult" topic.

In many frameworks and systems just handling security and authentication takes a big amount of effort and code (in many cases it can be 50% or more of all the code written).

**FastAPI** provides several tools to help you deal with **Security** easily, rapidly, in a standard way, without having to study and learn all the security specifications.

But first, let's check some small concepts.

## In a hurry?[¶](#in-a-hurry "Permanent link")

If you don't care about any of these terms and you just need to add security with authentication based on username and password _right now_ , skip to the next chapters.

## OAuth2[¶](#oauth2 "Permanent link")

OAuth2 is a specification that defines several ways to handle authentication and authorization.

It is quite an extensive specification and covers several complex use cases.

It includes ways to authenticate using a "third party".

That's what all the systems with "login with Facebook, Google, X (Twitter), GitHub" use underneath.

### OAuth 1[¶](#oauth-1 "Permanent link")

There was an OAuth 1, which is very different from OAuth2, and more complex, as it included direct specifications on how to encrypt the communication.

It is not very popular or used nowadays.

OAuth2 doesn't specify how to encrypt the communication, it expects you to have your application served with HTTPS.

Tip

In the section about **deployment** you will see how to set up HTTPS for free, using Traefik and Let's Encrypt.

## OpenID Connect[¶](#openid-connect "Permanent link")

OpenID Connect is another specification, based on **OAuth2**.

It just extends OAuth2 specifying some things that are relatively ambiguous in OAuth2, to try to make it more interoperable.

For example, Google login uses OpenID Connect (which underneath uses OAuth2).

But Facebook login doesn't support OpenID Connect. It has its own flavor of OAuth2.

### OpenID (not "OpenID Connect")[¶](#openid-not-openid-connect "Permanent link")

There was also an "OpenID" specification. That tried to solve the same thing as **OpenID Connect** , but was not based on OAuth2.

So, it was a complete additional system.

It is not very popular or used nowadays.

## OpenAPI[¶](#openapi "Permanent link")

OpenAPI (previously known as Swagger) is the open specification for building APIs (now part of the Linux Foundation).

**FastAPI** is based on **OpenAPI**.

That's what makes it possible to have multiple automatic interactive documentation interfaces, code generation, etc.

OpenAPI has a way to define multiple security "schemes".

By using them, you can take advantage of all these standard-based tools, including these interactive documentation systems.

OpenAPI defines the following security schemes:

  * `apiKey`: an application specific key that can come from:
    * A query parameter.
    * A header.
    * A cookie.
  * `http`: standard HTTP authentication systems, including:
    * `bearer`: a header `Authorization` with a value of `Bearer` plus a token. This is inherited from OAuth2.
    * HTTP Basic authentication.
    * HTTP Digest, etc.
  * `oauth2`: all the OAuth2 ways to handle security (called "flows").
    * Several of these flows are appropriate for building an OAuth 2.0 authentication provider (like Google, Facebook, X (Twitter), GitHub, etc):
      * `implicit`
      * `clientCredentials`
      * `authorizationCode`
    * But there is one specific "flow" that can be perfectly used for handling authentication in the same application directly:
      * `password`: some next chapters will cover examples of this.
  * `openIdConnect`: has a way to define how to discover OAuth2 authentication data automatically.
    * This automatic discovery is what is defined in the OpenID Connect specification.

Tip

Integrating other authentication/authorization providers like Google, Facebook, X (Twitter), GitHub, etc. is also possible and relatively easy.

The most complex problem is building an authentication/authorization provider like those, but **FastAPI** gives you the tools to do it easily, while doing the heavy lifting for you.

## **FastAPI** utilities[¶](#fastapi-utilities "Permanent link")

FastAPI provides several tools for each of these security schemes in the `fastapi.security` module that simplify using these security mechanisms.

In the next chapters you will see how to add security to your API using those tools provided by **FastAPI**.

And you will also see how it gets automatically integrated into the interactive documentation system.

---

###### Security - First Steps¶

# Security - First Steps[¶](#security-first-steps "Permanent link")

Let's imagine that you have your **backend** API in some domain.

And you have a **frontend** in another domain or in a different path of the same domain (or in a mobile application).

And you want to have a way for the frontend to authenticate with the backend, using a **username** and **password**.

We can use **OAuth2** to build that with **FastAPI**.

But let's save you the time of reading the full long specification just to find those little pieces of information you need.

Let's use the tools provided by **FastAPI** to handle security.

## How it looks[¶](#how-it-looks "Permanent link")

Let's first just use the code and see how it works, and then we'll come back to understand what's happening.

## Create `main.py`[¶](#create-main-py "Permanent link")

Copy the example in a file `main.py`:

Python 3.9+
    
    
    from typing import Annotated
    
    from fastapi import Depends, FastAPI
    from fastapi.security import OAuth2PasswordBearer
    
    app = FastAPI()
    
    oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")
    
    
    @app.get("/items/")
    async def read_items(token: Annotated[str, Depends(oauth2_scheme)]):
        return {"token": token}
    

ü§ì Other versions and variants

Python 3.9+ - non-Annotated

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import Depends, FastAPI
    from fastapi.security import OAuth2PasswordBearer
    
    app = FastAPI()
    
    oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")
    
    
    @app.get("/items/")
    async def read_items(token: str = Depends(oauth2_scheme)):
        return {"token": token}
    

## Run it[¶](#run-it "Permanent link")

Info

The [`python-multipart`](https://github.com/Kludex/python-multipart) package is automatically installed with **FastAPI** when you run the `pip install "fastapi[standard]"` command.

However, if you use the `pip install fastapi` command, the `python-multipart` package is not included by default.

To install it manually, make sure you create a [virtual environment](../../../virtual-environments/), activate it, and then install it with:
    
    
    $ pip install python-multipart
    

This is because **OAuth2** uses "form data" for sending the `username` and `password`.

Run the example with:
    
    
    $ fastapi dev main.py
    
    <span style="color: green;">INFO</span>:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
    

## Check it[¶](#check-it "Permanent link")

Go to the interactive docs at: <http://127.0.0.1:8000/docs>.

You will see something like this:

![](/img/tutorial/security/image01.png)

Authorize button!

You already have a shiny new "Authorize" button.

And your _path operation_ has a little lock in the top-right corner that you can click.

And if you click it, you have a little authorization form to type a `username` and `password` (and other optional fields):

![](/img/tutorial/security/image02.png)

Note

It doesn't matter what you type in the form, it won't work yet. But we'll get there.

This is of course not the frontend for the final users, but it's a great automatic tool to document interactively all your API.

It can be used by the frontend team (that can also be yourself).

It can be used by third party applications and systems.

And it can also be used by yourself, to debug, check and test the same application.

## The `password` flow[¶](#the-password-flow "Permanent link")

Now let's go back a bit and understand what is all that.

The `password` "flow" is one of the ways ("flows") defined in OAuth2, to handle security and authentication.

OAuth2 was designed so that the backend or API could be independent of the server that authenticates the user.

But in this case, the same **FastAPI** application will handle the API and the authentication.

So, let's review it from that simplified point of view:

  * The user types the `username` and `password` in the frontend, and hits `Enter`.
  * The frontend (running in the user's browser) sends that `username` and `password` to a specific URL in our API (declared with `tokenUrl="token"`).
  * The API checks that `username` and `password`, and responds with a "token" (we haven't implemented any of this yet).
    * A "token" is just a string with some content that we can use later to verify this user.
    * Normally, a token is set to expire after some time.
      * So, the user will have to log in again at some point later.
      * And if the token is stolen, the risk is less. It is not like a permanent key that will work forever (in most of the cases).
  * The frontend stores that token temporarily somewhere.
  * The user clicks in the frontend to go to another section of the frontend web app.
  * The frontend needs to fetch some more data from the API.
    * But it needs authentication for that specific endpoint.
    * So, to authenticate with our API, it sends a header `Authorization` with a value of `Bearer` plus the token.
    * If the token contains `foobar`, the content of the `Authorization` header would be: `Bearer foobar`.

## **FastAPI** 's `OAuth2PasswordBearer`[¶](#fastapis-oauth2passwordbearer "Permanent link")

**FastAPI** provides several tools, at different levels of abstraction, to implement these security features.

In this example we are going to use **OAuth2** , with the **Password** flow, using a **Bearer** token. We do that using the `OAuth2PasswordBearer` class.

Info

A "bearer" token is not the only option.

But it's the best one for our use case.

And it might be the best for most use cases, unless you are an OAuth2 expert and know exactly why there's another option that better suits your needs.

In that case, **FastAPI** also provides you with the tools to build it.

When we create an instance of the `OAuth2PasswordBearer` class we pass in the `tokenUrl` parameter. This parameter contains the URL that the client (the frontend running in the user's browser) will use to send the `username` and `password` in order to get a token.

Python 3.9+
    
    
    from typing import Annotated
    
    from fastapi import Depends, FastAPI
    from fastapi.security import OAuth2PasswordBearer
    
    app = FastAPI()
    
    oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")
    
    
    @app.get("/items/")
    async def read_items(token: Annotated[str, Depends(oauth2_scheme)]):
        return {"token": token}
    

ü§ì Other versions and variants

Python 3.9+ - non-Annotated

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import Depends, FastAPI
    from fastapi.security import OAuth2PasswordBearer
    
    app = FastAPI()
    
    oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")
    
    
    @app.get("/items/")
    async def read_items(token: str = Depends(oauth2_scheme)):
        return {"token": token}
    

Tip

Here `tokenUrl="token"` refers to a relative URL `token` that we haven't created yet. As it's a relative URL, it's equivalent to `./token`.

Because we are using a relative URL, if your API was located at `https://example.com/`, then it would refer to `https://example.com/token`. But if your API was located at `https://example.com/api/v1/`, then it would refer to `https://example.com/api/v1/token`.

Using a relative URL is important to make sure your application keeps working even in an advanced use case like [Behind a Proxy](../../../advanced/behind-a-proxy/).

This parameter doesn't create that endpoint / _path operation_ , but declares that the URL `/token` will be the one that the client should use to get the token. That information is used in OpenAPI, and then in the interactive API documentation systems.

We will soon also create the actual path operation.

Info

If you are a very strict "Pythonista" you might dislike the style of the parameter name `tokenUrl` instead of `token_url`.

That's because it is using the same name as in the OpenAPI spec. So that if you need to investigate more about any of these security schemes you can just copy and paste it to find more information about it.

The `oauth2_scheme` variable is an instance of `OAuth2PasswordBearer`, but it is also a "callable".

It could be called as:
    
    
    oauth2_scheme(some, parameters)
    

So, it can be used with `Depends`.

### Use it[¶](#use-it "Permanent link")

Now you can pass that `oauth2_scheme` in a dependency with `Depends`.

Python 3.9+
    
    
    from typing import Annotated
    
    from fastapi import Depends, FastAPI
    from fastapi.security import OAuth2PasswordBearer
    
    app = FastAPI()
    
    oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")
    
    
    @app.get("/items/")
    async def read_items(token: Annotated[str, Depends(oauth2_scheme)]):
        return {"token": token}
    

ü§ì Other versions and variants

Python 3.9+ - non-Annotated

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import Depends, FastAPI
    from fastapi.security import OAuth2PasswordBearer
    
    app = FastAPI()
    
    oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")
    
    
    @app.get("/items/")
    async def read_items(token: str = Depends(oauth2_scheme)):
        return {"token": token}
    

This dependency will provide a `str` that is assigned to the parameter `token` of the _path operation function_.

**FastAPI** will know that it can use this dependency to define a "security scheme" in the OpenAPI schema (and the automatic API docs).

Technical Details

**FastAPI** will know that it can use the class `OAuth2PasswordBearer` (declared in a dependency) to define the security scheme in OpenAPI because it inherits from `fastapi.security.oauth2.OAuth2`, which in turn inherits from `fastapi.security.base.SecurityBase`.

All the security utilities that integrate with OpenAPI (and the automatic API docs) inherit from `SecurityBase`, that's how **FastAPI** can know how to integrate them in OpenAPI.

## What it does[¶](#what-it-does "Permanent link")

It will go and look in the request for that `Authorization` header, check if the value is `Bearer` plus some token, and will return the token as a `str`.

If it doesn't see an `Authorization` header, or the value doesn't have a `Bearer` token, it will respond with a 401 status code error (`UNAUTHORIZED`) directly.

You don't even have to check if the token exists to return an error. You can be sure that if your function is executed, it will have a `str` in that token.

You can try it already in the interactive docs:

![](/img/tutorial/security/image03.png)

We are not verifying the validity of the token yet, but that's a start already.

## Recap[¶](#recap "Permanent link")

So, in just 3 or 4 extra lines, you already have some primitive form of security.

---

###### Get Current User¶

# Get Current User[¶](#get-current-user "Permanent link")

In the previous chapter the security system (which is based on the dependency injection system) was giving the _path operation function_ a `token` as a `str`:

Python 3.9+
    
    
    from typing import Annotated
    
    from fastapi import Depends, FastAPI
    from fastapi.security import OAuth2PasswordBearer
    
    app = FastAPI()
    
    oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")
    
    
    @app.get("/items/")
    async def read_items(token: Annotated[str, Depends(oauth2_scheme)]):
        return {"token": token}
    

ü§ì Other versions and variants

Python 3.9+ - non-Annotated

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import Depends, FastAPI
    from fastapi.security import OAuth2PasswordBearer
    
    app = FastAPI()
    
    oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")
    
    
    @app.get("/items/")
    async def read_items(token: str = Depends(oauth2_scheme)):
        return {"token": token}
    

But that is still not that useful.

Let's make it give us the current user.

## Create a user model[¶](#create-a-user-model "Permanent link")

First, let's create a Pydantic user model.

The same way we use Pydantic to declare bodies, we can use it anywhere else:

Python 3.10+
    
    
    from typing import Annotated
    
    from fastapi import Depends, FastAPI
    from fastapi.security import OAuth2PasswordBearer
    from pydantic import BaseModel
    
    app = FastAPI()
    
    oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")
    
    
    class User(BaseModel):
        username: str
        email: str | None = None
        full_name: str | None = None
        disabled: bool | None = None
    
    
    def fake_decode_token(token):
        return User(
            username=token + "fakedecoded", email="john@example.com", full_name="John Doe"
        )
    
    
    async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):
        user = fake_decode_token(token)
        return user
    
    
    @app.get("/users/me")
    async def read_users_me(current_user: Annotated[User, Depends(get_current_user)]):
        return current_user
    

ü§ì Other versions and variants

Python 3.9+Python 3.10+ - non-AnnotatedPython 3.9+ - non-Annotated
    
    
    from typing import Annotated, Union
    
    from fastapi import Depends, FastAPI
    from fastapi.security import OAuth2PasswordBearer
    from pydantic import BaseModel
    
    app = FastAPI()
    
    oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")
    
    
    class User(BaseModel):
        username: str
        email: Union[str, None] = None
        full_name: Union[str, None] = None
        disabled: Union[bool, None] = None
    
    
    def fake_decode_token(token):
        return User(
            username=token + "fakedecoded", email="john@example.com", full_name="John Doe"
        )
    
    
    async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):
        user = fake_decode_token(token)
        return user
    
    
    @app.get("/users/me")
    async def read_users_me(current_user: Annotated[User, Depends(get_current_user)]):
        return current_user
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import Depends, FastAPI
    from fastapi.security import OAuth2PasswordBearer
    from pydantic import BaseModel
    
    app = FastAPI()
    
    oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")
    
    
    class User(BaseModel):
        username: str
        email: str | None = None
        full_name: str | None = None
        disabled: bool | None = None
    
    
    def fake_decode_token(token):
        return User(
            username=token + "fakedecoded", email="john@example.com", full_name="John Doe"
        )
    
    
    async def get_current_user(token: str = Depends(oauth2_scheme)):
        user = fake_decode_token(token)
        return user
    
    
    @app.get("/users/me")
    async def read_users_me(current_user: User = Depends(get_current_user)):
        return current_user
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from typing import Union
    
    from fastapi import Depends, FastAPI
    from fastapi.security import OAuth2PasswordBearer
    from pydantic import BaseModel
    
    app = FastAPI()
    
    oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")
    
    
    class User(BaseModel):
        username: str
        email: Union[str, None] = None
        full_name: Union[str, None] = None
        disabled: Union[bool, None] = None
    
    
    def fake_decode_token(token):
        return User(
            username=token + "fakedecoded", email="john@example.com", full_name="John Doe"
        )
    
    
    async def get_current_user(token: str = Depends(oauth2_scheme)):
        user = fake_decode_token(token)
        return user
    
    
    @app.get("/users/me")
    async def read_users_me(current_user: User = Depends(get_current_user)):
        return current_user
    

## Create a `get_current_user` dependency[¶](#create-a-get-current-user-dependency "Permanent link")

Let's create a dependency `get_current_user`.

Remember that dependencies can have sub-dependencies?

`get_current_user` will have a dependency with the same `oauth2_scheme` we created before.

The same as we were doing before in the _path operation_ directly, our new dependency `get_current_user` will receive a `token` as a `str` from the sub-dependency `oauth2_scheme`:

Python 3.10+
    
    
    from typing import Annotated
    
    from fastapi import Depends, FastAPI
    from fastapi.security import OAuth2PasswordBearer
    from pydantic import BaseModel
    
    app = FastAPI()
    
    oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")
    
    
    class User(BaseModel):
        username: str
        email: str | None = None
        full_name: str | None = None
        disabled: bool | None = None
    
    
    def fake_decode_token(token):
        return User(
            username=token + "fakedecoded", email="john@example.com", full_name="John Doe"
        )
    
    
    async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):
        user = fake_decode_token(token)
        return user
    
    
    @app.get("/users/me")
    async def read_users_me(current_user: Annotated[User, Depends(get_current_user)]):
        return current_user
    

ü§ì Other versions and variants

Python 3.9+Python 3.10+ - non-AnnotatedPython 3.9+ - non-Annotated
    
    
    from typing import Annotated, Union
    
    from fastapi import Depends, FastAPI
    from fastapi.security import OAuth2PasswordBearer
    from pydantic import BaseModel
    
    app = FastAPI()
    
    oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")
    
    
    class User(BaseModel):
        username: str
        email: Union[str, None] = None
        full_name: Union[str, None] = None
        disabled: Union[bool, None] = None
    
    
    def fake_decode_token(token):
        return User(
            username=token + "fakedecoded", email="john@example.com", full_name="John Doe"
        )
    
    
    async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):
        user = fake_decode_token(token)
        return user
    
    
    @app.get("/users/me")
    async def read_users_me(current_user: Annotated[User, Depends(get_current_user)]):
        return current_user
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import Depends, FastAPI
    from fastapi.security import OAuth2PasswordBearer
    from pydantic import BaseModel
    
    app = FastAPI()
    
    oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")
    
    
    class User(BaseModel):
        username: str
        email: str | None = None
        full_name: str | None = None
        disabled: bool | None = None
    
    
    def fake_decode_token(token):
        return User(
            username=token + "fakedecoded", email="john@example.com", full_name="John Doe"
        )
    
    
    async def get_current_user(token: str = Depends(oauth2_scheme)):
        user = fake_decode_token(token)
        return user
    
    
    @app.get("/users/me")
    async def read_users_me(current_user: User = Depends(get_current_user)):
        return current_user
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from typing import Union
    
    from fastapi import Depends, FastAPI
    from fastapi.security import OAuth2PasswordBearer
    from pydantic import BaseModel
    
    app = FastAPI()
    
    oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")
    
    
    class User(BaseModel):
        username: str
        email: Union[str, None] = None
        full_name: Union[str, None] = None
        disabled: Union[bool, None] = None
    
    
    def fake_decode_token(token):
        return User(
            username=token + "fakedecoded", email="john@example.com", full_name="John Doe"
        )
    
    
    async def get_current_user(token: str = Depends(oauth2_scheme)):
        user = fake_decode_token(token)
        return user
    
    
    @app.get("/users/me")
    async def read_users_me(current_user: User = Depends(get_current_user)):
        return current_user
    

## Get the user[¶](#get-the-user "Permanent link")

`get_current_user` will use a (fake) utility function we created, that takes a token as a `str` and returns our Pydantic `User` model:

Python 3.10+
    
    
    from typing import Annotated
    
    from fastapi import Depends, FastAPI
    from fastapi.security import OAuth2PasswordBearer
    from pydantic import BaseModel
    
    app = FastAPI()
    
    oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")
    
    
    class User(BaseModel):
        username: str
        email: str | None = None
        full_name: str | None = None
        disabled: bool | None = None
    
    
    def fake_decode_token(token):
        return User(
            username=token + "fakedecoded", email="john@example.com", full_name="John Doe"
        )
    
    
    async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):
        user = fake_decode_token(token)
        return user
    
    
    @app.get("/users/me")
    async def read_users_me(current_user: Annotated[User, Depends(get_current_user)]):
        return current_user
    

ü§ì Other versions and variants

Python 3.9+Python 3.10+ - non-AnnotatedPython 3.9+ - non-Annotated
    
    
    from typing import Annotated, Union
    
    from fastapi import Depends, FastAPI
    from fastapi.security import OAuth2PasswordBearer
    from pydantic import BaseModel
    
    app = FastAPI()
    
    oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")
    
    
    class User(BaseModel):
        username: str
        email: Union[str, None] = None
        full_name: Union[str, None] = None
        disabled: Union[bool, None] = None
    
    
    def fake_decode_token(token):
        return User(
            username=token + "fakedecoded", email="john@example.com", full_name="John Doe"
        )
    
    
    async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):
        user = fake_decode_token(token)
        return user
    
    
    @app.get("/users/me")
    async def read_users_me(current_user: Annotated[User, Depends(get_current_user)]):
        return current_user
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import Depends, FastAPI
    from fastapi.security import OAuth2PasswordBearer
    from pydantic import BaseModel
    
    app = FastAPI()
    
    oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")
    
    
    class User(BaseModel):
        username: str
        email: str | None = None
        full_name: str | None = None
        disabled: bool | None = None
    
    
    def fake_decode_token(token):
        return User(
            username=token + "fakedecoded", email="john@example.com", full_name="John Doe"
        )
    
    
    async def get_current_user(token: str = Depends(oauth2_scheme)):
        user = fake_decode_token(token)
        return user
    
    
    @app.get("/users/me")
    async def read_users_me(current_user: User = Depends(get_current_user)):
        return current_user
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from typing import Union
    
    from fastapi import Depends, FastAPI
    from fastapi.security import OAuth2PasswordBearer
    from pydantic import BaseModel
    
    app = FastAPI()
    
    oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")
    
    
    class User(BaseModel):
        username: str
        email: Union[str, None] = None
        full_name: Union[str, None] = None
        disabled: Union[bool, None] = None
    
    
    def fake_decode_token(token):
        return User(
            username=token + "fakedecoded", email="john@example.com", full_name="John Doe"
        )
    
    
    async def get_current_user(token: str = Depends(oauth2_scheme)):
        user = fake_decode_token(token)
        return user
    
    
    @app.get("/users/me")
    async def read_users_me(current_user: User = Depends(get_current_user)):
        return current_user
    

## Inject the current user[¶](#inject-the-current-user "Permanent link")

So now we can use the same `Depends` with our `get_current_user` in the _path operation_ :

Python 3.10+
    
    
    from typing import Annotated
    
    from fastapi import Depends, FastAPI
    from fastapi.security import OAuth2PasswordBearer
    from pydantic import BaseModel
    
    app = FastAPI()
    
    oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")
    
    
    class User(BaseModel):
        username: str
        email: str | None = None
        full_name: str | None = None
        disabled: bool | None = None
    
    
    def fake_decode_token(token):
        return User(
            username=token + "fakedecoded", email="john@example.com", full_name="John Doe"
        )
    
    
    async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):
        user = fake_decode_token(token)
        return user
    
    
    @app.get("/users/me")
    async def read_users_me(current_user: Annotated[User, Depends(get_current_user)]):
        return current_user
    

ü§ì Other versions and variants

Python 3.9+Python 3.10+ - non-AnnotatedPython 3.9+ - non-Annotated
    
    
    from typing import Annotated, Union
    
    from fastapi import Depends, FastAPI
    from fastapi.security import OAuth2PasswordBearer
    from pydantic import BaseModel
    
    app = FastAPI()
    
    oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")
    
    
    class User(BaseModel):
        username: str
        email: Union[str, None] = None
        full_name: Union[str, None] = None
        disabled: Union[bool, None] = None
    
    
    def fake_decode_token(token):
        return User(
            username=token + "fakedecoded", email="john@example.com", full_name="John Doe"
        )
    
    
    async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):
        user = fake_decode_token(token)
        return user
    
    
    @app.get("/users/me")
    async def read_users_me(current_user: Annotated[User, Depends(get_current_user)]):
        return current_user
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import Depends, FastAPI
    from fastapi.security import OAuth2PasswordBearer
    from pydantic import BaseModel
    
    app = FastAPI()
    
    oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")
    
    
    class User(BaseModel):
        username: str
        email: str | None = None
        full_name: str | None = None
        disabled: bool | None = None
    
    
    def fake_decode_token(token):
        return User(
            username=token + "fakedecoded", email="john@example.com", full_name="John Doe"
        )
    
    
    async def get_current_user(token: str = Depends(oauth2_scheme)):
        user = fake_decode_token(token)
        return user
    
    
    @app.get("/users/me")
    async def read_users_me(current_user: User = Depends(get_current_user)):
        return current_user
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from typing import Union
    
    from fastapi import Depends, FastAPI
    from fastapi.security import OAuth2PasswordBearer
    from pydantic import BaseModel
    
    app = FastAPI()
    
    oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")
    
    
    class User(BaseModel):
        username: str
        email: Union[str, None] = None
        full_name: Union[str, None] = None
        disabled: Union[bool, None] = None
    
    
    def fake_decode_token(token):
        return User(
            username=token + "fakedecoded", email="john@example.com", full_name="John Doe"
        )
    
    
    async def get_current_user(token: str = Depends(oauth2_scheme)):
        user = fake_decode_token(token)
        return user
    
    
    @app.get("/users/me")
    async def read_users_me(current_user: User = Depends(get_current_user)):
        return current_user
    

Notice that we declare the type of `current_user` as the Pydantic model `User`.

This will help us inside of the function with all the completion and type checks.

Tip

You might remember that request bodies are also declared with Pydantic models.

Here **FastAPI** won't get confused because you are using `Depends`.

Check

The way this dependency system is designed allows us to have different dependencies (different "dependables") that all return a `User` model.

We are not restricted to having only one dependency that can return that type of data.

## Other models[¶](#other-models "Permanent link")

You can now get the current user directly in the _path operation functions_ and deal with the security mechanisms at the **Dependency Injection** level, using `Depends`.

And you can use any model or data for the security requirements (in this case, a Pydantic model `User`).

But you are not restricted to using some specific data model, class or type.

Do you want to have an `id` and `email` and not have any `username` in your model? Sure. You can use these same tools.

Do you want to just have a `str`? Or just a `dict`? Or a database class model instance directly? It all works the same way.

You actually don't have users that log in to your application but robots, bots, or other systems, that have just an access token? Again, it all works the same.

Just use any kind of model, any kind of class, any kind of database that you need for your application. **FastAPI** has you covered with the dependency injection system.

## Code size[¶](#code-size "Permanent link")

This example might seem verbose. Keep in mind that we are mixing security, data models, utility functions and _path operations_ in the same file.

But here's the key point.

The security and dependency injection stuff is written once.

And you can make it as complex as you want. And still, have it written only once, in a single place. With all the flexibility.

But you can have thousands of endpoints (_path operations_) using the same security system.

And all of them (or any portion of them that you want) can take advantage of re-using these dependencies or any other dependencies you create.

And all these thousands of _path operations_ can be as small as 3 lines:

Python 3.10+
    
    
    from typing import Annotated
    
    from fastapi import Depends, FastAPI
    from fastapi.security import OAuth2PasswordBearer
    from pydantic import BaseModel
    
    app = FastAPI()
    
    oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")
    
    
    class User(BaseModel):
        username: str
        email: str | None = None
        full_name: str | None = None
        disabled: bool | None = None
    
    
    def fake_decode_token(token):
        return User(
            username=token + "fakedecoded", email="john@example.com", full_name="John Doe"
        )
    
    
    async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):
        user = fake_decode_token(token)
        return user
    
    
    @app.get("/users/me")
    async def read_users_me(current_user: Annotated[User, Depends(get_current_user)]):
        return current_user
    

ü§ì Other versions and variants

Python 3.9+Python 3.10+ - non-AnnotatedPython 3.9+ - non-Annotated
    
    
    from typing import Annotated, Union
    
    from fastapi import Depends, FastAPI
    from fastapi.security import OAuth2PasswordBearer
    from pydantic import BaseModel
    
    app = FastAPI()
    
    oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")
    
    
    class User(BaseModel):
        username: str
        email: Union[str, None] = None
        full_name: Union[str, None] = None
        disabled: Union[bool, None] = None
    
    
    def fake_decode_token(token):
        return User(
            username=token + "fakedecoded", email="john@example.com", full_name="John Doe"
        )
    
    
    async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):
        user = fake_decode_token(token)
        return user
    
    
    @app.get("/users/me")
    async def read_users_me(current_user: Annotated[User, Depends(get_current_user)]):
        return current_user
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import Depends, FastAPI
    from fastapi.security import OAuth2PasswordBearer
    from pydantic import BaseModel
    
    app = FastAPI()
    
    oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")
    
    
    class User(BaseModel):
        username: str
        email: str | None = None
        full_name: str | None = None
        disabled: bool | None = None
    
    
    def fake_decode_token(token):
        return User(
            username=token + "fakedecoded", email="john@example.com", full_name="John Doe"
        )
    
    
    async def get_current_user(token: str = Depends(oauth2_scheme)):
        user = fake_decode_token(token)
        return user
    
    
    @app.get("/users/me")
    async def read_users_me(current_user: User = Depends(get_current_user)):
        return current_user
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from typing import Union
    
    from fastapi import Depends, FastAPI
    from fastapi.security import OAuth2PasswordBearer
    from pydantic import BaseModel
    
    app = FastAPI()
    
    oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")
    
    
    class User(BaseModel):
        username: str
        email: Union[str, None] = None
        full_name: Union[str, None] = None
        disabled: Union[bool, None] = None
    
    
    def fake_decode_token(token):
        return User(
            username=token + "fakedecoded", email="john@example.com", full_name="John Doe"
        )
    
    
    async def get_current_user(token: str = Depends(oauth2_scheme)):
        user = fake_decode_token(token)
        return user
    
    
    @app.get("/users/me")
    async def read_users_me(current_user: User = Depends(get_current_user)):
        return current_user
    

## Recap[¶](#recap "Permanent link")

You can now get the current user directly in your _path operation function_.

We are already halfway there.

We just need to add a _path operation_ for the user/client to actually send the `username` and `password`.

That comes next.

---

###### Simple OAuth2 with Password and Bearer¶

# Simple OAuth2 with Password and Bearer[¶](#simple-oauth2-with-password-and-bearer "Permanent link")

Now let's build from the previous chapter and add the missing parts to have a complete security flow.

## Get the `username` and `password`[¶](#get-the-username-and-password "Permanent link")

We are going to use **FastAPI** security utilities to get the `username` and `password`.

OAuth2 specifies that when using the "password flow" (that we are using) the client/user must send a `username` and `password` fields as form data.

And the spec says that the fields have to be named like that. So `user-name` or `email` wouldn't work.

But don't worry, you can show it as you wish to your final users in the frontend.

And your database models can use any other names you want.

But for the login _path operation_ , we need to use these names to be compatible with the spec (and be able to, for example, use the integrated API documentation system).

The spec also states that the `username` and `password` must be sent as form data (so, no JSON here).

### `scope`[¶](#scope "Permanent link")

The spec also says that the client can send another form field "`scope`".

The form field name is `scope` (in singular), but it is actually a long string with "scopes" separated by spaces.

Each "scope" is just a string (without spaces).

They are normally used to declare specific security permissions, for example:

  * `users:read` or `users:write` are common examples.
  * `instagram_basic` is used by Facebook / Instagram.
  * `https://www.googleapis.com/auth/drive` is used by Google.

Info

In OAuth2 a "scope" is just a string that declares a specific permission required.

It doesn't matter if it has other characters like `:` or if it is a URL.

Those details are implementation specific.

For OAuth2 they are just strings.

## Code to get the `username` and `password`[¶](#code-to-get-the-username-and-password "Permanent link")

Now let's use the utilities provided by **FastAPI** to handle this.

### `OAuth2PasswordRequestForm`[¶](#oauth2passwordrequestform "Permanent link")

First, import `OAuth2PasswordRequestForm`, and use it as a dependency with `Depends` in the _path operation_ for `/token`:

Python 3.10+
    
    
    from typing import Annotated
    
    from fastapi import Depends, FastAPI, HTTPException, status
    from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
    from pydantic import BaseModel
    
    fake_users_db = {
        "johndoe": {
            "username": "johndoe",
            "full_name": "John Doe",
            "email": "johndoe@example.com",
            "hashed_password": "fakehashedsecret",
            "disabled": False,
        },
        "alice": {
            "username": "alice",
            "full_name": "Alice Wonderson",
            "email": "alice@example.com",
            "hashed_password": "fakehashedsecret2",
            "disabled": True,
        },
    }
    
    app = FastAPI()
    
    
    def fake_hash_password(password: str):
        return "fakehashed" + password
    
    
    oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")
    
    
    class User(BaseModel):
        username: str
        email: str | None = None
        full_name: str | None = None
        disabled: bool | None = None
    
    
    class UserInDB(User):
        hashed_password: str
    
    
    def get_user(db, username: str):
        if username in db:
            user_dict = db[username]
            return UserInDB(**user_dict)
    
    
    def fake_decode_token(token):
        # This doesn't provide any security at all
        # Check the next version
        user = get_user(fake_users_db, token)
        return user
    
    
    async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):
        user = fake_decode_token(token)
        if not user:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Not authenticated",
                headers={"WWW-Authenticate": "Bearer"},
            )
        return user
    
    
    async def get_current_active_user(
        current_user: Annotated[User, Depends(get_current_user)],
    ):
        if current_user.disabled:
            raise HTTPException(status_code=400, detail="Inactive user")
        return current_user
    
    
    @app.post("/token")
    async def login(form_data: Annotated[OAuth2PasswordRequestForm, Depends()]):
        user_dict = fake_users_db.get(form_data.username)
        if not user_dict:
            raise HTTPException(status_code=400, detail="Incorrect username or password")
        user = UserInDB(**user_dict)
        hashed_password = fake_hash_password(form_data.password)
        if not hashed_password == user.hashed_password:
            raise HTTPException(status_code=400, detail="Incorrect username or password")
    
        return {"access_token": user.username, "token_type": "bearer"}
    
    
    @app.get("/users/me")
    async def read_users_me(
        current_user: Annotated[User, Depends(get_current_active_user)],
    ):
        return current_user
    

ü§ì Other versions and variants

Python 3.9+Python 3.10+ - non-AnnotatedPython 3.9+ - non-Annotated
    
    
    from typing import Annotated, Union
    
    from fastapi import Depends, FastAPI, HTTPException, status
    from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
    from pydantic import BaseModel
    
    fake_users_db = {
        "johndoe": {
            "username": "johndoe",
            "full_name": "John Doe",
            "email": "johndoe@example.com",
            "hashed_password": "fakehashedsecret",
            "disabled": False,
        },
        "alice": {
            "username": "alice",
            "full_name": "Alice Wonderson",
            "email": "alice@example.com",
            "hashed_password": "fakehashedsecret2",
            "disabled": True,
        },
    }
    
    app = FastAPI()
    
    
    def fake_hash_password(password: str):
        return "fakehashed" + password
    
    
    oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")
    
    
    class User(BaseModel):
        username: str
        email: Union[str, None] = None
        full_name: Union[str, None] = None
        disabled: Union[bool, None] = None
    
    
    class UserInDB(User):
        hashed_password: str
    
    
    def get_user(db, username: str):
        if username in db:
            user_dict = db[username]
            return UserInDB(**user_dict)
    
    
    def fake_decode_token(token):
        # This doesn't provide any security at all
        # Check the next version
        user = get_user(fake_users_db, token)
        return user
    
    
    async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):
        user = fake_decode_token(token)
        if not user:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Not authenticated",
                headers={"WWW-Authenticate": "Bearer"},
            )
        return user
    
    
    async def get_current_active_user(
        current_user: Annotated[User, Depends(get_current_user)],
    ):
        if current_user.disabled:
            raise HTTPException(status_code=400, detail="Inactive user")
        return current_user
    
    
    @app.post("/token")
    async def login(form_data: Annotated[OAuth2PasswordRequestForm, Depends()]):
        user_dict = fake_users_db.get(form_data.username)
        if not user_dict:
            raise HTTPException(status_code=400, detail="Incorrect username or password")
        user = UserInDB(**user_dict)
        hashed_password = fake_hash_password(form_data.password)
        if not hashed_password == user.hashed_password:
            raise HTTPException(status_code=400, detail="Incorrect username or password")
    
        return {"access_token": user.username, "token_type": "bearer"}
    
    
    @app.get("/users/me")
    async def read_users_me(
        current_user: Annotated[User, Depends(get_current_active_user)],
    ):
        return current_user
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import Depends, FastAPI, HTTPException, status
    from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
    from pydantic import BaseModel
    
    fake_users_db = {
        "johndoe": {
            "username": "johndoe",
            "full_name": "John Doe",
            "email": "johndoe@example.com",
            "hashed_password": "fakehashedsecret",
            "disabled": False,
        },
        "alice": {
            "username": "alice",
            "full_name": "Alice Wonderson",
            "email": "alice@example.com",
            "hashed_password": "fakehashedsecret2",
            "disabled": True,
        },
    }
    
    app = FastAPI()
    
    
    def fake_hash_password(password: str):
        return "fakehashed" + password
    
    
    oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")
    
    
    class User(BaseModel):
        username: str
        email: str | None = None
        full_name: str | None = None
        disabled: bool | None = None
    
    
    class UserInDB(User):
        hashed_password: str
    
    
    def get_user(db, username: str):
        if username in db:
            user_dict = db[username]
            return UserInDB(**user_dict)
    
    
    def fake_decode_token(token):
        # This doesn't provide any security at all
        # Check the next version
        user = get_user(fake_users_db, token)
        return user
    
    
    async def get_current_user(token: str = Depends(oauth2_scheme)):
        user = fake_decode_token(token)
        if not user:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Not authenticated",
                headers={"WWW-Authenticate": "Bearer"},
            )
        return user
    
    
    async def get_current_active_user(current_user: User = Depends(get_current_user)):
        if current_user.disabled:
            raise HTTPException(status_code=400, detail="Inactive user")
        return current_user
    
    
    @app.post("/token")
    async def login(form_data: OAuth2PasswordRequestForm = Depends()):
        user_dict = fake_users_db.get(form_data.username)
        if not user_dict:
            raise HTTPException(status_code=400, detail="Incorrect username or password")
        user = UserInDB(**user_dict)
        hashed_password = fake_hash_password(form_data.password)
        if not hashed_password == user.hashed_password:
            raise HTTPException(status_code=400, detail="Incorrect username or password")
    
        return {"access_token": user.username, "token_type": "bearer"}
    
    
    @app.get("/users/me")
    async def read_users_me(current_user: User = Depends(get_current_active_user)):
        return current_user
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from typing import Union
    
    from fastapi import Depends, FastAPI, HTTPException, status
    from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
    from pydantic import BaseModel
    
    fake_users_db = {
        "johndoe": {
            "username": "johndoe",
            "full_name": "John Doe",
            "email": "johndoe@example.com",
            "hashed_password": "fakehashedsecret",
            "disabled": False,
        },
        "alice": {
            "username": "alice",
            "full_name": "Alice Wonderson",
            "email": "alice@example.com",
            "hashed_password": "fakehashedsecret2",
            "disabled": True,
        },
    }
    
    app = FastAPI()
    
    
    def fake_hash_password(password: str):
        return "fakehashed" + password
    
    
    oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")
    
    
    class User(BaseModel):
        username: str
        email: Union[str, None] = None
        full_name: Union[str, None] = None
        disabled: Union[bool, None] = None
    
    
    class UserInDB(User):
        hashed_password: str
    
    
    def get_user(db, username: str):
        if username in db:
            user_dict = db[username]
            return UserInDB(**user_dict)
    
    
    def fake_decode_token(token):
        # This doesn't provide any security at all
        # Check the next version
        user = get_user(fake_users_db, token)
        return user
    
    
    async def get_current_user(token: str = Depends(oauth2_scheme)):
        user = fake_decode_token(token)
        if not user:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Not authenticated",
                headers={"WWW-Authenticate": "Bearer"},
            )
        return user
    
    
    async def get_current_active_user(current_user: User = Depends(get_current_user)):
        if current_user.disabled:
            raise HTTPException(status_code=400, detail="Inactive user")
        return current_user
    
    
    @app.post("/token")
    async def login(form_data: OAuth2PasswordRequestForm = Depends()):
        user_dict = fake_users_db.get(form_data.username)
        if not user_dict:
            raise HTTPException(status_code=400, detail="Incorrect username or password")
        user = UserInDB(**user_dict)
        hashed_password = fake_hash_password(form_data.password)
        if not hashed_password == user.hashed_password:
            raise HTTPException(status_code=400, detail="Incorrect username or password")
    
        return {"access_token": user.username, "token_type": "bearer"}
    
    
    @app.get("/users/me")
    async def read_users_me(current_user: User = Depends(get_current_active_user)):
        return current_user
    

`OAuth2PasswordRequestForm` is a class dependency that declares a form body with:

  * The `username`.
  * The `password`.
  * An optional `scope` field as a big string, composed of strings separated by spaces.
  * An optional `grant_type`.

Tip

The OAuth2 spec actually _requires_ a field `grant_type` with a fixed value of `password`, but `OAuth2PasswordRequestForm` doesn't enforce it.

If you need to enforce it, use `OAuth2PasswordRequestFormStrict` instead of `OAuth2PasswordRequestForm`.

  * An optional `client_id` (we don't need it for our example).
  * An optional `client_secret` (we don't need it for our example).

Info

The `OAuth2PasswordRequestForm` is not a special class for **FastAPI** as is `OAuth2PasswordBearer`.

`OAuth2PasswordBearer` makes **FastAPI** know that it is a security scheme. So it is added that way to OpenAPI.

But `OAuth2PasswordRequestForm` is just a class dependency that you could have written yourself, or you could have declared `Form` parameters directly.

But as it's a common use case, it is provided by **FastAPI** directly, just to make it easier.

### Use the form data[¶](#use-the-form-data "Permanent link")

Tip

The instance of the dependency class `OAuth2PasswordRequestForm` won't have an attribute `scope` with the long string separated by spaces, instead, it will have a `scopes` attribute with the actual list of strings for each scope sent.

We are not using `scopes` in this example, but the functionality is there if you need it.

Now, get the user data from the (fake) database, using the `username` from the form field.

If there is no such user, we return an error saying "Incorrect username or password".

For the error, we use the exception `HTTPException`:

Python 3.10+
    
    
    from typing import Annotated
    
    from fastapi import Depends, FastAPI, HTTPException, status
    from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
    from pydantic import BaseModel
    
    fake_users_db = {
        "johndoe": {
            "username": "johndoe",
            "full_name": "John Doe",
            "email": "johndoe@example.com",
            "hashed_password": "fakehashedsecret",
            "disabled": False,
        },
        "alice": {
            "username": "alice",
            "full_name": "Alice Wonderson",
            "email": "alice@example.com",
            "hashed_password": "fakehashedsecret2",
            "disabled": True,
        },
    }
    
    app = FastAPI()
    
    
    def fake_hash_password(password: str):
        return "fakehashed" + password
    
    
    oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")
    
    
    class User(BaseModel):
        username: str
        email: str | None = None
        full_name: str | None = None
        disabled: bool | None = None
    
    
    class UserInDB(User):
        hashed_password: str
    
    
    def get_user(db, username: str):
        if username in db:
            user_dict = db[username]
            return UserInDB(**user_dict)
    
    
    def fake_decode_token(token):
        # This doesn't provide any security at all
        # Check the next version
        user = get_user(fake_users_db, token)
        return user
    
    
    async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):
        user = fake_decode_token(token)
        if not user:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Not authenticated",
                headers={"WWW-Authenticate": "Bearer"},
            )
        return user
    
    
    async def get_current_active_user(
        current_user: Annotated[User, Depends(get_current_user)],
    ):
        if current_user.disabled:
            raise HTTPException(status_code=400, detail="Inactive user")
        return current_user
    
    
    @app.post("/token")
    async def login(form_data: Annotated[OAuth2PasswordRequestForm, Depends()]):
        user_dict = fake_users_db.get(form_data.username)
        if not user_dict:
            raise HTTPException(status_code=400, detail="Incorrect username or password")
        user = UserInDB(**user_dict)
        hashed_password = fake_hash_password(form_data.password)
        if not hashed_password == user.hashed_password:
            raise HTTPException(status_code=400, detail="Incorrect username or password")
    
        return {"access_token": user.username, "token_type": "bearer"}
    
    
    @app.get("/users/me")
    async def read_users_me(
        current_user: Annotated[User, Depends(get_current_active_user)],
    ):
        return current_user
    

ü§ì Other versions and variants

Python 3.9+Python 3.10+ - non-AnnotatedPython 3.9+ - non-Annotated
    
    
    from typing import Annotated, Union
    
    from fastapi import Depends, FastAPI, HTTPException, status
    from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
    from pydantic import BaseModel
    
    fake_users_db = {
        "johndoe": {
            "username": "johndoe",
            "full_name": "John Doe",
            "email": "johndoe@example.com",
            "hashed_password": "fakehashedsecret",
            "disabled": False,
        },
        "alice": {
            "username": "alice",
            "full_name": "Alice Wonderson",
            "email": "alice@example.com",
            "hashed_password": "fakehashedsecret2",
            "disabled": True,
        },
    }
    
    app = FastAPI()
    
    
    def fake_hash_password(password: str):
        return "fakehashed" + password
    
    
    oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")
    
    
    class User(BaseModel):
        username: str
        email: Union[str, None] = None
        full_name: Union[str, None] = None
        disabled: Union[bool, None] = None
    
    
    class UserInDB(User):
        hashed_password: str
    
    
    def get_user(db, username: str):
        if username in db:
            user_dict = db[username]
            return UserInDB(**user_dict)
    
    
    def fake_decode_token(token):
        # This doesn't provide any security at all
        # Check the next version
        user = get_user(fake_users_db, token)
        return user
    
    
    async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):
        user = fake_decode_token(token)
        if not user:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Not authenticated",
                headers={"WWW-Authenticate": "Bearer"},
            )
        return user
    
    
    async def get_current_active_user(
        current_user: Annotated[User, Depends(get_current_user)],
    ):
        if current_user.disabled:
            raise HTTPException(status_code=400, detail="Inactive user")
        return current_user
    
    
    @app.post("/token")
    async def login(form_data: Annotated[OAuth2PasswordRequestForm, Depends()]):
        user_dict = fake_users_db.get(form_data.username)
        if not user_dict:
            raise HTTPException(status_code=400, detail="Incorrect username or password")
        user = UserInDB(**user_dict)
        hashed_password = fake_hash_password(form_data.password)
        if not hashed_password == user.hashed_password:
            raise HTTPException(status_code=400, detail="Incorrect username or password")
    
        return {"access_token": user.username, "token_type": "bearer"}
    
    
    @app.get("/users/me")
    async def read_users_me(
        current_user: Annotated[User, Depends(get_current_active_user)],
    ):
        return current_user
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import Depends, FastAPI, HTTPException, status
    from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
    from pydantic import BaseModel
    
    fake_users_db = {
        "johndoe": {
            "username": "johndoe",
            "full_name": "John Doe",
            "email": "johndoe@example.com",
            "hashed_password": "fakehashedsecret",
            "disabled": False,
        },
        "alice": {
            "username": "alice",
            "full_name": "Alice Wonderson",
            "email": "alice@example.com",
            "hashed_password": "fakehashedsecret2",
            "disabled": True,
        },
    }
    
    app = FastAPI()
    
    
    def fake_hash_password(password: str):
        return "fakehashed" + password
    
    
    oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")
    
    
    class User(BaseModel):
        username: str
        email: str | None = None
        full_name: str | None = None
        disabled: bool | None = None
    
    
    class UserInDB(User):
        hashed_password: str
    
    
    def get_user(db, username: str):
        if username in db:
            user_dict = db[username]
            return UserInDB(**user_dict)
    
    
    def fake_decode_token(token):
        # This doesn't provide any security at all
        # Check the next version
        user = get_user(fake_users_db, token)
        return user
    
    
    async def get_current_user(token: str = Depends(oauth2_scheme)):
        user = fake_decode_token(token)
        if not user:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Not authenticated",
                headers={"WWW-Authenticate": "Bearer"},
            )
        return user
    
    
    async def get_current_active_user(current_user: User = Depends(get_current_user)):
        if current_user.disabled:
            raise HTTPException(status_code=400, detail="Inactive user")
        return current_user
    
    
    @app.post("/token")
    async def login(form_data: OAuth2PasswordRequestForm = Depends()):
        user_dict = fake_users_db.get(form_data.username)
        if not user_dict:
            raise HTTPException(status_code=400, detail="Incorrect username or password")
        user = UserInDB(**user_dict)
        hashed_password = fake_hash_password(form_data.password)
        if not hashed_password == user.hashed_password:
            raise HTTPException(status_code=400, detail="Incorrect username or password")
    
        return {"access_token": user.username, "token_type": "bearer"}
    
    
    @app.get("/users/me")
    async def read_users_me(current_user: User = Depends(get_current_active_user)):
        return current_user
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from typing import Union
    
    from fastapi import Depends, FastAPI, HTTPException, status
    from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
    from pydantic import BaseModel
    
    fake_users_db = {
        "johndoe": {
            "username": "johndoe",
            "full_name": "John Doe",
            "email": "johndoe@example.com",
            "hashed_password": "fakehashedsecret",
            "disabled": False,
        },
        "alice": {
            "username": "alice",
            "full_name": "Alice Wonderson",
            "email": "alice@example.com",
            "hashed_password": "fakehashedsecret2",
            "disabled": True,
        },
    }
    
    app = FastAPI()
    
    
    def fake_hash_password(password: str):
        return "fakehashed" + password
    
    
    oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")
    
    
    class User(BaseModel):
        username: str
        email: Union[str, None] = None
        full_name: Union[str, None] = None
        disabled: Union[bool, None] = None
    
    
    class UserInDB(User):
        hashed_password: str
    
    
    def get_user(db, username: str):
        if username in db:
            user_dict = db[username]
            return UserInDB(**user_dict)
    
    
    def fake_decode_token(token):
        # This doesn't provide any security at all
        # Check the next version
        user = get_user(fake_users_db, token)
        return user
    
    
    async def get_current_user(token: str = Depends(oauth2_scheme)):
        user = fake_decode_token(token)
        if not user:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Not authenticated",
                headers={"WWW-Authenticate": "Bearer"},
            )
        return user
    
    
    async def get_current_active_user(current_user: User = Depends(get_current_user)):
        if current_user.disabled:
            raise HTTPException(status_code=400, detail="Inactive user")
        return current_user
    
    
    @app.post("/token")
    async def login(form_data: OAuth2PasswordRequestForm = Depends()):
        user_dict = fake_users_db.get(form_data.username)
        if not user_dict:
            raise HTTPException(status_code=400, detail="Incorrect username or password")
        user = UserInDB(**user_dict)
        hashed_password = fake_hash_password(form_data.password)
        if not hashed_password == user.hashed_password:
            raise HTTPException(status_code=400, detail="Incorrect username or password")
    
        return {"access_token": user.username, "token_type": "bearer"}
    
    
    @app.get("/users/me")
    async def read_users_me(current_user: User = Depends(get_current_active_user)):
        return current_user
    

### Check the password[¶](#check-the-password "Permanent link")

At this point we have the user data from our database, but we haven't checked the password.

Let's put that data in the Pydantic `UserInDB` model first.

You should never save plaintext passwords, so, we'll use the (fake) password hashing system.

If the passwords don't match, we return the same error.

#### Password hashing[¶](#password-hashing "Permanent link")

"Hashing" means: converting some content (a password in this case) into a sequence of bytes (just a string) that looks like gibberish.

Whenever you pass exactly the same content (exactly the same password) you get exactly the same gibberish.

But you cannot convert from the gibberish back to the password.

##### Why use password hashing[¶](#why-use-password-hashing "Permanent link")

If your database is stolen, the thief won't have your users' plaintext passwords, only the hashes.

So, the thief won't be able to try to use those same passwords in another system (as many users use the same password everywhere, this would be dangerous).

Python 3.10+
    
    
    from typing import Annotated
    
    from fastapi import Depends, FastAPI, HTTPException, status
    from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
    from pydantic import BaseModel
    
    fake_users_db = {
        "johndoe": {
            "username": "johndoe",
            "full_name": "John Doe",
            "email": "johndoe@example.com",
            "hashed_password": "fakehashedsecret",
            "disabled": False,
        },
        "alice": {
            "username": "alice",
            "full_name": "Alice Wonderson",
            "email": "alice@example.com",
            "hashed_password": "fakehashedsecret2",
            "disabled": True,
        },
    }
    
    app = FastAPI()
    
    
    def fake_hash_password(password: str):
        return "fakehashed" + password
    
    
    oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")
    
    
    class User(BaseModel):
        username: str
        email: str | None = None
        full_name: str | None = None
        disabled: bool | None = None
    
    
    class UserInDB(User):
        hashed_password: str
    
    
    def get_user(db, username: str):
        if username in db:
            user_dict = db[username]
            return UserInDB(**user_dict)
    
    
    def fake_decode_token(token):
        # This doesn't provide any security at all
        # Check the next version
        user = get_user(fake_users_db, token)
        return user
    
    
    async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):
        user = fake_decode_token(token)
        if not user:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Not authenticated",
                headers={"WWW-Authenticate": "Bearer"},
            )
        return user
    
    
    async def get_current_active_user(
        current_user: Annotated[User, Depends(get_current_user)],
    ):
        if current_user.disabled:
            raise HTTPException(status_code=400, detail="Inactive user")
        return current_user
    
    
    @app.post("/token")
    async def login(form_data: Annotated[OAuth2PasswordRequestForm, Depends()]):
        user_dict = fake_users_db.get(form_data.username)
        if not user_dict:
            raise HTTPException(status_code=400, detail="Incorrect username or password")
        user = UserInDB(**user_dict)
        hashed_password = fake_hash_password(form_data.password)
        if not hashed_password == user.hashed_password:
            raise HTTPException(status_code=400, detail="Incorrect username or password")
    
        return {"access_token": user.username, "token_type": "bearer"}
    
    
    @app.get("/users/me")
    async def read_users_me(
        current_user: Annotated[User, Depends(get_current_active_user)],
    ):
        return current_user
    

ü§ì Other versions and variants

Python 3.9+Python 3.10+ - non-AnnotatedPython 3.9+ - non-Annotated
    
    
    from typing import Annotated, Union
    
    from fastapi import Depends, FastAPI, HTTPException, status
    from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
    from pydantic import BaseModel
    
    fake_users_db = {
        "johndoe": {
            "username": "johndoe",
            "full_name": "John Doe",
            "email": "johndoe@example.com",
            "hashed_password": "fakehashedsecret",
            "disabled": False,
        },
        "alice": {
            "username": "alice",
            "full_name": "Alice Wonderson",
            "email": "alice@example.com",
            "hashed_password": "fakehashedsecret2",
            "disabled": True,
        },
    }
    
    app = FastAPI()
    
    
    def fake_hash_password(password: str):
        return "fakehashed" + password
    
    
    oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")
    
    
    class User(BaseModel):
        username: str
        email: Union[str, None] = None
        full_name: Union[str, None] = None
        disabled: Union[bool, None] = None
    
    
    class UserInDB(User):
        hashed_password: str
    
    
    def get_user(db, username: str):
        if username in db:
            user_dict = db[username]
            return UserInDB(**user_dict)
    
    
    def fake_decode_token(token):
        # This doesn't provide any security at all
        # Check the next version
        user = get_user(fake_users_db, token)
        return user
    
    
    async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):
        user = fake_decode_token(token)
        if not user:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Not authenticated",
                headers={"WWW-Authenticate": "Bearer"},
            )
        return user
    
    
    async def get_current_active_user(
        current_user: Annotated[User, Depends(get_current_user)],
    ):
        if current_user.disabled:
            raise HTTPException(status_code=400, detail="Inactive user")
        return current_user
    
    
    @app.post("/token")
    async def login(form_data: Annotated[OAuth2PasswordRequestForm, Depends()]):
        user_dict = fake_users_db.get(form_data.username)
        if not user_dict:
            raise HTTPException(status_code=400, detail="Incorrect username or password")
        user = UserInDB(**user_dict)
        hashed_password = fake_hash_password(form_data.password)
        if not hashed_password == user.hashed_password:
            raise HTTPException(status_code=400, detail="Incorrect username or password")
    
        return {"access_token": user.username, "token_type": "bearer"}
    
    
    @app.get("/users/me")
    async def read_users_me(
        current_user: Annotated[User, Depends(get_current_active_user)],
    ):
        return current_user
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import Depends, FastAPI, HTTPException, status
    from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
    from pydantic import BaseModel
    
    fake_users_db = {
        "johndoe": {
            "username": "johndoe",
            "full_name": "John Doe",
            "email": "johndoe@example.com",
            "hashed_password": "fakehashedsecret",
            "disabled": False,
        },
        "alice": {
            "username": "alice",
            "full_name": "Alice Wonderson",
            "email": "alice@example.com",
            "hashed_password": "fakehashedsecret2",
            "disabled": True,
        },
    }
    
    app = FastAPI()
    
    
    def fake_hash_password(password: str):
        return "fakehashed" + password
    
    
    oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")
    
    
    class User(BaseModel):
        username: str
        email: str | None = None
        full_name: str | None = None
        disabled: bool | None = None
    
    
    class UserInDB(User):
        hashed_password: str
    
    
    def get_user(db, username: str):
        if username in db:
            user_dict = db[username]
            return UserInDB(**user_dict)
    
    
    def fake_decode_token(token):
        # This doesn't provide any security at all
        # Check the next version
        user = get_user(fake_users_db, token)
        return user
    
    
    async def get_current_user(token: str = Depends(oauth2_scheme)):
        user = fake_decode_token(token)
        if not user:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Not authenticated",
                headers={"WWW-Authenticate": "Bearer"},
            )
        return user
    
    
    async def get_current_active_user(current_user: User = Depends(get_current_user)):
        if current_user.disabled:
            raise HTTPException(status_code=400, detail="Inactive user")
        return current_user
    
    
    @app.post("/token")
    async def login(form_data: OAuth2PasswordRequestForm = Depends()):
        user_dict = fake_users_db.get(form_data.username)
        if not user_dict:
            raise HTTPException(status_code=400, detail="Incorrect username or password")
        user = UserInDB(**user_dict)
        hashed_password = fake_hash_password(form_data.password)
        if not hashed_password == user.hashed_password:
            raise HTTPException(status_code=400, detail="Incorrect username or password")
    
        return {"access_token": user.username, "token_type": "bearer"}
    
    
    @app.get("/users/me")
    async def read_users_me(current_user: User = Depends(get_current_active_user)):
        return current_user
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from typing import Union
    
    from fastapi import Depends, FastAPI, HTTPException, status
    from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
    from pydantic import BaseModel
    
    fake_users_db = {
        "johndoe": {
            "username": "johndoe",
            "full_name": "John Doe",
            "email": "johndoe@example.com",
            "hashed_password": "fakehashedsecret",
            "disabled": False,
        },
        "alice": {
            "username": "alice",
            "full_name": "Alice Wonderson",
            "email": "alice@example.com",
            "hashed_password": "fakehashedsecret2",
            "disabled": True,
        },
    }
    
    app = FastAPI()
    
    
    def fake_hash_password(password: str):
        return "fakehashed" + password
    
    
    oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")
    
    
    class User(BaseModel):
        username: str
        email: Union[str, None] = None
        full_name: Union[str, None] = None
        disabled: Union[bool, None] = None
    
    
    class UserInDB(User):
        hashed_password: str
    
    
    def get_user(db, username: str):
        if username in db:
            user_dict = db[username]
            return UserInDB(**user_dict)
    
    
    def fake_decode_token(token):
        # This doesn't provide any security at all
        # Check the next version
        user = get_user(fake_users_db, token)
        return user
    
    
    async def get_current_user(token: str = Depends(oauth2_scheme)):
        user = fake_decode_token(token)
        if not user:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Not authenticated",
                headers={"WWW-Authenticate": "Bearer"},
            )
        return user
    
    
    async def get_current_active_user(current_user: User = Depends(get_current_user)):
        if current_user.disabled:
            raise HTTPException(status_code=400, detail="Inactive user")
        return current_user
    
    
    @app.post("/token")
    async def login(form_data: OAuth2PasswordRequestForm = Depends()):
        user_dict = fake_users_db.get(form_data.username)
        if not user_dict:
            raise HTTPException(status_code=400, detail="Incorrect username or password")
        user = UserInDB(**user_dict)
        hashed_password = fake_hash_password(form_data.password)
        if not hashed_password == user.hashed_password:
            raise HTTPException(status_code=400, detail="Incorrect username or password")
    
        return {"access_token": user.username, "token_type": "bearer"}
    
    
    @app.get("/users/me")
    async def read_users_me(current_user: User = Depends(get_current_active_user)):
        return current_user
    

#### About `**user_dict`[¶](#about-user-dict "Permanent link")

`UserInDB(**user_dict)` means:

_Pass the keys and values of the`user_dict` directly as key-value arguments, equivalent to:_
    
    
    UserInDB(
        username = user_dict["username"],
        email = user_dict["email"],
        full_name = user_dict["full_name"],
        disabled = user_dict["disabled"],
        hashed_password = user_dict["hashed_password"],
    )
    

Info

For a more complete explanation of `**user_dict` check back in [the documentation for **Extra Models**](../../extra-models/#about-user-in-dict).

## Return the token[¶](#return-the-token "Permanent link")

The response of the `token` endpoint must be a JSON object.

It should have a `token_type`. In our case, as we are using "Bearer" tokens, the token type should be "`bearer`".

And it should have an `access_token`, with a string containing our access token.

For this simple example, we are going to just be completely insecure and return the same `username` as the token.

Tip

In the next chapter, you will see a real secure implementation, with password hashing and JWT tokens.

But for now, let's focus on the specific details we need.

Python 3.10+
    
    
    from typing import Annotated
    
    from fastapi import Depends, FastAPI, HTTPException, status
    from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
    from pydantic import BaseModel
    
    fake_users_db = {
        "johndoe": {
            "username": "johndoe",
            "full_name": "John Doe",
            "email": "johndoe@example.com",
            "hashed_password": "fakehashedsecret",
            "disabled": False,
        },
        "alice": {
            "username": "alice",
            "full_name": "Alice Wonderson",
            "email": "alice@example.com",
            "hashed_password": "fakehashedsecret2",
            "disabled": True,
        },
    }
    
    app = FastAPI()
    
    
    def fake_hash_password(password: str):
        return "fakehashed" + password
    
    
    oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")
    
    
    class User(BaseModel):
        username: str
        email: str | None = None
        full_name: str | None = None
        disabled: bool | None = None
    
    
    class UserInDB(User):
        hashed_password: str
    
    
    def get_user(db, username: str):
        if username in db:
            user_dict = db[username]
            return UserInDB(**user_dict)
    
    
    def fake_decode_token(token):
        # This doesn't provide any security at all
        # Check the next version
        user = get_user(fake_users_db, token)
        return user
    
    
    async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):
        user = fake_decode_token(token)
        if not user:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Not authenticated",
                headers={"WWW-Authenticate": "Bearer"},
            )
        return user
    
    
    async def get_current_active_user(
        current_user: Annotated[User, Depends(get_current_user)],
    ):
        if current_user.disabled:
            raise HTTPException(status_code=400, detail="Inactive user")
        return current_user
    
    
    @app.post("/token")
    async def login(form_data: Annotated[OAuth2PasswordRequestForm, Depends()]):
        user_dict = fake_users_db.get(form_data.username)
        if not user_dict:
            raise HTTPException(status_code=400, detail="Incorrect username or password")
        user = UserInDB(**user_dict)
        hashed_password = fake_hash_password(form_data.password)
        if not hashed_password == user.hashed_password:
            raise HTTPException(status_code=400, detail="Incorrect username or password")
    
        return {"access_token": user.username, "token_type": "bearer"}
    
    
    @app.get("/users/me")
    async def read_users_me(
        current_user: Annotated[User, Depends(get_current_active_user)],
    ):
        return current_user
    

ü§ì Other versions and variants

Python 3.9+Python 3.10+ - non-AnnotatedPython 3.9+ - non-Annotated
    
    
    from typing import Annotated, Union
    
    from fastapi import Depends, FastAPI, HTTPException, status
    from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
    from pydantic import BaseModel
    
    fake_users_db = {
        "johndoe": {
            "username": "johndoe",
            "full_name": "John Doe",
            "email": "johndoe@example.com",
            "hashed_password": "fakehashedsecret",
            "disabled": False,
        },
        "alice": {
            "username": "alice",
            "full_name": "Alice Wonderson",
            "email": "alice@example.com",
            "hashed_password": "fakehashedsecret2",
            "disabled": True,
        },
    }
    
    app = FastAPI()
    
    
    def fake_hash_password(password: str):
        return "fakehashed" + password
    
    
    oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")
    
    
    class User(BaseModel):
        username: str
        email: Union[str, None] = None
        full_name: Union[str, None] = None
        disabled: Union[bool, None] = None
    
    
    class UserInDB(User):
        hashed_password: str
    
    
    def get_user(db, username: str):
        if username in db:
            user_dict = db[username]
            return UserInDB(**user_dict)
    
    
    def fake_decode_token(token):
        # This doesn't provide any security at all
        # Check the next version
        user = get_user(fake_users_db, token)
        return user
    
    
    async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):
        user = fake_decode_token(token)
        if not user:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Not authenticated",
                headers={"WWW-Authenticate": "Bearer"},
            )
        return user
    
    
    async def get_current_active_user(
        current_user: Annotated[User, Depends(get_current_user)],
    ):
        if current_user.disabled:
            raise HTTPException(status_code=400, detail="Inactive user")
        return current_user
    
    
    @app.post("/token")
    async def login(form_data: Annotated[OAuth2PasswordRequestForm, Depends()]):
        user_dict = fake_users_db.get(form_data.username)
        if not user_dict:
            raise HTTPException(status_code=400, detail="Incorrect username or password")
        user = UserInDB(**user_dict)
        hashed_password = fake_hash_password(form_data.password)
        if not hashed_password == user.hashed_password:
            raise HTTPException(status_code=400, detail="Incorrect username or password")
    
        return {"access_token": user.username, "token_type": "bearer"}
    
    
    @app.get("/users/me")
    async def read_users_me(
        current_user: Annotated[User, Depends(get_current_active_user)],
    ):
        return current_user
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import Depends, FastAPI, HTTPException, status
    from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
    from pydantic import BaseModel
    
    fake_users_db = {
        "johndoe": {
            "username": "johndoe",
            "full_name": "John Doe",
            "email": "johndoe@example.com",
            "hashed_password": "fakehashedsecret",
            "disabled": False,
        },
        "alice": {
            "username": "alice",
            "full_name": "Alice Wonderson",
            "email": "alice@example.com",
            "hashed_password": "fakehashedsecret2",
            "disabled": True,
        },
    }
    
    app = FastAPI()
    
    
    def fake_hash_password(password: str):
        return "fakehashed" + password
    
    
    oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")
    
    
    class User(BaseModel):
        username: str
        email: str | None = None
        full_name: str | None = None
        disabled: bool | None = None
    
    
    class UserInDB(User):
        hashed_password: str
    
    
    def get_user(db, username: str):
        if username in db:
            user_dict = db[username]
            return UserInDB(**user_dict)
    
    
    def fake_decode_token(token):
        # This doesn't provide any security at all
        # Check the next version
        user = get_user(fake_users_db, token)
        return user
    
    
    async def get_current_user(token: str = Depends(oauth2_scheme)):
        user = fake_decode_token(token)
        if not user:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Not authenticated",
                headers={"WWW-Authenticate": "Bearer"},
            )
        return user
    
    
    async def get_current_active_user(current_user: User = Depends(get_current_user)):
        if current_user.disabled:
            raise HTTPException(status_code=400, detail="Inactive user")
        return current_user
    
    
    @app.post("/token")
    async def login(form_data: OAuth2PasswordRequestForm = Depends()):
        user_dict = fake_users_db.get(form_data.username)
        if not user_dict:
            raise HTTPException(status_code=400, detail="Incorrect username or password")
        user = UserInDB(**user_dict)
        hashed_password = fake_hash_password(form_data.password)
        if not hashed_password == user.hashed_password:
            raise HTTPException(status_code=400, detail="Incorrect username or password")
    
        return {"access_token": user.username, "token_type": "bearer"}
    
    
    @app.get("/users/me")
    async def read_users_me(current_user: User = Depends(get_current_active_user)):
        return current_user
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from typing import Union
    
    from fastapi import Depends, FastAPI, HTTPException, status
    from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
    from pydantic import BaseModel
    
    fake_users_db = {
        "johndoe": {
            "username": "johndoe",
            "full_name": "John Doe",
            "email": "johndoe@example.com",
            "hashed_password": "fakehashedsecret",
            "disabled": False,
        },
        "alice": {
            "username": "alice",
            "full_name": "Alice Wonderson",
            "email": "alice@example.com",
            "hashed_password": "fakehashedsecret2",
            "disabled": True,
        },
    }
    
    app = FastAPI()
    
    
    def fake_hash_password(password: str):
        return "fakehashed" + password
    
    
    oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")
    
    
    class User(BaseModel):
        username: str
        email: Union[str, None] = None
        full_name: Union[str, None] = None
        disabled: Union[bool, None] = None
    
    
    class UserInDB(User):
        hashed_password: str
    
    
    def get_user(db, username: str):
        if username in db:
            user_dict = db[username]
            return UserInDB(**user_dict)
    
    
    def fake_decode_token(token):
        # This doesn't provide any security at all
        # Check the next version
        user = get_user(fake_users_db, token)
        return user
    
    
    async def get_current_user(token: str = Depends(oauth2_scheme)):
        user = fake_decode_token(token)
        if not user:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Not authenticated",
                headers={"WWW-Authenticate": "Bearer"},
            )
        return user
    
    
    async def get_current_active_user(current_user: User = Depends(get_current_user)):
        if current_user.disabled:
            raise HTTPException(status_code=400, detail="Inactive user")
        return current_user
    
    
    @app.post("/token")
    async def login(form_data: OAuth2PasswordRequestForm = Depends()):
        user_dict = fake_users_db.get(form_data.username)
        if not user_dict:
            raise HTTPException(status_code=400, detail="Incorrect username or password")
        user = UserInDB(**user_dict)
        hashed_password = fake_hash_password(form_data.password)
        if not hashed_password == user.hashed_password:
            raise HTTPException(status_code=400, detail="Incorrect username or password")
    
        return {"access_token": user.username, "token_type": "bearer"}
    
    
    @app.get("/users/me")
    async def read_users_me(current_user: User = Depends(get_current_active_user)):
        return current_user
    

Tip

By the spec, you should return a JSON with an `access_token` and a `token_type`, the same as in this example.

This is something that you have to do yourself in your code, and make sure you use those JSON keys.

It's almost the only thing that you have to remember to do correctly yourself, to be compliant with the specifications.

For the rest, **FastAPI** handles it for you.

## Update the dependencies[¶](#update-the-dependencies "Permanent link")

Now we are going to update our dependencies.

We want to get the `current_user` _only_ if this user is active.

So, we create an additional dependency `get_current_active_user` that in turn uses `get_current_user` as a dependency.

Both of these dependencies will just return an HTTP error if the user doesn't exist, or if is inactive.

So, in our endpoint, we will only get a user if the user exists, was correctly authenticated, and is active:

Python 3.10+
    
    
    from typing import Annotated
    
    from fastapi import Depends, FastAPI, HTTPException, status
    from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
    from pydantic import BaseModel
    
    fake_users_db = {
        "johndoe": {
            "username": "johndoe",
            "full_name": "John Doe",
            "email": "johndoe@example.com",
            "hashed_password": "fakehashedsecret",
            "disabled": False,
        },
        "alice": {
            "username": "alice",
            "full_name": "Alice Wonderson",
            "email": "alice@example.com",
            "hashed_password": "fakehashedsecret2",
            "disabled": True,
        },
    }
    
    app = FastAPI()
    
    
    def fake_hash_password(password: str):
        return "fakehashed" + password
    
    
    oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")
    
    
    class User(BaseModel):
        username: str
        email: str | None = None
        full_name: str | None = None
        disabled: bool | None = None
    
    
    class UserInDB(User):
        hashed_password: str
    
    
    def get_user(db, username: str):
        if username in db:
            user_dict = db[username]
            return UserInDB(**user_dict)
    
    
    def fake_decode_token(token):
        # This doesn't provide any security at all
        # Check the next version
        user = get_user(fake_users_db, token)
        return user
    
    
    async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):
        user = fake_decode_token(token)
        if not user:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Not authenticated",
                headers={"WWW-Authenticate": "Bearer"},
            )
        return user
    
    
    async def get_current_active_user(
        current_user: Annotated[User, Depends(get_current_user)],
    ):
        if current_user.disabled:
            raise HTTPException(status_code=400, detail="Inactive user")
        return current_user
    
    
    @app.post("/token")
    async def login(form_data: Annotated[OAuth2PasswordRequestForm, Depends()]):
        user_dict = fake_users_db.get(form_data.username)
        if not user_dict:
            raise HTTPException(status_code=400, detail="Incorrect username or password")
        user = UserInDB(**user_dict)
        hashed_password = fake_hash_password(form_data.password)
        if not hashed_password == user.hashed_password:
            raise HTTPException(status_code=400, detail="Incorrect username or password")
    
        return {"access_token": user.username, "token_type": "bearer"}
    
    
    @app.get("/users/me")
    async def read_users_me(
        current_user: Annotated[User, Depends(get_current_active_user)],
    ):
        return current_user
    

ü§ì Other versions and variants

Python 3.9+Python 3.10+ - non-AnnotatedPython 3.9+ - non-Annotated
    
    
    from typing import Annotated, Union
    
    from fastapi import Depends, FastAPI, HTTPException, status
    from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
    from pydantic import BaseModel
    
    fake_users_db = {
        "johndoe": {
            "username": "johndoe",
            "full_name": "John Doe",
            "email": "johndoe@example.com",
            "hashed_password": "fakehashedsecret",
            "disabled": False,
        },
        "alice": {
            "username": "alice",
            "full_name": "Alice Wonderson",
            "email": "alice@example.com",
            "hashed_password": "fakehashedsecret2",
            "disabled": True,
        },
    }
    
    app = FastAPI()
    
    
    def fake_hash_password(password: str):
        return "fakehashed" + password
    
    
    oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")
    
    
    class User(BaseModel):
        username: str
        email: Union[str, None] = None
        full_name: Union[str, None] = None
        disabled: Union[bool, None] = None
    
    
    class UserInDB(User):
        hashed_password: str
    
    
    def get_user(db, username: str):
        if username in db:
            user_dict = db[username]
            return UserInDB(**user_dict)
    
    
    def fake_decode_token(token):
        # This doesn't provide any security at all
        # Check the next version
        user = get_user(fake_users_db, token)
        return user
    
    
    async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):
        user = fake_decode_token(token)
        if not user:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Not authenticated",
                headers={"WWW-Authenticate": "Bearer"},
            )
        return user
    
    
    async def get_current_active_user(
        current_user: Annotated[User, Depends(get_current_user)],
    ):
        if current_user.disabled:
            raise HTTPException(status_code=400, detail="Inactive user")
        return current_user
    
    
    @app.post("/token")
    async def login(form_data: Annotated[OAuth2PasswordRequestForm, Depends()]):
        user_dict = fake_users_db.get(form_data.username)
        if not user_dict:
            raise HTTPException(status_code=400, detail="Incorrect username or password")
        user = UserInDB(**user_dict)
        hashed_password = fake_hash_password(form_data.password)
        if not hashed_password == user.hashed_password:
            raise HTTPException(status_code=400, detail="Incorrect username or password")
    
        return {"access_token": user.username, "token_type": "bearer"}
    
    
    @app.get("/users/me")
    async def read_users_me(
        current_user: Annotated[User, Depends(get_current_active_user)],
    ):
        return current_user
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import Depends, FastAPI, HTTPException, status
    from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
    from pydantic import BaseModel
    
    fake_users_db = {
        "johndoe": {
            "username": "johndoe",
            "full_name": "John Doe",
            "email": "johndoe@example.com",
            "hashed_password": "fakehashedsecret",
            "disabled": False,
        },
        "alice": {
            "username": "alice",
            "full_name": "Alice Wonderson",
            "email": "alice@example.com",
            "hashed_password": "fakehashedsecret2",
            "disabled": True,
        },
    }
    
    app = FastAPI()
    
    
    def fake_hash_password(password: str):
        return "fakehashed" + password
    
    
    oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")
    
    
    class User(BaseModel):
        username: str
        email: str | None = None
        full_name: str | None = None
        disabled: bool | None = None
    
    
    class UserInDB(User):
        hashed_password: str
    
    
    def get_user(db, username: str):
        if username in db:
            user_dict = db[username]
            return UserInDB(**user_dict)
    
    
    def fake_decode_token(token):
        # This doesn't provide any security at all
        # Check the next version
        user = get_user(fake_users_db, token)
        return user
    
    
    async def get_current_user(token: str = Depends(oauth2_scheme)):
        user = fake_decode_token(token)
        if not user:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Not authenticated",
                headers={"WWW-Authenticate": "Bearer"},
            )
        return user
    
    
    async def get_current_active_user(current_user: User = Depends(get_current_user)):
        if current_user.disabled:
            raise HTTPException(status_code=400, detail="Inactive user")
        return current_user
    
    
    @app.post("/token")
    async def login(form_data: OAuth2PasswordRequestForm = Depends()):
        user_dict = fake_users_db.get(form_data.username)
        if not user_dict:
            raise HTTPException(status_code=400, detail="Incorrect username or password")
        user = UserInDB(**user_dict)
        hashed_password = fake_hash_password(form_data.password)
        if not hashed_password == user.hashed_password:
            raise HTTPException(status_code=400, detail="Incorrect username or password")
    
        return {"access_token": user.username, "token_type": "bearer"}
    
    
    @app.get("/users/me")
    async def read_users_me(current_user: User = Depends(get_current_active_user)):
        return current_user
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from typing import Union
    
    from fastapi import Depends, FastAPI, HTTPException, status
    from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
    from pydantic import BaseModel
    
    fake_users_db = {
        "johndoe": {
            "username": "johndoe",
            "full_name": "John Doe",
            "email": "johndoe@example.com",
            "hashed_password": "fakehashedsecret",
            "disabled": False,
        },
        "alice": {
            "username": "alice",
            "full_name": "Alice Wonderson",
            "email": "alice@example.com",
            "hashed_password": "fakehashedsecret2",
            "disabled": True,
        },
    }
    
    app = FastAPI()
    
    
    def fake_hash_password(password: str):
        return "fakehashed" + password
    
    
    oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")
    
    
    class User(BaseModel):
        username: str
        email: Union[str, None] = None
        full_name: Union[str, None] = None
        disabled: Union[bool, None] = None
    
    
    class UserInDB(User):
        hashed_password: str
    
    
    def get_user(db, username: str):
        if username in db:
            user_dict = db[username]
            return UserInDB(**user_dict)
    
    
    def fake_decode_token(token):
        # This doesn't provide any security at all
        # Check the next version
        user = get_user(fake_users_db, token)
        return user
    
    
    async def get_current_user(token: str = Depends(oauth2_scheme)):
        user = fake_decode_token(token)
        if not user:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Not authenticated",
                headers={"WWW-Authenticate": "Bearer"},
            )
        return user
    
    
    async def get_current_active_user(current_user: User = Depends(get_current_user)):
        if current_user.disabled:
            raise HTTPException(status_code=400, detail="Inactive user")
        return current_user
    
    
    @app.post("/token")
    async def login(form_data: OAuth2PasswordRequestForm = Depends()):
        user_dict = fake_users_db.get(form_data.username)
        if not user_dict:
            raise HTTPException(status_code=400, detail="Incorrect username or password")
        user = UserInDB(**user_dict)
        hashed_password = fake_hash_password(form_data.password)
        if not hashed_password == user.hashed_password:
            raise HTTPException(status_code=400, detail="Incorrect username or password")
    
        return {"access_token": user.username, "token_type": "bearer"}
    
    
    @app.get("/users/me")
    async def read_users_me(current_user: User = Depends(get_current_active_user)):
        return current_user
    

Info

The additional header `WWW-Authenticate` with value `Bearer` we are returning here is also part of the spec.

Any HTTP (error) status code 401 "UNAUTHORIZED" is supposed to also return a `WWW-Authenticate` header.

In the case of bearer tokens (our case), the value of that header should be `Bearer`.

You can actually skip that extra header and it would still work.

But it's provided here to be compliant with the specifications.

Also, there might be tools that expect and use it (now or in the future) and that might be useful for you or your users, now or in the future.

That's the benefit of standards...

## See it in action[¶](#see-it-in-action "Permanent link")

Open the interactive docs: <http://127.0.0.1:8000/docs>.

### Authenticate[¶](#authenticate "Permanent link")

Click the "Authorize" button.

Use the credentials:

User: `johndoe`

Password: `secret`

![](/img/tutorial/security/image04.png)

After authenticating in the system, you will see it like:

![](/img/tutorial/security/image05.png)

### Get your own user data[¶](#get-your-own-user-data "Permanent link")

Now use the operation `GET` with the path `/users/me`.

You will get your user's data, like:
    
    
    {
      "username": "johndoe",
      "email": "johndoe@example.com",
      "full_name": "John Doe",
      "disabled": false,
      "hashed_password": "fakehashedsecret"
    }
    

![](/img/tutorial/security/image06.png)

If you click the lock icon and logout, and then try the same operation again, you will get an HTTP 401 error of:
    
    
    {
      "detail": "Not authenticated"
    }
    

### Inactive user[¶](#inactive-user "Permanent link")

Now try with an inactive user, authenticate with:

User: `alice`

Password: `secret2`

And try to use the operation `GET` with the path `/users/me`.

You will get an "Inactive user" error, like:
    
    
    {
      "detail": "Inactive user"
    }
    

## Recap[¶](#recap "Permanent link")

You now have the tools to implement a complete security system based on `username` and `password` for your API.

Using these tools, you can make the security system compatible with any database and with any user or data model.

The only detail missing is that it is not actually "secure" yet.

In the next chapter you'll see how to use a secure password hashing library and JWT tokens.
  *[JWT]: JSON Web Tokens

---

###### OAuth2 with Password (and hashing), Bearer with JWT tokens¶

# OAuth2 with Password (and hashing), Bearer with JWT tokens[¶](#oauth2-with-password-and-hashing-bearer-with-jwt-tokens "Permanent link")

Now that we have all the security flow, let's make the application actually secure, using JWT tokens and secure password hashing.

This code is something you can actually use in your application, save the password hashes in your database, etc.

We are going to start from where we left in the previous chapter and increment it.

## About JWT[¶](#about-jwt "Permanent link")

JWT means "JSON Web Tokens".

It's a standard to codify a JSON object in a long dense string without spaces. It looks like this:
    
    
    eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
    

It is not encrypted, so, anyone could recover the information from the contents.

But it's signed. So, when you receive a token that you emitted, you can verify that you actually emitted it.

That way, you can create a token with an expiration of, let's say, 1 week. And then when the user comes back the next day with the token, you know that user is still logged in to your system.

After a week, the token will be expired and the user will not be authorized and will have to sign in again to get a new token. And if the user (or a third party) tried to modify the token to change the expiration, you would be able to discover it, because the signatures would not match.

If you want to play with JWT tokens and see how they work, check [https://jwt.io](https://jwt.io/).

## Install `PyJWT`[¶](#install-pyjwt "Permanent link")

We need to install `PyJWT` to generate and verify the JWT tokens in Python.

Make sure you create a [virtual environment](../../../virtual-environments/), activate it, and then install `pyjwt`:
    
    
    $ pip install pyjwt
    
    ---> 100%
    

Info

If you are planning to use digital signature algorithms like RSA or ECDSA, you should install the cryptography library dependency `pyjwt[crypto]`.

You can read more about it in the [PyJWT Installation docs](https://pyjwt.readthedocs.io/en/latest/installation.html).

## Password hashing[¶](#password-hashing "Permanent link")

"Hashing" means converting some content (a password in this case) into a sequence of bytes (just a string) that looks like gibberish.

Whenever you pass exactly the same content (exactly the same password) you get exactly the same gibberish.

But you cannot convert from the gibberish back to the password.

### Why use password hashing[¶](#why-use-password-hashing "Permanent link")

If your database is stolen, the thief won't have your users' plaintext passwords, only the hashes.

So, the thief won't be able to try to use that password in another system (as many users use the same password everywhere, this would be dangerous).

## Install `pwdlib`[¶](#install-pwdlib "Permanent link")

pwdlib is a great Python package to handle password hashes.

It supports many secure hashing algorithms and utilities to work with them.

The recommended algorithm is "Argon2".

Make sure you create a [virtual environment](../../../virtual-environments/), activate it, and then install pwdlib with Argon2:
    
    
    $ pip install "pwdlib[argon2]"
    
    ---> 100%
    

Tip

With `pwdlib`, you could even configure it to be able to read passwords created by **Django** , a **Flask** security plug-in or many others.

So, you would be able to, for example, share the same data from a Django application in a database with a FastAPI application. Or gradually migrate a Django application using the same database.

And your users would be able to login from your Django app or from your **FastAPI** app, at the same time.

## Hash and verify the passwords[¶](#hash-and-verify-the-passwords "Permanent link")

Import the tools we need from `pwdlib`.

Create a PasswordHash instance with recommended settings - it will be used for hashing and verifying passwords.

Tip

pwdlib also supports the bcrypt hashing algorithm but does not include legacy algorithms - for working with outdated hashes, it is recommended to use the passlib library.

For example, you could use it to read and verify passwords generated by another system (like Django) but hash any new passwords with a different algorithm like Argon2 or Bcrypt.

And be compatible with all of them at the same time.

Create a utility function to hash a password coming from the user.

And another utility to verify if a received password matches the hash stored.

And another one to authenticate and return a user.

Python 3.10+
    
    
    from datetime import datetime, timedelta, timezone
    from typing import Annotated
    
    import jwt
    from fastapi import Depends, FastAPI, HTTPException, status
    from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
    from jwt.exceptions import InvalidTokenError
    from pwdlib import PasswordHash
    from pydantic import BaseModel
    
    # to get a string like this run:
    # openssl rand -hex 32
    SECRET_KEY = "09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
    ALGORITHM = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES = 30
    
    
    fake_users_db = {
        "johndoe": {
            "username": "johndoe",
            "full_name": "John Doe",
            "email": "johndoe@example.com",
            "hashed_password": "$argon2id$v=19$m=65536,t=3,p=4$wagCPXjifgvUFBzq4hqe3w$CYaIb8sB+wtD+Vu/P4uod1+Qof8h+1g7bbDlBID48Rc",
            "disabled": False,
        }
    }
    
    
    class Token(BaseModel):
        access_token: str
        token_type: str
    
    
    class TokenData(BaseModel):
        username: str | None = None
    
    
    class User(BaseModel):
        username: str
        email: str | None = None
        full_name: str | None = None
        disabled: bool | None = None
    
    
    class UserInDB(User):
        hashed_password: str
    
    
    password_hash = PasswordHash.recommended()
    
    oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")
    
    app = FastAPI()
    
    
    def verify_password(plain_password, hashed_password):
        return password_hash.verify(plain_password, hashed_password)
    
    
    def get_password_hash(password):
        return password_hash.hash(password)
    
    
    def get_user(db, username: str):
        if username in db:
            user_dict = db[username]
            return UserInDB(**user_dict)
    
    
    def authenticate_user(fake_db, username: str, password: str):
        user = get_user(fake_db, username)
        if not user:
            return False
        if not verify_password(password, user.hashed_password):
            return False
        return user
    
    
    def create_access_token(data: dict, expires_delta: timedelta | None = None):
        to_encode = data.copy()
        if expires_delta:
            expire = datetime.now(timezone.utc) + expires_delta
        else:
            expire = datetime.now(timezone.utc) + timedelta(minutes=15)
        to_encode.update({"exp": expire})
        encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
        return encoded_jwt
    
    
    async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):
        credentials_exception = HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Could not validate credentials",
            headers={"WWW-Authenticate": "Bearer"},
        )
        try:
            payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
            username = payload.get("sub")
            if username is None:
                raise credentials_exception
            token_data = TokenData(username=username)
        except InvalidTokenError:
            raise credentials_exception
        user = get_user(fake_users_db, username=token_data.username)
        if user is None:
            raise credentials_exception
        return user
    
    
    async def get_current_active_user(
        current_user: Annotated[User, Depends(get_current_user)],
    ):
        if current_user.disabled:
            raise HTTPException(status_code=400, detail="Inactive user")
        return current_user
    
    
    @app.post("/token")
    async def login_for_access_token(
        form_data: Annotated[OAuth2PasswordRequestForm, Depends()],
    ) -> Token:
        user = authenticate_user(fake_users_db, form_data.username, form_data.password)
        if not user:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Incorrect username or password",
                headers={"WWW-Authenticate": "Bearer"},
            )
        access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
        access_token = create_access_token(
            data={"sub": user.username}, expires_delta=access_token_expires
        )
        return Token(access_token=access_token, token_type="bearer")
    
    
    @app.get("/users/me/")
    async def read_users_me(
        current_user: Annotated[User, Depends(get_current_active_user)],
    ) -> User:
        return current_user
    
    
    @app.get("/users/me/items/")
    async def read_own_items(
        current_user: Annotated[User, Depends(get_current_active_user)],
    ):
        return [{"item_id": "Foo", "owner": current_user.username}]
    

ü§ì Other versions and variants

Python 3.9+Python 3.10+ - non-AnnotatedPython 3.9+ - non-Annotated
    
    
    from datetime import datetime, timedelta, timezone
    from typing import Annotated, Union
    
    import jwt
    from fastapi import Depends, FastAPI, HTTPException, status
    from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
    from jwt.exceptions import InvalidTokenError
    from pwdlib import PasswordHash
    from pydantic import BaseModel
    
    # to get a string like this run:
    # openssl rand -hex 32
    SECRET_KEY = "09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
    ALGORITHM = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES = 30
    
    
    fake_users_db = {
        "johndoe": {
            "username": "johndoe",
            "full_name": "John Doe",
            "email": "johndoe@example.com",
            "hashed_password": "$argon2id$v=19$m=65536,t=3,p=4$wagCPXjifgvUFBzq4hqe3w$CYaIb8sB+wtD+Vu/P4uod1+Qof8h+1g7bbDlBID48Rc",
            "disabled": False,
        }
    }
    
    
    class Token(BaseModel):
        access_token: str
        token_type: str
    
    
    class TokenData(BaseModel):
        username: Union[str, None] = None
    
    
    class User(BaseModel):
        username: str
        email: Union[str, None] = None
        full_name: Union[str, None] = None
        disabled: Union[bool, None] = None
    
    
    class UserInDB(User):
        hashed_password: str
    
    
    password_hash = PasswordHash.recommended()
    
    oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")
    
    app = FastAPI()
    
    
    def verify_password(plain_password, hashed_password):
        return password_hash.verify(plain_password, hashed_password)
    
    
    def get_password_hash(password):
        return password_hash.hash(password)
    
    
    def get_user(db, username: str):
        if username in db:
            user_dict = db[username]
            return UserInDB(**user_dict)
    
    
    def authenticate_user(fake_db, username: str, password: str):
        user = get_user(fake_db, username)
        if not user:
            return False
        if not verify_password(password, user.hashed_password):
            return False
        return user
    
    
    def create_access_token(data: dict, expires_delta: Union[timedelta, None] = None):
        to_encode = data.copy()
        if expires_delta:
            expire = datetime.now(timezone.utc) + expires_delta
        else:
            expire = datetime.now(timezone.utc) + timedelta(minutes=15)
        to_encode.update({"exp": expire})
        encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
        return encoded_jwt
    
    
    async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):
        credentials_exception = HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Could not validate credentials",
            headers={"WWW-Authenticate": "Bearer"},
        )
        try:
            payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
            username = payload.get("sub")
            if username is None:
                raise credentials_exception
            token_data = TokenData(username=username)
        except InvalidTokenError:
            raise credentials_exception
        user = get_user(fake_users_db, username=token_data.username)
        if user is None:
            raise credentials_exception
        return user
    
    
    async def get_current_active_user(
        current_user: Annotated[User, Depends(get_current_user)],
    ):
        if current_user.disabled:
            raise HTTPException(status_code=400, detail="Inactive user")
        return current_user
    
    
    @app.post("/token")
    async def login_for_access_token(
        form_data: Annotated[OAuth2PasswordRequestForm, Depends()],
    ) -> Token:
        user = authenticate_user(fake_users_db, form_data.username, form_data.password)
        if not user:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Incorrect username or password",
                headers={"WWW-Authenticate": "Bearer"},
            )
        access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
        access_token = create_access_token(
            data={"sub": user.username}, expires_delta=access_token_expires
        )
        return Token(access_token=access_token, token_type="bearer")
    
    
    @app.get("/users/me/")
    async def read_users_me(
        current_user: Annotated[User, Depends(get_current_active_user)],
    ) -> User:
        return current_user
    
    
    @app.get("/users/me/items/")
    async def read_own_items(
        current_user: Annotated[User, Depends(get_current_active_user)],
    ):
        return [{"item_id": "Foo", "owner": current_user.username}]
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from datetime import datetime, timedelta, timezone
    
    import jwt
    from fastapi import Depends, FastAPI, HTTPException, status
    from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
    from jwt.exceptions import InvalidTokenError
    from pwdlib import PasswordHash
    from pydantic import BaseModel
    
    # to get a string like this run:
    # openssl rand -hex 32
    SECRET_KEY = "09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
    ALGORITHM = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES = 30
    
    
    fake_users_db = {
        "johndoe": {
            "username": "johndoe",
            "full_name": "John Doe",
            "email": "johndoe@example.com",
            "hashed_password": "$argon2id$v=19$m=65536,t=3,p=4$wagCPXjifgvUFBzq4hqe3w$CYaIb8sB+wtD+Vu/P4uod1+Qof8h+1g7bbDlBID48Rc",
            "disabled": False,
        }
    }
    
    
    class Token(BaseModel):
        access_token: str
        token_type: str
    
    
    class TokenData(BaseModel):
        username: str | None = None
    
    
    class User(BaseModel):
        username: str
        email: str | None = None
        full_name: str | None = None
        disabled: bool | None = None
    
    
    class UserInDB(User):
        hashed_password: str
    
    
    password_hash = PasswordHash.recommended()
    
    oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")
    
    app = FastAPI()
    
    
    def verify_password(plain_password, hashed_password):
        return password_hash.verify(plain_password, hashed_password)
    
    
    def get_password_hash(password):
        return password_hash.hash(password)
    
    
    def get_user(db, username: str):
        if username in db:
            user_dict = db[username]
            return UserInDB(**user_dict)
    
    
    def authenticate_user(fake_db, username: str, password: str):
        user = get_user(fake_db, username)
        if not user:
            return False
        if not verify_password(password, user.hashed_password):
            return False
        return user
    
    
    def create_access_token(data: dict, expires_delta: timedelta | None = None):
        to_encode = data.copy()
        if expires_delta:
            expire = datetime.now(timezone.utc) + expires_delta
        else:
            expire = datetime.now(timezone.utc) + timedelta(minutes=15)
        to_encode.update({"exp": expire})
        encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
        return encoded_jwt
    
    
    async def get_current_user(token: str = Depends(oauth2_scheme)):
        credentials_exception = HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Could not validate credentials",
            headers={"WWW-Authenticate": "Bearer"},
        )
        try:
            payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
            username = payload.get("sub")
            if username is None:
                raise credentials_exception
            token_data = TokenData(username=username)
        except InvalidTokenError:
            raise credentials_exception
        user = get_user(fake_users_db, username=token_data.username)
        if user is None:
            raise credentials_exception
        return user
    
    
    async def get_current_active_user(current_user: User = Depends(get_current_user)):
        if current_user.disabled:
            raise HTTPException(status_code=400, detail="Inactive user")
        return current_user
    
    
    @app.post("/token")
    async def login_for_access_token(
        form_data: OAuth2PasswordRequestForm = Depends(),
    ) -> Token:
        user = authenticate_user(fake_users_db, form_data.username, form_data.password)
        if not user:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Incorrect username or password",
                headers={"WWW-Authenticate": "Bearer"},
            )
        access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
        access_token = create_access_token(
            data={"sub": user.username}, expires_delta=access_token_expires
        )
        return Token(access_token=access_token, token_type="bearer")
    
    
    @app.get("/users/me/")
    async def read_users_me(current_user: User = Depends(get_current_active_user)) -> User:
        return current_user
    
    
    @app.get("/users/me/items/")
    async def read_own_items(current_user: User = Depends(get_current_active_user)):
        return [{"item_id": "Foo", "owner": current_user.username}]
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from datetime import datetime, timedelta, timezone
    from typing import Union
    
    import jwt
    from fastapi import Depends, FastAPI, HTTPException, status
    from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
    from jwt.exceptions import InvalidTokenError
    from pwdlib import PasswordHash
    from pydantic import BaseModel
    
    # to get a string like this run:
    # openssl rand -hex 32
    SECRET_KEY = "09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
    ALGORITHM = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES = 30
    
    
    fake_users_db = {
        "johndoe": {
            "username": "johndoe",
            "full_name": "John Doe",
            "email": "johndoe@example.com",
            "hashed_password": "$argon2id$v=19$m=65536,t=3,p=4$wagCPXjifgvUFBzq4hqe3w$CYaIb8sB+wtD+Vu/P4uod1+Qof8h+1g7bbDlBID48Rc",
            "disabled": False,
        }
    }
    
    
    class Token(BaseModel):
        access_token: str
        token_type: str
    
    
    class TokenData(BaseModel):
        username: Union[str, None] = None
    
    
    class User(BaseModel):
        username: str
        email: Union[str, None] = None
        full_name: Union[str, None] = None
        disabled: Union[bool, None] = None
    
    
    class UserInDB(User):
        hashed_password: str
    
    
    password_hash = PasswordHash.recommended()
    
    oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")
    
    app = FastAPI()
    
    
    def verify_password(plain_password, hashed_password):
        return password_hash.verify(plain_password, hashed_password)
    
    
    def get_password_hash(password):
        return password_hash.hash(password)
    
    
    def get_user(db, username: str):
        if username in db:
            user_dict = db[username]
            return UserInDB(**user_dict)
    
    
    def authenticate_user(fake_db, username: str, password: str):
        user = get_user(fake_db, username)
        if not user:
            return False
        if not verify_password(password, user.hashed_password):
            return False
        return user
    
    
    def create_access_token(data: dict, expires_delta: Union[timedelta, None] = None):
        to_encode = data.copy()
        if expires_delta:
            expire = datetime.now(timezone.utc) + expires_delta
        else:
            expire = datetime.now(timezone.utc) + timedelta(minutes=15)
        to_encode.update({"exp": expire})
        encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
        return encoded_jwt
    
    
    async def get_current_user(token: str = Depends(oauth2_scheme)):
        credentials_exception = HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Could not validate credentials",
            headers={"WWW-Authenticate": "Bearer"},
        )
        try:
            payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
            username = payload.get("sub")
            if username is None:
                raise credentials_exception
            token_data = TokenData(username=username)
        except InvalidTokenError:
            raise credentials_exception
        user = get_user(fake_users_db, username=token_data.username)
        if user is None:
            raise credentials_exception
        return user
    
    
    async def get_current_active_user(current_user: User = Depends(get_current_user)):
        if current_user.disabled:
            raise HTTPException(status_code=400, detail="Inactive user")
        return current_user
    
    
    @app.post("/token")
    async def login_for_access_token(
        form_data: OAuth2PasswordRequestForm = Depends(),
    ) -> Token:
        user = authenticate_user(fake_users_db, form_data.username, form_data.password)
        if not user:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Incorrect username or password",
                headers={"WWW-Authenticate": "Bearer"},
            )
        access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
        access_token = create_access_token(
            data={"sub": user.username}, expires_delta=access_token_expires
        )
        return Token(access_token=access_token, token_type="bearer")
    
    
    @app.get("/users/me/")
    async def read_users_me(current_user: User = Depends(get_current_active_user)) -> User:
        return current_user
    
    
    @app.get("/users/me/items/")
    async def read_own_items(current_user: User = Depends(get_current_active_user)):
        return [{"item_id": "Foo", "owner": current_user.username}]
    

Note

If you check the new (fake) database `fake_users_db`, you will see how the hashed password looks like now: `"$argon2id$v=19$m=65536,t=3,p=4$wagCPXjifgvUFBzq4hqe3w$CYaIb8sB+wtD+Vu/P4uod1+Qof8h+1g7bbDlBID48Rc"`.

## Handle JWT tokens[¶](#handle-jwt-tokens "Permanent link")

Import the modules installed.

Create a random secret key that will be used to sign the JWT tokens.

To generate a secure random secret key use the command:
    
    
    $ openssl rand -hex 32
    
    09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7
    

And copy the output to the variable `SECRET_KEY` (don't use the one in the example).

Create a variable `ALGORITHM` with the algorithm used to sign the JWT token and set it to `"HS256"`.

Create a variable for the expiration of the token.

Define a Pydantic Model that will be used in the token endpoint for the response.

Create a utility function to generate a new access token.

Python 3.10+
    
    
    from datetime import datetime, timedelta, timezone
    from typing import Annotated
    
    import jwt
    from fastapi import Depends, FastAPI, HTTPException, status
    from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
    from jwt.exceptions import InvalidTokenError
    from pwdlib import PasswordHash
    from pydantic import BaseModel
    
    # to get a string like this run:
    # openssl rand -hex 32
    SECRET_KEY = "09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
    ALGORITHM = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES = 30
    
    
    fake_users_db = {
        "johndoe": {
            "username": "johndoe",
            "full_name": "John Doe",
            "email": "johndoe@example.com",
            "hashed_password": "$argon2id$v=19$m=65536,t=3,p=4$wagCPXjifgvUFBzq4hqe3w$CYaIb8sB+wtD+Vu/P4uod1+Qof8h+1g7bbDlBID48Rc",
            "disabled": False,
        }
    }
    
    
    class Token(BaseModel):
        access_token: str
        token_type: str
    
    
    class TokenData(BaseModel):
        username: str | None = None
    
    
    class User(BaseModel):
        username: str
        email: str | None = None
        full_name: str | None = None
        disabled: bool | None = None
    
    
    class UserInDB(User):
        hashed_password: str
    
    
    password_hash = PasswordHash.recommended()
    
    oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")
    
    app = FastAPI()
    
    
    def verify_password(plain_password, hashed_password):
        return password_hash.verify(plain_password, hashed_password)
    
    
    def get_password_hash(password):
        return password_hash.hash(password)
    
    
    def get_user(db, username: str):
        if username in db:
            user_dict = db[username]
            return UserInDB(**user_dict)
    
    
    def authenticate_user(fake_db, username: str, password: str):
        user = get_user(fake_db, username)
        if not user:
            return False
        if not verify_password(password, user.hashed_password):
            return False
        return user
    
    
    def create_access_token(data: dict, expires_delta: timedelta | None = None):
        to_encode = data.copy()
        if expires_delta:
            expire = datetime.now(timezone.utc) + expires_delta
        else:
            expire = datetime.now(timezone.utc) + timedelta(minutes=15)
        to_encode.update({"exp": expire})
        encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
        return encoded_jwt
    
    
    async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):
        credentials_exception = HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Could not validate credentials",
            headers={"WWW-Authenticate": "Bearer"},
        )
        try:
            payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
            username = payload.get("sub")
            if username is None:
                raise credentials_exception
            token_data = TokenData(username=username)
        except InvalidTokenError:
            raise credentials_exception
        user = get_user(fake_users_db, username=token_data.username)
        if user is None:
            raise credentials_exception
        return user
    
    
    async def get_current_active_user(
        current_user: Annotated[User, Depends(get_current_user)],
    ):
        if current_user.disabled:
            raise HTTPException(status_code=400, detail="Inactive user")
        return current_user
    
    
    @app.post("/token")
    async def login_for_access_token(
        form_data: Annotated[OAuth2PasswordRequestForm, Depends()],
    ) -> Token:
        user = authenticate_user(fake_users_db, form_data.username, form_data.password)
        if not user:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Incorrect username or password",
                headers={"WWW-Authenticate": "Bearer"},
            )
        access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
        access_token = create_access_token(
            data={"sub": user.username}, expires_delta=access_token_expires
        )
        return Token(access_token=access_token, token_type="bearer")
    
    
    @app.get("/users/me/")
    async def read_users_me(
        current_user: Annotated[User, Depends(get_current_active_user)],
    ) -> User:
        return current_user
    
    
    @app.get("/users/me/items/")
    async def read_own_items(
        current_user: Annotated[User, Depends(get_current_active_user)],
    ):
        return [{"item_id": "Foo", "owner": current_user.username}]
    

ü§ì Other versions and variants

Python 3.9+Python 3.10+ - non-AnnotatedPython 3.9+ - non-Annotated
    
    
    from datetime import datetime, timedelta, timezone
    from typing import Annotated, Union
    
    import jwt
    from fastapi import Depends, FastAPI, HTTPException, status
    from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
    from jwt.exceptions import InvalidTokenError
    from pwdlib import PasswordHash
    from pydantic import BaseModel
    
    # to get a string like this run:
    # openssl rand -hex 32
    SECRET_KEY = "09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
    ALGORITHM = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES = 30
    
    
    fake_users_db = {
        "johndoe": {
            "username": "johndoe",
            "full_name": "John Doe",
            "email": "johndoe@example.com",
            "hashed_password": "$argon2id$v=19$m=65536,t=3,p=4$wagCPXjifgvUFBzq4hqe3w$CYaIb8sB+wtD+Vu/P4uod1+Qof8h+1g7bbDlBID48Rc",
            "disabled": False,
        }
    }
    
    
    class Token(BaseModel):
        access_token: str
        token_type: str
    
    
    class TokenData(BaseModel):
        username: Union[str, None] = None
    
    
    class User(BaseModel):
        username: str
        email: Union[str, None] = None
        full_name: Union[str, None] = None
        disabled: Union[bool, None] = None
    
    
    class UserInDB(User):
        hashed_password: str
    
    
    password_hash = PasswordHash.recommended()
    
    oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")
    
    app = FastAPI()
    
    
    def verify_password(plain_password, hashed_password):
        return password_hash.verify(plain_password, hashed_password)
    
    
    def get_password_hash(password):
        return password_hash.hash(password)
    
    
    def get_user(db, username: str):
        if username in db:
            user_dict = db[username]
            return UserInDB(**user_dict)
    
    
    def authenticate_user(fake_db, username: str, password: str):
        user = get_user(fake_db, username)
        if not user:
            return False
        if not verify_password(password, user.hashed_password):
            return False
        return user
    
    
    def create_access_token(data: dict, expires_delta: Union[timedelta, None] = None):
        to_encode = data.copy()
        if expires_delta:
            expire = datetime.now(timezone.utc) + expires_delta
        else:
            expire = datetime.now(timezone.utc) + timedelta(minutes=15)
        to_encode.update({"exp": expire})
        encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
        return encoded_jwt
    
    
    async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):
        credentials_exception = HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Could not validate credentials",
            headers={"WWW-Authenticate": "Bearer"},
        )
        try:
            payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
            username = payload.get("sub")
            if username is None:
                raise credentials_exception
            token_data = TokenData(username=username)
        except InvalidTokenError:
            raise credentials_exception
        user = get_user(fake_users_db, username=token_data.username)
        if user is None:
            raise credentials_exception
        return user
    
    
    async def get_current_active_user(
        current_user: Annotated[User, Depends(get_current_user)],
    ):
        if current_user.disabled:
            raise HTTPException(status_code=400, detail="Inactive user")
        return current_user
    
    
    @app.post("/token")
    async def login_for_access_token(
        form_data: Annotated[OAuth2PasswordRequestForm, Depends()],
    ) -> Token:
        user = authenticate_user(fake_users_db, form_data.username, form_data.password)
        if not user:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Incorrect username or password",
                headers={"WWW-Authenticate": "Bearer"},
            )
        access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
        access_token = create_access_token(
            data={"sub": user.username}, expires_delta=access_token_expires
        )
        return Token(access_token=access_token, token_type="bearer")
    
    
    @app.get("/users/me/")
    async def read_users_me(
        current_user: Annotated[User, Depends(get_current_active_user)],
    ) -> User:
        return current_user
    
    
    @app.get("/users/me/items/")
    async def read_own_items(
        current_user: Annotated[User, Depends(get_current_active_user)],
    ):
        return [{"item_id": "Foo", "owner": current_user.username}]
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from datetime import datetime, timedelta, timezone
    
    import jwt
    from fastapi import Depends, FastAPI, HTTPException, status
    from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
    from jwt.exceptions import InvalidTokenError
    from pwdlib import PasswordHash
    from pydantic import BaseModel
    
    # to get a string like this run:
    # openssl rand -hex 32
    SECRET_KEY = "09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
    ALGORITHM = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES = 30
    
    
    fake_users_db = {
        "johndoe": {
            "username": "johndoe",
            "full_name": "John Doe",
            "email": "johndoe@example.com",
            "hashed_password": "$argon2id$v=19$m=65536,t=3,p=4$wagCPXjifgvUFBzq4hqe3w$CYaIb8sB+wtD+Vu/P4uod1+Qof8h+1g7bbDlBID48Rc",
            "disabled": False,
        }
    }
    
    
    class Token(BaseModel):
        access_token: str
        token_type: str
    
    
    class TokenData(BaseModel):
        username: str | None = None
    
    
    class User(BaseModel):
        username: str
        email: str | None = None
        full_name: str | None = None
        disabled: bool | None = None
    
    
    class UserInDB(User):
        hashed_password: str
    
    
    password_hash = PasswordHash.recommended()
    
    oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")
    
    app = FastAPI()
    
    
    def verify_password(plain_password, hashed_password):
        return password_hash.verify(plain_password, hashed_password)
    
    
    def get_password_hash(password):
        return password_hash.hash(password)
    
    
    def get_user(db, username: str):
        if username in db:
            user_dict = db[username]
            return UserInDB(**user_dict)
    
    
    def authenticate_user(fake_db, username: str, password: str):
        user = get_user(fake_db, username)
        if not user:
            return False
        if not verify_password(password, user.hashed_password):
            return False
        return user
    
    
    def create_access_token(data: dict, expires_delta: timedelta | None = None):
        to_encode = data.copy()
        if expires_delta:
            expire = datetime.now(timezone.utc) + expires_delta
        else:
            expire = datetime.now(timezone.utc) + timedelta(minutes=15)
        to_encode.update({"exp": expire})
        encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
        return encoded_jwt
    
    
    async def get_current_user(token: str = Depends(oauth2_scheme)):
        credentials_exception = HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Could not validate credentials",
            headers={"WWW-Authenticate": "Bearer"},
        )
        try:
            payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
            username = payload.get("sub")
            if username is None:
                raise credentials_exception
            token_data = TokenData(username=username)
        except InvalidTokenError:
            raise credentials_exception
        user = get_user(fake_users_db, username=token_data.username)
        if user is None:
            raise credentials_exception
        return user
    
    
    async def get_current_active_user(current_user: User = Depends(get_current_user)):
        if current_user.disabled:
            raise HTTPException(status_code=400, detail="Inactive user")
        return current_user
    
    
    @app.post("/token")
    async def login_for_access_token(
        form_data: OAuth2PasswordRequestForm = Depends(),
    ) -> Token:
        user = authenticate_user(fake_users_db, form_data.username, form_data.password)
        if not user:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Incorrect username or password",
                headers={"WWW-Authenticate": "Bearer"},
            )
        access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
        access_token = create_access_token(
            data={"sub": user.username}, expires_delta=access_token_expires
        )
        return Token(access_token=access_token, token_type="bearer")
    
    
    @app.get("/users/me/")
    async def read_users_me(current_user: User = Depends(get_current_active_user)) -> User:
        return current_user
    
    
    @app.get("/users/me/items/")
    async def read_own_items(current_user: User = Depends(get_current_active_user)):
        return [{"item_id": "Foo", "owner": current_user.username}]
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from datetime import datetime, timedelta, timezone
    from typing import Union
    
    import jwt
    from fastapi import Depends, FastAPI, HTTPException, status
    from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
    from jwt.exceptions import InvalidTokenError
    from pwdlib import PasswordHash
    from pydantic import BaseModel
    
    # to get a string like this run:
    # openssl rand -hex 32
    SECRET_KEY = "09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
    ALGORITHM = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES = 30
    
    
    fake_users_db = {
        "johndoe": {
            "username": "johndoe",
            "full_name": "John Doe",
            "email": "johndoe@example.com",
            "hashed_password": "$argon2id$v=19$m=65536,t=3,p=4$wagCPXjifgvUFBzq4hqe3w$CYaIb8sB+wtD+Vu/P4uod1+Qof8h+1g7bbDlBID48Rc",
            "disabled": False,
        }
    }
    
    
    class Token(BaseModel):
        access_token: str
        token_type: str
    
    
    class TokenData(BaseModel):
        username: Union[str, None] = None
    
    
    class User(BaseModel):
        username: str
        email: Union[str, None] = None
        full_name: Union[str, None] = None
        disabled: Union[bool, None] = None
    
    
    class UserInDB(User):
        hashed_password: str
    
    
    password_hash = PasswordHash.recommended()
    
    oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")
    
    app = FastAPI()
    
    
    def verify_password(plain_password, hashed_password):
        return password_hash.verify(plain_password, hashed_password)
    
    
    def get_password_hash(password):
        return password_hash.hash(password)
    
    
    def get_user(db, username: str):
        if username in db:
            user_dict = db[username]
            return UserInDB(**user_dict)
    
    
    def authenticate_user(fake_db, username: str, password: str):
        user = get_user(fake_db, username)
        if not user:
            return False
        if not verify_password(password, user.hashed_password):
            return False
        return user
    
    
    def create_access_token(data: dict, expires_delta: Union[timedelta, None] = None):
        to_encode = data.copy()
        if expires_delta:
            expire = datetime.now(timezone.utc) + expires_delta
        else:
            expire = datetime.now(timezone.utc) + timedelta(minutes=15)
        to_encode.update({"exp": expire})
        encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
        return encoded_jwt
    
    
    async def get_current_user(token: str = Depends(oauth2_scheme)):
        credentials_exception = HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Could not validate credentials",
            headers={"WWW-Authenticate": "Bearer"},
        )
        try:
            payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
            username = payload.get("sub")
            if username is None:
                raise credentials_exception
            token_data = TokenData(username=username)
        except InvalidTokenError:
            raise credentials_exception
        user = get_user(fake_users_db, username=token_data.username)
        if user is None:
            raise credentials_exception
        return user
    
    
    async def get_current_active_user(current_user: User = Depends(get_current_user)):
        if current_user.disabled:
            raise HTTPException(status_code=400, detail="Inactive user")
        return current_user
    
    
    @app.post("/token")
    async def login_for_access_token(
        form_data: OAuth2PasswordRequestForm = Depends(),
    ) -> Token:
        user = authenticate_user(fake_users_db, form_data.username, form_data.password)
        if not user:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Incorrect username or password",
                headers={"WWW-Authenticate": "Bearer"},
            )
        access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
        access_token = create_access_token(
            data={"sub": user.username}, expires_delta=access_token_expires
        )
        return Token(access_token=access_token, token_type="bearer")
    
    
    @app.get("/users/me/")
    async def read_users_me(current_user: User = Depends(get_current_active_user)) -> User:
        return current_user
    
    
    @app.get("/users/me/items/")
    async def read_own_items(current_user: User = Depends(get_current_active_user)):
        return [{"item_id": "Foo", "owner": current_user.username}]
    

## Update the dependencies[¶](#update-the-dependencies "Permanent link")

Update `get_current_user` to receive the same token as before, but this time, using JWT tokens.

Decode the received token, verify it, and return the current user.

If the token is invalid, return an HTTP error right away.

Python 3.10+
    
    
    from datetime import datetime, timedelta, timezone
    from typing import Annotated
    
    import jwt
    from fastapi import Depends, FastAPI, HTTPException, status
    from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
    from jwt.exceptions import InvalidTokenError
    from pwdlib import PasswordHash
    from pydantic import BaseModel
    
    # to get a string like this run:
    # openssl rand -hex 32
    SECRET_KEY = "09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
    ALGORITHM = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES = 30
    
    
    fake_users_db = {
        "johndoe": {
            "username": "johndoe",
            "full_name": "John Doe",
            "email": "johndoe@example.com",
            "hashed_password": "$argon2id$v=19$m=65536,t=3,p=4$wagCPXjifgvUFBzq4hqe3w$CYaIb8sB+wtD+Vu/P4uod1+Qof8h+1g7bbDlBID48Rc",
            "disabled": False,
        }
    }
    
    
    class Token(BaseModel):
        access_token: str
        token_type: str
    
    
    class TokenData(BaseModel):
        username: str | None = None
    
    
    class User(BaseModel):
        username: str
        email: str | None = None
        full_name: str | None = None
        disabled: bool | None = None
    
    
    class UserInDB(User):
        hashed_password: str
    
    
    password_hash = PasswordHash.recommended()
    
    oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")
    
    app = FastAPI()
    
    
    def verify_password(plain_password, hashed_password):
        return password_hash.verify(plain_password, hashed_password)
    
    
    def get_password_hash(password):
        return password_hash.hash(password)
    
    
    def get_user(db, username: str):
        if username in db:
            user_dict = db[username]
            return UserInDB(**user_dict)
    
    
    def authenticate_user(fake_db, username: str, password: str):
        user = get_user(fake_db, username)
        if not user:
            return False
        if not verify_password(password, user.hashed_password):
            return False
        return user
    
    
    def create_access_token(data: dict, expires_delta: timedelta | None = None):
        to_encode = data.copy()
        if expires_delta:
            expire = datetime.now(timezone.utc) + expires_delta
        else:
            expire = datetime.now(timezone.utc) + timedelta(minutes=15)
        to_encode.update({"exp": expire})
        encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
        return encoded_jwt
    
    
    async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):
        credentials_exception = HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Could not validate credentials",
            headers={"WWW-Authenticate": "Bearer"},
        )
        try:
            payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
            username = payload.get("sub")
            if username is None:
                raise credentials_exception
            token_data = TokenData(username=username)
        except InvalidTokenError:
            raise credentials_exception
        user = get_user(fake_users_db, username=token_data.username)
        if user is None:
            raise credentials_exception
        return user
    
    
    async def get_current_active_user(
        current_user: Annotated[User, Depends(get_current_user)],
    ):
        if current_user.disabled:
            raise HTTPException(status_code=400, detail="Inactive user")
        return current_user
    
    
    @app.post("/token")
    async def login_for_access_token(
        form_data: Annotated[OAuth2PasswordRequestForm, Depends()],
    ) -> Token:
        user = authenticate_user(fake_users_db, form_data.username, form_data.password)
        if not user:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Incorrect username or password",
                headers={"WWW-Authenticate": "Bearer"},
            )
        access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
        access_token = create_access_token(
            data={"sub": user.username}, expires_delta=access_token_expires
        )
        return Token(access_token=access_token, token_type="bearer")
    
    
    @app.get("/users/me/")
    async def read_users_me(
        current_user: Annotated[User, Depends(get_current_active_user)],
    ) -> User:
        return current_user
    
    
    @app.get("/users/me/items/")
    async def read_own_items(
        current_user: Annotated[User, Depends(get_current_active_user)],
    ):
        return [{"item_id": "Foo", "owner": current_user.username}]
    

ü§ì Other versions and variants

Python 3.9+Python 3.10+ - non-AnnotatedPython 3.9+ - non-Annotated
    
    
    from datetime import datetime, timedelta, timezone
    from typing import Annotated, Union
    
    import jwt
    from fastapi import Depends, FastAPI, HTTPException, status
    from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
    from jwt.exceptions import InvalidTokenError
    from pwdlib import PasswordHash
    from pydantic import BaseModel
    
    # to get a string like this run:
    # openssl rand -hex 32
    SECRET_KEY = "09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
    ALGORITHM = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES = 30
    
    
    fake_users_db = {
        "johndoe": {
            "username": "johndoe",
            "full_name": "John Doe",
            "email": "johndoe@example.com",
            "hashed_password": "$argon2id$v=19$m=65536,t=3,p=4$wagCPXjifgvUFBzq4hqe3w$CYaIb8sB+wtD+Vu/P4uod1+Qof8h+1g7bbDlBID48Rc",
            "disabled": False,
        }
    }
    
    
    class Token(BaseModel):
        access_token: str
        token_type: str
    
    
    class TokenData(BaseModel):
        username: Union[str, None] = None
    
    
    class User(BaseModel):
        username: str
        email: Union[str, None] = None
        full_name: Union[str, None] = None
        disabled: Union[bool, None] = None
    
    
    class UserInDB(User):
        hashed_password: str
    
    
    password_hash = PasswordHash.recommended()
    
    oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")
    
    app = FastAPI()
    
    
    def verify_password(plain_password, hashed_password):
        return password_hash.verify(plain_password, hashed_password)
    
    
    def get_password_hash(password):
        return password_hash.hash(password)
    
    
    def get_user(db, username: str):
        if username in db:
            user_dict = db[username]
            return UserInDB(**user_dict)
    
    
    def authenticate_user(fake_db, username: str, password: str):
        user = get_user(fake_db, username)
        if not user:
            return False
        if not verify_password(password, user.hashed_password):
            return False
        return user
    
    
    def create_access_token(data: dict, expires_delta: Union[timedelta, None] = None):
        to_encode = data.copy()
        if expires_delta:
            expire = datetime.now(timezone.utc) + expires_delta
        else:
            expire = datetime.now(timezone.utc) + timedelta(minutes=15)
        to_encode.update({"exp": expire})
        encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
        return encoded_jwt
    
    
    async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):
        credentials_exception = HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Could not validate credentials",
            headers={"WWW-Authenticate": "Bearer"},
        )
        try:
            payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
            username = payload.get("sub")
            if username is None:
                raise credentials_exception
            token_data = TokenData(username=username)
        except InvalidTokenError:
            raise credentials_exception
        user = get_user(fake_users_db, username=token_data.username)
        if user is None:
            raise credentials_exception
        return user
    
    
    async def get_current_active_user(
        current_user: Annotated[User, Depends(get_current_user)],
    ):
        if current_user.disabled:
            raise HTTPException(status_code=400, detail="Inactive user")
        return current_user
    
    
    @app.post("/token")
    async def login_for_access_token(
        form_data: Annotated[OAuth2PasswordRequestForm, Depends()],
    ) -> Token:
        user = authenticate_user(fake_users_db, form_data.username, form_data.password)
        if not user:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Incorrect username or password",
                headers={"WWW-Authenticate": "Bearer"},
            )
        access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
        access_token = create_access_token(
            data={"sub": user.username}, expires_delta=access_token_expires
        )
        return Token(access_token=access_token, token_type="bearer")
    
    
    @app.get("/users/me/")
    async def read_users_me(
        current_user: Annotated[User, Depends(get_current_active_user)],
    ) -> User:
        return current_user
    
    
    @app.get("/users/me/items/")
    async def read_own_items(
        current_user: Annotated[User, Depends(get_current_active_user)],
    ):
        return [{"item_id": "Foo", "owner": current_user.username}]
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from datetime import datetime, timedelta, timezone
    
    import jwt
    from fastapi import Depends, FastAPI, HTTPException, status
    from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
    from jwt.exceptions import InvalidTokenError
    from pwdlib import PasswordHash
    from pydantic import BaseModel
    
    # to get a string like this run:
    # openssl rand -hex 32
    SECRET_KEY = "09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
    ALGORITHM = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES = 30
    
    
    fake_users_db = {
        "johndoe": {
            "username": "johndoe",
            "full_name": "John Doe",
            "email": "johndoe@example.com",
            "hashed_password": "$argon2id$v=19$m=65536,t=3,p=4$wagCPXjifgvUFBzq4hqe3w$CYaIb8sB+wtD+Vu/P4uod1+Qof8h+1g7bbDlBID48Rc",
            "disabled": False,
        }
    }
    
    
    class Token(BaseModel):
        access_token: str
        token_type: str
    
    
    class TokenData(BaseModel):
        username: str | None = None
    
    
    class User(BaseModel):
        username: str
        email: str | None = None
        full_name: str | None = None
        disabled: bool | None = None
    
    
    class UserInDB(User):
        hashed_password: str
    
    
    password_hash = PasswordHash.recommended()
    
    oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")
    
    app = FastAPI()
    
    
    def verify_password(plain_password, hashed_password):
        return password_hash.verify(plain_password, hashed_password)
    
    
    def get_password_hash(password):
        return password_hash.hash(password)
    
    
    def get_user(db, username: str):
        if username in db:
            user_dict = db[username]
            return UserInDB(**user_dict)
    
    
    def authenticate_user(fake_db, username: str, password: str):
        user = get_user(fake_db, username)
        if not user:
            return False
        if not verify_password(password, user.hashed_password):
            return False
        return user
    
    
    def create_access_token(data: dict, expires_delta: timedelta | None = None):
        to_encode = data.copy()
        if expires_delta:
            expire = datetime.now(timezone.utc) + expires_delta
        else:
            expire = datetime.now(timezone.utc) + timedelta(minutes=15)
        to_encode.update({"exp": expire})
        encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
        return encoded_jwt
    
    
    async def get_current_user(token: str = Depends(oauth2_scheme)):
        credentials_exception = HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Could not validate credentials",
            headers={"WWW-Authenticate": "Bearer"},
        )
        try:
            payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
            username = payload.get("sub")
            if username is None:
                raise credentials_exception
            token_data = TokenData(username=username)
        except InvalidTokenError:
            raise credentials_exception
        user = get_user(fake_users_db, username=token_data.username)
        if user is None:
            raise credentials_exception
        return user
    
    
    async def get_current_active_user(current_user: User = Depends(get_current_user)):
        if current_user.disabled:
            raise HTTPException(status_code=400, detail="Inactive user")
        return current_user
    
    
    @app.post("/token")
    async def login_for_access_token(
        form_data: OAuth2PasswordRequestForm = Depends(),
    ) -> Token:
        user = authenticate_user(fake_users_db, form_data.username, form_data.password)
        if not user:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Incorrect username or password",
                headers={"WWW-Authenticate": "Bearer"},
            )
        access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
        access_token = create_access_token(
            data={"sub": user.username}, expires_delta=access_token_expires
        )
        return Token(access_token=access_token, token_type="bearer")
    
    
    @app.get("/users/me/")
    async def read_users_me(current_user: User = Depends(get_current_active_user)) -> User:
        return current_user
    
    
    @app.get("/users/me/items/")
    async def read_own_items(current_user: User = Depends(get_current_active_user)):
        return [{"item_id": "Foo", "owner": current_user.username}]
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from datetime import datetime, timedelta, timezone
    from typing import Union
    
    import jwt
    from fastapi import Depends, FastAPI, HTTPException, status
    from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
    from jwt.exceptions import InvalidTokenError
    from pwdlib import PasswordHash
    from pydantic import BaseModel
    
    # to get a string like this run:
    # openssl rand -hex 32
    SECRET_KEY = "09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
    ALGORITHM = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES = 30
    
    
    fake_users_db = {
        "johndoe": {
            "username": "johndoe",
            "full_name": "John Doe",
            "email": "johndoe@example.com",
            "hashed_password": "$argon2id$v=19$m=65536,t=3,p=4$wagCPXjifgvUFBzq4hqe3w$CYaIb8sB+wtD+Vu/P4uod1+Qof8h+1g7bbDlBID48Rc",
            "disabled": False,
        }
    }
    
    
    class Token(BaseModel):
        access_token: str
        token_type: str
    
    
    class TokenData(BaseModel):
        username: Union[str, None] = None
    
    
    class User(BaseModel):
        username: str
        email: Union[str, None] = None
        full_name: Union[str, None] = None
        disabled: Union[bool, None] = None
    
    
    class UserInDB(User):
        hashed_password: str
    
    
    password_hash = PasswordHash.recommended()
    
    oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")
    
    app = FastAPI()
    
    
    def verify_password(plain_password, hashed_password):
        return password_hash.verify(plain_password, hashed_password)
    
    
    def get_password_hash(password):
        return password_hash.hash(password)
    
    
    def get_user(db, username: str):
        if username in db:
            user_dict = db[username]
            return UserInDB(**user_dict)
    
    
    def authenticate_user(fake_db, username: str, password: str):
        user = get_user(fake_db, username)
        if not user:
            return False
        if not verify_password(password, user.hashed_password):
            return False
        return user
    
    
    def create_access_token(data: dict, expires_delta: Union[timedelta, None] = None):
        to_encode = data.copy()
        if expires_delta:
            expire = datetime.now(timezone.utc) + expires_delta
        else:
            expire = datetime.now(timezone.utc) + timedelta(minutes=15)
        to_encode.update({"exp": expire})
        encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
        return encoded_jwt
    
    
    async def get_current_user(token: str = Depends(oauth2_scheme)):
        credentials_exception = HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Could not validate credentials",
            headers={"WWW-Authenticate": "Bearer"},
        )
        try:
            payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
            username = payload.get("sub")
            if username is None:
                raise credentials_exception
            token_data = TokenData(username=username)
        except InvalidTokenError:
            raise credentials_exception
        user = get_user(fake_users_db, username=token_data.username)
        if user is None:
            raise credentials_exception
        return user
    
    
    async def get_current_active_user(current_user: User = Depends(get_current_user)):
        if current_user.disabled:
            raise HTTPException(status_code=400, detail="Inactive user")
        return current_user
    
    
    @app.post("/token")
    async def login_for_access_token(
        form_data: OAuth2PasswordRequestForm = Depends(),
    ) -> Token:
        user = authenticate_user(fake_users_db, form_data.username, form_data.password)
        if not user:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Incorrect username or password",
                headers={"WWW-Authenticate": "Bearer"},
            )
        access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
        access_token = create_access_token(
            data={"sub": user.username}, expires_delta=access_token_expires
        )
        return Token(access_token=access_token, token_type="bearer")
    
    
    @app.get("/users/me/")
    async def read_users_me(current_user: User = Depends(get_current_active_user)) -> User:
        return current_user
    
    
    @app.get("/users/me/items/")
    async def read_own_items(current_user: User = Depends(get_current_active_user)):
        return [{"item_id": "Foo", "owner": current_user.username}]
    

## Update the `/token` _path operation_[¶](#update-the-token-path-operation "Permanent link")

Create a `timedelta` with the expiration time of the token.

Create a real JWT access token and return it.

Python 3.10+
    
    
    from datetime import datetime, timedelta, timezone
    from typing import Annotated
    
    import jwt
    from fastapi import Depends, FastAPI, HTTPException, status
    from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
    from jwt.exceptions import InvalidTokenError
    from pwdlib import PasswordHash
    from pydantic import BaseModel
    
    # to get a string like this run:
    # openssl rand -hex 32
    SECRET_KEY = "09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
    ALGORITHM = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES = 30
    
    
    fake_users_db = {
        "johndoe": {
            "username": "johndoe",
            "full_name": "John Doe",
            "email": "johndoe@example.com",
            "hashed_password": "$argon2id$v=19$m=65536,t=3,p=4$wagCPXjifgvUFBzq4hqe3w$CYaIb8sB+wtD+Vu/P4uod1+Qof8h+1g7bbDlBID48Rc",
            "disabled": False,
        }
    }
    
    
    class Token(BaseModel):
        access_token: str
        token_type: str
    
    
    class TokenData(BaseModel):
        username: str | None = None
    
    
    class User(BaseModel):
        username: str
        email: str | None = None
        full_name: str | None = None
        disabled: bool | None = None
    
    
    class UserInDB(User):
        hashed_password: str
    
    
    password_hash = PasswordHash.recommended()
    
    oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")
    
    app = FastAPI()
    
    
    def verify_password(plain_password, hashed_password):
        return password_hash.verify(plain_password, hashed_password)
    
    
    def get_password_hash(password):
        return password_hash.hash(password)
    
    
    def get_user(db, username: str):
        if username in db:
            user_dict = db[username]
            return UserInDB(**user_dict)
    
    
    def authenticate_user(fake_db, username: str, password: str):
        user = get_user(fake_db, username)
        if not user:
            return False
        if not verify_password(password, user.hashed_password):
            return False
        return user
    
    
    def create_access_token(data: dict, expires_delta: timedelta | None = None):
        to_encode = data.copy()
        if expires_delta:
            expire = datetime.now(timezone.utc) + expires_delta
        else:
            expire = datetime.now(timezone.utc) + timedelta(minutes=15)
        to_encode.update({"exp": expire})
        encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
        return encoded_jwt
    
    
    async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):
        credentials_exception = HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Could not validate credentials",
            headers={"WWW-Authenticate": "Bearer"},
        )
        try:
            payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
            username = payload.get("sub")
            if username is None:
                raise credentials_exception
            token_data = TokenData(username=username)
        except InvalidTokenError:
            raise credentials_exception
        user = get_user(fake_users_db, username=token_data.username)
        if user is None:
            raise credentials_exception
        return user
    
    
    async def get_current_active_user(
        current_user: Annotated[User, Depends(get_current_user)],
    ):
        if current_user.disabled:
            raise HTTPException(status_code=400, detail="Inactive user")
        return current_user
    
    
    @app.post("/token")
    async def login_for_access_token(
        form_data: Annotated[OAuth2PasswordRequestForm, Depends()],
    ) -> Token:
        user = authenticate_user(fake_users_db, form_data.username, form_data.password)
        if not user:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Incorrect username or password",
                headers={"WWW-Authenticate": "Bearer"},
            )
        access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
        access_token = create_access_token(
            data={"sub": user.username}, expires_delta=access_token_expires
        )
        return Token(access_token=access_token, token_type="bearer")
    
    
    @app.get("/users/me/")
    async def read_users_me(
        current_user: Annotated[User, Depends(get_current_active_user)],
    ) -> User:
        return current_user
    
    
    @app.get("/users/me/items/")
    async def read_own_items(
        current_user: Annotated[User, Depends(get_current_active_user)],
    ):
        return [{"item_id": "Foo", "owner": current_user.username}]
    

ü§ì Other versions and variants

Python 3.9+Python 3.10+ - non-AnnotatedPython 3.9+ - non-Annotated
    
    
    from datetime import datetime, timedelta, timezone
    from typing import Annotated, Union
    
    import jwt
    from fastapi import Depends, FastAPI, HTTPException, status
    from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
    from jwt.exceptions import InvalidTokenError
    from pwdlib import PasswordHash
    from pydantic import BaseModel
    
    # to get a string like this run:
    # openssl rand -hex 32
    SECRET_KEY = "09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
    ALGORITHM = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES = 30
    
    
    fake_users_db = {
        "johndoe": {
            "username": "johndoe",
            "full_name": "John Doe",
            "email": "johndoe@example.com",
            "hashed_password": "$argon2id$v=19$m=65536,t=3,p=4$wagCPXjifgvUFBzq4hqe3w$CYaIb8sB+wtD+Vu/P4uod1+Qof8h+1g7bbDlBID48Rc",
            "disabled": False,
        }
    }
    
    
    class Token(BaseModel):
        access_token: str
        token_type: str
    
    
    class TokenData(BaseModel):
        username: Union[str, None] = None
    
    
    class User(BaseModel):
        username: str
        email: Union[str, None] = None
        full_name: Union[str, None] = None
        disabled: Union[bool, None] = None
    
    
    class UserInDB(User):
        hashed_password: str
    
    
    password_hash = PasswordHash.recommended()
    
    oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")
    
    app = FastAPI()
    
    
    def verify_password(plain_password, hashed_password):
        return password_hash.verify(plain_password, hashed_password)
    
    
    def get_password_hash(password):
        return password_hash.hash(password)
    
    
    def get_user(db, username: str):
        if username in db:
            user_dict = db[username]
            return UserInDB(**user_dict)
    
    
    def authenticate_user(fake_db, username: str, password: str):
        user = get_user(fake_db, username)
        if not user:
            return False
        if not verify_password(password, user.hashed_password):
            return False
        return user
    
    
    def create_access_token(data: dict, expires_delta: Union[timedelta, None] = None):
        to_encode = data.copy()
        if expires_delta:
            expire = datetime.now(timezone.utc) + expires_delta
        else:
            expire = datetime.now(timezone.utc) + timedelta(minutes=15)
        to_encode.update({"exp": expire})
        encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
        return encoded_jwt
    
    
    async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):
        credentials_exception = HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Could not validate credentials",
            headers={"WWW-Authenticate": "Bearer"},
        )
        try:
            payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
            username = payload.get("sub")
            if username is None:
                raise credentials_exception
            token_data = TokenData(username=username)
        except InvalidTokenError:
            raise credentials_exception
        user = get_user(fake_users_db, username=token_data.username)
        if user is None:
            raise credentials_exception
        return user
    
    
    async def get_current_active_user(
        current_user: Annotated[User, Depends(get_current_user)],
    ):
        if current_user.disabled:
            raise HTTPException(status_code=400, detail="Inactive user")
        return current_user
    
    
    @app.post("/token")
    async def login_for_access_token(
        form_data: Annotated[OAuth2PasswordRequestForm, Depends()],
    ) -> Token:
        user = authenticate_user(fake_users_db, form_data.username, form_data.password)
        if not user:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Incorrect username or password",
                headers={"WWW-Authenticate": "Bearer"},
            )
        access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
        access_token = create_access_token(
            data={"sub": user.username}, expires_delta=access_token_expires
        )
        return Token(access_token=access_token, token_type="bearer")
    
    
    @app.get("/users/me/")
    async def read_users_me(
        current_user: Annotated[User, Depends(get_current_active_user)],
    ) -> User:
        return current_user
    
    
    @app.get("/users/me/items/")
    async def read_own_items(
        current_user: Annotated[User, Depends(get_current_active_user)],
    ):
        return [{"item_id": "Foo", "owner": current_user.username}]
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from datetime import datetime, timedelta, timezone
    
    import jwt
    from fastapi import Depends, FastAPI, HTTPException, status
    from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
    from jwt.exceptions import InvalidTokenError
    from pwdlib import PasswordHash
    from pydantic import BaseModel
    
    # to get a string like this run:
    # openssl rand -hex 32
    SECRET_KEY = "09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
    ALGORITHM = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES = 30
    
    
    fake_users_db = {
        "johndoe": {
            "username": "johndoe",
            "full_name": "John Doe",
            "email": "johndoe@example.com",
            "hashed_password": "$argon2id$v=19$m=65536,t=3,p=4$wagCPXjifgvUFBzq4hqe3w$CYaIb8sB+wtD+Vu/P4uod1+Qof8h+1g7bbDlBID48Rc",
            "disabled": False,
        }
    }
    
    
    class Token(BaseModel):
        access_token: str
        token_type: str
    
    
    class TokenData(BaseModel):
        username: str | None = None
    
    
    class User(BaseModel):
        username: str
        email: str | None = None
        full_name: str | None = None
        disabled: bool | None = None
    
    
    class UserInDB(User):
        hashed_password: str
    
    
    password_hash = PasswordHash.recommended()
    
    oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")
    
    app = FastAPI()
    
    
    def verify_password(plain_password, hashed_password):
        return password_hash.verify(plain_password, hashed_password)
    
    
    def get_password_hash(password):
        return password_hash.hash(password)
    
    
    def get_user(db, username: str):
        if username in db:
            user_dict = db[username]
            return UserInDB(**user_dict)
    
    
    def authenticate_user(fake_db, username: str, password: str):
        user = get_user(fake_db, username)
        if not user:
            return False
        if not verify_password(password, user.hashed_password):
            return False
        return user
    
    
    def create_access_token(data: dict, expires_delta: timedelta | None = None):
        to_encode = data.copy()
        if expires_delta:
            expire = datetime.now(timezone.utc) + expires_delta
        else:
            expire = datetime.now(timezone.utc) + timedelta(minutes=15)
        to_encode.update({"exp": expire})
        encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
        return encoded_jwt
    
    
    async def get_current_user(token: str = Depends(oauth2_scheme)):
        credentials_exception = HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Could not validate credentials",
            headers={"WWW-Authenticate": "Bearer"},
        )
        try:
            payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
            username = payload.get("sub")
            if username is None:
                raise credentials_exception
            token_data = TokenData(username=username)
        except InvalidTokenError:
            raise credentials_exception
        user = get_user(fake_users_db, username=token_data.username)
        if user is None:
            raise credentials_exception
        return user
    
    
    async def get_current_active_user(current_user: User = Depends(get_current_user)):
        if current_user.disabled:
            raise HTTPException(status_code=400, detail="Inactive user")
        return current_user
    
    
    @app.post("/token")
    async def login_for_access_token(
        form_data: OAuth2PasswordRequestForm = Depends(),
    ) -> Token:
        user = authenticate_user(fake_users_db, form_data.username, form_data.password)
        if not user:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Incorrect username or password",
                headers={"WWW-Authenticate": "Bearer"},
            )
        access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
        access_token = create_access_token(
            data={"sub": user.username}, expires_delta=access_token_expires
        )
        return Token(access_token=access_token, token_type="bearer")
    
    
    @app.get("/users/me/")
    async def read_users_me(current_user: User = Depends(get_current_active_user)) -> User:
        return current_user
    
    
    @app.get("/users/me/items/")
    async def read_own_items(current_user: User = Depends(get_current_active_user)):
        return [{"item_id": "Foo", "owner": current_user.username}]
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from datetime import datetime, timedelta, timezone
    from typing import Union
    
    import jwt
    from fastapi import Depends, FastAPI, HTTPException, status
    from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
    from jwt.exceptions import InvalidTokenError
    from pwdlib import PasswordHash
    from pydantic import BaseModel
    
    # to get a string like this run:
    # openssl rand -hex 32
    SECRET_KEY = "09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
    ALGORITHM = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES = 30
    
    
    fake_users_db = {
        "johndoe": {
            "username": "johndoe",
            "full_name": "John Doe",
            "email": "johndoe@example.com",
            "hashed_password": "$argon2id$v=19$m=65536,t=3,p=4$wagCPXjifgvUFBzq4hqe3w$CYaIb8sB+wtD+Vu/P4uod1+Qof8h+1g7bbDlBID48Rc",
            "disabled": False,
        }
    }
    
    
    class Token(BaseModel):
        access_token: str
        token_type: str
    
    
    class TokenData(BaseModel):
        username: Union[str, None] = None
    
    
    class User(BaseModel):
        username: str
        email: Union[str, None] = None
        full_name: Union[str, None] = None
        disabled: Union[bool, None] = None
    
    
    class UserInDB(User):
        hashed_password: str
    
    
    password_hash = PasswordHash.recommended()
    
    oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")
    
    app = FastAPI()
    
    
    def verify_password(plain_password, hashed_password):
        return password_hash.verify(plain_password, hashed_password)
    
    
    def get_password_hash(password):
        return password_hash.hash(password)
    
    
    def get_user(db, username: str):
        if username in db:
            user_dict = db[username]
            return UserInDB(**user_dict)
    
    
    def authenticate_user(fake_db, username: str, password: str):
        user = get_user(fake_db, username)
        if not user:
            return False
        if not verify_password(password, user.hashed_password):
            return False
        return user
    
    
    def create_access_token(data: dict, expires_delta: Union[timedelta, None] = None):
        to_encode = data.copy()
        if expires_delta:
            expire = datetime.now(timezone.utc) + expires_delta
        else:
            expire = datetime.now(timezone.utc) + timedelta(minutes=15)
        to_encode.update({"exp": expire})
        encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
        return encoded_jwt
    
    
    async def get_current_user(token: str = Depends(oauth2_scheme)):
        credentials_exception = HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Could not validate credentials",
            headers={"WWW-Authenticate": "Bearer"},
        )
        try:
            payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
            username = payload.get("sub")
            if username is None:
                raise credentials_exception
            token_data = TokenData(username=username)
        except InvalidTokenError:
            raise credentials_exception
        user = get_user(fake_users_db, username=token_data.username)
        if user is None:
            raise credentials_exception
        return user
    
    
    async def get_current_active_user(current_user: User = Depends(get_current_user)):
        if current_user.disabled:
            raise HTTPException(status_code=400, detail="Inactive user")
        return current_user
    
    
    @app.post("/token")
    async def login_for_access_token(
        form_data: OAuth2PasswordRequestForm = Depends(),
    ) -> Token:
        user = authenticate_user(fake_users_db, form_data.username, form_data.password)
        if not user:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Incorrect username or password",
                headers={"WWW-Authenticate": "Bearer"},
            )
        access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
        access_token = create_access_token(
            data={"sub": user.username}, expires_delta=access_token_expires
        )
        return Token(access_token=access_token, token_type="bearer")
    
    
    @app.get("/users/me/")
    async def read_users_me(current_user: User = Depends(get_current_active_user)) -> User:
        return current_user
    
    
    @app.get("/users/me/items/")
    async def read_own_items(current_user: User = Depends(get_current_active_user)):
        return [{"item_id": "Foo", "owner": current_user.username}]
    

### Technical details about the JWT "subject" `sub`[¶](#technical-details-about-the-jwt-subject-sub "Permanent link")

The JWT specification says that there's a key `sub`, with the subject of the token.

It's optional to use it, but that's where you would put the user's identification, so we are using it here.

JWT might be used for other things apart from identifying a user and allowing them to perform operations directly on your API.

For example, you could identify a "car" or a "blog post".

Then you could add permissions about that entity, like "drive" (for the car) or "edit" (for the blog).

And then, you could give that JWT token to a user (or bot), and they could use it to perform those actions (drive the car, or edit the blog post) without even needing to have an account, just with the JWT token your API generated for that.

Using these ideas, JWT can be used for way more sophisticated scenarios.

In those cases, several of those entities could have the same ID, let's say `foo` (a user `foo`, a car `foo`, and a blog post `foo`).

So, to avoid ID collisions, when creating the JWT token for the user, you could prefix the value of the `sub` key, e.g. with `username:`. So, in this example, the value of `sub` could have been: `username:johndoe`.

The important thing to keep in mind is that the `sub` key should have a unique identifier across the entire application, and it should be a string.

## Check it[¶](#check-it "Permanent link")

Run the server and go to the docs: <http://127.0.0.1:8000/docs>.

You'll see the user interface like:

![](/img/tutorial/security/image07.png)

Authorize the application the same way as before.

Using the credentials:

Username: `johndoe` Password: `secret`

Check

Notice that nowhere in the code is the plaintext password "`secret`", we only have the hashed version.

![](/img/tutorial/security/image08.png)

Call the endpoint `/users/me/`, you will get the response as:
    
    
    {
      "username": "johndoe",
      "email": "johndoe@example.com",
      "full_name": "John Doe",
      "disabled": false
    }
    

![](/img/tutorial/security/image09.png)

If you open the developer tools, you could see how the data sent only includes the token, the password is only sent in the first request to authenticate the user and get that access token, but not afterwards:

![](/img/tutorial/security/image10.png)

Note

Notice the header `Authorization`, with a value that starts with `Bearer`.

## Advanced usage with `scopes`[¶](#advanced-usage-with-scopes "Permanent link")

OAuth2 has the notion of "scopes".

You can use them to add a specific set of permissions to a JWT token.

Then you can give this token to a user directly or a third party, to interact with your API with a set of restrictions.

You can learn how to use them and how they are integrated into **FastAPI** later in the **Advanced User Guide**.

## Recap[¶](#recap "Permanent link")

With what you have seen up to now, you can set up a secure **FastAPI** application using standards like OAuth2 and JWT.

In almost any framework handling the security becomes a rather complex subject quite quickly.

Many packages that simplify it a lot have to make many compromises with the data model, database, and available features. And some of these packages that simplify things too much actually have security flaws underneath.

* * *

**FastAPI** doesn't make any compromise with any database, data model or tool.

It gives you all the flexibility to choose the ones that fit your project the best.

And you can use directly many well maintained and widely used packages like `pwdlib` and `PyJWT`, because **FastAPI** doesn't require any complex mechanisms to integrate external packages.

But it provides you the tools to simplify the process as much as possible without compromising flexibility, robustness, or security.

And you can use and implement secure, standard protocols, like OAuth2 in a relatively simple way.

You can learn more in the **Advanced User Guide** about how to use OAuth2 "scopes", for a more fine-grained permission system, following these same standards. OAuth2 with scopes is the mechanism used by many big authentication providers, like Facebook, Google, GitHub, Microsoft, X (Twitter), etc. to authorize third party applications to interact with their APIs on behalf of their users.
  *[JWT]: JSON Web Tokens

---

###### Middleware¶

# Middleware[¶](#middleware "Permanent link")

You can add middleware to **FastAPI** applications.

A "middleware" is a function that works with every **request** before it is processed by any specific _path operation_. And also with every **response** before returning it.

  * It takes each **request** that comes to your application.
  * It can then do something to that **request** or run any needed code.
  * Then it passes the **request** to be processed by the rest of the application (by some _path operation_).
  * It then takes the **response** generated by the application (by some _path operation_).
  * It can do something to that **response** or run any needed code.
  * Then it returns the **response**.

Technical Details

If you have dependencies with `yield`, the exit code will run _after_ the middleware.

If there were any background tasks (covered in the [Background Tasks](../background-tasks/) section, you will see it later), they will run _after_ all the middleware.

## Create a middleware[¶](#create-a-middleware "Permanent link")

To create a middleware you use the decorator `@app.middleware("http")` on top of a function.

The middleware function receives:

  * The `request`.
  * A function `call_next` that will receive the `request` as a parameter.
    * This function will pass the `request` to the corresponding _path operation_.
    * Then it returns the `response` generated by the corresponding _path operation_.
  * You can then further modify the `response` before returning it.

Python 3.9+
    
    
    import time
    
    from fastapi import FastAPI, Request
    
    app = FastAPI()
    
    
    @app.middleware("http")
    async def add_process_time_header(request: Request, call_next):
        start_time = time.perf_counter()
        response = await call_next(request)
        process_time = time.perf_counter() - start_time
        response.headers["X-Process-Time"] = str(process_time)
        return response
    

Tip

Keep in mind that custom proprietary headers can be added [using the `X-` prefix](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers).

But if you have custom headers that you want a client in a browser to be able to see, you need to add them to your CORS configurations ([CORS (Cross-Origin Resource Sharing)](../cors/)) using the parameter `expose_headers` documented in [Starlette's CORS docs](https://www.starlette.dev/middleware/#corsmiddleware).

Technical Details

You could also use `from starlette.requests import Request`.

**FastAPI** provides it as a convenience for you, the developer. But it comes directly from Starlette.

### Before and after the `response`[¶](#before-and-after-the-response "Permanent link")

You can add code to be run with the `request`, before any _path operation_ receives it.

And also after the `response` is generated, before returning it.

For example, you could add a custom header `X-Process-Time` containing the time in seconds that it took to process the request and generate a response:

Python 3.9+
    
    
    import time
    
    from fastapi import FastAPI, Request
    
    app = FastAPI()
    
    
    @app.middleware("http")
    async def add_process_time_header(request: Request, call_next):
        start_time = time.perf_counter()
        response = await call_next(request)
        process_time = time.perf_counter() - start_time
        response.headers["X-Process-Time"] = str(process_time)
        return response
    

Tip

Here we use [`time.perf_counter()`](https://docs.python.org/3/library/time.html#time.perf_counter) instead of `time.time()` because it can be more precise for these use cases. ü§ì

## Multiple middleware execution order[¶](#multiple-middleware-execution-order "Permanent link")

When you add multiple middlewares using either `@app.middleware()` decorator or `app.add_middleware()` method, each new middleware wraps the application, forming a stack. The last middleware added is the _outermost_ , and the first is the _innermost_.

On the request path, the _outermost_ middleware runs first.

On the response path, it runs last.

For example:
    
    
    app.add_middleware(MiddlewareA)
    app.add_middleware(MiddlewareB)
    

This results in the following execution order:

  * **Request** : MiddlewareB ‚Üí MiddlewareA ‚Üí route

  * **Response** : route ‚Üí MiddlewareA ‚Üí MiddlewareB

This stacking behavior ensures that middlewares are executed in a predictable and controllable order.

## Other middlewares[¶](#other-middlewares "Permanent link")

You can later read more about other middlewares in the [Advanced User Guide: Advanced Middleware](../../advanced/middleware/).

You will read about how to handle CORS with a middleware in the next section.
  *[CORS]: Cross-Origin Resource Sharing

---

###### CORS (Cross-Origin Resource Sharing)¶

# CORS (Cross-Origin Resource Sharing)[¶](#cors-cross-origin-resource-sharing "Permanent link")

[CORS or "Cross-Origin Resource Sharing"](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) refers to the situations when a frontend running in a browser has JavaScript code that communicates with a backend, and the backend is in a different "origin" than the frontend.

## Origin[¶](#origin "Permanent link")

An origin is the combination of protocol (`http`, `https`), domain (`myapp.com`, `localhost`, `localhost.tiangolo.com`), and port (`80`, `443`, `8080`).

So, all these are different origins:

  * `http://localhost`
  * `https://localhost`
  * `http://localhost:8080`

Even if they are all in `localhost`, they use different protocols or ports, so, they are different "origins".

## Steps[¶](#steps "Permanent link")

So, let's say you have a frontend running in your browser at `http://localhost:8080`, and its JavaScript is trying to communicate with a backend running at `http://localhost` (because we don't specify a port, the browser will assume the default port `80`).

Then, the browser will send an HTTP `OPTIONS` request to the `:80`-backend, and if the backend sends the appropriate headers authorizing the communication from this different origin (`http://localhost:8080`) then the `:8080`-browser will let the JavaScript in the frontend send its request to the `:80`-backend.

To achieve this, the `:80`-backend must have a list of "allowed origins".

In this case, the list would have to include `http://localhost:8080` for the `:8080`-frontend to work correctly.

## Wildcards[¶](#wildcards "Permanent link")

It's also possible to declare the list as `"*"` (a "wildcard") to say that all are allowed.

But that will only allow certain types of communication, excluding everything that involves credentials: Cookies, Authorization headers like those used with Bearer Tokens, etc.

So, for everything to work correctly, it's better to specify explicitly the allowed origins.

## Use `CORSMiddleware`[¶](#use-corsmiddleware "Permanent link")

You can configure it in your **FastAPI** application using the `CORSMiddleware`.

  * Import `CORSMiddleware`.
  * Create a list of allowed origins (as strings).
  * Add it as a "middleware" to your **FastAPI** application.

You can also specify whether your backend allows:

  * Credentials (Authorization headers, Cookies, etc).
  * Specific HTTP methods (`POST`, `PUT`) or all of them with the wildcard `"*"`.
  * Specific HTTP headers or all of them with the wildcard `"*"`.

Python 3.9+
    
    
    from fastapi import FastAPI
    from fastapi.middleware.cors import CORSMiddleware
    
    app = FastAPI()
    
    origins = [
        "http://localhost.tiangolo.com",
        "https://localhost.tiangolo.com",
        "http://localhost",
        "http://localhost:8080",
    ]
    
    app.add_middleware(
        CORSMiddleware,
        allow_origins=origins,
        allow_credentials=True,
        allow_methods=["*"],
        allow_headers=["*"],
    )
    
    
    @app.get("/")
    async def main():
        return {"message": "Hello World"}
    

The default parameters used by the `CORSMiddleware` implementation are restrictive by default, so you'll need to explicitly enable particular origins, methods, or headers, in order for browsers to be permitted to use them in a Cross-Domain context.

The following arguments are supported:

  * `allow_origins` \- A list of origins that should be permitted to make cross-origin requests. E.g. `['https://example.org', 'https://www.example.org']`. You can use `['*']` to allow any origin.
  * `allow_origin_regex` \- A regex string to match against origins that should be permitted to make cross-origin requests. e.g. `'https://.*\.example\.org'`.
  * `allow_methods` \- A list of HTTP methods that should be allowed for cross-origin requests. Defaults to `['GET']`. You can use `['*']` to allow all standard methods.
  * `allow_headers` \- A list of HTTP request headers that should be supported for cross-origin requests. Defaults to `[]`. You can use `['*']` to allow all headers. The `Accept`, `Accept-Language`, `Content-Language` and `Content-Type` headers are always allowed for [simple CORS requests](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#simple_requests).
  * `allow_credentials` \- Indicate that cookies should be supported for cross-origin requests. Defaults to `False`.

None of `allow_origins`, `allow_methods` and `allow_headers` can be set to `['*']` if `allow_credentials` is set to `True`. All of them must be [explicitly specified](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#credentialed_requests_and_wildcards).

  * `expose_headers` \- Indicate any response headers that should be made accessible to the browser. Defaults to `[]`.

  * `max_age` \- Sets a maximum time in seconds for browsers to cache CORS responses. Defaults to `600`.

The middleware responds to two particular types of HTTP request...

### CORS preflight requests[¶](#cors-preflight-requests "Permanent link")

These are any `OPTIONS` request with `Origin` and `Access-Control-Request-Method` headers.

In this case the middleware will intercept the incoming request and respond with appropriate CORS headers, and either a `200` or `400` response for informational purposes.

### Simple requests[¶](#simple-requests "Permanent link")

Any request with an `Origin` header. In this case the middleware will pass the request through as normal, but will include appropriate CORS headers on the response.

## More info[¶](#more-info "Permanent link")

For more info about CORS, check the [Mozilla CORS documentation](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS).

Technical Details

You could also use `from starlette.middleware.cors import CORSMiddleware`.

**FastAPI** provides several middlewares in `fastapi.middleware` just as a convenience for you, the developer. But most of the available middlewares come directly from Starlette.
  *[CORS]: Cross-Origin Resource Sharing

---

###### SQL (Relational) Databases¶

# SQL (Relational) Databases[¶](#sql-relational-databases "Permanent link")

**FastAPI** doesn't require you to use a SQL (relational) database. But you can use **any database** that you want.

Here we'll see an example using [SQLModel](https://sqlmodel.tiangolo.com/).

**SQLModel** is built on top of [SQLAlchemy](https://www.sqlalchemy.org/) and Pydantic. It was made by the same author of **FastAPI** to be the perfect match for FastAPI applications that need to use **SQL databases**.

Tip

You could use any other SQL or NoSQL database library you want (in some cases called "ORMs"), FastAPI doesn't force you to use anything. üòé

As SQLModel is based on SQLAlchemy, you can easily use **any database supported** by SQLAlchemy (which makes them also supported by SQLModel), like:

  * PostgreSQL
  * MySQL
  * SQLite
  * Oracle
  * Microsoft SQL Server, etc.

In this example, we'll use **SQLite** , because it uses a single file and Python has integrated support. So, you can copy this example and run it as is.

Later, for your production application, you might want to use a database server like **PostgreSQL**.

Tip

There is an official project generator with **FastAPI** and **PostgreSQL** including a frontend and more tools: <https://github.com/fastapi/full-stack-fastapi-template>

This is a very simple and short tutorial, if you want to learn about databases in general, about SQL, or more advanced features, go to the [SQLModel docs](https://sqlmodel.tiangolo.com/).

## Install `SQLModel`[¶](#install-sqlmodel "Permanent link")

First, make sure you create your [virtual environment](../../virtual-environments/), activate it, and then install `sqlmodel`:
    
    
    $ pip install sqlmodel
    ---> 100%
    

## Create the App with a Single Model[¶](#create-the-app-with-a-single-model "Permanent link")

We'll create the simplest first version of the app with a single **SQLModel** model first.

Later we'll improve it increasing security and versatility with **multiple models** below. ü§ì

### Create Models[¶](#create-models "Permanent link")

Import `SQLModel` and create a database model:

Python 3.10+
    
    
    from typing import Annotated
    
    from fastapi import Depends, FastAPI, HTTPException, Query
    from sqlmodel import Field, Session, SQLModel, create_engine, select
    
    
    class Hero(SQLModel, table=True):
        id: int | None = Field(default=None, primary_key=True)
        name: str = Field(index=True)
        age: int | None = Field(default=None, index=True)
        secret_name: str
    
    # Code below omitted üëá
    

üëÄ Full file preview

Python 3.10+
    
    
    from typing import Annotated
    
    from fastapi import Depends, FastAPI, HTTPException, Query
    from sqlmodel import Field, Session, SQLModel, create_engine, select
    
    
    class Hero(SQLModel, table=True):
        id: int | None = Field(default=None, primary_key=True)
        name: str = Field(index=True)
        age: int | None = Field(default=None, index=True)
        secret_name: str
    
    
    sqlite_file_name = "database.db"
    sqlite_url = f"sqlite:///{sqlite_file_name}"
    
    connect_args = {"check_same_thread": False}
    engine = create_engine(sqlite_url, connect_args=connect_args)
    
    
    def create_db_and_tables():
        SQLModel.metadata.create_all(engine)
    
    
    def get_session():
        with Session(engine) as session:
            yield session
    
    
    SessionDep = Annotated[Session, Depends(get_session)]
    
    app = FastAPI()
    
    
    @app.on_event("startup")
    def on_startup():
        create_db_and_tables()
    
    
    @app.post("/heroes/")
    def create_hero(hero: Hero, session: SessionDep) -> Hero:
        session.add(hero)
        session.commit()
        session.refresh(hero)
        return hero
    
    
    @app.get("/heroes/")
    def read_heroes(
        session: SessionDep,
        offset: int = 0,
        limit: Annotated[int, Query(le=100)] = 100,
    ) -> list[Hero]:
        heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
        return heroes
    
    
    @app.get("/heroes/{hero_id}")
    def read_hero(hero_id: int, session: SessionDep) -> Hero:
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        return hero
    
    
    @app.delete("/heroes/{hero_id}")
    def delete_hero(hero_id: int, session: SessionDep):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        session.delete(hero)
        session.commit()
        return {"ok": True}
    

ü§ì Other versions and variants

Python 3.9+Python 3.10+ - non-AnnotatedPython 3.9+ - non-Annotated
    
    
    from typing import Annotated, Union
    
    from fastapi import Depends, FastAPI, HTTPException, Query
    from sqlmodel import Field, Session, SQLModel, create_engine, select
    
    
    class Hero(SQLModel, table=True):
        id: Union[int, None] = Field(default=None, primary_key=True)
        name: str = Field(index=True)
        age: Union[int, None] = Field(default=None, index=True)
        secret_name: str
    
    
    sqlite_file_name = "database.db"
    sqlite_url = f"sqlite:///{sqlite_file_name}"
    
    connect_args = {"check_same_thread": False}
    engine = create_engine(sqlite_url, connect_args=connect_args)
    
    
    def create_db_and_tables():
        SQLModel.metadata.create_all(engine)
    
    
    def get_session():
        with Session(engine) as session:
            yield session
    
    
    SessionDep = Annotated[Session, Depends(get_session)]
    
    app = FastAPI()
    
    
    @app.on_event("startup")
    def on_startup():
        create_db_and_tables()
    
    
    @app.post("/heroes/")
    def create_hero(hero: Hero, session: SessionDep) -> Hero:
        session.add(hero)
        session.commit()
        session.refresh(hero)
        return hero
    
    
    @app.get("/heroes/")
    def read_heroes(
        session: SessionDep,
        offset: int = 0,
        limit: Annotated[int, Query(le=100)] = 100,
    ) -> list[Hero]:
        heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
        return heroes
    
    
    @app.get("/heroes/{hero_id}")
    def read_hero(hero_id: int, session: SessionDep) -> Hero:
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        return hero
    
    
    @app.delete("/heroes/{hero_id}")
    def delete_hero(hero_id: int, session: SessionDep):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        session.delete(hero)
        session.commit()
        return {"ok": True}
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import Depends, FastAPI, HTTPException, Query
    from sqlmodel import Field, Session, SQLModel, create_engine, select
    
    
    class Hero(SQLModel, table=True):
        id: int | None = Field(default=None, primary_key=True)
        name: str = Field(index=True)
        age: int | None = Field(default=None, index=True)
        secret_name: str
    
    
    sqlite_file_name = "database.db"
    sqlite_url = f"sqlite:///{sqlite_file_name}"
    
    connect_args = {"check_same_thread": False}
    engine = create_engine(sqlite_url, connect_args=connect_args)
    
    
    def create_db_and_tables():
        SQLModel.metadata.create_all(engine)
    
    
    def get_session():
        with Session(engine) as session:
            yield session
    
    
    app = FastAPI()
    
    
    @app.on_event("startup")
    def on_startup():
        create_db_and_tables()
    
    
    @app.post("/heroes/")
    def create_hero(hero: Hero, session: Session = Depends(get_session)) -> Hero:
        session.add(hero)
        session.commit()
        session.refresh(hero)
        return hero
    
    
    @app.get("/heroes/")
    def read_heroes(
        session: Session = Depends(get_session),
        offset: int = 0,
        limit: int = Query(default=100, le=100),
    ) -> list[Hero]:
        heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
        return heroes
    
    
    @app.get("/heroes/{hero_id}")
    def read_hero(hero_id: int, session: Session = Depends(get_session)) -> Hero:
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        return hero
    
    
    @app.delete("/heroes/{hero_id}")
    def delete_hero(hero_id: int, session: Session = Depends(get_session)):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        session.delete(hero)
        session.commit()
        return {"ok": True}
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from typing import Union
    
    from fastapi import Depends, FastAPI, HTTPException, Query
    from sqlmodel import Field, Session, SQLModel, create_engine, select
    
    
    class Hero(SQLModel, table=True):
        id: Union[int, None] = Field(default=None, primary_key=True)
        name: str = Field(index=True)
        age: Union[int, None] = Field(default=None, index=True)
        secret_name: str
    
    
    sqlite_file_name = "database.db"
    sqlite_url = f"sqlite:///{sqlite_file_name}"
    
    connect_args = {"check_same_thread": False}
    engine = create_engine(sqlite_url, connect_args=connect_args)
    
    
    def create_db_and_tables():
        SQLModel.metadata.create_all(engine)
    
    
    def get_session():
        with Session(engine) as session:
            yield session
    
    
    app = FastAPI()
    
    
    @app.on_event("startup")
    def on_startup():
        create_db_and_tables()
    
    
    @app.post("/heroes/")
    def create_hero(hero: Hero, session: Session = Depends(get_session)) -> Hero:
        session.add(hero)
        session.commit()
        session.refresh(hero)
        return hero
    
    
    @app.get("/heroes/")
    def read_heroes(
        session: Session = Depends(get_session),
        offset: int = 0,
        limit: int = Query(default=100, le=100),
    ) -> list[Hero]:
        heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
        return heroes
    
    
    @app.get("/heroes/{hero_id}")
    def read_hero(hero_id: int, session: Session = Depends(get_session)) -> Hero:
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        return hero
    
    
    @app.delete("/heroes/{hero_id}")
    def delete_hero(hero_id: int, session: Session = Depends(get_session)):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        session.delete(hero)
        session.commit()
        return {"ok": True}
    

The `Hero` class is very similar to a Pydantic model (in fact, underneath, it actually _is a Pydantic model_).

There are a few differences:

  * `table=True` tells SQLModel that this is a _table model_ , it should represent a **table** in the SQL database, it's not just a _data model_ (as would be any other regular Pydantic class).

  * `Field(primary_key=True)` tells SQLModel that the `id` is the **primary key** in the SQL database (you can learn more about SQL primary keys in the SQLModel docs).

**Note:** We use `int | None` for the primary key field so that in Python code we can _create an object without an`id`_ (`id=None`), assuming the database will _generate it when saving_. SQLModel understands that the database will provide the `id` and _defines the column as a non-null`INTEGER`_ in the database schema. See [SQLModel docs on primary keys](https://sqlmodel.tiangolo.com/tutorial/create-db-and-table/#primary-key-id) for details.

  * `Field(index=True)` tells SQLModel that it should create a **SQL index** for this column, that would allow faster lookups in the database when reading data filtered by this column.

SQLModel will know that something declared as `str` will be a SQL column of type `TEXT` (or `VARCHAR`, depending on the database).

### Create an Engine[¶](#create-an-engine "Permanent link")

A SQLModel `engine` (underneath it's actually a SQLAlchemy `engine`) is what **holds the connections** to the database.

You would have **one single`engine` object** for all your code to connect to the same database.

Python 3.10+
    
    
    # Code above omitted üëÜ
    
    sqlite_file_name = "database.db"
    sqlite_url = f"sqlite:///{sqlite_file_name}"
    
    connect_args = {"check_same_thread": False}
    engine = create_engine(sqlite_url, connect_args=connect_args)
    
    # Code below omitted üëá
    

üëÄ Full file preview

Python 3.10+
    
    
    from typing import Annotated
    
    from fastapi import Depends, FastAPI, HTTPException, Query
    from sqlmodel import Field, Session, SQLModel, create_engine, select
    
    
    class Hero(SQLModel, table=True):
        id: int | None = Field(default=None, primary_key=True)
        name: str = Field(index=True)
        age: int | None = Field(default=None, index=True)
        secret_name: str
    
    
    sqlite_file_name = "database.db"
    sqlite_url = f"sqlite:///{sqlite_file_name}"
    
    connect_args = {"check_same_thread": False}
    engine = create_engine(sqlite_url, connect_args=connect_args)
    
    
    def create_db_and_tables():
        SQLModel.metadata.create_all(engine)
    
    
    def get_session():
        with Session(engine) as session:
            yield session
    
    
    SessionDep = Annotated[Session, Depends(get_session)]
    
    app = FastAPI()
    
    
    @app.on_event("startup")
    def on_startup():
        create_db_and_tables()
    
    
    @app.post("/heroes/")
    def create_hero(hero: Hero, session: SessionDep) -> Hero:
        session.add(hero)
        session.commit()
        session.refresh(hero)
        return hero
    
    
    @app.get("/heroes/")
    def read_heroes(
        session: SessionDep,
        offset: int = 0,
        limit: Annotated[int, Query(le=100)] = 100,
    ) -> list[Hero]:
        heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
        return heroes
    
    
    @app.get("/heroes/{hero_id}")
    def read_hero(hero_id: int, session: SessionDep) -> Hero:
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        return hero
    
    
    @app.delete("/heroes/{hero_id}")
    def delete_hero(hero_id: int, session: SessionDep):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        session.delete(hero)
        session.commit()
        return {"ok": True}
    

ü§ì Other versions and variants

Python 3.9+Python 3.10+ - non-AnnotatedPython 3.9+ - non-Annotated
    
    
    from typing import Annotated, Union
    
    from fastapi import Depends, FastAPI, HTTPException, Query
    from sqlmodel import Field, Session, SQLModel, create_engine, select
    
    
    class Hero(SQLModel, table=True):
        id: Union[int, None] = Field(default=None, primary_key=True)
        name: str = Field(index=True)
        age: Union[int, None] = Field(default=None, index=True)
        secret_name: str
    
    
    sqlite_file_name = "database.db"
    sqlite_url = f"sqlite:///{sqlite_file_name}"
    
    connect_args = {"check_same_thread": False}
    engine = create_engine(sqlite_url, connect_args=connect_args)
    
    
    def create_db_and_tables():
        SQLModel.metadata.create_all(engine)
    
    
    def get_session():
        with Session(engine) as session:
            yield session
    
    
    SessionDep = Annotated[Session, Depends(get_session)]
    
    app = FastAPI()
    
    
    @app.on_event("startup")
    def on_startup():
        create_db_and_tables()
    
    
    @app.post("/heroes/")
    def create_hero(hero: Hero, session: SessionDep) -> Hero:
        session.add(hero)
        session.commit()
        session.refresh(hero)
        return hero
    
    
    @app.get("/heroes/")
    def read_heroes(
        session: SessionDep,
        offset: int = 0,
        limit: Annotated[int, Query(le=100)] = 100,
    ) -> list[Hero]:
        heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
        return heroes
    
    
    @app.get("/heroes/{hero_id}")
    def read_hero(hero_id: int, session: SessionDep) -> Hero:
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        return hero
    
    
    @app.delete("/heroes/{hero_id}")
    def delete_hero(hero_id: int, session: SessionDep):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        session.delete(hero)
        session.commit()
        return {"ok": True}
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import Depends, FastAPI, HTTPException, Query
    from sqlmodel import Field, Session, SQLModel, create_engine, select
    
    
    class Hero(SQLModel, table=True):
        id: int | None = Field(default=None, primary_key=True)
        name: str = Field(index=True)
        age: int | None = Field(default=None, index=True)
        secret_name: str
    
    
    sqlite_file_name = "database.db"
    sqlite_url = f"sqlite:///{sqlite_file_name}"
    
    connect_args = {"check_same_thread": False}
    engine = create_engine(sqlite_url, connect_args=connect_args)
    
    
    def create_db_and_tables():
        SQLModel.metadata.create_all(engine)
    
    
    def get_session():
        with Session(engine) as session:
            yield session
    
    
    app = FastAPI()
    
    
    @app.on_event("startup")
    def on_startup():
        create_db_and_tables()
    
    
    @app.post("/heroes/")
    def create_hero(hero: Hero, session: Session = Depends(get_session)) -> Hero:
        session.add(hero)
        session.commit()
        session.refresh(hero)
        return hero
    
    
    @app.get("/heroes/")
    def read_heroes(
        session: Session = Depends(get_session),
        offset: int = 0,
        limit: int = Query(default=100, le=100),
    ) -> list[Hero]:
        heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
        return heroes
    
    
    @app.get("/heroes/{hero_id}")
    def read_hero(hero_id: int, session: Session = Depends(get_session)) -> Hero:
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        return hero
    
    
    @app.delete("/heroes/{hero_id}")
    def delete_hero(hero_id: int, session: Session = Depends(get_session)):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        session.delete(hero)
        session.commit()
        return {"ok": True}
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from typing import Union
    
    from fastapi import Depends, FastAPI, HTTPException, Query
    from sqlmodel import Field, Session, SQLModel, create_engine, select
    
    
    class Hero(SQLModel, table=True):
        id: Union[int, None] = Field(default=None, primary_key=True)
        name: str = Field(index=True)
        age: Union[int, None] = Field(default=None, index=True)
        secret_name: str
    
    
    sqlite_file_name = "database.db"
    sqlite_url = f"sqlite:///{sqlite_file_name}"
    
    connect_args = {"check_same_thread": False}
    engine = create_engine(sqlite_url, connect_args=connect_args)
    
    
    def create_db_and_tables():
        SQLModel.metadata.create_all(engine)
    
    
    def get_session():
        with Session(engine) as session:
            yield session
    
    
    app = FastAPI()
    
    
    @app.on_event("startup")
    def on_startup():
        create_db_and_tables()
    
    
    @app.post("/heroes/")
    def create_hero(hero: Hero, session: Session = Depends(get_session)) -> Hero:
        session.add(hero)
        session.commit()
        session.refresh(hero)
        return hero
    
    
    @app.get("/heroes/")
    def read_heroes(
        session: Session = Depends(get_session),
        offset: int = 0,
        limit: int = Query(default=100, le=100),
    ) -> list[Hero]:
        heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
        return heroes
    
    
    @app.get("/heroes/{hero_id}")
    def read_hero(hero_id: int, session: Session = Depends(get_session)) -> Hero:
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        return hero
    
    
    @app.delete("/heroes/{hero_id}")
    def delete_hero(hero_id: int, session: Session = Depends(get_session)):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        session.delete(hero)
        session.commit()
        return {"ok": True}
    

Using `check_same_thread=False` allows FastAPI to use the same SQLite database in different threads. This is necessary as **one single request** could use **more than one thread** (for example in dependencies).

Don't worry, with the way the code is structured, we'll make sure we use **a single SQLModel _session_ per request** later, this is actually what the `check_same_thread` is trying to achieve.

### Create the Tables[¶](#create-the-tables "Permanent link")

We then add a function that uses `SQLModel.metadata.create_all(engine)` to **create the tables** for all the _table models_.

Python 3.10+
    
    
    # Code above omitted üëÜ
    
    def create_db_and_tables():
        SQLModel.metadata.create_all(engine)
    
    # Code below omitted üëá
    

üëÄ Full file preview

Python 3.10+
    
    
    from typing import Annotated
    
    from fastapi import Depends, FastAPI, HTTPException, Query
    from sqlmodel import Field, Session, SQLModel, create_engine, select
    
    
    class Hero(SQLModel, table=True):
        id: int | None = Field(default=None, primary_key=True)
        name: str = Field(index=True)
        age: int | None = Field(default=None, index=True)
        secret_name: str
    
    
    sqlite_file_name = "database.db"
    sqlite_url = f"sqlite:///{sqlite_file_name}"
    
    connect_args = {"check_same_thread": False}
    engine = create_engine(sqlite_url, connect_args=connect_args)
    
    
    def create_db_and_tables():
        SQLModel.metadata.create_all(engine)
    
    
    def get_session():
        with Session(engine) as session:
            yield session
    
    
    SessionDep = Annotated[Session, Depends(get_session)]
    
    app = FastAPI()
    
    
    @app.on_event("startup")
    def on_startup():
        create_db_and_tables()
    
    
    @app.post("/heroes/")
    def create_hero(hero: Hero, session: SessionDep) -> Hero:
        session.add(hero)
        session.commit()
        session.refresh(hero)
        return hero
    
    
    @app.get("/heroes/")
    def read_heroes(
        session: SessionDep,
        offset: int = 0,
        limit: Annotated[int, Query(le=100)] = 100,
    ) -> list[Hero]:
        heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
        return heroes
    
    
    @app.get("/heroes/{hero_id}")
    def read_hero(hero_id: int, session: SessionDep) -> Hero:
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        return hero
    
    
    @app.delete("/heroes/{hero_id}")
    def delete_hero(hero_id: int, session: SessionDep):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        session.delete(hero)
        session.commit()
        return {"ok": True}
    

ü§ì Other versions and variants

Python 3.9+Python 3.10+ - non-AnnotatedPython 3.9+ - non-Annotated
    
    
    from typing import Annotated, Union
    
    from fastapi import Depends, FastAPI, HTTPException, Query
    from sqlmodel import Field, Session, SQLModel, create_engine, select
    
    
    class Hero(SQLModel, table=True):
        id: Union[int, None] = Field(default=None, primary_key=True)
        name: str = Field(index=True)
        age: Union[int, None] = Field(default=None, index=True)
        secret_name: str
    
    
    sqlite_file_name = "database.db"
    sqlite_url = f"sqlite:///{sqlite_file_name}"
    
    connect_args = {"check_same_thread": False}
    engine = create_engine(sqlite_url, connect_args=connect_args)
    
    
    def create_db_and_tables():
        SQLModel.metadata.create_all(engine)
    
    
    def get_session():
        with Session(engine) as session:
            yield session
    
    
    SessionDep = Annotated[Session, Depends(get_session)]
    
    app = FastAPI()
    
    
    @app.on_event("startup")
    def on_startup():
        create_db_and_tables()
    
    
    @app.post("/heroes/")
    def create_hero(hero: Hero, session: SessionDep) -> Hero:
        session.add(hero)
        session.commit()
        session.refresh(hero)
        return hero
    
    
    @app.get("/heroes/")
    def read_heroes(
        session: SessionDep,
        offset: int = 0,
        limit: Annotated[int, Query(le=100)] = 100,
    ) -> list[Hero]:
        heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
        return heroes
    
    
    @app.get("/heroes/{hero_id}")
    def read_hero(hero_id: int, session: SessionDep) -> Hero:
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        return hero
    
    
    @app.delete("/heroes/{hero_id}")
    def delete_hero(hero_id: int, session: SessionDep):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        session.delete(hero)
        session.commit()
        return {"ok": True}
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import Depends, FastAPI, HTTPException, Query
    from sqlmodel import Field, Session, SQLModel, create_engine, select
    
    
    class Hero(SQLModel, table=True):
        id: int | None = Field(default=None, primary_key=True)
        name: str = Field(index=True)
        age: int | None = Field(default=None, index=True)
        secret_name: str
    
    
    sqlite_file_name = "database.db"
    sqlite_url = f"sqlite:///{sqlite_file_name}"
    
    connect_args = {"check_same_thread": False}
    engine = create_engine(sqlite_url, connect_args=connect_args)
    
    
    def create_db_and_tables():
        SQLModel.metadata.create_all(engine)
    
    
    def get_session():
        with Session(engine) as session:
            yield session
    
    
    app = FastAPI()
    
    
    @app.on_event("startup")
    def on_startup():
        create_db_and_tables()
    
    
    @app.post("/heroes/")
    def create_hero(hero: Hero, session: Session = Depends(get_session)) -> Hero:
        session.add(hero)
        session.commit()
        session.refresh(hero)
        return hero
    
    
    @app.get("/heroes/")
    def read_heroes(
        session: Session = Depends(get_session),
        offset: int = 0,
        limit: int = Query(default=100, le=100),
    ) -> list[Hero]:
        heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
        return heroes
    
    
    @app.get("/heroes/{hero_id}")
    def read_hero(hero_id: int, session: Session = Depends(get_session)) -> Hero:
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        return hero
    
    
    @app.delete("/heroes/{hero_id}")
    def delete_hero(hero_id: int, session: Session = Depends(get_session)):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        session.delete(hero)
        session.commit()
        return {"ok": True}
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from typing import Union
    
    from fastapi import Depends, FastAPI, HTTPException, Query
    from sqlmodel import Field, Session, SQLModel, create_engine, select
    
    
    class Hero(SQLModel, table=True):
        id: Union[int, None] = Field(default=None, primary_key=True)
        name: str = Field(index=True)
        age: Union[int, None] = Field(default=None, index=True)
        secret_name: str
    
    
    sqlite_file_name = "database.db"
    sqlite_url = f"sqlite:///{sqlite_file_name}"
    
    connect_args = {"check_same_thread": False}
    engine = create_engine(sqlite_url, connect_args=connect_args)
    
    
    def create_db_and_tables():
        SQLModel.metadata.create_all(engine)
    
    
    def get_session():
        with Session(engine) as session:
            yield session
    
    
    app = FastAPI()
    
    
    @app.on_event("startup")
    def on_startup():
        create_db_and_tables()
    
    
    @app.post("/heroes/")
    def create_hero(hero: Hero, session: Session = Depends(get_session)) -> Hero:
        session.add(hero)
        session.commit()
        session.refresh(hero)
        return hero
    
    
    @app.get("/heroes/")
    def read_heroes(
        session: Session = Depends(get_session),
        offset: int = 0,
        limit: int = Query(default=100, le=100),
    ) -> list[Hero]:
        heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
        return heroes
    
    
    @app.get("/heroes/{hero_id}")
    def read_hero(hero_id: int, session: Session = Depends(get_session)) -> Hero:
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        return hero
    
    
    @app.delete("/heroes/{hero_id}")
    def delete_hero(hero_id: int, session: Session = Depends(get_session)):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        session.delete(hero)
        session.commit()
        return {"ok": True}
    

### Create a Session Dependency[¶](#create-a-session-dependency "Permanent link")

A **`Session`** is what stores the **objects in memory** and keeps track of any changes needed in the data, then it **uses the`engine`** to communicate with the database.

We will create a FastAPI **dependency** with `yield` that will provide a new `Session` for each request. This is what ensures that we use a single session per request. ü§ì

Then we create an `Annotated` dependency `SessionDep` to simplify the rest of the code that will use this dependency.

Python 3.10+
    
    
    # Code above omitted üëÜ
    
    def get_session():
        with Session(engine) as session:
            yield session
    
    
    SessionDep = Annotated[Session, Depends(get_session)]
    
    # Code below omitted üëá
    

üëÄ Full file preview

Python 3.10+
    
    
    from typing import Annotated
    
    from fastapi import Depends, FastAPI, HTTPException, Query
    from sqlmodel import Field, Session, SQLModel, create_engine, select
    
    
    class Hero(SQLModel, table=True):
        id: int | None = Field(default=None, primary_key=True)
        name: str = Field(index=True)
        age: int | None = Field(default=None, index=True)
        secret_name: str
    
    
    sqlite_file_name = "database.db"
    sqlite_url = f"sqlite:///{sqlite_file_name}"
    
    connect_args = {"check_same_thread": False}
    engine = create_engine(sqlite_url, connect_args=connect_args)
    
    
    def create_db_and_tables():
        SQLModel.metadata.create_all(engine)
    
    
    def get_session():
        with Session(engine) as session:
            yield session
    
    
    SessionDep = Annotated[Session, Depends(get_session)]
    
    app = FastAPI()
    
    
    @app.on_event("startup")
    def on_startup():
        create_db_and_tables()
    
    
    @app.post("/heroes/")
    def create_hero(hero: Hero, session: SessionDep) -> Hero:
        session.add(hero)
        session.commit()
        session.refresh(hero)
        return hero
    
    
    @app.get("/heroes/")
    def read_heroes(
        session: SessionDep,
        offset: int = 0,
        limit: Annotated[int, Query(le=100)] = 100,
    ) -> list[Hero]:
        heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
        return heroes
    
    
    @app.get("/heroes/{hero_id}")
    def read_hero(hero_id: int, session: SessionDep) -> Hero:
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        return hero
    
    
    @app.delete("/heroes/{hero_id}")
    def delete_hero(hero_id: int, session: SessionDep):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        session.delete(hero)
        session.commit()
        return {"ok": True}
    

ü§ì Other versions and variants

Python 3.9+Python 3.10+ - non-AnnotatedPython 3.9+ - non-Annotated
    
    
    from typing import Annotated, Union
    
    from fastapi import Depends, FastAPI, HTTPException, Query
    from sqlmodel import Field, Session, SQLModel, create_engine, select
    
    
    class Hero(SQLModel, table=True):
        id: Union[int, None] = Field(default=None, primary_key=True)
        name: str = Field(index=True)
        age: Union[int, None] = Field(default=None, index=True)
        secret_name: str
    
    
    sqlite_file_name = "database.db"
    sqlite_url = f"sqlite:///{sqlite_file_name}"
    
    connect_args = {"check_same_thread": False}
    engine = create_engine(sqlite_url, connect_args=connect_args)
    
    
    def create_db_and_tables():
        SQLModel.metadata.create_all(engine)
    
    
    def get_session():
        with Session(engine) as session:
            yield session
    
    
    SessionDep = Annotated[Session, Depends(get_session)]
    
    app = FastAPI()
    
    
    @app.on_event("startup")
    def on_startup():
        create_db_and_tables()
    
    
    @app.post("/heroes/")
    def create_hero(hero: Hero, session: SessionDep) -> Hero:
        session.add(hero)
        session.commit()
        session.refresh(hero)
        return hero
    
    
    @app.get("/heroes/")
    def read_heroes(
        session: SessionDep,
        offset: int = 0,
        limit: Annotated[int, Query(le=100)] = 100,
    ) -> list[Hero]:
        heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
        return heroes
    
    
    @app.get("/heroes/{hero_id}")
    def read_hero(hero_id: int, session: SessionDep) -> Hero:
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        return hero
    
    
    @app.delete("/heroes/{hero_id}")
    def delete_hero(hero_id: int, session: SessionDep):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        session.delete(hero)
        session.commit()
        return {"ok": True}
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import Depends, FastAPI, HTTPException, Query
    from sqlmodel import Field, Session, SQLModel, create_engine, select
    
    
    class Hero(SQLModel, table=True):
        id: int | None = Field(default=None, primary_key=True)
        name: str = Field(index=True)
        age: int | None = Field(default=None, index=True)
        secret_name: str
    
    
    sqlite_file_name = "database.db"
    sqlite_url = f"sqlite:///{sqlite_file_name}"
    
    connect_args = {"check_same_thread": False}
    engine = create_engine(sqlite_url, connect_args=connect_args)
    
    
    def create_db_and_tables():
        SQLModel.metadata.create_all(engine)
    
    
    def get_session():
        with Session(engine) as session:
            yield session
    
    
    app = FastAPI()
    
    
    @app.on_event("startup")
    def on_startup():
        create_db_and_tables()
    
    
    @app.post("/heroes/")
    def create_hero(hero: Hero, session: Session = Depends(get_session)) -> Hero:
        session.add(hero)
        session.commit()
        session.refresh(hero)
        return hero
    
    
    @app.get("/heroes/")
    def read_heroes(
        session: Session = Depends(get_session),
        offset: int = 0,
        limit: int = Query(default=100, le=100),
    ) -> list[Hero]:
        heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
        return heroes
    
    
    @app.get("/heroes/{hero_id}")
    def read_hero(hero_id: int, session: Session = Depends(get_session)) -> Hero:
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        return hero
    
    
    @app.delete("/heroes/{hero_id}")
    def delete_hero(hero_id: int, session: Session = Depends(get_session)):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        session.delete(hero)
        session.commit()
        return {"ok": True}
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from typing import Union
    
    from fastapi import Depends, FastAPI, HTTPException, Query
    from sqlmodel import Field, Session, SQLModel, create_engine, select
    
    
    class Hero(SQLModel, table=True):
        id: Union[int, None] = Field(default=None, primary_key=True)
        name: str = Field(index=True)
        age: Union[int, None] = Field(default=None, index=True)
        secret_name: str
    
    
    sqlite_file_name = "database.db"
    sqlite_url = f"sqlite:///{sqlite_file_name}"
    
    connect_args = {"check_same_thread": False}
    engine = create_engine(sqlite_url, connect_args=connect_args)
    
    
    def create_db_and_tables():
        SQLModel.metadata.create_all(engine)
    
    
    def get_session():
        with Session(engine) as session:
            yield session
    
    
    app = FastAPI()
    
    
    @app.on_event("startup")
    def on_startup():
        create_db_and_tables()
    
    
    @app.post("/heroes/")
    def create_hero(hero: Hero, session: Session = Depends(get_session)) -> Hero:
        session.add(hero)
        session.commit()
        session.refresh(hero)
        return hero
    
    
    @app.get("/heroes/")
    def read_heroes(
        session: Session = Depends(get_session),
        offset: int = 0,
        limit: int = Query(default=100, le=100),
    ) -> list[Hero]:
        heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
        return heroes
    
    
    @app.get("/heroes/{hero_id}")
    def read_hero(hero_id: int, session: Session = Depends(get_session)) -> Hero:
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        return hero
    
    
    @app.delete("/heroes/{hero_id}")
    def delete_hero(hero_id: int, session: Session = Depends(get_session)):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        session.delete(hero)
        session.commit()
        return {"ok": True}
    

### Create Database Tables on Startup[¶](#create-database-tables-on-startup "Permanent link")

We will create the database tables when the application starts.

Python 3.10+
    
    
    # Code above omitted üëÜ
    
    app = FastAPI()
    
    
    @app.on_event("startup")
    def on_startup():
        create_db_and_tables()
    
    # Code below omitted üëá
    

üëÄ Full file preview

Python 3.10+
    
    
    from typing import Annotated
    
    from fastapi import Depends, FastAPI, HTTPException, Query
    from sqlmodel import Field, Session, SQLModel, create_engine, select
    
    
    class Hero(SQLModel, table=True):
        id: int | None = Field(default=None, primary_key=True)
        name: str = Field(index=True)
        age: int | None = Field(default=None, index=True)
        secret_name: str
    
    
    sqlite_file_name = "database.db"
    sqlite_url = f"sqlite:///{sqlite_file_name}"
    
    connect_args = {"check_same_thread": False}
    engine = create_engine(sqlite_url, connect_args=connect_args)
    
    
    def create_db_and_tables():
        SQLModel.metadata.create_all(engine)
    
    
    def get_session():
        with Session(engine) as session:
            yield session
    
    
    SessionDep = Annotated[Session, Depends(get_session)]
    
    app = FastAPI()
    
    
    @app.on_event("startup")
    def on_startup():
        create_db_and_tables()
    
    
    @app.post("/heroes/")
    def create_hero(hero: Hero, session: SessionDep) -> Hero:
        session.add(hero)
        session.commit()
        session.refresh(hero)
        return hero
    
    
    @app.get("/heroes/")
    def read_heroes(
        session: SessionDep,
        offset: int = 0,
        limit: Annotated[int, Query(le=100)] = 100,
    ) -> list[Hero]:
        heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
        return heroes
    
    
    @app.get("/heroes/{hero_id}")
    def read_hero(hero_id: int, session: SessionDep) -> Hero:
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        return hero
    
    
    @app.delete("/heroes/{hero_id}")
    def delete_hero(hero_id: int, session: SessionDep):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        session.delete(hero)
        session.commit()
        return {"ok": True}
    

ü§ì Other versions and variants

Python 3.9+Python 3.10+ - non-AnnotatedPython 3.9+ - non-Annotated
    
    
    from typing import Annotated, Union
    
    from fastapi import Depends, FastAPI, HTTPException, Query
    from sqlmodel import Field, Session, SQLModel, create_engine, select
    
    
    class Hero(SQLModel, table=True):
        id: Union[int, None] = Field(default=None, primary_key=True)
        name: str = Field(index=True)
        age: Union[int, None] = Field(default=None, index=True)
        secret_name: str
    
    
    sqlite_file_name = "database.db"
    sqlite_url = f"sqlite:///{sqlite_file_name}"
    
    connect_args = {"check_same_thread": False}
    engine = create_engine(sqlite_url, connect_args=connect_args)
    
    
    def create_db_and_tables():
        SQLModel.metadata.create_all(engine)
    
    
    def get_session():
        with Session(engine) as session:
            yield session
    
    
    SessionDep = Annotated[Session, Depends(get_session)]
    
    app = FastAPI()
    
    
    @app.on_event("startup")
    def on_startup():
        create_db_and_tables()
    
    
    @app.post("/heroes/")
    def create_hero(hero: Hero, session: SessionDep) -> Hero:
        session.add(hero)
        session.commit()
        session.refresh(hero)
        return hero
    
    
    @app.get("/heroes/")
    def read_heroes(
        session: SessionDep,
        offset: int = 0,
        limit: Annotated[int, Query(le=100)] = 100,
    ) -> list[Hero]:
        heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
        return heroes
    
    
    @app.get("/heroes/{hero_id}")
    def read_hero(hero_id: int, session: SessionDep) -> Hero:
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        return hero
    
    
    @app.delete("/heroes/{hero_id}")
    def delete_hero(hero_id: int, session: SessionDep):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        session.delete(hero)
        session.commit()
        return {"ok": True}
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import Depends, FastAPI, HTTPException, Query
    from sqlmodel import Field, Session, SQLModel, create_engine, select
    
    
    class Hero(SQLModel, table=True):
        id: int | None = Field(default=None, primary_key=True)
        name: str = Field(index=True)
        age: int | None = Field(default=None, index=True)
        secret_name: str
    
    
    sqlite_file_name = "database.db"
    sqlite_url = f"sqlite:///{sqlite_file_name}"
    
    connect_args = {"check_same_thread": False}
    engine = create_engine(sqlite_url, connect_args=connect_args)
    
    
    def create_db_and_tables():
        SQLModel.metadata.create_all(engine)
    
    
    def get_session():
        with Session(engine) as session:
            yield session
    
    
    app = FastAPI()
    
    
    @app.on_event("startup")
    def on_startup():
        create_db_and_tables()
    
    
    @app.post("/heroes/")
    def create_hero(hero: Hero, session: Session = Depends(get_session)) -> Hero:
        session.add(hero)
        session.commit()
        session.refresh(hero)
        return hero
    
    
    @app.get("/heroes/")
    def read_heroes(
        session: Session = Depends(get_session),
        offset: int = 0,
        limit: int = Query(default=100, le=100),
    ) -> list[Hero]:
        heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
        return heroes
    
    
    @app.get("/heroes/{hero_id}")
    def read_hero(hero_id: int, session: Session = Depends(get_session)) -> Hero:
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        return hero
    
    
    @app.delete("/heroes/{hero_id}")
    def delete_hero(hero_id: int, session: Session = Depends(get_session)):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        session.delete(hero)
        session.commit()
        return {"ok": True}
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from typing import Union
    
    from fastapi import Depends, FastAPI, HTTPException, Query
    from sqlmodel import Field, Session, SQLModel, create_engine, select
    
    
    class Hero(SQLModel, table=True):
        id: Union[int, None] = Field(default=None, primary_key=True)
        name: str = Field(index=True)
        age: Union[int, None] = Field(default=None, index=True)
        secret_name: str
    
    
    sqlite_file_name = "database.db"
    sqlite_url = f"sqlite:///{sqlite_file_name}"
    
    connect_args = {"check_same_thread": False}
    engine = create_engine(sqlite_url, connect_args=connect_args)
    
    
    def create_db_and_tables():
        SQLModel.metadata.create_all(engine)
    
    
    def get_session():
        with Session(engine) as session:
            yield session
    
    
    app = FastAPI()
    
    
    @app.on_event("startup")
    def on_startup():
        create_db_and_tables()
    
    
    @app.post("/heroes/")
    def create_hero(hero: Hero, session: Session = Depends(get_session)) -> Hero:
        session.add(hero)
        session.commit()
        session.refresh(hero)
        return hero
    
    
    @app.get("/heroes/")
    def read_heroes(
        session: Session = Depends(get_session),
        offset: int = 0,
        limit: int = Query(default=100, le=100),
    ) -> list[Hero]:
        heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
        return heroes
    
    
    @app.get("/heroes/{hero_id}")
    def read_hero(hero_id: int, session: Session = Depends(get_session)) -> Hero:
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        return hero
    
    
    @app.delete("/heroes/{hero_id}")
    def delete_hero(hero_id: int, session: Session = Depends(get_session)):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        session.delete(hero)
        session.commit()
        return {"ok": True}
    

Here we create the tables on an application startup event.

For production you would probably use a migration script that runs before you start your app. ü§ì

Tip

SQLModel will have migration utilities wrapping Alembic, but for now, you can use [Alembic](https://alembic.sqlalchemy.org/en/latest/) directly.

### Create a Hero[¶](#create-a-hero "Permanent link")

Because each SQLModel model is also a Pydantic model, you can use it in the same **type annotations** that you could use Pydantic models.

For example, if you declare a parameter of type `Hero`, it will be read from the **JSON body**.

The same way, you can declare it as the function's **return type** , and then the shape of the data will show up in the automatic API docs UI.

Python 3.10+
    
    
    # Code above omitted üëÜ
    
    @app.post("/heroes/")
    def create_hero(hero: Hero, session: SessionDep) -> Hero:
        session.add(hero)
        session.commit()
        session.refresh(hero)
        return hero
    
    # Code below omitted üëá
    

üëÄ Full file preview

Python 3.10+
    
    
    from typing import Annotated
    
    from fastapi import Depends, FastAPI, HTTPException, Query
    from sqlmodel import Field, Session, SQLModel, create_engine, select
    
    
    class Hero(SQLModel, table=True):
        id: int | None = Field(default=None, primary_key=True)
        name: str = Field(index=True)
        age: int | None = Field(default=None, index=True)
        secret_name: str
    
    
    sqlite_file_name = "database.db"
    sqlite_url = f"sqlite:///{sqlite_file_name}"
    
    connect_args = {"check_same_thread": False}
    engine = create_engine(sqlite_url, connect_args=connect_args)
    
    
    def create_db_and_tables():
        SQLModel.metadata.create_all(engine)
    
    
    def get_session():
        with Session(engine) as session:
            yield session
    
    
    SessionDep = Annotated[Session, Depends(get_session)]
    
    app = FastAPI()
    
    
    @app.on_event("startup")
    def on_startup():
        create_db_and_tables()
    
    
    @app.post("/heroes/")
    def create_hero(hero: Hero, session: SessionDep) -> Hero:
        session.add(hero)
        session.commit()
        session.refresh(hero)
        return hero
    
    
    @app.get("/heroes/")
    def read_heroes(
        session: SessionDep,
        offset: int = 0,
        limit: Annotated[int, Query(le=100)] = 100,
    ) -> list[Hero]:
        heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
        return heroes
    
    
    @app.get("/heroes/{hero_id}")
    def read_hero(hero_id: int, session: SessionDep) -> Hero:
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        return hero
    
    
    @app.delete("/heroes/{hero_id}")
    def delete_hero(hero_id: int, session: SessionDep):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        session.delete(hero)
        session.commit()
        return {"ok": True}
    

ü§ì Other versions and variants

Python 3.9+Python 3.10+ - non-AnnotatedPython 3.9+ - non-Annotated
    
    
    from typing import Annotated, Union
    
    from fastapi import Depends, FastAPI, HTTPException, Query
    from sqlmodel import Field, Session, SQLModel, create_engine, select
    
    
    class Hero(SQLModel, table=True):
        id: Union[int, None] = Field(default=None, primary_key=True)
        name: str = Field(index=True)
        age: Union[int, None] = Field(default=None, index=True)
        secret_name: str
    
    
    sqlite_file_name = "database.db"
    sqlite_url = f"sqlite:///{sqlite_file_name}"
    
    connect_args = {"check_same_thread": False}
    engine = create_engine(sqlite_url, connect_args=connect_args)
    
    
    def create_db_and_tables():
        SQLModel.metadata.create_all(engine)
    
    
    def get_session():
        with Session(engine) as session:
            yield session
    
    
    SessionDep = Annotated[Session, Depends(get_session)]
    
    app = FastAPI()
    
    
    @app.on_event("startup")
    def on_startup():
        create_db_and_tables()
    
    
    @app.post("/heroes/")
    def create_hero(hero: Hero, session: SessionDep) -> Hero:
        session.add(hero)
        session.commit()
        session.refresh(hero)
        return hero
    
    
    @app.get("/heroes/")
    def read_heroes(
        session: SessionDep,
        offset: int = 0,
        limit: Annotated[int, Query(le=100)] = 100,
    ) -> list[Hero]:
        heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
        return heroes
    
    
    @app.get("/heroes/{hero_id}")
    def read_hero(hero_id: int, session: SessionDep) -> Hero:
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        return hero
    
    
    @app.delete("/heroes/{hero_id}")
    def delete_hero(hero_id: int, session: SessionDep):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        session.delete(hero)
        session.commit()
        return {"ok": True}
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import Depends, FastAPI, HTTPException, Query
    from sqlmodel import Field, Session, SQLModel, create_engine, select
    
    
    class Hero(SQLModel, table=True):
        id: int | None = Field(default=None, primary_key=True)
        name: str = Field(index=True)
        age: int | None = Field(default=None, index=True)
        secret_name: str
    
    
    sqlite_file_name = "database.db"
    sqlite_url = f"sqlite:///{sqlite_file_name}"
    
    connect_args = {"check_same_thread": False}
    engine = create_engine(sqlite_url, connect_args=connect_args)
    
    
    def create_db_and_tables():
        SQLModel.metadata.create_all(engine)
    
    
    def get_session():
        with Session(engine) as session:
            yield session
    
    
    app = FastAPI()
    
    
    @app.on_event("startup")
    def on_startup():
        create_db_and_tables()
    
    
    @app.post("/heroes/")
    def create_hero(hero: Hero, session: Session = Depends(get_session)) -> Hero:
        session.add(hero)
        session.commit()
        session.refresh(hero)
        return hero
    
    
    @app.get("/heroes/")
    def read_heroes(
        session: Session = Depends(get_session),
        offset: int = 0,
        limit: int = Query(default=100, le=100),
    ) -> list[Hero]:
        heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
        return heroes
    
    
    @app.get("/heroes/{hero_id}")
    def read_hero(hero_id: int, session: Session = Depends(get_session)) -> Hero:
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        return hero
    
    
    @app.delete("/heroes/{hero_id}")
    def delete_hero(hero_id: int, session: Session = Depends(get_session)):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        session.delete(hero)
        session.commit()
        return {"ok": True}
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from typing import Union
    
    from fastapi import Depends, FastAPI, HTTPException, Query
    from sqlmodel import Field, Session, SQLModel, create_engine, select
    
    
    class Hero(SQLModel, table=True):
        id: Union[int, None] = Field(default=None, primary_key=True)
        name: str = Field(index=True)
        age: Union[int, None] = Field(default=None, index=True)
        secret_name: str
    
    
    sqlite_file_name = "database.db"
    sqlite_url = f"sqlite:///{sqlite_file_name}"
    
    connect_args = {"check_same_thread": False}
    engine = create_engine(sqlite_url, connect_args=connect_args)
    
    
    def create_db_and_tables():
        SQLModel.metadata.create_all(engine)
    
    
    def get_session():
        with Session(engine) as session:
            yield session
    
    
    app = FastAPI()
    
    
    @app.on_event("startup")
    def on_startup():
        create_db_and_tables()
    
    
    @app.post("/heroes/")
    def create_hero(hero: Hero, session: Session = Depends(get_session)) -> Hero:
        session.add(hero)
        session.commit()
        session.refresh(hero)
        return hero
    
    
    @app.get("/heroes/")
    def read_heroes(
        session: Session = Depends(get_session),
        offset: int = 0,
        limit: int = Query(default=100, le=100),
    ) -> list[Hero]:
        heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
        return heroes
    
    
    @app.get("/heroes/{hero_id}")
    def read_hero(hero_id: int, session: Session = Depends(get_session)) -> Hero:
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        return hero
    
    
    @app.delete("/heroes/{hero_id}")
    def delete_hero(hero_id: int, session: Session = Depends(get_session)):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        session.delete(hero)
        session.commit()
        return {"ok": True}
    

Here we use the `SessionDep` dependency (a `Session`) to add the new `Hero` to the `Session` instance, commit the changes to the database, refresh the data in the `hero`, and then return it.

### Read Heroes[¶](#read-heroes "Permanent link")

We can **read** `Hero`s from the database using a `select()`. We can include a `limit` and `offset` to paginate the results.

Python 3.10+
    
    
    # Code above omitted üëÜ
    
    @app.get("/heroes/")
    def read_heroes(
        session: SessionDep,
        offset: int = 0,
        limit: Annotated[int, Query(le=100)] = 100,
    ) -> list[Hero]:
        heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
        return heroes
    
    # Code below omitted üëá
    

üëÄ Full file preview

Python 3.10+
    
    
    from typing import Annotated
    
    from fastapi import Depends, FastAPI, HTTPException, Query
    from sqlmodel import Field, Session, SQLModel, create_engine, select
    
    
    class Hero(SQLModel, table=True):
        id: int | None = Field(default=None, primary_key=True)
        name: str = Field(index=True)
        age: int | None = Field(default=None, index=True)
        secret_name: str
    
    
    sqlite_file_name = "database.db"
    sqlite_url = f"sqlite:///{sqlite_file_name}"
    
    connect_args = {"check_same_thread": False}
    engine = create_engine(sqlite_url, connect_args=connect_args)
    
    
    def create_db_and_tables():
        SQLModel.metadata.create_all(engine)
    
    
    def get_session():
        with Session(engine) as session:
            yield session
    
    
    SessionDep = Annotated[Session, Depends(get_session)]
    
    app = FastAPI()
    
    
    @app.on_event("startup")
    def on_startup():
        create_db_and_tables()
    
    
    @app.post("/heroes/")
    def create_hero(hero: Hero, session: SessionDep) -> Hero:
        session.add(hero)
        session.commit()
        session.refresh(hero)
        return hero
    
    
    @app.get("/heroes/")
    def read_heroes(
        session: SessionDep,
        offset: int = 0,
        limit: Annotated[int, Query(le=100)] = 100,
    ) -> list[Hero]:
        heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
        return heroes
    
    
    @app.get("/heroes/{hero_id}")
    def read_hero(hero_id: int, session: SessionDep) -> Hero:
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        return hero
    
    
    @app.delete("/heroes/{hero_id}")
    def delete_hero(hero_id: int, session: SessionDep):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        session.delete(hero)
        session.commit()
        return {"ok": True}
    

ü§ì Other versions and variants

Python 3.9+Python 3.10+ - non-AnnotatedPython 3.9+ - non-Annotated
    
    
    from typing import Annotated, Union
    
    from fastapi import Depends, FastAPI, HTTPException, Query
    from sqlmodel import Field, Session, SQLModel, create_engine, select
    
    
    class Hero(SQLModel, table=True):
        id: Union[int, None] = Field(default=None, primary_key=True)
        name: str = Field(index=True)
        age: Union[int, None] = Field(default=None, index=True)
        secret_name: str
    
    
    sqlite_file_name = "database.db"
    sqlite_url = f"sqlite:///{sqlite_file_name}"
    
    connect_args = {"check_same_thread": False}
    engine = create_engine(sqlite_url, connect_args=connect_args)
    
    
    def create_db_and_tables():
        SQLModel.metadata.create_all(engine)
    
    
    def get_session():
        with Session(engine) as session:
            yield session
    
    
    SessionDep = Annotated[Session, Depends(get_session)]
    
    app = FastAPI()
    
    
    @app.on_event("startup")
    def on_startup():
        create_db_and_tables()
    
    
    @app.post("/heroes/")
    def create_hero(hero: Hero, session: SessionDep) -> Hero:
        session.add(hero)
        session.commit()
        session.refresh(hero)
        return hero
    
    
    @app.get("/heroes/")
    def read_heroes(
        session: SessionDep,
        offset: int = 0,
        limit: Annotated[int, Query(le=100)] = 100,
    ) -> list[Hero]:
        heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
        return heroes
    
    
    @app.get("/heroes/{hero_id}")
    def read_hero(hero_id: int, session: SessionDep) -> Hero:
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        return hero
    
    
    @app.delete("/heroes/{hero_id}")
    def delete_hero(hero_id: int, session: SessionDep):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        session.delete(hero)
        session.commit()
        return {"ok": True}
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import Depends, FastAPI, HTTPException, Query
    from sqlmodel import Field, Session, SQLModel, create_engine, select
    
    
    class Hero(SQLModel, table=True):
        id: int | None = Field(default=None, primary_key=True)
        name: str = Field(index=True)
        age: int | None = Field(default=None, index=True)
        secret_name: str
    
    
    sqlite_file_name = "database.db"
    sqlite_url = f"sqlite:///{sqlite_file_name}"
    
    connect_args = {"check_same_thread": False}
    engine = create_engine(sqlite_url, connect_args=connect_args)
    
    
    def create_db_and_tables():
        SQLModel.metadata.create_all(engine)
    
    
    def get_session():
        with Session(engine) as session:
            yield session
    
    
    app = FastAPI()
    
    
    @app.on_event("startup")
    def on_startup():
        create_db_and_tables()
    
    
    @app.post("/heroes/")
    def create_hero(hero: Hero, session: Session = Depends(get_session)) -> Hero:
        session.add(hero)
        session.commit()
        session.refresh(hero)
        return hero
    
    
    @app.get("/heroes/")
    def read_heroes(
        session: Session = Depends(get_session),
        offset: int = 0,
        limit: int = Query(default=100, le=100),
    ) -> list[Hero]:
        heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
        return heroes
    
    
    @app.get("/heroes/{hero_id}")
    def read_hero(hero_id: int, session: Session = Depends(get_session)) -> Hero:
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        return hero
    
    
    @app.delete("/heroes/{hero_id}")
    def delete_hero(hero_id: int, session: Session = Depends(get_session)):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        session.delete(hero)
        session.commit()
        return {"ok": True}
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from typing import Union
    
    from fastapi import Depends, FastAPI, HTTPException, Query
    from sqlmodel import Field, Session, SQLModel, create_engine, select
    
    
    class Hero(SQLModel, table=True):
        id: Union[int, None] = Field(default=None, primary_key=True)
        name: str = Field(index=True)
        age: Union[int, None] = Field(default=None, index=True)
        secret_name: str
    
    
    sqlite_file_name = "database.db"
    sqlite_url = f"sqlite:///{sqlite_file_name}"
    
    connect_args = {"check_same_thread": False}
    engine = create_engine(sqlite_url, connect_args=connect_args)
    
    
    def create_db_and_tables():
        SQLModel.metadata.create_all(engine)
    
    
    def get_session():
        with Session(engine) as session:
            yield session
    
    
    app = FastAPI()
    
    
    @app.on_event("startup")
    def on_startup():
        create_db_and_tables()
    
    
    @app.post("/heroes/")
    def create_hero(hero: Hero, session: Session = Depends(get_session)) -> Hero:
        session.add(hero)
        session.commit()
        session.refresh(hero)
        return hero
    
    
    @app.get("/heroes/")
    def read_heroes(
        session: Session = Depends(get_session),
        offset: int = 0,
        limit: int = Query(default=100, le=100),
    ) -> list[Hero]:
        heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
        return heroes
    
    
    @app.get("/heroes/{hero_id}")
    def read_hero(hero_id: int, session: Session = Depends(get_session)) -> Hero:
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        return hero
    
    
    @app.delete("/heroes/{hero_id}")
    def delete_hero(hero_id: int, session: Session = Depends(get_session)):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        session.delete(hero)
        session.commit()
        return {"ok": True}
    

### Read One Hero[¶](#read-one-hero "Permanent link")

We can **read** a single `Hero`.

Python 3.10+
    
    
    # Code above omitted üëÜ
    
    @app.get("/heroes/{hero_id}")
    def read_hero(hero_id: int, session: SessionDep) -> Hero:
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        return hero
    
    # Code below omitted üëá
    

üëÄ Full file preview

Python 3.10+
    
    
    from typing import Annotated
    
    from fastapi import Depends, FastAPI, HTTPException, Query
    from sqlmodel import Field, Session, SQLModel, create_engine, select
    
    
    class Hero(SQLModel, table=True):
        id: int | None = Field(default=None, primary_key=True)
        name: str = Field(index=True)
        age: int | None = Field(default=None, index=True)
        secret_name: str
    
    
    sqlite_file_name = "database.db"
    sqlite_url = f"sqlite:///{sqlite_file_name}"
    
    connect_args = {"check_same_thread": False}
    engine = create_engine(sqlite_url, connect_args=connect_args)
    
    
    def create_db_and_tables():
        SQLModel.metadata.create_all(engine)
    
    
    def get_session():
        with Session(engine) as session:
            yield session
    
    
    SessionDep = Annotated[Session, Depends(get_session)]
    
    app = FastAPI()
    
    
    @app.on_event("startup")
    def on_startup():
        create_db_and_tables()
    
    
    @app.post("/heroes/")
    def create_hero(hero: Hero, session: SessionDep) -> Hero:
        session.add(hero)
        session.commit()
        session.refresh(hero)
        return hero
    
    
    @app.get("/heroes/")
    def read_heroes(
        session: SessionDep,
        offset: int = 0,
        limit: Annotated[int, Query(le=100)] = 100,
    ) -> list[Hero]:
        heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
        return heroes
    
    
    @app.get("/heroes/{hero_id}")
    def read_hero(hero_id: int, session: SessionDep) -> Hero:
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        return hero
    
    
    @app.delete("/heroes/{hero_id}")
    def delete_hero(hero_id: int, session: SessionDep):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        session.delete(hero)
        session.commit()
        return {"ok": True}
    

ü§ì Other versions and variants

Python 3.9+Python 3.10+ - non-AnnotatedPython 3.9+ - non-Annotated
    
    
    from typing import Annotated, Union
    
    from fastapi import Depends, FastAPI, HTTPException, Query
    from sqlmodel import Field, Session, SQLModel, create_engine, select
    
    
    class Hero(SQLModel, table=True):
        id: Union[int, None] = Field(default=None, primary_key=True)
        name: str = Field(index=True)
        age: Union[int, None] = Field(default=None, index=True)
        secret_name: str
    
    
    sqlite_file_name = "database.db"
    sqlite_url = f"sqlite:///{sqlite_file_name}"
    
    connect_args = {"check_same_thread": False}
    engine = create_engine(sqlite_url, connect_args=connect_args)
    
    
    def create_db_and_tables():
        SQLModel.metadata.create_all(engine)
    
    
    def get_session():
        with Session(engine) as session:
            yield session
    
    
    SessionDep = Annotated[Session, Depends(get_session)]
    
    app = FastAPI()
    
    
    @app.on_event("startup")
    def on_startup():
        create_db_and_tables()
    
    
    @app.post("/heroes/")
    def create_hero(hero: Hero, session: SessionDep) -> Hero:
        session.add(hero)
        session.commit()
        session.refresh(hero)
        return hero
    
    
    @app.get("/heroes/")
    def read_heroes(
        session: SessionDep,
        offset: int = 0,
        limit: Annotated[int, Query(le=100)] = 100,
    ) -> list[Hero]:
        heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
        return heroes
    
    
    @app.get("/heroes/{hero_id}")
    def read_hero(hero_id: int, session: SessionDep) -> Hero:
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        return hero
    
    
    @app.delete("/heroes/{hero_id}")
    def delete_hero(hero_id: int, session: SessionDep):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        session.delete(hero)
        session.commit()
        return {"ok": True}
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import Depends, FastAPI, HTTPException, Query
    from sqlmodel import Field, Session, SQLModel, create_engine, select
    
    
    class Hero(SQLModel, table=True):
        id: int | None = Field(default=None, primary_key=True)
        name: str = Field(index=True)
        age: int | None = Field(default=None, index=True)
        secret_name: str
    
    
    sqlite_file_name = "database.db"
    sqlite_url = f"sqlite:///{sqlite_file_name}"
    
    connect_args = {"check_same_thread": False}
    engine = create_engine(sqlite_url, connect_args=connect_args)
    
    
    def create_db_and_tables():
        SQLModel.metadata.create_all(engine)
    
    
    def get_session():
        with Session(engine) as session:
            yield session
    
    
    app = FastAPI()
    
    
    @app.on_event("startup")
    def on_startup():
        create_db_and_tables()
    
    
    @app.post("/heroes/")
    def create_hero(hero: Hero, session: Session = Depends(get_session)) -> Hero:
        session.add(hero)
        session.commit()
        session.refresh(hero)
        return hero
    
    
    @app.get("/heroes/")
    def read_heroes(
        session: Session = Depends(get_session),
        offset: int = 0,
        limit: int = Query(default=100, le=100),
    ) -> list[Hero]:
        heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
        return heroes
    
    
    @app.get("/heroes/{hero_id}")
    def read_hero(hero_id: int, session: Session = Depends(get_session)) -> Hero:
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        return hero
    
    
    @app.delete("/heroes/{hero_id}")
    def delete_hero(hero_id: int, session: Session = Depends(get_session)):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        session.delete(hero)
        session.commit()
        return {"ok": True}
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from typing import Union
    
    from fastapi import Depends, FastAPI, HTTPException, Query
    from sqlmodel import Field, Session, SQLModel, create_engine, select
    
    
    class Hero(SQLModel, table=True):
        id: Union[int, None] = Field(default=None, primary_key=True)
        name: str = Field(index=True)
        age: Union[int, None] = Field(default=None, index=True)
        secret_name: str
    
    
    sqlite_file_name = "database.db"
    sqlite_url = f"sqlite:///{sqlite_file_name}"
    
    connect_args = {"check_same_thread": False}
    engine = create_engine(sqlite_url, connect_args=connect_args)
    
    
    def create_db_and_tables():
        SQLModel.metadata.create_all(engine)
    
    
    def get_session():
        with Session(engine) as session:
            yield session
    
    
    app = FastAPI()
    
    
    @app.on_event("startup")
    def on_startup():
        create_db_and_tables()
    
    
    @app.post("/heroes/")
    def create_hero(hero: Hero, session: Session = Depends(get_session)) -> Hero:
        session.add(hero)
        session.commit()
        session.refresh(hero)
        return hero
    
    
    @app.get("/heroes/")
    def read_heroes(
        session: Session = Depends(get_session),
        offset: int = 0,
        limit: int = Query(default=100, le=100),
    ) -> list[Hero]:
        heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
        return heroes
    
    
    @app.get("/heroes/{hero_id}")
    def read_hero(hero_id: int, session: Session = Depends(get_session)) -> Hero:
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        return hero
    
    
    @app.delete("/heroes/{hero_id}")
    def delete_hero(hero_id: int, session: Session = Depends(get_session)):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        session.delete(hero)
        session.commit()
        return {"ok": True}
    

### Delete a Hero[¶](#delete-a-hero "Permanent link")

We can also **delete** a `Hero`.

Python 3.10+
    
    
    # Code above omitted üëÜ
    
    @app.delete("/heroes/{hero_id}")
    def delete_hero(hero_id: int, session: SessionDep):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        session.delete(hero)
        session.commit()
        return {"ok": True}
    

üëÄ Full file preview

Python 3.10+
    
    
    from typing import Annotated
    
    from fastapi import Depends, FastAPI, HTTPException, Query
    from sqlmodel import Field, Session, SQLModel, create_engine, select
    
    
    class Hero(SQLModel, table=True):
        id: int | None = Field(default=None, primary_key=True)
        name: str = Field(index=True)
        age: int | None = Field(default=None, index=True)
        secret_name: str
    
    
    sqlite_file_name = "database.db"
    sqlite_url = f"sqlite:///{sqlite_file_name}"
    
    connect_args = {"check_same_thread": False}
    engine = create_engine(sqlite_url, connect_args=connect_args)
    
    
    def create_db_and_tables():
        SQLModel.metadata.create_all(engine)
    
    
    def get_session():
        with Session(engine) as session:
            yield session
    
    
    SessionDep = Annotated[Session, Depends(get_session)]
    
    app = FastAPI()
    
    
    @app.on_event("startup")
    def on_startup():
        create_db_and_tables()
    
    
    @app.post("/heroes/")
    def create_hero(hero: Hero, session: SessionDep) -> Hero:
        session.add(hero)
        session.commit()
        session.refresh(hero)
        return hero
    
    
    @app.get("/heroes/")
    def read_heroes(
        session: SessionDep,
        offset: int = 0,
        limit: Annotated[int, Query(le=100)] = 100,
    ) -> list[Hero]:
        heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
        return heroes
    
    
    @app.get("/heroes/{hero_id}")
    def read_hero(hero_id: int, session: SessionDep) -> Hero:
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        return hero
    
    
    @app.delete("/heroes/{hero_id}")
    def delete_hero(hero_id: int, session: SessionDep):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        session.delete(hero)
        session.commit()
        return {"ok": True}
    

ü§ì Other versions and variants

Python 3.9+Python 3.10+ - non-AnnotatedPython 3.9+ - non-Annotated
    
    
    from typing import Annotated, Union
    
    from fastapi import Depends, FastAPI, HTTPException, Query
    from sqlmodel import Field, Session, SQLModel, create_engine, select
    
    
    class Hero(SQLModel, table=True):
        id: Union[int, None] = Field(default=None, primary_key=True)
        name: str = Field(index=True)
        age: Union[int, None] = Field(default=None, index=True)
        secret_name: str
    
    
    sqlite_file_name = "database.db"
    sqlite_url = f"sqlite:///{sqlite_file_name}"
    
    connect_args = {"check_same_thread": False}
    engine = create_engine(sqlite_url, connect_args=connect_args)
    
    
    def create_db_and_tables():
        SQLModel.metadata.create_all(engine)
    
    
    def get_session():
        with Session(engine) as session:
            yield session
    
    
    SessionDep = Annotated[Session, Depends(get_session)]
    
    app = FastAPI()
    
    
    @app.on_event("startup")
    def on_startup():
        create_db_and_tables()
    
    
    @app.post("/heroes/")
    def create_hero(hero: Hero, session: SessionDep) -> Hero:
        session.add(hero)
        session.commit()
        session.refresh(hero)
        return hero
    
    
    @app.get("/heroes/")
    def read_heroes(
        session: SessionDep,
        offset: int = 0,
        limit: Annotated[int, Query(le=100)] = 100,
    ) -> list[Hero]:
        heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
        return heroes
    
    
    @app.get("/heroes/{hero_id}")
    def read_hero(hero_id: int, session: SessionDep) -> Hero:
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        return hero
    
    
    @app.delete("/heroes/{hero_id}")
    def delete_hero(hero_id: int, session: SessionDep):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        session.delete(hero)
        session.commit()
        return {"ok": True}
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import Depends, FastAPI, HTTPException, Query
    from sqlmodel import Field, Session, SQLModel, create_engine, select
    
    
    class Hero(SQLModel, table=True):
        id: int | None = Field(default=None, primary_key=True)
        name: str = Field(index=True)
        age: int | None = Field(default=None, index=True)
        secret_name: str
    
    
    sqlite_file_name = "database.db"
    sqlite_url = f"sqlite:///{sqlite_file_name}"
    
    connect_args = {"check_same_thread": False}
    engine = create_engine(sqlite_url, connect_args=connect_args)
    
    
    def create_db_and_tables():
        SQLModel.metadata.create_all(engine)
    
    
    def get_session():
        with Session(engine) as session:
            yield session
    
    
    app = FastAPI()
    
    
    @app.on_event("startup")
    def on_startup():
        create_db_and_tables()
    
    
    @app.post("/heroes/")
    def create_hero(hero: Hero, session: Session = Depends(get_session)) -> Hero:
        session.add(hero)
        session.commit()
        session.refresh(hero)
        return hero
    
    
    @app.get("/heroes/")
    def read_heroes(
        session: Session = Depends(get_session),
        offset: int = 0,
        limit: int = Query(default=100, le=100),
    ) -> list[Hero]:
        heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
        return heroes
    
    
    @app.get("/heroes/{hero_id}")
    def read_hero(hero_id: int, session: Session = Depends(get_session)) -> Hero:
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        return hero
    
    
    @app.delete("/heroes/{hero_id}")
    def delete_hero(hero_id: int, session: Session = Depends(get_session)):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        session.delete(hero)
        session.commit()
        return {"ok": True}
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from typing import Union
    
    from fastapi import Depends, FastAPI, HTTPException, Query
    from sqlmodel import Field, Session, SQLModel, create_engine, select
    
    
    class Hero(SQLModel, table=True):
        id: Union[int, None] = Field(default=None, primary_key=True)
        name: str = Field(index=True)
        age: Union[int, None] = Field(default=None, index=True)
        secret_name: str
    
    
    sqlite_file_name = "database.db"
    sqlite_url = f"sqlite:///{sqlite_file_name}"
    
    connect_args = {"check_same_thread": False}
    engine = create_engine(sqlite_url, connect_args=connect_args)
    
    
    def create_db_and_tables():
        SQLModel.metadata.create_all(engine)
    
    
    def get_session():
        with Session(engine) as session:
            yield session
    
    
    app = FastAPI()
    
    
    @app.on_event("startup")
    def on_startup():
        create_db_and_tables()
    
    
    @app.post("/heroes/")
    def create_hero(hero: Hero, session: Session = Depends(get_session)) -> Hero:
        session.add(hero)
        session.commit()
        session.refresh(hero)
        return hero
    
    
    @app.get("/heroes/")
    def read_heroes(
        session: Session = Depends(get_session),
        offset: int = 0,
        limit: int = Query(default=100, le=100),
    ) -> list[Hero]:
        heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
        return heroes
    
    
    @app.get("/heroes/{hero_id}")
    def read_hero(hero_id: int, session: Session = Depends(get_session)) -> Hero:
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        return hero
    
    
    @app.delete("/heroes/{hero_id}")
    def delete_hero(hero_id: int, session: Session = Depends(get_session)):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        session.delete(hero)
        session.commit()
        return {"ok": True}
    

### Run the App[¶](#run-the-app "Permanent link")

You can run the app:
    
    
    $ fastapi dev main.py
    
    <span style="color: green;">INFO</span>:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
    

Then go to the `/docs` UI, you will see that **FastAPI** is using these **models** to **document** the API, and it will use them to **serialize** and **validate** the data too.

![](/img/tutorial/sql-databases/image01.png)

## Update the App with Multiple Models[¶](#update-the-app-with-multiple-models "Permanent link")

Now let's **refactor** this app a bit to increase **security** and **versatility**.

If you check the previous app, in the UI you can see that, up to now, it lets the client decide the `id` of the `Hero` to create. üò±

We shouldn't let that happen, they could overwrite an `id` we already have assigned in the DB. Deciding the `id` should be done by the **backend** or the **database** , **not by the client**.

Additionally, we create a `secret_name` for the hero, but so far, we are returning it everywhere, that's not very **secret**... üòÖ

We'll fix these things by adding a few **extra models**. Here's where SQLModel will shine. ‚ú®

### Create Multiple Models[¶](#create-multiple-models "Permanent link")

In **SQLModel** , any model class that has `table=True` is a **table model**.

And any model class that doesn't have `table=True` is a **data model** , these ones are actually just Pydantic models (with a couple of small extra features). ü§ì

With SQLModel, we can use **inheritance** to **avoid duplicating** all the fields in all the cases.

#### `HeroBase` \- the base class[¶](#herobase-the-base-class "Permanent link")

Let's start with a `HeroBase` model that has all the **fields that are shared** by all the models:

  * `name`
  * `age`

Python 3.10+
    
    
    # Code above omitted üëÜ
    
    class HeroBase(SQLModel):
        name: str = Field(index=True)
        age: int | None = Field(default=None, index=True)
    
    # Code below omitted üëá
    

üëÄ Full file preview

Python 3.10+
    
    
    from typing import Annotated
    
    from fastapi import Depends, FastAPI, HTTPException, Query
    from sqlmodel import Field, Session, SQLModel, create_engine, select
    
    
    class HeroBase(SQLModel):
        name: str = Field(index=True)
        age: int | None = Field(default=None, index=True)
    
    
    class Hero(HeroBase, table=True):
        id: int | None = Field(default=None, primary_key=True)
        secret_name: str
    
    
    class HeroPublic(HeroBase):
        id: int
    
    
    class HeroCreate(HeroBase):
        secret_name: str
    
    
    class HeroUpdate(HeroBase):
        name: str | None = None
        age: int | None = None
        secret_name: str | None = None
    
    
    sqlite_file_name = "database.db"
    sqlite_url = f"sqlite:///{sqlite_file_name}"
    
    connect_args = {"check_same_thread": False}
    engine = create_engine(sqlite_url, connect_args=connect_args)
    
    
    def create_db_and_tables():
        SQLModel.metadata.create_all(engine)
    
    
    def get_session():
        with Session(engine) as session:
            yield session
    
    
    SessionDep = Annotated[Session, Depends(get_session)]
    app = FastAPI()
    
    
    @app.on_event("startup")
    def on_startup():
        create_db_and_tables()
    
    
    @app.post("/heroes/", response_model=HeroPublic)
    def create_hero(hero: HeroCreate, session: SessionDep):
        db_hero = Hero.model_validate(hero)
        session.add(db_hero)
        session.commit()
        session.refresh(db_hero)
        return db_hero
    
    
    @app.get("/heroes/", response_model=list[HeroPublic])
    def read_heroes(
        session: SessionDep,
        offset: int = 0,
        limit: Annotated[int, Query(le=100)] = 100,
    ):
        heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
        return heroes
    
    
    @app.get("/heroes/{hero_id}", response_model=HeroPublic)
    def read_hero(hero_id: int, session: SessionDep):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        return hero
    
    
    @app.patch("/heroes/{hero_id}", response_model=HeroPublic)
    def update_hero(hero_id: int, hero: HeroUpdate, session: SessionDep):
        hero_db = session.get(Hero, hero_id)
        if not hero_db:
            raise HTTPException(status_code=404, detail="Hero not found")
        hero_data = hero.model_dump(exclude_unset=True)
        hero_db.sqlmodel_update(hero_data)
        session.add(hero_db)
        session.commit()
        session.refresh(hero_db)
        return hero_db
    
    
    @app.delete("/heroes/{hero_id}")
    def delete_hero(hero_id: int, session: SessionDep):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        session.delete(hero)
        session.commit()
        return {"ok": True}
    

ü§ì Other versions and variants

Python 3.9+Python 3.10+ - non-AnnotatedPython 3.9+ - non-Annotated
    
    
    from typing import Annotated, Union
    
    from fastapi import Depends, FastAPI, HTTPException, Query
    from sqlmodel import Field, Session, SQLModel, create_engine, select
    
    
    class HeroBase(SQLModel):
        name: str = Field(index=True)
        age: Union[int, None] = Field(default=None, index=True)
    
    
    class Hero(HeroBase, table=True):
        id: Union[int, None] = Field(default=None, primary_key=True)
        secret_name: str
    
    
    class HeroPublic(HeroBase):
        id: int
    
    
    class HeroCreate(HeroBase):
        secret_name: str
    
    
    class HeroUpdate(HeroBase):
        name: Union[str, None] = None
        age: Union[int, None] = None
        secret_name: Union[str, None] = None
    
    
    sqlite_file_name = "database.db"
    sqlite_url = f"sqlite:///{sqlite_file_name}"
    
    connect_args = {"check_same_thread": False}
    engine = create_engine(sqlite_url, connect_args=connect_args)
    
    
    def create_db_and_tables():
        SQLModel.metadata.create_all(engine)
    
    
    def get_session():
        with Session(engine) as session:
            yield session
    
    
    SessionDep = Annotated[Session, Depends(get_session)]
    app = FastAPI()
    
    
    @app.on_event("startup")
    def on_startup():
        create_db_and_tables()
    
    
    @app.post("/heroes/", response_model=HeroPublic)
    def create_hero(hero: HeroCreate, session: SessionDep):
        db_hero = Hero.model_validate(hero)
        session.add(db_hero)
        session.commit()
        session.refresh(db_hero)
        return db_hero
    
    
    @app.get("/heroes/", response_model=list[HeroPublic])
    def read_heroes(
        session: SessionDep,
        offset: int = 0,
        limit: Annotated[int, Query(le=100)] = 100,
    ):
        heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
        return heroes
    
    
    @app.get("/heroes/{hero_id}", response_model=HeroPublic)
    def read_hero(hero_id: int, session: SessionDep):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        return hero
    
    
    @app.patch("/heroes/{hero_id}", response_model=HeroPublic)
    def update_hero(hero_id: int, hero: HeroUpdate, session: SessionDep):
        hero_db = session.get(Hero, hero_id)
        if not hero_db:
            raise HTTPException(status_code=404, detail="Hero not found")
        hero_data = hero.model_dump(exclude_unset=True)
        hero_db.sqlmodel_update(hero_data)
        session.add(hero_db)
        session.commit()
        session.refresh(hero_db)
        return hero_db
    
    
    @app.delete("/heroes/{hero_id}")
    def delete_hero(hero_id: int, session: SessionDep):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        session.delete(hero)
        session.commit()
        return {"ok": True}
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import Depends, FastAPI, HTTPException, Query
    from sqlmodel import Field, Session, SQLModel, create_engine, select
    
    
    class HeroBase(SQLModel):
        name: str = Field(index=True)
        age: int | None = Field(default=None, index=True)
    
    
    class Hero(HeroBase, table=True):
        id: int | None = Field(default=None, primary_key=True)
        secret_name: str
    
    
    class HeroPublic(HeroBase):
        id: int
    
    
    class HeroCreate(HeroBase):
        secret_name: str
    
    
    class HeroUpdate(HeroBase):
        name: str | None = None
        age: int | None = None
        secret_name: str | None = None
    
    
    sqlite_file_name = "database.db"
    sqlite_url = f"sqlite:///{sqlite_file_name}"
    
    connect_args = {"check_same_thread": False}
    engine = create_engine(sqlite_url, connect_args=connect_args)
    
    
    def create_db_and_tables():
        SQLModel.metadata.create_all(engine)
    
    
    def get_session():
        with Session(engine) as session:
            yield session
    
    
    app = FastAPI()
    
    
    @app.on_event("startup")
    def on_startup():
        create_db_and_tables()
    
    
    @app.post("/heroes/", response_model=HeroPublic)
    def create_hero(hero: HeroCreate, session: Session = Depends(get_session)):
        db_hero = Hero.model_validate(hero)
        session.add(db_hero)
        session.commit()
        session.refresh(db_hero)
        return db_hero
    
    
    @app.get("/heroes/", response_model=list[HeroPublic])
    def read_heroes(
        session: Session = Depends(get_session),
        offset: int = 0,
        limit: int = Query(default=100, le=100),
    ):
        heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
        return heroes
    
    
    @app.get("/heroes/{hero_id}", response_model=HeroPublic)
    def read_hero(hero_id: int, session: Session = Depends(get_session)):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        return hero
    
    
    @app.patch("/heroes/{hero_id}", response_model=HeroPublic)
    def update_hero(
        hero_id: int, hero: HeroUpdate, session: Session = Depends(get_session)
    ):
        hero_db = session.get(Hero, hero_id)
        if not hero_db:
            raise HTTPException(status_code=404, detail="Hero not found")
        hero_data = hero.model_dump(exclude_unset=True)
        hero_db.sqlmodel_update(hero_data)
        session.add(hero_db)
        session.commit()
        session.refresh(hero_db)
        return hero_db
    
    
    @app.delete("/heroes/{hero_id}")
    def delete_hero(hero_id: int, session: Session = Depends(get_session)):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        session.delete(hero)
        session.commit()
        return {"ok": True}
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from typing import Union
    
    from fastapi import Depends, FastAPI, HTTPException, Query
    from sqlmodel import Field, Session, SQLModel, create_engine, select
    
    
    class HeroBase(SQLModel):
        name: str = Field(index=True)
        age: Union[int, None] = Field(default=None, index=True)
    
    
    class Hero(HeroBase, table=True):
        id: Union[int, None] = Field(default=None, primary_key=True)
        secret_name: str
    
    
    class HeroPublic(HeroBase):
        id: int
    
    
    class HeroCreate(HeroBase):
        secret_name: str
    
    
    class HeroUpdate(HeroBase):
        name: Union[str, None] = None
        age: Union[int, None] = None
        secret_name: Union[str, None] = None
    
    
    sqlite_file_name = "database.db"
    sqlite_url = f"sqlite:///{sqlite_file_name}"
    
    connect_args = {"check_same_thread": False}
    engine = create_engine(sqlite_url, connect_args=connect_args)
    
    
    def create_db_and_tables():
        SQLModel.metadata.create_all(engine)
    
    
    def get_session():
        with Session(engine) as session:
            yield session
    
    
    app = FastAPI()
    
    
    @app.on_event("startup")
    def on_startup():
        create_db_and_tables()
    
    
    @app.post("/heroes/", response_model=HeroPublic)
    def create_hero(hero: HeroCreate, session: Session = Depends(get_session)):
        db_hero = Hero.model_validate(hero)
        session.add(db_hero)
        session.commit()
        session.refresh(db_hero)
        return db_hero
    
    
    @app.get("/heroes/", response_model=list[HeroPublic])
    def read_heroes(
        session: Session = Depends(get_session),
        offset: int = 0,
        limit: int = Query(default=100, le=100),
    ):
        heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
        return heroes
    
    
    @app.get("/heroes/{hero_id}", response_model=HeroPublic)
    def read_hero(hero_id: int, session: Session = Depends(get_session)):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        return hero
    
    
    @app.patch("/heroes/{hero_id}", response_model=HeroPublic)
    def update_hero(
        hero_id: int, hero: HeroUpdate, session: Session = Depends(get_session)
    ):
        hero_db = session.get(Hero, hero_id)
        if not hero_db:
            raise HTTPException(status_code=404, detail="Hero not found")
        hero_data = hero.model_dump(exclude_unset=True)
        hero_db.sqlmodel_update(hero_data)
        session.add(hero_db)
        session.commit()
        session.refresh(hero_db)
        return hero_db
    
    
    @app.delete("/heroes/{hero_id}")
    def delete_hero(hero_id: int, session: Session = Depends(get_session)):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        session.delete(hero)
        session.commit()
        return {"ok": True}
    

#### `Hero` \- the _table model_[¶](#hero-the-table-model "Permanent link")

Then let's create `Hero`, the actual _table model_ , with the **extra fields** that are not always in the other models:

  * `id`
  * `secret_name`

Because `Hero` inherits form `HeroBase`, it **also** has the **fields** declared in `HeroBase`, so all the fields for `Hero` are:

  * `id`
  * `name`
  * `age`
  * `secret_name`

Python 3.10+
    
    
    # Code above omitted üëÜ
    
    class HeroBase(SQLModel):
        name: str = Field(index=True)
        age: int | None = Field(default=None, index=True)
    
    
    class Hero(HeroBase, table=True):
        id: int | None = Field(default=None, primary_key=True)
        secret_name: str
    
    # Code below omitted üëá
    

üëÄ Full file preview

Python 3.10+
    
    
    from typing import Annotated
    
    from fastapi import Depends, FastAPI, HTTPException, Query
    from sqlmodel import Field, Session, SQLModel, create_engine, select
    
    
    class HeroBase(SQLModel):
        name: str = Field(index=True)
        age: int | None = Field(default=None, index=True)
    
    
    class Hero(HeroBase, table=True):
        id: int | None = Field(default=None, primary_key=True)
        secret_name: str
    
    
    class HeroPublic(HeroBase):
        id: int
    
    
    class HeroCreate(HeroBase):
        secret_name: str
    
    
    class HeroUpdate(HeroBase):
        name: str | None = None
        age: int | None = None
        secret_name: str | None = None
    
    
    sqlite_file_name = "database.db"
    sqlite_url = f"sqlite:///{sqlite_file_name}"
    
    connect_args = {"check_same_thread": False}
    engine = create_engine(sqlite_url, connect_args=connect_args)
    
    
    def create_db_and_tables():
        SQLModel.metadata.create_all(engine)
    
    
    def get_session():
        with Session(engine) as session:
            yield session
    
    
    SessionDep = Annotated[Session, Depends(get_session)]
    app = FastAPI()
    
    
    @app.on_event("startup")
    def on_startup():
        create_db_and_tables()
    
    
    @app.post("/heroes/", response_model=HeroPublic)
    def create_hero(hero: HeroCreate, session: SessionDep):
        db_hero = Hero.model_validate(hero)
        session.add(db_hero)
        session.commit()
        session.refresh(db_hero)
        return db_hero
    
    
    @app.get("/heroes/", response_model=list[HeroPublic])
    def read_heroes(
        session: SessionDep,
        offset: int = 0,
        limit: Annotated[int, Query(le=100)] = 100,
    ):
        heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
        return heroes
    
    
    @app.get("/heroes/{hero_id}", response_model=HeroPublic)
    def read_hero(hero_id: int, session: SessionDep):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        return hero
    
    
    @app.patch("/heroes/{hero_id}", response_model=HeroPublic)
    def update_hero(hero_id: int, hero: HeroUpdate, session: SessionDep):
        hero_db = session.get(Hero, hero_id)
        if not hero_db:
            raise HTTPException(status_code=404, detail="Hero not found")
        hero_data = hero.model_dump(exclude_unset=True)
        hero_db.sqlmodel_update(hero_data)
        session.add(hero_db)
        session.commit()
        session.refresh(hero_db)
        return hero_db
    
    
    @app.delete("/heroes/{hero_id}")
    def delete_hero(hero_id: int, session: SessionDep):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        session.delete(hero)
        session.commit()
        return {"ok": True}
    

ü§ì Other versions and variants

Python 3.9+Python 3.10+ - non-AnnotatedPython 3.9+ - non-Annotated
    
    
    from typing import Annotated, Union
    
    from fastapi import Depends, FastAPI, HTTPException, Query
    from sqlmodel import Field, Session, SQLModel, create_engine, select
    
    
    class HeroBase(SQLModel):
        name: str = Field(index=True)
        age: Union[int, None] = Field(default=None, index=True)
    
    
    class Hero(HeroBase, table=True):
        id: Union[int, None] = Field(default=None, primary_key=True)
        secret_name: str
    
    
    class HeroPublic(HeroBase):
        id: int
    
    
    class HeroCreate(HeroBase):
        secret_name: str
    
    
    class HeroUpdate(HeroBase):
        name: Union[str, None] = None
        age: Union[int, None] = None
        secret_name: Union[str, None] = None
    
    
    sqlite_file_name = "database.db"
    sqlite_url = f"sqlite:///{sqlite_file_name}"
    
    connect_args = {"check_same_thread": False}
    engine = create_engine(sqlite_url, connect_args=connect_args)
    
    
    def create_db_and_tables():
        SQLModel.metadata.create_all(engine)
    
    
    def get_session():
        with Session(engine) as session:
            yield session
    
    
    SessionDep = Annotated[Session, Depends(get_session)]
    app = FastAPI()
    
    
    @app.on_event("startup")
    def on_startup():
        create_db_and_tables()
    
    
    @app.post("/heroes/", response_model=HeroPublic)
    def create_hero(hero: HeroCreate, session: SessionDep):
        db_hero = Hero.model_validate(hero)
        session.add(db_hero)
        session.commit()
        session.refresh(db_hero)
        return db_hero
    
    
    @app.get("/heroes/", response_model=list[HeroPublic])
    def read_heroes(
        session: SessionDep,
        offset: int = 0,
        limit: Annotated[int, Query(le=100)] = 100,
    ):
        heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
        return heroes
    
    
    @app.get("/heroes/{hero_id}", response_model=HeroPublic)
    def read_hero(hero_id: int, session: SessionDep):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        return hero
    
    
    @app.patch("/heroes/{hero_id}", response_model=HeroPublic)
    def update_hero(hero_id: int, hero: HeroUpdate, session: SessionDep):
        hero_db = session.get(Hero, hero_id)
        if not hero_db:
            raise HTTPException(status_code=404, detail="Hero not found")
        hero_data = hero.model_dump(exclude_unset=True)
        hero_db.sqlmodel_update(hero_data)
        session.add(hero_db)
        session.commit()
        session.refresh(hero_db)
        return hero_db
    
    
    @app.delete("/heroes/{hero_id}")
    def delete_hero(hero_id: int, session: SessionDep):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        session.delete(hero)
        session.commit()
        return {"ok": True}
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import Depends, FastAPI, HTTPException, Query
    from sqlmodel import Field, Session, SQLModel, create_engine, select
    
    
    class HeroBase(SQLModel):
        name: str = Field(index=True)
        age: int | None = Field(default=None, index=True)
    
    
    class Hero(HeroBase, table=True):
        id: int | None = Field(default=None, primary_key=True)
        secret_name: str
    
    
    class HeroPublic(HeroBase):
        id: int
    
    
    class HeroCreate(HeroBase):
        secret_name: str
    
    
    class HeroUpdate(HeroBase):
        name: str | None = None
        age: int | None = None
        secret_name: str | None = None
    
    
    sqlite_file_name = "database.db"
    sqlite_url = f"sqlite:///{sqlite_file_name}"
    
    connect_args = {"check_same_thread": False}
    engine = create_engine(sqlite_url, connect_args=connect_args)
    
    
    def create_db_and_tables():
        SQLModel.metadata.create_all(engine)
    
    
    def get_session():
        with Session(engine) as session:
            yield session
    
    
    app = FastAPI()
    
    
    @app.on_event("startup")
    def on_startup():
        create_db_and_tables()
    
    
    @app.post("/heroes/", response_model=HeroPublic)
    def create_hero(hero: HeroCreate, session: Session = Depends(get_session)):
        db_hero = Hero.model_validate(hero)
        session.add(db_hero)
        session.commit()
        session.refresh(db_hero)
        return db_hero
    
    
    @app.get("/heroes/", response_model=list[HeroPublic])
    def read_heroes(
        session: Session = Depends(get_session),
        offset: int = 0,
        limit: int = Query(default=100, le=100),
    ):
        heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
        return heroes
    
    
    @app.get("/heroes/{hero_id}", response_model=HeroPublic)
    def read_hero(hero_id: int, session: Session = Depends(get_session)):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        return hero
    
    
    @app.patch("/heroes/{hero_id}", response_model=HeroPublic)
    def update_hero(
        hero_id: int, hero: HeroUpdate, session: Session = Depends(get_session)
    ):
        hero_db = session.get(Hero, hero_id)
        if not hero_db:
            raise HTTPException(status_code=404, detail="Hero not found")
        hero_data = hero.model_dump(exclude_unset=True)
        hero_db.sqlmodel_update(hero_data)
        session.add(hero_db)
        session.commit()
        session.refresh(hero_db)
        return hero_db
    
    
    @app.delete("/heroes/{hero_id}")
    def delete_hero(hero_id: int, session: Session = Depends(get_session)):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        session.delete(hero)
        session.commit()
        return {"ok": True}
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from typing import Union
    
    from fastapi import Depends, FastAPI, HTTPException, Query
    from sqlmodel import Field, Session, SQLModel, create_engine, select
    
    
    class HeroBase(SQLModel):
        name: str = Field(index=True)
        age: Union[int, None] = Field(default=None, index=True)
    
    
    class Hero(HeroBase, table=True):
        id: Union[int, None] = Field(default=None, primary_key=True)
        secret_name: str
    
    
    class HeroPublic(HeroBase):
        id: int
    
    
    class HeroCreate(HeroBase):
        secret_name: str
    
    
    class HeroUpdate(HeroBase):
        name: Union[str, None] = None
        age: Union[int, None] = None
        secret_name: Union[str, None] = None
    
    
    sqlite_file_name = "database.db"
    sqlite_url = f"sqlite:///{sqlite_file_name}"
    
    connect_args = {"check_same_thread": False}
    engine = create_engine(sqlite_url, connect_args=connect_args)
    
    
    def create_db_and_tables():
        SQLModel.metadata.create_all(engine)
    
    
    def get_session():
        with Session(engine) as session:
            yield session
    
    
    app = FastAPI()
    
    
    @app.on_event("startup")
    def on_startup():
        create_db_and_tables()
    
    
    @app.post("/heroes/", response_model=HeroPublic)
    def create_hero(hero: HeroCreate, session: Session = Depends(get_session)):
        db_hero = Hero.model_validate(hero)
        session.add(db_hero)
        session.commit()
        session.refresh(db_hero)
        return db_hero
    
    
    @app.get("/heroes/", response_model=list[HeroPublic])
    def read_heroes(
        session: Session = Depends(get_session),
        offset: int = 0,
        limit: int = Query(default=100, le=100),
    ):
        heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
        return heroes
    
    
    @app.get("/heroes/{hero_id}", response_model=HeroPublic)
    def read_hero(hero_id: int, session: Session = Depends(get_session)):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        return hero
    
    
    @app.patch("/heroes/{hero_id}", response_model=HeroPublic)
    def update_hero(
        hero_id: int, hero: HeroUpdate, session: Session = Depends(get_session)
    ):
        hero_db = session.get(Hero, hero_id)
        if not hero_db:
            raise HTTPException(status_code=404, detail="Hero not found")
        hero_data = hero.model_dump(exclude_unset=True)
        hero_db.sqlmodel_update(hero_data)
        session.add(hero_db)
        session.commit()
        session.refresh(hero_db)
        return hero_db
    
    
    @app.delete("/heroes/{hero_id}")
    def delete_hero(hero_id: int, session: Session = Depends(get_session)):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        session.delete(hero)
        session.commit()
        return {"ok": True}
    

#### `HeroPublic` \- the public _data model_[¶](#heropublic-the-public-data-model "Permanent link")

Next, we create a `HeroPublic` model, this is the one that will be **returned** to the clients of the API.

It has the same fields as `HeroBase`, so it won't include `secret_name`.

Finally, the identity of our heroes is protected! ü•∑

It also re-declares `id: int`. By doing this, we are making a **contract** with the API clients, so that they can always expect the `id` to be there and to be an `int` (it will never be `None`).

Tip

Having the return model ensure that a value is always available and always `int` (not `None`) is very useful for the API clients, they can write much simpler code having this certainty.

Also, **automatically generated clients** will have simpler interfaces, so that the developers communicating with your API can have a much better time working with your API. üòé

All the fields in `HeroPublic` are the same as in `HeroBase`, with `id` declared as `int` (not `None`):

  * `id`
  * `name`
  * `age`

Python 3.10+
    
    
    # Code above omitted üëÜ
    
    class HeroBase(SQLModel):
        name: str = Field(index=True)
        age: int | None = Field(default=None, index=True)
    
    
    class Hero(HeroBase, table=True):
        id: int | None = Field(default=None, primary_key=True)
        secret_name: str
    
    
    class HeroPublic(HeroBase):
        id: int
    
    # Code below omitted üëá
    

üëÄ Full file preview

Python 3.10+
    
    
    from typing import Annotated
    
    from fastapi import Depends, FastAPI, HTTPException, Query
    from sqlmodel import Field, Session, SQLModel, create_engine, select
    
    
    class HeroBase(SQLModel):
        name: str = Field(index=True)
        age: int | None = Field(default=None, index=True)
    
    
    class Hero(HeroBase, table=True):
        id: int | None = Field(default=None, primary_key=True)
        secret_name: str
    
    
    class HeroPublic(HeroBase):
        id: int
    
    
    class HeroCreate(HeroBase):
        secret_name: str
    
    
    class HeroUpdate(HeroBase):
        name: str | None = None
        age: int | None = None
        secret_name: str | None = None
    
    
    sqlite_file_name = "database.db"
    sqlite_url = f"sqlite:///{sqlite_file_name}"
    
    connect_args = {"check_same_thread": False}
    engine = create_engine(sqlite_url, connect_args=connect_args)
    
    
    def create_db_and_tables():
        SQLModel.metadata.create_all(engine)
    
    
    def get_session():
        with Session(engine) as session:
            yield session
    
    
    SessionDep = Annotated[Session, Depends(get_session)]
    app = FastAPI()
    
    
    @app.on_event("startup")
    def on_startup():
        create_db_and_tables()
    
    
    @app.post("/heroes/", response_model=HeroPublic)
    def create_hero(hero: HeroCreate, session: SessionDep):
        db_hero = Hero.model_validate(hero)
        session.add(db_hero)
        session.commit()
        session.refresh(db_hero)
        return db_hero
    
    
    @app.get("/heroes/", response_model=list[HeroPublic])
    def read_heroes(
        session: SessionDep,
        offset: int = 0,
        limit: Annotated[int, Query(le=100)] = 100,
    ):
        heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
        return heroes
    
    
    @app.get("/heroes/{hero_id}", response_model=HeroPublic)
    def read_hero(hero_id: int, session: SessionDep):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        return hero
    
    
    @app.patch("/heroes/{hero_id}", response_model=HeroPublic)
    def update_hero(hero_id: int, hero: HeroUpdate, session: SessionDep):
        hero_db = session.get(Hero, hero_id)
        if not hero_db:
            raise HTTPException(status_code=404, detail="Hero not found")
        hero_data = hero.model_dump(exclude_unset=True)
        hero_db.sqlmodel_update(hero_data)
        session.add(hero_db)
        session.commit()
        session.refresh(hero_db)
        return hero_db
    
    
    @app.delete("/heroes/{hero_id}")
    def delete_hero(hero_id: int, session: SessionDep):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        session.delete(hero)
        session.commit()
        return {"ok": True}
    

ü§ì Other versions and variants

Python 3.9+Python 3.10+ - non-AnnotatedPython 3.9+ - non-Annotated
    
    
    from typing import Annotated, Union
    
    from fastapi import Depends, FastAPI, HTTPException, Query
    from sqlmodel import Field, Session, SQLModel, create_engine, select
    
    
    class HeroBase(SQLModel):
        name: str = Field(index=True)
        age: Union[int, None] = Field(default=None, index=True)
    
    
    class Hero(HeroBase, table=True):
        id: Union[int, None] = Field(default=None, primary_key=True)
        secret_name: str
    
    
    class HeroPublic(HeroBase):
        id: int
    
    
    class HeroCreate(HeroBase):
        secret_name: str
    
    
    class HeroUpdate(HeroBase):
        name: Union[str, None] = None
        age: Union[int, None] = None
        secret_name: Union[str, None] = None
    
    
    sqlite_file_name = "database.db"
    sqlite_url = f"sqlite:///{sqlite_file_name}"
    
    connect_args = {"check_same_thread": False}
    engine = create_engine(sqlite_url, connect_args=connect_args)
    
    
    def create_db_and_tables():
        SQLModel.metadata.create_all(engine)
    
    
    def get_session():
        with Session(engine) as session:
            yield session
    
    
    SessionDep = Annotated[Session, Depends(get_session)]
    app = FastAPI()
    
    
    @app.on_event("startup")
    def on_startup():
        create_db_and_tables()
    
    
    @app.post("/heroes/", response_model=HeroPublic)
    def create_hero(hero: HeroCreate, session: SessionDep):
        db_hero = Hero.model_validate(hero)
        session.add(db_hero)
        session.commit()
        session.refresh(db_hero)
        return db_hero
    
    
    @app.get("/heroes/", response_model=list[HeroPublic])
    def read_heroes(
        session: SessionDep,
        offset: int = 0,
        limit: Annotated[int, Query(le=100)] = 100,
    ):
        heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
        return heroes
    
    
    @app.get("/heroes/{hero_id}", response_model=HeroPublic)
    def read_hero(hero_id: int, session: SessionDep):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        return hero
    
    
    @app.patch("/heroes/{hero_id}", response_model=HeroPublic)
    def update_hero(hero_id: int, hero: HeroUpdate, session: SessionDep):
        hero_db = session.get(Hero, hero_id)
        if not hero_db:
            raise HTTPException(status_code=404, detail="Hero not found")
        hero_data = hero.model_dump(exclude_unset=True)
        hero_db.sqlmodel_update(hero_data)
        session.add(hero_db)
        session.commit()
        session.refresh(hero_db)
        return hero_db
    
    
    @app.delete("/heroes/{hero_id}")
    def delete_hero(hero_id: int, session: SessionDep):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        session.delete(hero)
        session.commit()
        return {"ok": True}
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import Depends, FastAPI, HTTPException, Query
    from sqlmodel import Field, Session, SQLModel, create_engine, select
    
    
    class HeroBase(SQLModel):
        name: str = Field(index=True)
        age: int | None = Field(default=None, index=True)
    
    
    class Hero(HeroBase, table=True):
        id: int | None = Field(default=None, primary_key=True)
        secret_name: str
    
    
    class HeroPublic(HeroBase):
        id: int
    
    
    class HeroCreate(HeroBase):
        secret_name: str
    
    
    class HeroUpdate(HeroBase):
        name: str | None = None
        age: int | None = None
        secret_name: str | None = None
    
    
    sqlite_file_name = "database.db"
    sqlite_url = f"sqlite:///{sqlite_file_name}"
    
    connect_args = {"check_same_thread": False}
    engine = create_engine(sqlite_url, connect_args=connect_args)
    
    
    def create_db_and_tables():
        SQLModel.metadata.create_all(engine)
    
    
    def get_session():
        with Session(engine) as session:
            yield session
    
    
    app = FastAPI()
    
    
    @app.on_event("startup")
    def on_startup():
        create_db_and_tables()
    
    
    @app.post("/heroes/", response_model=HeroPublic)
    def create_hero(hero: HeroCreate, session: Session = Depends(get_session)):
        db_hero = Hero.model_validate(hero)
        session.add(db_hero)
        session.commit()
        session.refresh(db_hero)
        return db_hero
    
    
    @app.get("/heroes/", response_model=list[HeroPublic])
    def read_heroes(
        session: Session = Depends(get_session),
        offset: int = 0,
        limit: int = Query(default=100, le=100),
    ):
        heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
        return heroes
    
    
    @app.get("/heroes/{hero_id}", response_model=HeroPublic)
    def read_hero(hero_id: int, session: Session = Depends(get_session)):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        return hero
    
    
    @app.patch("/heroes/{hero_id}", response_model=HeroPublic)
    def update_hero(
        hero_id: int, hero: HeroUpdate, session: Session = Depends(get_session)
    ):
        hero_db = session.get(Hero, hero_id)
        if not hero_db:
            raise HTTPException(status_code=404, detail="Hero not found")
        hero_data = hero.model_dump(exclude_unset=True)
        hero_db.sqlmodel_update(hero_data)
        session.add(hero_db)
        session.commit()
        session.refresh(hero_db)
        return hero_db
    
    
    @app.delete("/heroes/{hero_id}")
    def delete_hero(hero_id: int, session: Session = Depends(get_session)):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        session.delete(hero)
        session.commit()
        return {"ok": True}
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from typing import Union
    
    from fastapi import Depends, FastAPI, HTTPException, Query
    from sqlmodel import Field, Session, SQLModel, create_engine, select
    
    
    class HeroBase(SQLModel):
        name: str = Field(index=True)
        age: Union[int, None] = Field(default=None, index=True)
    
    
    class Hero(HeroBase, table=True):
        id: Union[int, None] = Field(default=None, primary_key=True)
        secret_name: str
    
    
    class HeroPublic(HeroBase):
        id: int
    
    
    class HeroCreate(HeroBase):
        secret_name: str
    
    
    class HeroUpdate(HeroBase):
        name: Union[str, None] = None
        age: Union[int, None] = None
        secret_name: Union[str, None] = None
    
    
    sqlite_file_name = "database.db"
    sqlite_url = f"sqlite:///{sqlite_file_name}"
    
    connect_args = {"check_same_thread": False}
    engine = create_engine(sqlite_url, connect_args=connect_args)
    
    
    def create_db_and_tables():
        SQLModel.metadata.create_all(engine)
    
    
    def get_session():
        with Session(engine) as session:
            yield session
    
    
    app = FastAPI()
    
    
    @app.on_event("startup")
    def on_startup():
        create_db_and_tables()
    
    
    @app.post("/heroes/", response_model=HeroPublic)
    def create_hero(hero: HeroCreate, session: Session = Depends(get_session)):
        db_hero = Hero.model_validate(hero)
        session.add(db_hero)
        session.commit()
        session.refresh(db_hero)
        return db_hero
    
    
    @app.get("/heroes/", response_model=list[HeroPublic])
    def read_heroes(
        session: Session = Depends(get_session),
        offset: int = 0,
        limit: int = Query(default=100, le=100),
    ):
        heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
        return heroes
    
    
    @app.get("/heroes/{hero_id}", response_model=HeroPublic)
    def read_hero(hero_id: int, session: Session = Depends(get_session)):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        return hero
    
    
    @app.patch("/heroes/{hero_id}", response_model=HeroPublic)
    def update_hero(
        hero_id: int, hero: HeroUpdate, session: Session = Depends(get_session)
    ):
        hero_db = session.get(Hero, hero_id)
        if not hero_db:
            raise HTTPException(status_code=404, detail="Hero not found")
        hero_data = hero.model_dump(exclude_unset=True)
        hero_db.sqlmodel_update(hero_data)
        session.add(hero_db)
        session.commit()
        session.refresh(hero_db)
        return hero_db
    
    
    @app.delete("/heroes/{hero_id}")
    def delete_hero(hero_id: int, session: Session = Depends(get_session)):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        session.delete(hero)
        session.commit()
        return {"ok": True}
    

#### `HeroCreate` \- the _data model_ to create a hero[¶](#herocreate-the-data-model-to-create-a-hero "Permanent link")

Now we create a `HeroCreate` model, this is the one that will **validate** the data from the clients.

It has the same fields as `HeroBase`, and it also has `secret_name`.

Now, when the clients **create a new hero** , they will send the `secret_name`, it will be stored in the database, but those secret names won't be returned in the API to the clients.

Tip

This is how you would handle **passwords**. Receive them, but don't return them in the API.

You would also **hash** the values of the passwords before storing them, **never store them in plain text**.

The fields of `HeroCreate` are:

  * `name`
  * `age`
  * `secret_name`

Python 3.10+
    
    
    # Code above omitted üëÜ
    
    class HeroBase(SQLModel):
        name: str = Field(index=True)
        age: int | None = Field(default=None, index=True)
    
    
    class Hero(HeroBase, table=True):
        id: int | None = Field(default=None, primary_key=True)
        secret_name: str
    
    
    class HeroPublic(HeroBase):
        id: int
    
    
    class HeroCreate(HeroBase):
        secret_name: str
    
    # Code below omitted üëá
    

üëÄ Full file preview

Python 3.10+
    
    
    from typing import Annotated
    
    from fastapi import Depends, FastAPI, HTTPException, Query
    from sqlmodel import Field, Session, SQLModel, create_engine, select
    
    
    class HeroBase(SQLModel):
        name: str = Field(index=True)
        age: int | None = Field(default=None, index=True)
    
    
    class Hero(HeroBase, table=True):
        id: int | None = Field(default=None, primary_key=True)
        secret_name: str
    
    
    class HeroPublic(HeroBase):
        id: int
    
    
    class HeroCreate(HeroBase):
        secret_name: str
    
    
    class HeroUpdate(HeroBase):
        name: str | None = None
        age: int | None = None
        secret_name: str | None = None
    
    
    sqlite_file_name = "database.db"
    sqlite_url = f"sqlite:///{sqlite_file_name}"
    
    connect_args = {"check_same_thread": False}
    engine = create_engine(sqlite_url, connect_args=connect_args)
    
    
    def create_db_and_tables():
        SQLModel.metadata.create_all(engine)
    
    
    def get_session():
        with Session(engine) as session:
            yield session
    
    
    SessionDep = Annotated[Session, Depends(get_session)]
    app = FastAPI()
    
    
    @app.on_event("startup")
    def on_startup():
        create_db_and_tables()
    
    
    @app.post("/heroes/", response_model=HeroPublic)
    def create_hero(hero: HeroCreate, session: SessionDep):
        db_hero = Hero.model_validate(hero)
        session.add(db_hero)
        session.commit()
        session.refresh(db_hero)
        return db_hero
    
    
    @app.get("/heroes/", response_model=list[HeroPublic])
    def read_heroes(
        session: SessionDep,
        offset: int = 0,
        limit: Annotated[int, Query(le=100)] = 100,
    ):
        heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
        return heroes
    
    
    @app.get("/heroes/{hero_id}", response_model=HeroPublic)
    def read_hero(hero_id: int, session: SessionDep):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        return hero
    
    
    @app.patch("/heroes/{hero_id}", response_model=HeroPublic)
    def update_hero(hero_id: int, hero: HeroUpdate, session: SessionDep):
        hero_db = session.get(Hero, hero_id)
        if not hero_db:
            raise HTTPException(status_code=404, detail="Hero not found")
        hero_data = hero.model_dump(exclude_unset=True)
        hero_db.sqlmodel_update(hero_data)
        session.add(hero_db)
        session.commit()
        session.refresh(hero_db)
        return hero_db
    
    
    @app.delete("/heroes/{hero_id}")
    def delete_hero(hero_id: int, session: SessionDep):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        session.delete(hero)
        session.commit()
        return {"ok": True}
    

ü§ì Other versions and variants

Python 3.9+Python 3.10+ - non-AnnotatedPython 3.9+ - non-Annotated
    
    
    from typing import Annotated, Union
    
    from fastapi import Depends, FastAPI, HTTPException, Query
    from sqlmodel import Field, Session, SQLModel, create_engine, select
    
    
    class HeroBase(SQLModel):
        name: str = Field(index=True)
        age: Union[int, None] = Field(default=None, index=True)
    
    
    class Hero(HeroBase, table=True):
        id: Union[int, None] = Field(default=None, primary_key=True)
        secret_name: str
    
    
    class HeroPublic(HeroBase):
        id: int
    
    
    class HeroCreate(HeroBase):
        secret_name: str
    
    
    class HeroUpdate(HeroBase):
        name: Union[str, None] = None
        age: Union[int, None] = None
        secret_name: Union[str, None] = None
    
    
    sqlite_file_name = "database.db"
    sqlite_url = f"sqlite:///{sqlite_file_name}"
    
    connect_args = {"check_same_thread": False}
    engine = create_engine(sqlite_url, connect_args=connect_args)
    
    
    def create_db_and_tables():
        SQLModel.metadata.create_all(engine)
    
    
    def get_session():
        with Session(engine) as session:
            yield session
    
    
    SessionDep = Annotated[Session, Depends(get_session)]
    app = FastAPI()
    
    
    @app.on_event("startup")
    def on_startup():
        create_db_and_tables()
    
    
    @app.post("/heroes/", response_model=HeroPublic)
    def create_hero(hero: HeroCreate, session: SessionDep):
        db_hero = Hero.model_validate(hero)
        session.add(db_hero)
        session.commit()
        session.refresh(db_hero)
        return db_hero
    
    
    @app.get("/heroes/", response_model=list[HeroPublic])
    def read_heroes(
        session: SessionDep,
        offset: int = 0,
        limit: Annotated[int, Query(le=100)] = 100,
    ):
        heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
        return heroes
    
    
    @app.get("/heroes/{hero_id}", response_model=HeroPublic)
    def read_hero(hero_id: int, session: SessionDep):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        return hero
    
    
    @app.patch("/heroes/{hero_id}", response_model=HeroPublic)
    def update_hero(hero_id: int, hero: HeroUpdate, session: SessionDep):
        hero_db = session.get(Hero, hero_id)
        if not hero_db:
            raise HTTPException(status_code=404, detail="Hero not found")
        hero_data = hero.model_dump(exclude_unset=True)
        hero_db.sqlmodel_update(hero_data)
        session.add(hero_db)
        session.commit()
        session.refresh(hero_db)
        return hero_db
    
    
    @app.delete("/heroes/{hero_id}")
    def delete_hero(hero_id: int, session: SessionDep):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        session.delete(hero)
        session.commit()
        return {"ok": True}
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import Depends, FastAPI, HTTPException, Query
    from sqlmodel import Field, Session, SQLModel, create_engine, select
    
    
    class HeroBase(SQLModel):
        name: str = Field(index=True)
        age: int | None = Field(default=None, index=True)
    
    
    class Hero(HeroBase, table=True):
        id: int | None = Field(default=None, primary_key=True)
        secret_name: str
    
    
    class HeroPublic(HeroBase):
        id: int
    
    
    class HeroCreate(HeroBase):
        secret_name: str
    
    
    class HeroUpdate(HeroBase):
        name: str | None = None
        age: int | None = None
        secret_name: str | None = None
    
    
    sqlite_file_name = "database.db"
    sqlite_url = f"sqlite:///{sqlite_file_name}"
    
    connect_args = {"check_same_thread": False}
    engine = create_engine(sqlite_url, connect_args=connect_args)
    
    
    def create_db_and_tables():
        SQLModel.metadata.create_all(engine)
    
    
    def get_session():
        with Session(engine) as session:
            yield session
    
    
    app = FastAPI()
    
    
    @app.on_event("startup")
    def on_startup():
        create_db_and_tables()
    
    
    @app.post("/heroes/", response_model=HeroPublic)
    def create_hero(hero: HeroCreate, session: Session = Depends(get_session)):
        db_hero = Hero.model_validate(hero)
        session.add(db_hero)
        session.commit()
        session.refresh(db_hero)
        return db_hero
    
    
    @app.get("/heroes/", response_model=list[HeroPublic])
    def read_heroes(
        session: Session = Depends(get_session),
        offset: int = 0,
        limit: int = Query(default=100, le=100),
    ):
        heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
        return heroes
    
    
    @app.get("/heroes/{hero_id}", response_model=HeroPublic)
    def read_hero(hero_id: int, session: Session = Depends(get_session)):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        return hero
    
    
    @app.patch("/heroes/{hero_id}", response_model=HeroPublic)
    def update_hero(
        hero_id: int, hero: HeroUpdate, session: Session = Depends(get_session)
    ):
        hero_db = session.get(Hero, hero_id)
        if not hero_db:
            raise HTTPException(status_code=404, detail="Hero not found")
        hero_data = hero.model_dump(exclude_unset=True)
        hero_db.sqlmodel_update(hero_data)
        session.add(hero_db)
        session.commit()
        session.refresh(hero_db)
        return hero_db
    
    
    @app.delete("/heroes/{hero_id}")
    def delete_hero(hero_id: int, session: Session = Depends(get_session)):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        session.delete(hero)
        session.commit()
        return {"ok": True}
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from typing import Union
    
    from fastapi import Depends, FastAPI, HTTPException, Query
    from sqlmodel import Field, Session, SQLModel, create_engine, select
    
    
    class HeroBase(SQLModel):
        name: str = Field(index=True)
        age: Union[int, None] = Field(default=None, index=True)
    
    
    class Hero(HeroBase, table=True):
        id: Union[int, None] = Field(default=None, primary_key=True)
        secret_name: str
    
    
    class HeroPublic(HeroBase):
        id: int
    
    
    class HeroCreate(HeroBase):
        secret_name: str
    
    
    class HeroUpdate(HeroBase):
        name: Union[str, None] = None
        age: Union[int, None] = None
        secret_name: Union[str, None] = None
    
    
    sqlite_file_name = "database.db"
    sqlite_url = f"sqlite:///{sqlite_file_name}"
    
    connect_args = {"check_same_thread": False}
    engine = create_engine(sqlite_url, connect_args=connect_args)
    
    
    def create_db_and_tables():
        SQLModel.metadata.create_all(engine)
    
    
    def get_session():
        with Session(engine) as session:
            yield session
    
    
    app = FastAPI()
    
    
    @app.on_event("startup")
    def on_startup():
        create_db_and_tables()
    
    
    @app.post("/heroes/", response_model=HeroPublic)
    def create_hero(hero: HeroCreate, session: Session = Depends(get_session)):
        db_hero = Hero.model_validate(hero)
        session.add(db_hero)
        session.commit()
        session.refresh(db_hero)
        return db_hero
    
    
    @app.get("/heroes/", response_model=list[HeroPublic])
    def read_heroes(
        session: Session = Depends(get_session),
        offset: int = 0,
        limit: int = Query(default=100, le=100),
    ):
        heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
        return heroes
    
    
    @app.get("/heroes/{hero_id}", response_model=HeroPublic)
    def read_hero(hero_id: int, session: Session = Depends(get_session)):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        return hero
    
    
    @app.patch("/heroes/{hero_id}", response_model=HeroPublic)
    def update_hero(
        hero_id: int, hero: HeroUpdate, session: Session = Depends(get_session)
    ):
        hero_db = session.get(Hero, hero_id)
        if not hero_db:
            raise HTTPException(status_code=404, detail="Hero not found")
        hero_data = hero.model_dump(exclude_unset=True)
        hero_db.sqlmodel_update(hero_data)
        session.add(hero_db)
        session.commit()
        session.refresh(hero_db)
        return hero_db
    
    
    @app.delete("/heroes/{hero_id}")
    def delete_hero(hero_id: int, session: Session = Depends(get_session)):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        session.delete(hero)
        session.commit()
        return {"ok": True}
    

#### `HeroUpdate` \- the _data model_ to update a hero[¶](#heroupdate-the-data-model-to-update-a-hero "Permanent link")

We didn't have a way to **update a hero** in the previous version of the app, but now with **multiple models** , we can do it. üéâ

The `HeroUpdate` _data model_ is somewhat special, it has **all the same fields** that would be needed to create a new hero, but all the fields are **optional** (they all have a default value). This way, when you update a hero, you can send just the fields that you want to update.

Because all the **fields actually change** (the type now includes `None` and they now have a default value of `None`), we need to **re-declare** them.

We don't really need to inherit from `HeroBase` because we are re-declaring all the fields. I'll leave it inheriting just for consistency, but this is not necessary. It's more a matter of personal taste. ü§∑

The fields of `HeroUpdate` are:

  * `name`
  * `age`
  * `secret_name`

Python 3.10+
    
    
    # Code above omitted üëÜ
    
    class HeroBase(SQLModel):
        name: str = Field(index=True)
        age: int | None = Field(default=None, index=True)
    
    
    class Hero(HeroBase, table=True):
        id: int | None = Field(default=None, primary_key=True)
        secret_name: str
    
    
    class HeroPublic(HeroBase):
        id: int
    
    
    class HeroCreate(HeroBase):
        secret_name: str
    
    
    class HeroUpdate(HeroBase):
        name: str | None = None
        age: int | None = None
        secret_name: str | None = None
    
    # Code below omitted üëá
    

üëÄ Full file preview

Python 3.10+
    
    
    from typing import Annotated
    
    from fastapi import Depends, FastAPI, HTTPException, Query
    from sqlmodel import Field, Session, SQLModel, create_engine, select
    
    
    class HeroBase(SQLModel):
        name: str = Field(index=True)
        age: int | None = Field(default=None, index=True)
    
    
    class Hero(HeroBase, table=True):
        id: int | None = Field(default=None, primary_key=True)
        secret_name: str
    
    
    class HeroPublic(HeroBase):
        id: int
    
    
    class HeroCreate(HeroBase):
        secret_name: str
    
    
    class HeroUpdate(HeroBase):
        name: str | None = None
        age: int | None = None
        secret_name: str | None = None
    
    
    sqlite_file_name = "database.db"
    sqlite_url = f"sqlite:///{sqlite_file_name}"
    
    connect_args = {"check_same_thread": False}
    engine = create_engine(sqlite_url, connect_args=connect_args)
    
    
    def create_db_and_tables():
        SQLModel.metadata.create_all(engine)
    
    
    def get_session():
        with Session(engine) as session:
            yield session
    
    
    SessionDep = Annotated[Session, Depends(get_session)]
    app = FastAPI()
    
    
    @app.on_event("startup")
    def on_startup():
        create_db_and_tables()
    
    
    @app.post("/heroes/", response_model=HeroPublic)
    def create_hero(hero: HeroCreate, session: SessionDep):
        db_hero = Hero.model_validate(hero)
        session.add(db_hero)
        session.commit()
        session.refresh(db_hero)
        return db_hero
    
    
    @app.get("/heroes/", response_model=list[HeroPublic])
    def read_heroes(
        session: SessionDep,
        offset: int = 0,
        limit: Annotated[int, Query(le=100)] = 100,
    ):
        heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
        return heroes
    
    
    @app.get("/heroes/{hero_id}", response_model=HeroPublic)
    def read_hero(hero_id: int, session: SessionDep):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        return hero
    
    
    @app.patch("/heroes/{hero_id}", response_model=HeroPublic)
    def update_hero(hero_id: int, hero: HeroUpdate, session: SessionDep):
        hero_db = session.get(Hero, hero_id)
        if not hero_db:
            raise HTTPException(status_code=404, detail="Hero not found")
        hero_data = hero.model_dump(exclude_unset=True)
        hero_db.sqlmodel_update(hero_data)
        session.add(hero_db)
        session.commit()
        session.refresh(hero_db)
        return hero_db
    
    
    @app.delete("/heroes/{hero_id}")
    def delete_hero(hero_id: int, session: SessionDep):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        session.delete(hero)
        session.commit()
        return {"ok": True}
    

ü§ì Other versions and variants

Python 3.9+Python 3.10+ - non-AnnotatedPython 3.9+ - non-Annotated
    
    
    from typing import Annotated, Union
    
    from fastapi import Depends, FastAPI, HTTPException, Query
    from sqlmodel import Field, Session, SQLModel, create_engine, select
    
    
    class HeroBase(SQLModel):
        name: str = Field(index=True)
        age: Union[int, None] = Field(default=None, index=True)
    
    
    class Hero(HeroBase, table=True):
        id: Union[int, None] = Field(default=None, primary_key=True)
        secret_name: str
    
    
    class HeroPublic(HeroBase):
        id: int
    
    
    class HeroCreate(HeroBase):
        secret_name: str
    
    
    class HeroUpdate(HeroBase):
        name: Union[str, None] = None
        age: Union[int, None] = None
        secret_name: Union[str, None] = None
    
    
    sqlite_file_name = "database.db"
    sqlite_url = f"sqlite:///{sqlite_file_name}"
    
    connect_args = {"check_same_thread": False}
    engine = create_engine(sqlite_url, connect_args=connect_args)
    
    
    def create_db_and_tables():
        SQLModel.metadata.create_all(engine)
    
    
    def get_session():
        with Session(engine) as session:
            yield session
    
    
    SessionDep = Annotated[Session, Depends(get_session)]
    app = FastAPI()
    
    
    @app.on_event("startup")
    def on_startup():
        create_db_and_tables()
    
    
    @app.post("/heroes/", response_model=HeroPublic)
    def create_hero(hero: HeroCreate, session: SessionDep):
        db_hero = Hero.model_validate(hero)
        session.add(db_hero)
        session.commit()
        session.refresh(db_hero)
        return db_hero
    
    
    @app.get("/heroes/", response_model=list[HeroPublic])
    def read_heroes(
        session: SessionDep,
        offset: int = 0,
        limit: Annotated[int, Query(le=100)] = 100,
    ):
        heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
        return heroes
    
    
    @app.get("/heroes/{hero_id}", response_model=HeroPublic)
    def read_hero(hero_id: int, session: SessionDep):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        return hero
    
    
    @app.patch("/heroes/{hero_id}", response_model=HeroPublic)
    def update_hero(hero_id: int, hero: HeroUpdate, session: SessionDep):
        hero_db = session.get(Hero, hero_id)
        if not hero_db:
            raise HTTPException(status_code=404, detail="Hero not found")
        hero_data = hero.model_dump(exclude_unset=True)
        hero_db.sqlmodel_update(hero_data)
        session.add(hero_db)
        session.commit()
        session.refresh(hero_db)
        return hero_db
    
    
    @app.delete("/heroes/{hero_id}")
    def delete_hero(hero_id: int, session: SessionDep):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        session.delete(hero)
        session.commit()
        return {"ok": True}
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import Depends, FastAPI, HTTPException, Query
    from sqlmodel import Field, Session, SQLModel, create_engine, select
    
    
    class HeroBase(SQLModel):
        name: str = Field(index=True)
        age: int | None = Field(default=None, index=True)
    
    
    class Hero(HeroBase, table=True):
        id: int | None = Field(default=None, primary_key=True)
        secret_name: str
    
    
    class HeroPublic(HeroBase):
        id: int
    
    
    class HeroCreate(HeroBase):
        secret_name: str
    
    
    class HeroUpdate(HeroBase):
        name: str | None = None
        age: int | None = None
        secret_name: str | None = None
    
    
    sqlite_file_name = "database.db"
    sqlite_url = f"sqlite:///{sqlite_file_name}"
    
    connect_args = {"check_same_thread": False}
    engine = create_engine(sqlite_url, connect_args=connect_args)
    
    
    def create_db_and_tables():
        SQLModel.metadata.create_all(engine)
    
    
    def get_session():
        with Session(engine) as session:
            yield session
    
    
    app = FastAPI()
    
    
    @app.on_event("startup")
    def on_startup():
        create_db_and_tables()
    
    
    @app.post("/heroes/", response_model=HeroPublic)
    def create_hero(hero: HeroCreate, session: Session = Depends(get_session)):
        db_hero = Hero.model_validate(hero)
        session.add(db_hero)
        session.commit()
        session.refresh(db_hero)
        return db_hero
    
    
    @app.get("/heroes/", response_model=list[HeroPublic])
    def read_heroes(
        session: Session = Depends(get_session),
        offset: int = 0,
        limit: int = Query(default=100, le=100),
    ):
        heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
        return heroes
    
    
    @app.get("/heroes/{hero_id}", response_model=HeroPublic)
    def read_hero(hero_id: int, session: Session = Depends(get_session)):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        return hero
    
    
    @app.patch("/heroes/{hero_id}", response_model=HeroPublic)
    def update_hero(
        hero_id: int, hero: HeroUpdate, session: Session = Depends(get_session)
    ):
        hero_db = session.get(Hero, hero_id)
        if not hero_db:
            raise HTTPException(status_code=404, detail="Hero not found")
        hero_data = hero.model_dump(exclude_unset=True)
        hero_db.sqlmodel_update(hero_data)
        session.add(hero_db)
        session.commit()
        session.refresh(hero_db)
        return hero_db
    
    
    @app.delete("/heroes/{hero_id}")
    def delete_hero(hero_id: int, session: Session = Depends(get_session)):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        session.delete(hero)
        session.commit()
        return {"ok": True}
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from typing import Union
    
    from fastapi import Depends, FastAPI, HTTPException, Query
    from sqlmodel import Field, Session, SQLModel, create_engine, select
    
    
    class HeroBase(SQLModel):
        name: str = Field(index=True)
        age: Union[int, None] = Field(default=None, index=True)
    
    
    class Hero(HeroBase, table=True):
        id: Union[int, None] = Field(default=None, primary_key=True)
        secret_name: str
    
    
    class HeroPublic(HeroBase):
        id: int
    
    
    class HeroCreate(HeroBase):
        secret_name: str
    
    
    class HeroUpdate(HeroBase):
        name: Union[str, None] = None
        age: Union[int, None] = None
        secret_name: Union[str, None] = None
    
    
    sqlite_file_name = "database.db"
    sqlite_url = f"sqlite:///{sqlite_file_name}"
    
    connect_args = {"check_same_thread": False}
    engine = create_engine(sqlite_url, connect_args=connect_args)
    
    
    def create_db_and_tables():
        SQLModel.metadata.create_all(engine)
    
    
    def get_session():
        with Session(engine) as session:
            yield session
    
    
    app = FastAPI()
    
    
    @app.on_event("startup")
    def on_startup():
        create_db_and_tables()
    
    
    @app.post("/heroes/", response_model=HeroPublic)
    def create_hero(hero: HeroCreate, session: Session = Depends(get_session)):
        db_hero = Hero.model_validate(hero)
        session.add(db_hero)
        session.commit()
        session.refresh(db_hero)
        return db_hero
    
    
    @app.get("/heroes/", response_model=list[HeroPublic])
    def read_heroes(
        session: Session = Depends(get_session),
        offset: int = 0,
        limit: int = Query(default=100, le=100),
    ):
        heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
        return heroes
    
    
    @app.get("/heroes/{hero_id}", response_model=HeroPublic)
    def read_hero(hero_id: int, session: Session = Depends(get_session)):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        return hero
    
    
    @app.patch("/heroes/{hero_id}", response_model=HeroPublic)
    def update_hero(
        hero_id: int, hero: HeroUpdate, session: Session = Depends(get_session)
    ):
        hero_db = session.get(Hero, hero_id)
        if not hero_db:
            raise HTTPException(status_code=404, detail="Hero not found")
        hero_data = hero.model_dump(exclude_unset=True)
        hero_db.sqlmodel_update(hero_data)
        session.add(hero_db)
        session.commit()
        session.refresh(hero_db)
        return hero_db
    
    
    @app.delete("/heroes/{hero_id}")
    def delete_hero(hero_id: int, session: Session = Depends(get_session)):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        session.delete(hero)
        session.commit()
        return {"ok": True}
    

### Create with `HeroCreate` and return a `HeroPublic`[¶](#create-with-herocreate-and-return-a-heropublic "Permanent link")

Now that we have **multiple models** , we can update the parts of the app that use them.

We receive in the request a `HeroCreate` _data model_ , and from it, we create a `Hero` _table model_.

This new _table model_ `Hero` will have the fields sent by the client, and will also have an `id` generated by the database.

Then we return the same _table model_ `Hero` as is from the function. But as we declare the `response_model` with the `HeroPublic` _data model_ , **FastAPI** will use `HeroPublic` to validate and serialize the data.

Python 3.10+
    
    
    # Code above omitted üëÜ
    
    @app.post("/heroes/", response_model=HeroPublic)
    def create_hero(hero: HeroCreate, session: SessionDep):
        db_hero = Hero.model_validate(hero)
        session.add(db_hero)
        session.commit()
        session.refresh(db_hero)
        return db_hero
    
    # Code below omitted üëá
    

üëÄ Full file preview

Python 3.10+
    
    
    from typing import Annotated
    
    from fastapi import Depends, FastAPI, HTTPException, Query
    from sqlmodel import Field, Session, SQLModel, create_engine, select
    
    
    class HeroBase(SQLModel):
        name: str = Field(index=True)
        age: int | None = Field(default=None, index=True)
    
    
    class Hero(HeroBase, table=True):
        id: int | None = Field(default=None, primary_key=True)
        secret_name: str
    
    
    class HeroPublic(HeroBase):
        id: int
    
    
    class HeroCreate(HeroBase):
        secret_name: str
    
    
    class HeroUpdate(HeroBase):
        name: str | None = None
        age: int | None = None
        secret_name: str | None = None
    
    
    sqlite_file_name = "database.db"
    sqlite_url = f"sqlite:///{sqlite_file_name}"
    
    connect_args = {"check_same_thread": False}
    engine = create_engine(sqlite_url, connect_args=connect_args)
    
    
    def create_db_and_tables():
        SQLModel.metadata.create_all(engine)
    
    
    def get_session():
        with Session(engine) as session:
            yield session
    
    
    SessionDep = Annotated[Session, Depends(get_session)]
    app = FastAPI()
    
    
    @app.on_event("startup")
    def on_startup():
        create_db_and_tables()
    
    
    @app.post("/heroes/", response_model=HeroPublic)
    def create_hero(hero: HeroCreate, session: SessionDep):
        db_hero = Hero.model_validate(hero)
        session.add(db_hero)
        session.commit()
        session.refresh(db_hero)
        return db_hero
    
    
    @app.get("/heroes/", response_model=list[HeroPublic])
    def read_heroes(
        session: SessionDep,
        offset: int = 0,
        limit: Annotated[int, Query(le=100)] = 100,
    ):
        heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
        return heroes
    
    
    @app.get("/heroes/{hero_id}", response_model=HeroPublic)
    def read_hero(hero_id: int, session: SessionDep):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        return hero
    
    
    @app.patch("/heroes/{hero_id}", response_model=HeroPublic)
    def update_hero(hero_id: int, hero: HeroUpdate, session: SessionDep):
        hero_db = session.get(Hero, hero_id)
        if not hero_db:
            raise HTTPException(status_code=404, detail="Hero not found")
        hero_data = hero.model_dump(exclude_unset=True)
        hero_db.sqlmodel_update(hero_data)
        session.add(hero_db)
        session.commit()
        session.refresh(hero_db)
        return hero_db
    
    
    @app.delete("/heroes/{hero_id}")
    def delete_hero(hero_id: int, session: SessionDep):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        session.delete(hero)
        session.commit()
        return {"ok": True}
    

ü§ì Other versions and variants

Python 3.9+Python 3.10+ - non-AnnotatedPython 3.9+ - non-Annotated
    
    
    from typing import Annotated, Union
    
    from fastapi import Depends, FastAPI, HTTPException, Query
    from sqlmodel import Field, Session, SQLModel, create_engine, select
    
    
    class HeroBase(SQLModel):
        name: str = Field(index=True)
        age: Union[int, None] = Field(default=None, index=True)
    
    
    class Hero(HeroBase, table=True):
        id: Union[int, None] = Field(default=None, primary_key=True)
        secret_name: str
    
    
    class HeroPublic(HeroBase):
        id: int
    
    
    class HeroCreate(HeroBase):
        secret_name: str
    
    
    class HeroUpdate(HeroBase):
        name: Union[str, None] = None
        age: Union[int, None] = None
        secret_name: Union[str, None] = None
    
    
    sqlite_file_name = "database.db"
    sqlite_url = f"sqlite:///{sqlite_file_name}"
    
    connect_args = {"check_same_thread": False}
    engine = create_engine(sqlite_url, connect_args=connect_args)
    
    
    def create_db_and_tables():
        SQLModel.metadata.create_all(engine)
    
    
    def get_session():
        with Session(engine) as session:
            yield session
    
    
    SessionDep = Annotated[Session, Depends(get_session)]
    app = FastAPI()
    
    
    @app.on_event("startup")
    def on_startup():
        create_db_and_tables()
    
    
    @app.post("/heroes/", response_model=HeroPublic)
    def create_hero(hero: HeroCreate, session: SessionDep):
        db_hero = Hero.model_validate(hero)
        session.add(db_hero)
        session.commit()
        session.refresh(db_hero)
        return db_hero
    
    
    @app.get("/heroes/", response_model=list[HeroPublic])
    def read_heroes(
        session: SessionDep,
        offset: int = 0,
        limit: Annotated[int, Query(le=100)] = 100,
    ):
        heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
        return heroes
    
    
    @app.get("/heroes/{hero_id}", response_model=HeroPublic)
    def read_hero(hero_id: int, session: SessionDep):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        return hero
    
    
    @app.patch("/heroes/{hero_id}", response_model=HeroPublic)
    def update_hero(hero_id: int, hero: HeroUpdate, session: SessionDep):
        hero_db = session.get(Hero, hero_id)
        if not hero_db:
            raise HTTPException(status_code=404, detail="Hero not found")
        hero_data = hero.model_dump(exclude_unset=True)
        hero_db.sqlmodel_update(hero_data)
        session.add(hero_db)
        session.commit()
        session.refresh(hero_db)
        return hero_db
    
    
    @app.delete("/heroes/{hero_id}")
    def delete_hero(hero_id: int, session: SessionDep):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        session.delete(hero)
        session.commit()
        return {"ok": True}
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import Depends, FastAPI, HTTPException, Query
    from sqlmodel import Field, Session, SQLModel, create_engine, select
    
    
    class HeroBase(SQLModel):
        name: str = Field(index=True)
        age: int | None = Field(default=None, index=True)
    
    
    class Hero(HeroBase, table=True):
        id: int | None = Field(default=None, primary_key=True)
        secret_name: str
    
    
    class HeroPublic(HeroBase):
        id: int
    
    
    class HeroCreate(HeroBase):
        secret_name: str
    
    
    class HeroUpdate(HeroBase):
        name: str | None = None
        age: int | None = None
        secret_name: str | None = None
    
    
    sqlite_file_name = "database.db"
    sqlite_url = f"sqlite:///{sqlite_file_name}"
    
    connect_args = {"check_same_thread": False}
    engine = create_engine(sqlite_url, connect_args=connect_args)
    
    
    def create_db_and_tables():
        SQLModel.metadata.create_all(engine)
    
    
    def get_session():
        with Session(engine) as session:
            yield session
    
    
    app = FastAPI()
    
    
    @app.on_event("startup")
    def on_startup():
        create_db_and_tables()
    
    
    @app.post("/heroes/", response_model=HeroPublic)
    def create_hero(hero: HeroCreate, session: Session = Depends(get_session)):
        db_hero = Hero.model_validate(hero)
        session.add(db_hero)
        session.commit()
        session.refresh(db_hero)
        return db_hero
    
    
    @app.get("/heroes/", response_model=list[HeroPublic])
    def read_heroes(
        session: Session = Depends(get_session),
        offset: int = 0,
        limit: int = Query(default=100, le=100),
    ):
        heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
        return heroes
    
    
    @app.get("/heroes/{hero_id}", response_model=HeroPublic)
    def read_hero(hero_id: int, session: Session = Depends(get_session)):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        return hero
    
    
    @app.patch("/heroes/{hero_id}", response_model=HeroPublic)
    def update_hero(
        hero_id: int, hero: HeroUpdate, session: Session = Depends(get_session)
    ):
        hero_db = session.get(Hero, hero_id)
        if not hero_db:
            raise HTTPException(status_code=404, detail="Hero not found")
        hero_data = hero.model_dump(exclude_unset=True)
        hero_db.sqlmodel_update(hero_data)
        session.add(hero_db)
        session.commit()
        session.refresh(hero_db)
        return hero_db
    
    
    @app.delete("/heroes/{hero_id}")
    def delete_hero(hero_id: int, session: Session = Depends(get_session)):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        session.delete(hero)
        session.commit()
        return {"ok": True}
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from typing import Union
    
    from fastapi import Depends, FastAPI, HTTPException, Query
    from sqlmodel import Field, Session, SQLModel, create_engine, select
    
    
    class HeroBase(SQLModel):
        name: str = Field(index=True)
        age: Union[int, None] = Field(default=None, index=True)
    
    
    class Hero(HeroBase, table=True):
        id: Union[int, None] = Field(default=None, primary_key=True)
        secret_name: str
    
    
    class HeroPublic(HeroBase):
        id: int
    
    
    class HeroCreate(HeroBase):
        secret_name: str
    
    
    class HeroUpdate(HeroBase):
        name: Union[str, None] = None
        age: Union[int, None] = None
        secret_name: Union[str, None] = None
    
    
    sqlite_file_name = "database.db"
    sqlite_url = f"sqlite:///{sqlite_file_name}"
    
    connect_args = {"check_same_thread": False}
    engine = create_engine(sqlite_url, connect_args=connect_args)
    
    
    def create_db_and_tables():
        SQLModel.metadata.create_all(engine)
    
    
    def get_session():
        with Session(engine) as session:
            yield session
    
    
    app = FastAPI()
    
    
    @app.on_event("startup")
    def on_startup():
        create_db_and_tables()
    
    
    @app.post("/heroes/", response_model=HeroPublic)
    def create_hero(hero: HeroCreate, session: Session = Depends(get_session)):
        db_hero = Hero.model_validate(hero)
        session.add(db_hero)
        session.commit()
        session.refresh(db_hero)
        return db_hero
    
    
    @app.get("/heroes/", response_model=list[HeroPublic])
    def read_heroes(
        session: Session = Depends(get_session),
        offset: int = 0,
        limit: int = Query(default=100, le=100),
    ):
        heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
        return heroes
    
    
    @app.get("/heroes/{hero_id}", response_model=HeroPublic)
    def read_hero(hero_id: int, session: Session = Depends(get_session)):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        return hero
    
    
    @app.patch("/heroes/{hero_id}", response_model=HeroPublic)
    def update_hero(
        hero_id: int, hero: HeroUpdate, session: Session = Depends(get_session)
    ):
        hero_db = session.get(Hero, hero_id)
        if not hero_db:
            raise HTTPException(status_code=404, detail="Hero not found")
        hero_data = hero.model_dump(exclude_unset=True)
        hero_db.sqlmodel_update(hero_data)
        session.add(hero_db)
        session.commit()
        session.refresh(hero_db)
        return hero_db
    
    
    @app.delete("/heroes/{hero_id}")
    def delete_hero(hero_id: int, session: Session = Depends(get_session)):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        session.delete(hero)
        session.commit()
        return {"ok": True}
    

Tip

Now we use `response_model=HeroPublic` instead of the **return type annotation** `-> HeroPublic` because the value that we are returning is actually _not_ a `HeroPublic`.

If we had declared `-> HeroPublic`, your editor and linter would complain (rightfully so) that you are returning a `Hero` instead of a `HeroPublic`.

By declaring it in `response_model` we are telling **FastAPI** to do its thing, without interfering with the type annotations and the help from your editor and other tools.

### Read Heroes with `HeroPublic`[¶](#read-heroes-with-heropublic "Permanent link")

We can do the same as before to **read** `Hero`s, again, we use `response_model=list[HeroPublic]` to ensure that the data is validated and serialized correctly.

Python 3.10+
    
    
    # Code above omitted üëÜ
    
    @app.get("/heroes/", response_model=list[HeroPublic])
    def read_heroes(
        session: SessionDep,
        offset: int = 0,
        limit: Annotated[int, Query(le=100)] = 100,
    ):
        heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
        return heroes
    
    # Code below omitted üëá
    

üëÄ Full file preview

Python 3.10+
    
    
    from typing import Annotated
    
    from fastapi import Depends, FastAPI, HTTPException, Query
    from sqlmodel import Field, Session, SQLModel, create_engine, select
    
    
    class HeroBase(SQLModel):
        name: str = Field(index=True)
        age: int | None = Field(default=None, index=True)
    
    
    class Hero(HeroBase, table=True):
        id: int | None = Field(default=None, primary_key=True)
        secret_name: str
    
    
    class HeroPublic(HeroBase):
        id: int
    
    
    class HeroCreate(HeroBase):
        secret_name: str
    
    
    class HeroUpdate(HeroBase):
        name: str | None = None
        age: int | None = None
        secret_name: str | None = None
    
    
    sqlite_file_name = "database.db"
    sqlite_url = f"sqlite:///{sqlite_file_name}"
    
    connect_args = {"check_same_thread": False}
    engine = create_engine(sqlite_url, connect_args=connect_args)
    
    
    def create_db_and_tables():
        SQLModel.metadata.create_all(engine)
    
    
    def get_session():
        with Session(engine) as session:
            yield session
    
    
    SessionDep = Annotated[Session, Depends(get_session)]
    app = FastAPI()
    
    
    @app.on_event("startup")
    def on_startup():
        create_db_and_tables()
    
    
    @app.post("/heroes/", response_model=HeroPublic)
    def create_hero(hero: HeroCreate, session: SessionDep):
        db_hero = Hero.model_validate(hero)
        session.add(db_hero)
        session.commit()
        session.refresh(db_hero)
        return db_hero
    
    
    @app.get("/heroes/", response_model=list[HeroPublic])
    def read_heroes(
        session: SessionDep,
        offset: int = 0,
        limit: Annotated[int, Query(le=100)] = 100,
    ):
        heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
        return heroes
    
    
    @app.get("/heroes/{hero_id}", response_model=HeroPublic)
    def read_hero(hero_id: int, session: SessionDep):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        return hero
    
    
    @app.patch("/heroes/{hero_id}", response_model=HeroPublic)
    def update_hero(hero_id: int, hero: HeroUpdate, session: SessionDep):
        hero_db = session.get(Hero, hero_id)
        if not hero_db:
            raise HTTPException(status_code=404, detail="Hero not found")
        hero_data = hero.model_dump(exclude_unset=True)
        hero_db.sqlmodel_update(hero_data)
        session.add(hero_db)
        session.commit()
        session.refresh(hero_db)
        return hero_db
    
    
    @app.delete("/heroes/{hero_id}")
    def delete_hero(hero_id: int, session: SessionDep):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        session.delete(hero)
        session.commit()
        return {"ok": True}
    

ü§ì Other versions and variants

Python 3.9+Python 3.10+ - non-AnnotatedPython 3.9+ - non-Annotated
    
    
    from typing import Annotated, Union
    
    from fastapi import Depends, FastAPI, HTTPException, Query
    from sqlmodel import Field, Session, SQLModel, create_engine, select
    
    
    class HeroBase(SQLModel):
        name: str = Field(index=True)
        age: Union[int, None] = Field(default=None, index=True)
    
    
    class Hero(HeroBase, table=True):
        id: Union[int, None] = Field(default=None, primary_key=True)
        secret_name: str
    
    
    class HeroPublic(HeroBase):
        id: int
    
    
    class HeroCreate(HeroBase):
        secret_name: str
    
    
    class HeroUpdate(HeroBase):
        name: Union[str, None] = None
        age: Union[int, None] = None
        secret_name: Union[str, None] = None
    
    
    sqlite_file_name = "database.db"
    sqlite_url = f"sqlite:///{sqlite_file_name}"
    
    connect_args = {"check_same_thread": False}
    engine = create_engine(sqlite_url, connect_args=connect_args)
    
    
    def create_db_and_tables():
        SQLModel.metadata.create_all(engine)
    
    
    def get_session():
        with Session(engine) as session:
            yield session
    
    
    SessionDep = Annotated[Session, Depends(get_session)]
    app = FastAPI()
    
    
    @app.on_event("startup")
    def on_startup():
        create_db_and_tables()
    
    
    @app.post("/heroes/", response_model=HeroPublic)
    def create_hero(hero: HeroCreate, session: SessionDep):
        db_hero = Hero.model_validate(hero)
        session.add(db_hero)
        session.commit()
        session.refresh(db_hero)
        return db_hero
    
    
    @app.get("/heroes/", response_model=list[HeroPublic])
    def read_heroes(
        session: SessionDep,
        offset: int = 0,
        limit: Annotated[int, Query(le=100)] = 100,
    ):
        heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
        return heroes
    
    
    @app.get("/heroes/{hero_id}", response_model=HeroPublic)
    def read_hero(hero_id: int, session: SessionDep):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        return hero
    
    
    @app.patch("/heroes/{hero_id}", response_model=HeroPublic)
    def update_hero(hero_id: int, hero: HeroUpdate, session: SessionDep):
        hero_db = session.get(Hero, hero_id)
        if not hero_db:
            raise HTTPException(status_code=404, detail="Hero not found")
        hero_data = hero.model_dump(exclude_unset=True)
        hero_db.sqlmodel_update(hero_data)
        session.add(hero_db)
        session.commit()
        session.refresh(hero_db)
        return hero_db
    
    
    @app.delete("/heroes/{hero_id}")
    def delete_hero(hero_id: int, session: SessionDep):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        session.delete(hero)
        session.commit()
        return {"ok": True}
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import Depends, FastAPI, HTTPException, Query
    from sqlmodel import Field, Session, SQLModel, create_engine, select
    
    
    class HeroBase(SQLModel):
        name: str = Field(index=True)
        age: int | None = Field(default=None, index=True)
    
    
    class Hero(HeroBase, table=True):
        id: int | None = Field(default=None, primary_key=True)
        secret_name: str
    
    
    class HeroPublic(HeroBase):
        id: int
    
    
    class HeroCreate(HeroBase):
        secret_name: str
    
    
    class HeroUpdate(HeroBase):
        name: str | None = None
        age: int | None = None
        secret_name: str | None = None
    
    
    sqlite_file_name = "database.db"
    sqlite_url = f"sqlite:///{sqlite_file_name}"
    
    connect_args = {"check_same_thread": False}
    engine = create_engine(sqlite_url, connect_args=connect_args)
    
    
    def create_db_and_tables():
        SQLModel.metadata.create_all(engine)
    
    
    def get_session():
        with Session(engine) as session:
            yield session
    
    
    app = FastAPI()
    
    
    @app.on_event("startup")
    def on_startup():
        create_db_and_tables()
    
    
    @app.post("/heroes/", response_model=HeroPublic)
    def create_hero(hero: HeroCreate, session: Session = Depends(get_session)):
        db_hero = Hero.model_validate(hero)
        session.add(db_hero)
        session.commit()
        session.refresh(db_hero)
        return db_hero
    
    
    @app.get("/heroes/", response_model=list[HeroPublic])
    def read_heroes(
        session: Session = Depends(get_session),
        offset: int = 0,
        limit: int = Query(default=100, le=100),
    ):
        heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
        return heroes
    
    
    @app.get("/heroes/{hero_id}", response_model=HeroPublic)
    def read_hero(hero_id: int, session: Session = Depends(get_session)):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        return hero
    
    
    @app.patch("/heroes/{hero_id}", response_model=HeroPublic)
    def update_hero(
        hero_id: int, hero: HeroUpdate, session: Session = Depends(get_session)
    ):
        hero_db = session.get(Hero, hero_id)
        if not hero_db:
            raise HTTPException(status_code=404, detail="Hero not found")
        hero_data = hero.model_dump(exclude_unset=True)
        hero_db.sqlmodel_update(hero_data)
        session.add(hero_db)
        session.commit()
        session.refresh(hero_db)
        return hero_db
    
    
    @app.delete("/heroes/{hero_id}")
    def delete_hero(hero_id: int, session: Session = Depends(get_session)):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        session.delete(hero)
        session.commit()
        return {"ok": True}
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from typing import Union
    
    from fastapi import Depends, FastAPI, HTTPException, Query
    from sqlmodel import Field, Session, SQLModel, create_engine, select
    
    
    class HeroBase(SQLModel):
        name: str = Field(index=True)
        age: Union[int, None] = Field(default=None, index=True)
    
    
    class Hero(HeroBase, table=True):
        id: Union[int, None] = Field(default=None, primary_key=True)
        secret_name: str
    
    
    class HeroPublic(HeroBase):
        id: int
    
    
    class HeroCreate(HeroBase):
        secret_name: str
    
    
    class HeroUpdate(HeroBase):
        name: Union[str, None] = None
        age: Union[int, None] = None
        secret_name: Union[str, None] = None
    
    
    sqlite_file_name = "database.db"
    sqlite_url = f"sqlite:///{sqlite_file_name}"
    
    connect_args = {"check_same_thread": False}
    engine = create_engine(sqlite_url, connect_args=connect_args)
    
    
    def create_db_and_tables():
        SQLModel.metadata.create_all(engine)
    
    
    def get_session():
        with Session(engine) as session:
            yield session
    
    
    app = FastAPI()
    
    
    @app.on_event("startup")
    def on_startup():
        create_db_and_tables()
    
    
    @app.post("/heroes/", response_model=HeroPublic)
    def create_hero(hero: HeroCreate, session: Session = Depends(get_session)):
        db_hero = Hero.model_validate(hero)
        session.add(db_hero)
        session.commit()
        session.refresh(db_hero)
        return db_hero
    
    
    @app.get("/heroes/", response_model=list[HeroPublic])
    def read_heroes(
        session: Session = Depends(get_session),
        offset: int = 0,
        limit: int = Query(default=100, le=100),
    ):
        heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
        return heroes
    
    
    @app.get("/heroes/{hero_id}", response_model=HeroPublic)
    def read_hero(hero_id: int, session: Session = Depends(get_session)):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        return hero
    
    
    @app.patch("/heroes/{hero_id}", response_model=HeroPublic)
    def update_hero(
        hero_id: int, hero: HeroUpdate, session: Session = Depends(get_session)
    ):
        hero_db = session.get(Hero, hero_id)
        if not hero_db:
            raise HTTPException(status_code=404, detail="Hero not found")
        hero_data = hero.model_dump(exclude_unset=True)
        hero_db.sqlmodel_update(hero_data)
        session.add(hero_db)
        session.commit()
        session.refresh(hero_db)
        return hero_db
    
    
    @app.delete("/heroes/{hero_id}")
    def delete_hero(hero_id: int, session: Session = Depends(get_session)):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        session.delete(hero)
        session.commit()
        return {"ok": True}
    

### Read One Hero with `HeroPublic`[¶](#read-one-hero-with-heropublic "Permanent link")

We can **read** a single hero:

Python 3.10+
    
    
    # Code above omitted üëÜ
    
    @app.get("/heroes/{hero_id}", response_model=HeroPublic)
    def read_hero(hero_id: int, session: SessionDep):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        return hero
    
    # Code below omitted üëá
    

üëÄ Full file preview

Python 3.10+
    
    
    from typing import Annotated
    
    from fastapi import Depends, FastAPI, HTTPException, Query
    from sqlmodel import Field, Session, SQLModel, create_engine, select
    
    
    class HeroBase(SQLModel):
        name: str = Field(index=True)
        age: int | None = Field(default=None, index=True)
    
    
    class Hero(HeroBase, table=True):
        id: int | None = Field(default=None, primary_key=True)
        secret_name: str
    
    
    class HeroPublic(HeroBase):
        id: int
    
    
    class HeroCreate(HeroBase):
        secret_name: str
    
    
    class HeroUpdate(HeroBase):
        name: str | None = None
        age: int | None = None
        secret_name: str | None = None
    
    
    sqlite_file_name = "database.db"
    sqlite_url = f"sqlite:///{sqlite_file_name}"
    
    connect_args = {"check_same_thread": False}
    engine = create_engine(sqlite_url, connect_args=connect_args)
    
    
    def create_db_and_tables():
        SQLModel.metadata.create_all(engine)
    
    
    def get_session():
        with Session(engine) as session:
            yield session
    
    
    SessionDep = Annotated[Session, Depends(get_session)]
    app = FastAPI()
    
    
    @app.on_event("startup")
    def on_startup():
        create_db_and_tables()
    
    
    @app.post("/heroes/", response_model=HeroPublic)
    def create_hero(hero: HeroCreate, session: SessionDep):
        db_hero = Hero.model_validate(hero)
        session.add(db_hero)
        session.commit()
        session.refresh(db_hero)
        return db_hero
    
    
    @app.get("/heroes/", response_model=list[HeroPublic])
    def read_heroes(
        session: SessionDep,
        offset: int = 0,
        limit: Annotated[int, Query(le=100)] = 100,
    ):
        heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
        return heroes
    
    
    @app.get("/heroes/{hero_id}", response_model=HeroPublic)
    def read_hero(hero_id: int, session: SessionDep):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        return hero
    
    
    @app.patch("/heroes/{hero_id}", response_model=HeroPublic)
    def update_hero(hero_id: int, hero: HeroUpdate, session: SessionDep):
        hero_db = session.get(Hero, hero_id)
        if not hero_db:
            raise HTTPException(status_code=404, detail="Hero not found")
        hero_data = hero.model_dump(exclude_unset=True)
        hero_db.sqlmodel_update(hero_data)
        session.add(hero_db)
        session.commit()
        session.refresh(hero_db)
        return hero_db
    
    
    @app.delete("/heroes/{hero_id}")
    def delete_hero(hero_id: int, session: SessionDep):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        session.delete(hero)
        session.commit()
        return {"ok": True}
    

ü§ì Other versions and variants

Python 3.9+Python 3.10+ - non-AnnotatedPython 3.9+ - non-Annotated
    
    
    from typing import Annotated, Union
    
    from fastapi import Depends, FastAPI, HTTPException, Query
    from sqlmodel import Field, Session, SQLModel, create_engine, select
    
    
    class HeroBase(SQLModel):
        name: str = Field(index=True)
        age: Union[int, None] = Field(default=None, index=True)
    
    
    class Hero(HeroBase, table=True):
        id: Union[int, None] = Field(default=None, primary_key=True)
        secret_name: str
    
    
    class HeroPublic(HeroBase):
        id: int
    
    
    class HeroCreate(HeroBase):
        secret_name: str
    
    
    class HeroUpdate(HeroBase):
        name: Union[str, None] = None
        age: Union[int, None] = None
        secret_name: Union[str, None] = None
    
    
    sqlite_file_name = "database.db"
    sqlite_url = f"sqlite:///{sqlite_file_name}"
    
    connect_args = {"check_same_thread": False}
    engine = create_engine(sqlite_url, connect_args=connect_args)
    
    
    def create_db_and_tables():
        SQLModel.metadata.create_all(engine)
    
    
    def get_session():
        with Session(engine) as session:
            yield session
    
    
    SessionDep = Annotated[Session, Depends(get_session)]
    app = FastAPI()
    
    
    @app.on_event("startup")
    def on_startup():
        create_db_and_tables()
    
    
    @app.post("/heroes/", response_model=HeroPublic)
    def create_hero(hero: HeroCreate, session: SessionDep):
        db_hero = Hero.model_validate(hero)
        session.add(db_hero)
        session.commit()
        session.refresh(db_hero)
        return db_hero
    
    
    @app.get("/heroes/", response_model=list[HeroPublic])
    def read_heroes(
        session: SessionDep,
        offset: int = 0,
        limit: Annotated[int, Query(le=100)] = 100,
    ):
        heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
        return heroes
    
    
    @app.get("/heroes/{hero_id}", response_model=HeroPublic)
    def read_hero(hero_id: int, session: SessionDep):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        return hero
    
    
    @app.patch("/heroes/{hero_id}", response_model=HeroPublic)
    def update_hero(hero_id: int, hero: HeroUpdate, session: SessionDep):
        hero_db = session.get(Hero, hero_id)
        if not hero_db:
            raise HTTPException(status_code=404, detail="Hero not found")
        hero_data = hero.model_dump(exclude_unset=True)
        hero_db.sqlmodel_update(hero_data)
        session.add(hero_db)
        session.commit()
        session.refresh(hero_db)
        return hero_db
    
    
    @app.delete("/heroes/{hero_id}")
    def delete_hero(hero_id: int, session: SessionDep):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        session.delete(hero)
        session.commit()
        return {"ok": True}
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import Depends, FastAPI, HTTPException, Query
    from sqlmodel import Field, Session, SQLModel, create_engine, select
    
    
    class HeroBase(SQLModel):
        name: str = Field(index=True)
        age: int | None = Field(default=None, index=True)
    
    
    class Hero(HeroBase, table=True):
        id: int | None = Field(default=None, primary_key=True)
        secret_name: str
    
    
    class HeroPublic(HeroBase):
        id: int
    
    
    class HeroCreate(HeroBase):
        secret_name: str
    
    
    class HeroUpdate(HeroBase):
        name: str | None = None
        age: int | None = None
        secret_name: str | None = None
    
    
    sqlite_file_name = "database.db"
    sqlite_url = f"sqlite:///{sqlite_file_name}"
    
    connect_args = {"check_same_thread": False}
    engine = create_engine(sqlite_url, connect_args=connect_args)
    
    
    def create_db_and_tables():
        SQLModel.metadata.create_all(engine)
    
    
    def get_session():
        with Session(engine) as session:
            yield session
    
    
    app = FastAPI()
    
    
    @app.on_event("startup")
    def on_startup():
        create_db_and_tables()
    
    
    @app.post("/heroes/", response_model=HeroPublic)
    def create_hero(hero: HeroCreate, session: Session = Depends(get_session)):
        db_hero = Hero.model_validate(hero)
        session.add(db_hero)
        session.commit()
        session.refresh(db_hero)
        return db_hero
    
    
    @app.get("/heroes/", response_model=list[HeroPublic])
    def read_heroes(
        session: Session = Depends(get_session),
        offset: int = 0,
        limit: int = Query(default=100, le=100),
    ):
        heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
        return heroes
    
    
    @app.get("/heroes/{hero_id}", response_model=HeroPublic)
    def read_hero(hero_id: int, session: Session = Depends(get_session)):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        return hero
    
    
    @app.patch("/heroes/{hero_id}", response_model=HeroPublic)
    def update_hero(
        hero_id: int, hero: HeroUpdate, session: Session = Depends(get_session)
    ):
        hero_db = session.get(Hero, hero_id)
        if not hero_db:
            raise HTTPException(status_code=404, detail="Hero not found")
        hero_data = hero.model_dump(exclude_unset=True)
        hero_db.sqlmodel_update(hero_data)
        session.add(hero_db)
        session.commit()
        session.refresh(hero_db)
        return hero_db
    
    
    @app.delete("/heroes/{hero_id}")
    def delete_hero(hero_id: int, session: Session = Depends(get_session)):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        session.delete(hero)
        session.commit()
        return {"ok": True}
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from typing import Union
    
    from fastapi import Depends, FastAPI, HTTPException, Query
    from sqlmodel import Field, Session, SQLModel, create_engine, select
    
    
    class HeroBase(SQLModel):
        name: str = Field(index=True)
        age: Union[int, None] = Field(default=None, index=True)
    
    
    class Hero(HeroBase, table=True):
        id: Union[int, None] = Field(default=None, primary_key=True)
        secret_name: str
    
    
    class HeroPublic(HeroBase):
        id: int
    
    
    class HeroCreate(HeroBase):
        secret_name: str
    
    
    class HeroUpdate(HeroBase):
        name: Union[str, None] = None
        age: Union[int, None] = None
        secret_name: Union[str, None] = None
    
    
    sqlite_file_name = "database.db"
    sqlite_url = f"sqlite:///{sqlite_file_name}"
    
    connect_args = {"check_same_thread": False}
    engine = create_engine(sqlite_url, connect_args=connect_args)
    
    
    def create_db_and_tables():
        SQLModel.metadata.create_all(engine)
    
    
    def get_session():
        with Session(engine) as session:
            yield session
    
    
    app = FastAPI()
    
    
    @app.on_event("startup")
    def on_startup():
        create_db_and_tables()
    
    
    @app.post("/heroes/", response_model=HeroPublic)
    def create_hero(hero: HeroCreate, session: Session = Depends(get_session)):
        db_hero = Hero.model_validate(hero)
        session.add(db_hero)
        session.commit()
        session.refresh(db_hero)
        return db_hero
    
    
    @app.get("/heroes/", response_model=list[HeroPublic])
    def read_heroes(
        session: Session = Depends(get_session),
        offset: int = 0,
        limit: int = Query(default=100, le=100),
    ):
        heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
        return heroes
    
    
    @app.get("/heroes/{hero_id}", response_model=HeroPublic)
    def read_hero(hero_id: int, session: Session = Depends(get_session)):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        return hero
    
    
    @app.patch("/heroes/{hero_id}", response_model=HeroPublic)
    def update_hero(
        hero_id: int, hero: HeroUpdate, session: Session = Depends(get_session)
    ):
        hero_db = session.get(Hero, hero_id)
        if not hero_db:
            raise HTTPException(status_code=404, detail="Hero not found")
        hero_data = hero.model_dump(exclude_unset=True)
        hero_db.sqlmodel_update(hero_data)
        session.add(hero_db)
        session.commit()
        session.refresh(hero_db)
        return hero_db
    
    
    @app.delete("/heroes/{hero_id}")
    def delete_hero(hero_id: int, session: Session = Depends(get_session)):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        session.delete(hero)
        session.commit()
        return {"ok": True}
    

### Update a Hero with `HeroUpdate`[¶](#update-a-hero-with-heroupdate "Permanent link")

We can **update a hero**. For this we use an HTTP `PATCH` operation.

And in the code, we get a `dict` with all the data sent by the client, **only the data sent by the client** , excluding any values that would be there just for being the default values. To do it we use `exclude_unset=True`. This is the main trick. ü™Ñ

Then we use `hero_db.sqlmodel_update(hero_data)` to update the `hero_db` with the data from `hero_data`.

Python 3.10+
    
    
    # Code above omitted üëÜ
    
    @app.patch("/heroes/{hero_id}", response_model=HeroPublic)
    def update_hero(hero_id: int, hero: HeroUpdate, session: SessionDep):
        hero_db = session.get(Hero, hero_id)
        if not hero_db:
            raise HTTPException(status_code=404, detail="Hero not found")
        hero_data = hero.model_dump(exclude_unset=True)
        hero_db.sqlmodel_update(hero_data)
        session.add(hero_db)
        session.commit()
        session.refresh(hero_db)
        return hero_db
    
    # Code below omitted üëá
    

üëÄ Full file preview

Python 3.10+
    
    
    from typing import Annotated
    
    from fastapi import Depends, FastAPI, HTTPException, Query
    from sqlmodel import Field, Session, SQLModel, create_engine, select
    
    
    class HeroBase(SQLModel):
        name: str = Field(index=True)
        age: int | None = Field(default=None, index=True)
    
    
    class Hero(HeroBase, table=True):
        id: int | None = Field(default=None, primary_key=True)
        secret_name: str
    
    
    class HeroPublic(HeroBase):
        id: int
    
    
    class HeroCreate(HeroBase):
        secret_name: str
    
    
    class HeroUpdate(HeroBase):
        name: str | None = None
        age: int | None = None
        secret_name: str | None = None
    
    
    sqlite_file_name = "database.db"
    sqlite_url = f"sqlite:///{sqlite_file_name}"
    
    connect_args = {"check_same_thread": False}
    engine = create_engine(sqlite_url, connect_args=connect_args)
    
    
    def create_db_and_tables():
        SQLModel.metadata.create_all(engine)
    
    
    def get_session():
        with Session(engine) as session:
            yield session
    
    
    SessionDep = Annotated[Session, Depends(get_session)]
    app = FastAPI()
    
    
    @app.on_event("startup")
    def on_startup():
        create_db_and_tables()
    
    
    @app.post("/heroes/", response_model=HeroPublic)
    def create_hero(hero: HeroCreate, session: SessionDep):
        db_hero = Hero.model_validate(hero)
        session.add(db_hero)
        session.commit()
        session.refresh(db_hero)
        return db_hero
    
    
    @app.get("/heroes/", response_model=list[HeroPublic])
    def read_heroes(
        session: SessionDep,
        offset: int = 0,
        limit: Annotated[int, Query(le=100)] = 100,
    ):
        heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
        return heroes
    
    
    @app.get("/heroes/{hero_id}", response_model=HeroPublic)
    def read_hero(hero_id: int, session: SessionDep):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        return hero
    
    
    @app.patch("/heroes/{hero_id}", response_model=HeroPublic)
    def update_hero(hero_id: int, hero: HeroUpdate, session: SessionDep):
        hero_db = session.get(Hero, hero_id)
        if not hero_db:
            raise HTTPException(status_code=404, detail="Hero not found")
        hero_data = hero.model_dump(exclude_unset=True)
        hero_db.sqlmodel_update(hero_data)
        session.add(hero_db)
        session.commit()
        session.refresh(hero_db)
        return hero_db
    
    
    @app.delete("/heroes/{hero_id}")
    def delete_hero(hero_id: int, session: SessionDep):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        session.delete(hero)
        session.commit()
        return {"ok": True}
    

ü§ì Other versions and variants

Python 3.9+Python 3.10+ - non-AnnotatedPython 3.9+ - non-Annotated
    
    
    from typing import Annotated, Union
    
    from fastapi import Depends, FastAPI, HTTPException, Query
    from sqlmodel import Field, Session, SQLModel, create_engine, select
    
    
    class HeroBase(SQLModel):
        name: str = Field(index=True)
        age: Union[int, None] = Field(default=None, index=True)
    
    
    class Hero(HeroBase, table=True):
        id: Union[int, None] = Field(default=None, primary_key=True)
        secret_name: str
    
    
    class HeroPublic(HeroBase):
        id: int
    
    
    class HeroCreate(HeroBase):
        secret_name: str
    
    
    class HeroUpdate(HeroBase):
        name: Union[str, None] = None
        age: Union[int, None] = None
        secret_name: Union[str, None] = None
    
    
    sqlite_file_name = "database.db"
    sqlite_url = f"sqlite:///{sqlite_file_name}"
    
    connect_args = {"check_same_thread": False}
    engine = create_engine(sqlite_url, connect_args=connect_args)
    
    
    def create_db_and_tables():
        SQLModel.metadata.create_all(engine)
    
    
    def get_session():
        with Session(engine) as session:
            yield session
    
    
    SessionDep = Annotated[Session, Depends(get_session)]
    app = FastAPI()
    
    
    @app.on_event("startup")
    def on_startup():
        create_db_and_tables()
    
    
    @app.post("/heroes/", response_model=HeroPublic)
    def create_hero(hero: HeroCreate, session: SessionDep):
        db_hero = Hero.model_validate(hero)
        session.add(db_hero)
        session.commit()
        session.refresh(db_hero)
        return db_hero
    
    
    @app.get("/heroes/", response_model=list[HeroPublic])
    def read_heroes(
        session: SessionDep,
        offset: int = 0,
        limit: Annotated[int, Query(le=100)] = 100,
    ):
        heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
        return heroes
    
    
    @app.get("/heroes/{hero_id}", response_model=HeroPublic)
    def read_hero(hero_id: int, session: SessionDep):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        return hero
    
    
    @app.patch("/heroes/{hero_id}", response_model=HeroPublic)
    def update_hero(hero_id: int, hero: HeroUpdate, session: SessionDep):
        hero_db = session.get(Hero, hero_id)
        if not hero_db:
            raise HTTPException(status_code=404, detail="Hero not found")
        hero_data = hero.model_dump(exclude_unset=True)
        hero_db.sqlmodel_update(hero_data)
        session.add(hero_db)
        session.commit()
        session.refresh(hero_db)
        return hero_db
    
    
    @app.delete("/heroes/{hero_id}")
    def delete_hero(hero_id: int, session: SessionDep):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        session.delete(hero)
        session.commit()
        return {"ok": True}
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import Depends, FastAPI, HTTPException, Query
    from sqlmodel import Field, Session, SQLModel, create_engine, select
    
    
    class HeroBase(SQLModel):
        name: str = Field(index=True)
        age: int | None = Field(default=None, index=True)
    
    
    class Hero(HeroBase, table=True):
        id: int | None = Field(default=None, primary_key=True)
        secret_name: str
    
    
    class HeroPublic(HeroBase):
        id: int
    
    
    class HeroCreate(HeroBase):
        secret_name: str
    
    
    class HeroUpdate(HeroBase):
        name: str | None = None
        age: int | None = None
        secret_name: str | None = None
    
    
    sqlite_file_name = "database.db"
    sqlite_url = f"sqlite:///{sqlite_file_name}"
    
    connect_args = {"check_same_thread": False}
    engine = create_engine(sqlite_url, connect_args=connect_args)
    
    
    def create_db_and_tables():
        SQLModel.metadata.create_all(engine)
    
    
    def get_session():
        with Session(engine) as session:
            yield session
    
    
    app = FastAPI()
    
    
    @app.on_event("startup")
    def on_startup():
        create_db_and_tables()
    
    
    @app.post("/heroes/", response_model=HeroPublic)
    def create_hero(hero: HeroCreate, session: Session = Depends(get_session)):
        db_hero = Hero.model_validate(hero)
        session.add(db_hero)
        session.commit()
        session.refresh(db_hero)
        return db_hero
    
    
    @app.get("/heroes/", response_model=list[HeroPublic])
    def read_heroes(
        session: Session = Depends(get_session),
        offset: int = 0,
        limit: int = Query(default=100, le=100),
    ):
        heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
        return heroes
    
    
    @app.get("/heroes/{hero_id}", response_model=HeroPublic)
    def read_hero(hero_id: int, session: Session = Depends(get_session)):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        return hero
    
    
    @app.patch("/heroes/{hero_id}", response_model=HeroPublic)
    def update_hero(
        hero_id: int, hero: HeroUpdate, session: Session = Depends(get_session)
    ):
        hero_db = session.get(Hero, hero_id)
        if not hero_db:
            raise HTTPException(status_code=404, detail="Hero not found")
        hero_data = hero.model_dump(exclude_unset=True)
        hero_db.sqlmodel_update(hero_data)
        session.add(hero_db)
        session.commit()
        session.refresh(hero_db)
        return hero_db
    
    
    @app.delete("/heroes/{hero_id}")
    def delete_hero(hero_id: int, session: Session = Depends(get_session)):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        session.delete(hero)
        session.commit()
        return {"ok": True}
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from typing import Union
    
    from fastapi import Depends, FastAPI, HTTPException, Query
    from sqlmodel import Field, Session, SQLModel, create_engine, select
    
    
    class HeroBase(SQLModel):
        name: str = Field(index=True)
        age: Union[int, None] = Field(default=None, index=True)
    
    
    class Hero(HeroBase, table=True):
        id: Union[int, None] = Field(default=None, primary_key=True)
        secret_name: str
    
    
    class HeroPublic(HeroBase):
        id: int
    
    
    class HeroCreate(HeroBase):
        secret_name: str
    
    
    class HeroUpdate(HeroBase):
        name: Union[str, None] = None
        age: Union[int, None] = None
        secret_name: Union[str, None] = None
    
    
    sqlite_file_name = "database.db"
    sqlite_url = f"sqlite:///{sqlite_file_name}"
    
    connect_args = {"check_same_thread": False}
    engine = create_engine(sqlite_url, connect_args=connect_args)
    
    
    def create_db_and_tables():
        SQLModel.metadata.create_all(engine)
    
    
    def get_session():
        with Session(engine) as session:
            yield session
    
    
    app = FastAPI()
    
    
    @app.on_event("startup")
    def on_startup():
        create_db_and_tables()
    
    
    @app.post("/heroes/", response_model=HeroPublic)
    def create_hero(hero: HeroCreate, session: Session = Depends(get_session)):
        db_hero = Hero.model_validate(hero)
        session.add(db_hero)
        session.commit()
        session.refresh(db_hero)
        return db_hero
    
    
    @app.get("/heroes/", response_model=list[HeroPublic])
    def read_heroes(
        session: Session = Depends(get_session),
        offset: int = 0,
        limit: int = Query(default=100, le=100),
    ):
        heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
        return heroes
    
    
    @app.get("/heroes/{hero_id}", response_model=HeroPublic)
    def read_hero(hero_id: int, session: Session = Depends(get_session)):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        return hero
    
    
    @app.patch("/heroes/{hero_id}", response_model=HeroPublic)
    def update_hero(
        hero_id: int, hero: HeroUpdate, session: Session = Depends(get_session)
    ):
        hero_db = session.get(Hero, hero_id)
        if not hero_db:
            raise HTTPException(status_code=404, detail="Hero not found")
        hero_data = hero.model_dump(exclude_unset=True)
        hero_db.sqlmodel_update(hero_data)
        session.add(hero_db)
        session.commit()
        session.refresh(hero_db)
        return hero_db
    
    
    @app.delete("/heroes/{hero_id}")
    def delete_hero(hero_id: int, session: Session = Depends(get_session)):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        session.delete(hero)
        session.commit()
        return {"ok": True}
    

### Delete a Hero Again[¶](#delete-a-hero-again "Permanent link")

**Deleting** a hero stays pretty much the same.

We won't satisfy the desire to refactor everything in this one. üòÖ

Python 3.10+
    
    
    # Code above omitted üëÜ
    
    @app.delete("/heroes/{hero_id}")
    def delete_hero(hero_id: int, session: SessionDep):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        session.delete(hero)
        session.commit()
        return {"ok": True}
    

üëÄ Full file preview

Python 3.10+
    
    
    from typing import Annotated
    
    from fastapi import Depends, FastAPI, HTTPException, Query
    from sqlmodel import Field, Session, SQLModel, create_engine, select
    
    
    class HeroBase(SQLModel):
        name: str = Field(index=True)
        age: int | None = Field(default=None, index=True)
    
    
    class Hero(HeroBase, table=True):
        id: int | None = Field(default=None, primary_key=True)
        secret_name: str
    
    
    class HeroPublic(HeroBase):
        id: int
    
    
    class HeroCreate(HeroBase):
        secret_name: str
    
    
    class HeroUpdate(HeroBase):
        name: str | None = None
        age: int | None = None
        secret_name: str | None = None
    
    
    sqlite_file_name = "database.db"
    sqlite_url = f"sqlite:///{sqlite_file_name}"
    
    connect_args = {"check_same_thread": False}
    engine = create_engine(sqlite_url, connect_args=connect_args)
    
    
    def create_db_and_tables():
        SQLModel.metadata.create_all(engine)
    
    
    def get_session():
        with Session(engine) as session:
            yield session
    
    
    SessionDep = Annotated[Session, Depends(get_session)]
    app = FastAPI()
    
    
    @app.on_event("startup")
    def on_startup():
        create_db_and_tables()
    
    
    @app.post("/heroes/", response_model=HeroPublic)
    def create_hero(hero: HeroCreate, session: SessionDep):
        db_hero = Hero.model_validate(hero)
        session.add(db_hero)
        session.commit()
        session.refresh(db_hero)
        return db_hero
    
    
    @app.get("/heroes/", response_model=list[HeroPublic])
    def read_heroes(
        session: SessionDep,
        offset: int = 0,
        limit: Annotated[int, Query(le=100)] = 100,
    ):
        heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
        return heroes
    
    
    @app.get("/heroes/{hero_id}", response_model=HeroPublic)
    def read_hero(hero_id: int, session: SessionDep):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        return hero
    
    
    @app.patch("/heroes/{hero_id}", response_model=HeroPublic)
    def update_hero(hero_id: int, hero: HeroUpdate, session: SessionDep):
        hero_db = session.get(Hero, hero_id)
        if not hero_db:
            raise HTTPException(status_code=404, detail="Hero not found")
        hero_data = hero.model_dump(exclude_unset=True)
        hero_db.sqlmodel_update(hero_data)
        session.add(hero_db)
        session.commit()
        session.refresh(hero_db)
        return hero_db
    
    
    @app.delete("/heroes/{hero_id}")
    def delete_hero(hero_id: int, session: SessionDep):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        session.delete(hero)
        session.commit()
        return {"ok": True}
    

ü§ì Other versions and variants

Python 3.9+Python 3.10+ - non-AnnotatedPython 3.9+ - non-Annotated
    
    
    from typing import Annotated, Union
    
    from fastapi import Depends, FastAPI, HTTPException, Query
    from sqlmodel import Field, Session, SQLModel, create_engine, select
    
    
    class HeroBase(SQLModel):
        name: str = Field(index=True)
        age: Union[int, None] = Field(default=None, index=True)
    
    
    class Hero(HeroBase, table=True):
        id: Union[int, None] = Field(default=None, primary_key=True)
        secret_name: str
    
    
    class HeroPublic(HeroBase):
        id: int
    
    
    class HeroCreate(HeroBase):
        secret_name: str
    
    
    class HeroUpdate(HeroBase):
        name: Union[str, None] = None
        age: Union[int, None] = None
        secret_name: Union[str, None] = None
    
    
    sqlite_file_name = "database.db"
    sqlite_url = f"sqlite:///{sqlite_file_name}"
    
    connect_args = {"check_same_thread": False}
    engine = create_engine(sqlite_url, connect_args=connect_args)
    
    
    def create_db_and_tables():
        SQLModel.metadata.create_all(engine)
    
    
    def get_session():
        with Session(engine) as session:
            yield session
    
    
    SessionDep = Annotated[Session, Depends(get_session)]
    app = FastAPI()
    
    
    @app.on_event("startup")
    def on_startup():
        create_db_and_tables()
    
    
    @app.post("/heroes/", response_model=HeroPublic)
    def create_hero(hero: HeroCreate, session: SessionDep):
        db_hero = Hero.model_validate(hero)
        session.add(db_hero)
        session.commit()
        session.refresh(db_hero)
        return db_hero
    
    
    @app.get("/heroes/", response_model=list[HeroPublic])
    def read_heroes(
        session: SessionDep,
        offset: int = 0,
        limit: Annotated[int, Query(le=100)] = 100,
    ):
        heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
        return heroes
    
    
    @app.get("/heroes/{hero_id}", response_model=HeroPublic)
    def read_hero(hero_id: int, session: SessionDep):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        return hero
    
    
    @app.patch("/heroes/{hero_id}", response_model=HeroPublic)
    def update_hero(hero_id: int, hero: HeroUpdate, session: SessionDep):
        hero_db = session.get(Hero, hero_id)
        if not hero_db:
            raise HTTPException(status_code=404, detail="Hero not found")
        hero_data = hero.model_dump(exclude_unset=True)
        hero_db.sqlmodel_update(hero_data)
        session.add(hero_db)
        session.commit()
        session.refresh(hero_db)
        return hero_db
    
    
    @app.delete("/heroes/{hero_id}")
    def delete_hero(hero_id: int, session: SessionDep):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        session.delete(hero)
        session.commit()
        return {"ok": True}
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import Depends, FastAPI, HTTPException, Query
    from sqlmodel import Field, Session, SQLModel, create_engine, select
    
    
    class HeroBase(SQLModel):
        name: str = Field(index=True)
        age: int | None = Field(default=None, index=True)
    
    
    class Hero(HeroBase, table=True):
        id: int | None = Field(default=None, primary_key=True)
        secret_name: str
    
    
    class HeroPublic(HeroBase):
        id: int
    
    
    class HeroCreate(HeroBase):
        secret_name: str
    
    
    class HeroUpdate(HeroBase):
        name: str | None = None
        age: int | None = None
        secret_name: str | None = None
    
    
    sqlite_file_name = "database.db"
    sqlite_url = f"sqlite:///{sqlite_file_name}"
    
    connect_args = {"check_same_thread": False}
    engine = create_engine(sqlite_url, connect_args=connect_args)
    
    
    def create_db_and_tables():
        SQLModel.metadata.create_all(engine)
    
    
    def get_session():
        with Session(engine) as session:
            yield session
    
    
    app = FastAPI()
    
    
    @app.on_event("startup")
    def on_startup():
        create_db_and_tables()
    
    
    @app.post("/heroes/", response_model=HeroPublic)
    def create_hero(hero: HeroCreate, session: Session = Depends(get_session)):
        db_hero = Hero.model_validate(hero)
        session.add(db_hero)
        session.commit()
        session.refresh(db_hero)
        return db_hero
    
    
    @app.get("/heroes/", response_model=list[HeroPublic])
    def read_heroes(
        session: Session = Depends(get_session),
        offset: int = 0,
        limit: int = Query(default=100, le=100),
    ):
        heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
        return heroes
    
    
    @app.get("/heroes/{hero_id}", response_model=HeroPublic)
    def read_hero(hero_id: int, session: Session = Depends(get_session)):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        return hero
    
    
    @app.patch("/heroes/{hero_id}", response_model=HeroPublic)
    def update_hero(
        hero_id: int, hero: HeroUpdate, session: Session = Depends(get_session)
    ):
        hero_db = session.get(Hero, hero_id)
        if not hero_db:
            raise HTTPException(status_code=404, detail="Hero not found")
        hero_data = hero.model_dump(exclude_unset=True)
        hero_db.sqlmodel_update(hero_data)
        session.add(hero_db)
        session.commit()
        session.refresh(hero_db)
        return hero_db
    
    
    @app.delete("/heroes/{hero_id}")
    def delete_hero(hero_id: int, session: Session = Depends(get_session)):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        session.delete(hero)
        session.commit()
        return {"ok": True}
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from typing import Union
    
    from fastapi import Depends, FastAPI, HTTPException, Query
    from sqlmodel import Field, Session, SQLModel, create_engine, select
    
    
    class HeroBase(SQLModel):
        name: str = Field(index=True)
        age: Union[int, None] = Field(default=None, index=True)
    
    
    class Hero(HeroBase, table=True):
        id: Union[int, None] = Field(default=None, primary_key=True)
        secret_name: str
    
    
    class HeroPublic(HeroBase):
        id: int
    
    
    class HeroCreate(HeroBase):
        secret_name: str
    
    
    class HeroUpdate(HeroBase):
        name: Union[str, None] = None
        age: Union[int, None] = None
        secret_name: Union[str, None] = None
    
    
    sqlite_file_name = "database.db"
    sqlite_url = f"sqlite:///{sqlite_file_name}"
    
    connect_args = {"check_same_thread": False}
    engine = create_engine(sqlite_url, connect_args=connect_args)
    
    
    def create_db_and_tables():
        SQLModel.metadata.create_all(engine)
    
    
    def get_session():
        with Session(engine) as session:
            yield session
    
    
    app = FastAPI()
    
    
    @app.on_event("startup")
    def on_startup():
        create_db_and_tables()
    
    
    @app.post("/heroes/", response_model=HeroPublic)
    def create_hero(hero: HeroCreate, session: Session = Depends(get_session)):
        db_hero = Hero.model_validate(hero)
        session.add(db_hero)
        session.commit()
        session.refresh(db_hero)
        return db_hero
    
    
    @app.get("/heroes/", response_model=list[HeroPublic])
    def read_heroes(
        session: Session = Depends(get_session),
        offset: int = 0,
        limit: int = Query(default=100, le=100),
    ):
        heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
        return heroes
    
    
    @app.get("/heroes/{hero_id}", response_model=HeroPublic)
    def read_hero(hero_id: int, session: Session = Depends(get_session)):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        return hero
    
    
    @app.patch("/heroes/{hero_id}", response_model=HeroPublic)
    def update_hero(
        hero_id: int, hero: HeroUpdate, session: Session = Depends(get_session)
    ):
        hero_db = session.get(Hero, hero_id)
        if not hero_db:
            raise HTTPException(status_code=404, detail="Hero not found")
        hero_data = hero.model_dump(exclude_unset=True)
        hero_db.sqlmodel_update(hero_data)
        session.add(hero_db)
        session.commit()
        session.refresh(hero_db)
        return hero_db
    
    
    @app.delete("/heroes/{hero_id}")
    def delete_hero(hero_id: int, session: Session = Depends(get_session)):
        hero = session.get(Hero, hero_id)
        if not hero:
            raise HTTPException(status_code=404, detail="Hero not found")
        session.delete(hero)
        session.commit()
        return {"ok": True}
    

### Run the App Again[¶](#run-the-app-again "Permanent link")

You can run the app again:
    
    
    $ fastapi dev main.py
    
    <span style="color: green;">INFO</span>:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
    

If you go to the `/docs` API UI, you will see that it is now updated, and it won't expect to receive the `id` from the client when creating a hero, etc.

![](/img/tutorial/sql-databases/image02.png)

## Recap[¶](#recap "Permanent link")

You can use [**SQLModel**](https://sqlmodel.tiangolo.com/) to interact with a SQL database and simplify the code with _data models_ and _table models_.

You can learn a lot more at the **SQLModel** docs, there's a longer mini [tutorial on using SQLModel with **FastAPI**](https://sqlmodel.tiangolo.com/tutorial/fastapi/). üöÄ
  *["ORMs"]: Object Relational Mapper: a fancy term for a library where some classes represent SQL tables and instances represent rows in those tables

---

###### Bigger Applications - Multiple Files¶

# Bigger Applications - Multiple Files[¶](#bigger-applications-multiple-files "Permanent link")

If you are building an application or a web API, it's rarely the case that you can put everything in a single file.

**FastAPI** provides a convenience tool to structure your application while keeping all the flexibility.

Info

If you come from Flask, this would be the equivalent of Flask's Blueprints.

## An example file structure[¶](#an-example-file-structure "Permanent link")

Let's say you have a file structure like this:
    
    
    .
    ‚îú‚îÄ‚îÄ app
    ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ __init__.py
    ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ main.py
    ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ dependencies.py
    ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ routers
    ‚îÇ¬†¬† ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
    ‚îÇ¬†¬† ‚îÇ   ‚îú‚îÄ‚îÄ items.py
    ‚îÇ¬†¬† ‚îÇ   ‚îî‚îÄ‚îÄ users.py
    ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ internal
    ‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ __init__.py
    ‚îÇ¬†¬†     ‚îî‚îÄ‚îÄ admin.py
    

Tip

There are several `__init__.py` files: one in each directory or subdirectory.

This is what allows importing code from one file into another.

For example, in `app/main.py` you could have a line like:
    
    
    from app.routers import items
    

  * The `app` directory contains everything. And it has an empty file `app/__init__.py`, so it is a "Python package" (a collection of "Python modules"): `app`.
  * It contains an `app/main.py` file. As it is inside a Python package (a directory with a file `__init__.py`), it is a "module" of that package: `app.main`.
  * There's also an `app/dependencies.py` file, just like `app/main.py`, it is a "module": `app.dependencies`.
  * There's a subdirectory `app/routers/` with another file `__init__.py`, so it's a "Python subpackage": `app.routers`.
  * The file `app/routers/items.py` is inside a package, `app/routers/`, so, it's a submodule: `app.routers.items`.
  * The same with `app/routers/users.py`, it's another submodule: `app.routers.users`.
  * There's also a subdirectory `app/internal/` with another file `__init__.py`, so it's another "Python subpackage": `app.internal`.
  * And the file `app/internal/admin.py` is another submodule: `app.internal.admin`.

![](/img/tutorial/bigger-applications/package.drawio.svg)

The same file structure with comments:
    
    
    .
    ‚îú‚îÄ‚îÄ app                  # "app" is a Python package
    ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ __init__.py      # this file makes "app" a "Python package"
    ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ main.py          # "main" module, e.g. import app.main
    ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ dependencies.py  # "dependencies" module, e.g. import app.dependencies
    ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ routers          # "routers" is a "Python subpackage"
    ‚îÇ¬†¬† ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py  # makes "routers" a "Python subpackage"
    ‚îÇ¬†¬† ‚îÇ   ‚îú‚îÄ‚îÄ items.py     # "items" submodule, e.g. import app.routers.items
    ‚îÇ¬†¬† ‚îÇ   ‚îî‚îÄ‚îÄ users.py     # "users" submodule, e.g. import app.routers.users
    ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ internal         # "internal" is a "Python subpackage"
    ‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ __init__.py  # makes "internal" a "Python subpackage"
    ‚îÇ¬†¬†     ‚îî‚îÄ‚îÄ admin.py     # "admin" submodule, e.g. import app.internal.admin
    

## `APIRouter`[¶](#apirouter "Permanent link")

Let's say the file dedicated to handling just users is the submodule at `/app/routers/users.py`.

You want to have the _path operations_ related to your users separated from the rest of the code, to keep it organized.

But it's still part of the same **FastAPI** application/web API (it's part of the same "Python Package").

You can create the _path operations_ for that module using `APIRouter`.

### Import `APIRouter`[¶](#import-apirouter "Permanent link")

You import it and create an "instance" the same way you would with the class `FastAPI`:

Python 3.8+

app/routers/users.py
    
    
    from fastapi import APIRouter
    
    router = APIRouter()
    
    
    @router.get("/users/", tags=["users"])
    async def read_users():
        return [{"username": "Rick"}, {"username": "Morty"}]
    
    
    @router.get("/users/me", tags=["users"])
    async def read_user_me():
        return {"username": "fakecurrentuser"}
    
    
    @router.get("/users/{username}", tags=["users"])
    async def read_user(username: str):
        return {"username": username}
    

### _Path operations_ with `APIRouter`[¶](#path-operations-with-apirouter "Permanent link")

And then you use it to declare your _path operations_.

Use it the same way you would use the `FastAPI` class:

Python 3.8+

app/routers/users.py
    
    
    from fastapi import APIRouter
    
    router = APIRouter()
    
    
    @router.get("/users/", tags=["users"])
    async def read_users():
        return [{"username": "Rick"}, {"username": "Morty"}]
    
    
    @router.get("/users/me", tags=["users"])
    async def read_user_me():
        return {"username": "fakecurrentuser"}
    
    
    @router.get("/users/{username}", tags=["users"])
    async def read_user(username: str):
        return {"username": username}
    

You can think of `APIRouter` as a "mini `FastAPI`" class.

All the same options are supported.

All the same `parameters`, `responses`, `dependencies`, `tags`, etc.

Tip

In this example, the variable is called `router`, but you can name it however you want.

We are going to include this `APIRouter` in the main `FastAPI` app, but first, let's check the dependencies and another `APIRouter`.

## Dependencies[¶](#dependencies "Permanent link")

We see that we are going to need some dependencies used in several places of the application.

So we put them in their own `dependencies` module (`app/dependencies.py`).

We will now use a simple dependency to read a custom `X-Token` header:

Python 3.9+

app/dependencies.py
    
    
    from typing import Annotated
    
    from fastapi import Header, HTTPException
    
    
    async def get_token_header(x_token: Annotated[str, Header()]):
        if x_token != "fake-super-secret-token":
            raise HTTPException(status_code=400, detail="X-Token header invalid")
    
    
    async def get_query_token(token: str):
        if token != "jessica":
            raise HTTPException(status_code=400, detail="No Jessica token provided")
    

ü§ì Other versions and variants

Python 3.9+ - non-Annotated

Tip

Prefer to use the `Annotated` version if possible.

app/dependencies.py
    
    
    from fastapi import Header, HTTPException
    
    
    async def get_token_header(x_token: str = Header()):
        if x_token != "fake-super-secret-token":
            raise HTTPException(status_code=400, detail="X-Token header invalid")
    
    
    async def get_query_token(token: str):
        if token != "jessica":
            raise HTTPException(status_code=400, detail="No Jessica token provided")
    

Tip

We are using an invented header to simplify this example.

But in real cases you will get better results using the integrated [Security utilities](../security/).

## Another module with `APIRouter`[¶](#another-module-with-apirouter "Permanent link")

Let's say you also have the endpoints dedicated to handling "items" from your application in the module at `app/routers/items.py`.

You have _path operations_ for:

  * `/items/`
  * `/items/{item_id}`

It's all the same structure as with `app/routers/users.py`.

But we want to be smarter and simplify the code a bit.

We know all the _path operations_ in this module have the same:

  * Path `prefix`: `/items`.
  * `tags`: (just one tag: `items`).
  * Extra `responses`.
  * `dependencies`: they all need that `X-Token` dependency we created.

So, instead of adding all that to each _path operation_ , we can add it to the `APIRouter`.

Python 3.8+

app/routers/items.py
    
    
    from fastapi import APIRouter, Depends, HTTPException
    
    from ..dependencies import get_token_header
    
    router = APIRouter(
        prefix="/items",
        tags=["items"],
        dependencies=[Depends(get_token_header)],
        responses={404: {"description": "Not found"}},
    )
    
    
    fake_items_db = {"plumbus": {"name": "Plumbus"}, "gun": {"name": "Portal Gun"}}
    
    
    @router.get("/")
    async def read_items():
        return fake_items_db
    
    
    @router.get("/{item_id}")
    async def read_item(item_id: str):
        if item_id not in fake_items_db:
            raise HTTPException(status_code=404, detail="Item not found")
        return {"name": fake_items_db[item_id]["name"], "item_id": item_id}
    
    
    @router.put(
        "/{item_id}",
        tags=["custom"],
        responses={403: {"description": "Operation forbidden"}},
    )
    async def update_item(item_id: str):
        if item_id != "plumbus":
            raise HTTPException(
                status_code=403, detail="You can only update the item: plumbus"
            )
        return {"item_id": item_id, "name": "The great Plumbus"}
    

As the path of each _path operation_ has to start with `/`, like in:
    
    
    @router.get("/{item_id}")
    async def read_item(item_id: str):
        ...
    

...the prefix must not include a final `/`.

So, the prefix in this case is `/items`.

We can also add a list of `tags` and extra `responses` that will be applied to all the _path operations_ included in this router.

And we can add a list of `dependencies` that will be added to all the _path operations_ in the router and will be executed/solved for each request made to them.

Tip

Note that, much like [dependencies in _path operation decorators_](../dependencies/dependencies-in-path-operation-decorators/), no value will be passed to your _path operation function_.

The end result is that the item paths are now:

  * `/items/`
  * `/items/{item_id}`

...as we intended.

  * They will be marked with a list of tags that contain a single string `"items"`.
    * These "tags" are especially useful for the automatic interactive documentation systems (using OpenAPI).
  * All of them will include the predefined `responses`.
  * All these _path operations_ will have the list of `dependencies` evaluated/executed before them.
    * If you also declare dependencies in a specific _path operation_ , **they will be executed too**.
    * The router dependencies are executed first, then the [`dependencies` in the decorator](../dependencies/dependencies-in-path-operation-decorators/), and then the normal parameter dependencies.
    * You can also add [`Security` dependencies with `scopes`](../../advanced/security/oauth2-scopes/).

Tip

Having `dependencies` in the `APIRouter` can be used, for example, to require authentication for a whole group of _path operations_. Even if the dependencies are not added individually to each one of them.

Check

The `prefix`, `tags`, `responses`, and `dependencies` parameters are (as in many other cases) just a feature from **FastAPI** to help you avoid code duplication.

### Import the dependencies[¶](#import-the-dependencies "Permanent link")

This code lives in the module `app.routers.items`, the file `app/routers/items.py`.

And we need to get the dependency function from the module `app.dependencies`, the file `app/dependencies.py`.

So we use a relative import with `..` for the dependencies:

Python 3.8+

app/routers/items.py
    
    
    from fastapi import APIRouter, Depends, HTTPException
    
    from ..dependencies import get_token_header
    
    router = APIRouter(
        prefix="/items",
        tags=["items"],
        dependencies=[Depends(get_token_header)],
        responses={404: {"description": "Not found"}},
    )
    
    
    fake_items_db = {"plumbus": {"name": "Plumbus"}, "gun": {"name": "Portal Gun"}}
    
    
    @router.get("/")
    async def read_items():
        return fake_items_db
    
    
    @router.get("/{item_id}")
    async def read_item(item_id: str):
        if item_id not in fake_items_db:
            raise HTTPException(status_code=404, detail="Item not found")
        return {"name": fake_items_db[item_id]["name"], "item_id": item_id}
    
    
    @router.put(
        "/{item_id}",
        tags=["custom"],
        responses={403: {"description": "Operation forbidden"}},
    )
    async def update_item(item_id: str):
        if item_id != "plumbus":
            raise HTTPException(
                status_code=403, detail="You can only update the item: plumbus"
            )
        return {"item_id": item_id, "name": "The great Plumbus"}
    

#### How relative imports work[¶](#how-relative-imports-work "Permanent link")

Tip

If you know perfectly how imports work, continue to the next section below.

A single dot `.`, like in:
    
    
    from .dependencies import get_token_header
    

would mean:

  * Starting in the same package that this module (the file `app/routers/items.py`) lives in (the directory `app/routers/`)...
  * find the module `dependencies` (an imaginary file at `app/routers/dependencies.py`)...
  * and from it, import the function `get_token_header`.

But that file doesn't exist, our dependencies are in a file at `app/dependencies.py`.

Remember how our app/file structure looks like:

![](/img/tutorial/bigger-applications/package.drawio.svg)

* * *

The two dots `..`, like in:
    
    
    from ..dependencies import get_token_header
    

mean:

  * Starting in the same package that this module (the file `app/routers/items.py`) lives in (the directory `app/routers/`)...
  * go to the parent package (the directory `app/`)...
  * and in there, find the module `dependencies` (the file at `app/dependencies.py`)...
  * and from it, import the function `get_token_header`.

That works correctly! üéâ

* * *

The same way, if we had used three dots `...`, like in:
    
    
    from ...dependencies import get_token_header
    

that would mean:

  * Starting in the same package that this module (the file `app/routers/items.py`) lives in (the directory `app/routers/`)...
  * go to the parent package (the directory `app/`)...
  * then go to the parent of that package (there's no parent package, `app` is the top level üò±)...
  * and in there, find the module `dependencies` (the file at `app/dependencies.py`)...
  * and from it, import the function `get_token_header`.

That would refer to some package above `app/`, with its own file `__init__.py`, etc. But we don't have that. So, that would throw an error in our example. üö®

But now you know how it works, so you can use relative imports in your own apps no matter how complex they are. ü§ì

### Add some custom `tags`, `responses`, and `dependencies`[¶](#add-some-custom-tags-responses-and-dependencies "Permanent link")

We are not adding the prefix `/items` nor the `tags=["items"]` to each _path operation_ because we added them to the `APIRouter`.

But we can still add _more_ `tags` that will be applied to a specific _path operation_ , and also some extra `responses` specific to that _path operation_ :

Python 3.8+

app/routers/items.py
    
    
    from fastapi import APIRouter, Depends, HTTPException
    
    from ..dependencies import get_token_header
    
    router = APIRouter(
        prefix="/items",
        tags=["items"],
        dependencies=[Depends(get_token_header)],
        responses={404: {"description": "Not found"}},
    )
    
    
    fake_items_db = {"plumbus": {"name": "Plumbus"}, "gun": {"name": "Portal Gun"}}
    
    
    @router.get("/")
    async def read_items():
        return fake_items_db
    
    
    @router.get("/{item_id}")
    async def read_item(item_id: str):
        if item_id not in fake_items_db:
            raise HTTPException(status_code=404, detail="Item not found")
        return {"name": fake_items_db[item_id]["name"], "item_id": item_id}
    
    
    @router.put(
        "/{item_id}",
        tags=["custom"],
        responses={403: {"description": "Operation forbidden"}},
    )
    async def update_item(item_id: str):
        if item_id != "plumbus":
            raise HTTPException(
                status_code=403, detail="You can only update the item: plumbus"
            )
        return {"item_id": item_id, "name": "The great Plumbus"}
    

Tip

This last path operation will have the combination of tags: `["items", "custom"]`.

And it will also have both responses in the documentation, one for `404` and one for `403`.

## The main `FastAPI`[¶](#the-main-fastapi "Permanent link")

Now, let's see the module at `app/main.py`.

Here's where you import and use the class `FastAPI`.

This will be the main file in your application that ties everything together.

And as most of your logic will now live in its own specific module, the main file will be quite simple.

### Import `FastAPI`[¶](#import-fastapi "Permanent link")

You import and create a `FastAPI` class as normally.

And we can even declare [global dependencies](../dependencies/global-dependencies/) that will be combined with the dependencies for each `APIRouter`:

Python 3.9+

app/main.py
    
    
    from fastapi import Depends, FastAPI
    
    from .dependencies import get_query_token, get_token_header
    from .internal import admin
    from .routers import items, users
    
    app = FastAPI(dependencies=[Depends(get_query_token)])
    
    
    app.include_router(users.router)
    app.include_router(items.router)
    app.include_router(
        admin.router,
        prefix="/admin",
        tags=["admin"],
        dependencies=[Depends(get_token_header)],
        responses={418: {"description": "I'm a teapot"}},
    )
    
    
    @app.get("/")
    async def root():
        return {"message": "Hello Bigger Applications!"}
    

ü§ì Other versions and variants

Python 3.9+ - non-Annotated

Tip

Prefer to use the `Annotated` version if possible.

app/main.py
    
    
    from fastapi import Depends, FastAPI
    
    from .dependencies import get_query_token, get_token_header
    from .internal import admin
    from .routers import items, users
    
    app = FastAPI(dependencies=[Depends(get_query_token)])
    
    
    app.include_router(users.router)
    app.include_router(items.router)
    app.include_router(
        admin.router,
        prefix="/admin",
        tags=["admin"],
        dependencies=[Depends(get_token_header)],
        responses={418: {"description": "I'm a teapot"}},
    )
    
    
    @app.get("/")
    async def root():
        return {"message": "Hello Bigger Applications!"}
    

### Import the `APIRouter`[¶](#import-the-apirouter "Permanent link")

Now we import the other submodules that have `APIRouter`s:

Python 3.9+

app/main.py
    
    
    from fastapi import Depends, FastAPI
    
    from .dependencies import get_query_token, get_token_header
    from .internal import admin
    from .routers import items, users
    
    app = FastAPI(dependencies=[Depends(get_query_token)])
    
    
    app.include_router(users.router)
    app.include_router(items.router)
    app.include_router(
        admin.router,
        prefix="/admin",
        tags=["admin"],
        dependencies=[Depends(get_token_header)],
        responses={418: {"description": "I'm a teapot"}},
    )
    
    
    @app.get("/")
    async def root():
        return {"message": "Hello Bigger Applications!"}
    

ü§ì Other versions and variants

Python 3.9+ - non-Annotated

Tip

Prefer to use the `Annotated` version if possible.

app/main.py
    
    
    from fastapi import Depends, FastAPI
    
    from .dependencies import get_query_token, get_token_header
    from .internal import admin
    from .routers import items, users
    
    app = FastAPI(dependencies=[Depends(get_query_token)])
    
    
    app.include_router(users.router)
    app.include_router(items.router)
    app.include_router(
        admin.router,
        prefix="/admin",
        tags=["admin"],
        dependencies=[Depends(get_token_header)],
        responses={418: {"description": "I'm a teapot"}},
    )
    
    
    @app.get("/")
    async def root():
        return {"message": "Hello Bigger Applications!"}
    

As the files `app/routers/users.py` and `app/routers/items.py` are submodules that are part of the same Python package `app`, we can use a single dot `.` to import them using "relative imports".

### How the importing works[¶](#how-the-importing-works "Permanent link")

The section:
    
    
    from .routers import items, users
    

means:

  * Starting in the same package that this module (the file `app/main.py`) lives in (the directory `app/`)...
  * look for the subpackage `routers` (the directory at `app/routers/`)...
  * and from it, import the submodule `items` (the file at `app/routers/items.py`) and `users` (the file at `app/routers/users.py`)...

The module `items` will have a variable `router` (`items.router`). This is the same one we created in the file `app/routers/items.py`, it's an `APIRouter` object.

And then we do the same for the module `users`.

We could also import them like:
    
    
    from app.routers import items, users
    

Info

The first version is a "relative import":
    
    
    from .routers import items, users
    

The second version is an "absolute import":
    
    
    from app.routers import items, users
    

To learn more about Python Packages and Modules, read [the official Python documentation about Modules](https://docs.python.org/3/tutorial/modules.html).

### Avoid name collisions[¶](#avoid-name-collisions "Permanent link")

We are importing the submodule `items` directly, instead of importing just its variable `router`.

This is because we also have another variable named `router` in the submodule `users`.

If we had imported one after the other, like:
    
    
    from .routers.items import router
    from .routers.users import router
    

the `router` from `users` would overwrite the one from `items` and we wouldn't be able to use them at the same time.

So, to be able to use both of them in the same file, we import the submodules directly:

Python 3.9+

app/main.py
    
    
    from fastapi import Depends, FastAPI
    
    from .dependencies import get_query_token, get_token_header
    from .internal import admin
    from .routers import items, users
    
    app = FastAPI(dependencies=[Depends(get_query_token)])
    
    
    app.include_router(users.router)
    app.include_router(items.router)
    app.include_router(
        admin.router,
        prefix="/admin",
        tags=["admin"],
        dependencies=[Depends(get_token_header)],
        responses={418: {"description": "I'm a teapot"}},
    )
    
    
    @app.get("/")
    async def root():
        return {"message": "Hello Bigger Applications!"}
    

ü§ì Other versions and variants

Python 3.9+ - non-Annotated

Tip

Prefer to use the `Annotated` version if possible.

app/main.py
    
    
    from fastapi import Depends, FastAPI
    
    from .dependencies import get_query_token, get_token_header
    from .internal import admin
    from .routers import items, users
    
    app = FastAPI(dependencies=[Depends(get_query_token)])
    
    
    app.include_router(users.router)
    app.include_router(items.router)
    app.include_router(
        admin.router,
        prefix="/admin",
        tags=["admin"],
        dependencies=[Depends(get_token_header)],
        responses={418: {"description": "I'm a teapot"}},
    )
    
    
    @app.get("/")
    async def root():
        return {"message": "Hello Bigger Applications!"}
    

### Include the `APIRouter`s for `users` and `items`[¶](#include-the-apirouters-for-users-and-items "Permanent link")

Now, let's include the `router`s from the submodules `users` and `items`:

Python 3.9+

app/main.py
    
    
    from fastapi import Depends, FastAPI
    
    from .dependencies import get_query_token, get_token_header
    from .internal import admin
    from .routers import items, users
    
    app = FastAPI(dependencies=[Depends(get_query_token)])
    
    
    app.include_router(users.router)
    app.include_router(items.router)
    app.include_router(
        admin.router,
        prefix="/admin",
        tags=["admin"],
        dependencies=[Depends(get_token_header)],
        responses={418: {"description": "I'm a teapot"}},
    )
    
    
    @app.get("/")
    async def root():
        return {"message": "Hello Bigger Applications!"}
    

ü§ì Other versions and variants

Python 3.9+ - non-Annotated

Tip

Prefer to use the `Annotated` version if possible.

app/main.py
    
    
    from fastapi import Depends, FastAPI
    
    from .dependencies import get_query_token, get_token_header
    from .internal import admin
    from .routers import items, users
    
    app = FastAPI(dependencies=[Depends(get_query_token)])
    
    
    app.include_router(users.router)
    app.include_router(items.router)
    app.include_router(
        admin.router,
        prefix="/admin",
        tags=["admin"],
        dependencies=[Depends(get_token_header)],
        responses={418: {"description": "I'm a teapot"}},
    )
    
    
    @app.get("/")
    async def root():
        return {"message": "Hello Bigger Applications!"}
    

Info

`users.router` contains the `APIRouter` inside of the file `app/routers/users.py`.

And `items.router` contains the `APIRouter` inside of the file `app/routers/items.py`.

With `app.include_router()` we can add each `APIRouter` to the main `FastAPI` application.

It will include all the routes from that router as part of it.

Technical Details

It will actually internally create a _path operation_ for each _path operation_ that was declared in the `APIRouter`.

So, behind the scenes, it will actually work as if everything was the same single app.

Check

You don't have to worry about performance when including routers.

This will take microseconds and will only happen at startup.

So it won't affect performance. ‚ö°

### Include an `APIRouter` with a custom `prefix`, `tags`, `responses`, and `dependencies`[¶](#include-an-apirouter-with-a-custom-prefix-tags-responses-and-dependencies "Permanent link")

Now, let's imagine your organization gave you the `app/internal/admin.py` file.

It contains an `APIRouter` with some admin _path operations_ that your organization shares between several projects.

For this example it will be super simple. But let's say that because it is shared with other projects in the organization, we cannot modify it and add a `prefix`, `dependencies`, `tags`, etc. directly to the `APIRouter`:

Python 3.8+

app/internal/admin.py
    
    
    from fastapi import APIRouter
    
    router = APIRouter()
    
    
    @router.post("/")
    async def update_admin():
        return {"message": "Admin getting schwifty"}
    

But we still want to set a custom `prefix` when including the `APIRouter` so that all its _path operations_ start with `/admin`, we want to secure it with the `dependencies` we already have for this project, and we want to include `tags` and `responses`.

We can declare all that without having to modify the original `APIRouter` by passing those parameters to `app.include_router()`:

Python 3.9+

app/main.py
    
    
    from fastapi import Depends, FastAPI
    
    from .dependencies import get_query_token, get_token_header
    from .internal import admin
    from .routers import items, users
    
    app = FastAPI(dependencies=[Depends(get_query_token)])
    
    
    app.include_router(users.router)
    app.include_router(items.router)
    app.include_router(
        admin.router,
        prefix="/admin",
        tags=["admin"],
        dependencies=[Depends(get_token_header)],
        responses={418: {"description": "I'm a teapot"}},
    )
    
    
    @app.get("/")
    async def root():
        return {"message": "Hello Bigger Applications!"}
    

ü§ì Other versions and variants

Python 3.9+ - non-Annotated

Tip

Prefer to use the `Annotated` version if possible.

app/main.py
    
    
    from fastapi import Depends, FastAPI
    
    from .dependencies import get_query_token, get_token_header
    from .internal import admin
    from .routers import items, users
    
    app = FastAPI(dependencies=[Depends(get_query_token)])
    
    
    app.include_router(users.router)
    app.include_router(items.router)
    app.include_router(
        admin.router,
        prefix="/admin",
        tags=["admin"],
        dependencies=[Depends(get_token_header)],
        responses={418: {"description": "I'm a teapot"}},
    )
    
    
    @app.get("/")
    async def root():
        return {"message": "Hello Bigger Applications!"}
    

That way, the original `APIRouter` will stay unmodified, so we can still share that same `app/internal/admin.py` file with other projects in the organization.

The result is that in our app, each of the _path operations_ from the `admin` module will have:

  * The prefix `/admin`.
  * The tag `admin`.
  * The dependency `get_token_header`.
  * The response `418`. üçµ

But that will only affect that `APIRouter` in our app, not in any other code that uses it.

So, for example, other projects could use the same `APIRouter` with a different authentication method.

### Include a _path operation_[¶](#include-a-path-operation "Permanent link")

We can also add _path operations_ directly to the `FastAPI` app.

Here we do it... just to show that we can ü§∑:

Python 3.9+

app/main.py
    
    
    from fastapi import Depends, FastAPI
    
    from .dependencies import get_query_token, get_token_header
    from .internal import admin
    from .routers import items, users
    
    app = FastAPI(dependencies=[Depends(get_query_token)])
    
    
    app.include_router(users.router)
    app.include_router(items.router)
    app.include_router(
        admin.router,
        prefix="/admin",
        tags=["admin"],
        dependencies=[Depends(get_token_header)],
        responses={418: {"description": "I'm a teapot"}},
    )
    
    
    @app.get("/")
    async def root():
        return {"message": "Hello Bigger Applications!"}
    

ü§ì Other versions and variants

Python 3.9+ - non-Annotated

Tip

Prefer to use the `Annotated` version if possible.

app/main.py
    
    
    from fastapi import Depends, FastAPI
    
    from .dependencies import get_query_token, get_token_header
    from .internal import admin
    from .routers import items, users
    
    app = FastAPI(dependencies=[Depends(get_query_token)])
    
    
    app.include_router(users.router)
    app.include_router(items.router)
    app.include_router(
        admin.router,
        prefix="/admin",
        tags=["admin"],
        dependencies=[Depends(get_token_header)],
        responses={418: {"description": "I'm a teapot"}},
    )
    
    
    @app.get("/")
    async def root():
        return {"message": "Hello Bigger Applications!"}
    

and it will work correctly, together with all the other _path operations_ added with `app.include_router()`.

Very Technical Details

**Note** : this is a very technical detail that you probably can **just skip**.

* * *

The `APIRouter`s are not "mounted", they are not isolated from the rest of the application.

This is because we want to include their _path operations_ in the OpenAPI schema and the user interfaces.

As we cannot just isolate them and "mount" them independently of the rest, the _path operations_ are "cloned" (re-created), not included directly.

## Check the automatic API docs[¶](#check-the-automatic-api-docs "Permanent link")

Now, run your app:
    
    
    $ fastapi dev app/main.py
    
    <span style="color: green;">INFO</span>:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
    

And open the docs at <http://127.0.0.1:8000/docs>.

You will see the automatic API docs, including the paths from all the submodules, using the correct paths (and prefixes) and the correct tags:

![](/img/tutorial/bigger-applications/image01.png)

## Include the same router multiple times with different `prefix`[¶](#include-the-same-router-multiple-times-with-different-prefix "Permanent link")

You can also use `.include_router()` multiple times with the _same_ router using different prefixes.

This could be useful, for example, to expose the same API under different prefixes, e.g. `/api/v1` and `/api/latest`.

This is an advanced usage that you might not really need, but it's there in case you do.

## Include an `APIRouter` in another[¶](#include-an-apirouter-in-another "Permanent link")

The same way you can include an `APIRouter` in a `FastAPI` application, you can include an `APIRouter` in another `APIRouter` using:
    
    
    router.include_router(other_router)
    

Make sure you do it before including `router` in the `FastAPI` app, so that the _path operations_ from `other_router` are also included.

---

###### Background Tasks¶

# Background Tasks[¶](#background-tasks "Permanent link")

You can define background tasks to be run _after_ returning a response.

This is useful for operations that need to happen after a request, but that the client doesn't really have to be waiting for the operation to complete before receiving the response.

This includes, for example:

  * Email notifications sent after performing an action:
    * As connecting to an email server and sending an email tends to be "slow" (several seconds), you can return the response right away and send the email notification in the background.
  * Processing data:
    * For example, let's say you receive a file that must go through a slow process, you can return a response of "Accepted" (HTTP 202) and process the file in the background.

## Using `BackgroundTasks`[¶](#using-backgroundtasks "Permanent link")

First, import `BackgroundTasks` and define a parameter in your _path operation function_ with a type declaration of `BackgroundTasks`:

Python 3.9+
    
    
    from fastapi import BackgroundTasks, FastAPI
    
    app = FastAPI()
    
    
    def write_notification(email: str, message=""):
        with open("log.txt", mode="w") as email_file:
            content = f"notification for {email}: {message}"
            email_file.write(content)
    
    
    @app.post("/send-notification/{email}")
    async def send_notification(email: str, background_tasks: BackgroundTasks):
        background_tasks.add_task(write_notification, email, message="some notification")
        return {"message": "Notification sent in the background"}
    

**FastAPI** will create the object of type `BackgroundTasks` for you and pass it as that parameter.

## Create a task function[¶](#create-a-task-function "Permanent link")

Create a function to be run as the background task.

It is just a standard function that can receive parameters.

It can be an `async def` or normal `def` function, **FastAPI** will know how to handle it correctly.

In this case, the task function will write to a file (simulating sending an email).

And as the write operation doesn't use `async` and `await`, we define the function with normal `def`:

Python 3.9+
    
    
    from fastapi import BackgroundTasks, FastAPI
    
    app = FastAPI()
    
    
    def write_notification(email: str, message=""):
        with open("log.txt", mode="w") as email_file:
            content = f"notification for {email}: {message}"
            email_file.write(content)
    
    
    @app.post("/send-notification/{email}")
    async def send_notification(email: str, background_tasks: BackgroundTasks):
        background_tasks.add_task(write_notification, email, message="some notification")
        return {"message": "Notification sent in the background"}
    

## Add the background task[¶](#add-the-background-task "Permanent link")

Inside of your _path operation function_ , pass your task function to the _background tasks_ object with the method `.add_task()`:

Python 3.9+
    
    
    from fastapi import BackgroundTasks, FastAPI
    
    app = FastAPI()
    
    
    def write_notification(email: str, message=""):
        with open("log.txt", mode="w") as email_file:
            content = f"notification for {email}: {message}"
            email_file.write(content)
    
    
    @app.post("/send-notification/{email}")
    async def send_notification(email: str, background_tasks: BackgroundTasks):
        background_tasks.add_task(write_notification, email, message="some notification")
        return {"message": "Notification sent in the background"}
    

`.add_task()` receives as arguments:

  * A task function to be run in the background (`write_notification`).
  * Any sequence of arguments that should be passed to the task function in order (`email`).
  * Any keyword arguments that should be passed to the task function (`message="some notification"`).

## Dependency Injection[¶](#dependency-injection "Permanent link")

Using `BackgroundTasks` also works with the dependency injection system, you can declare a parameter of type `BackgroundTasks` at multiple levels: in a _path operation function_ , in a dependency (dependable), in a sub-dependency, etc.

**FastAPI** knows what to do in each case and how to reuse the same object, so that all the background tasks are merged together and are run in the background afterwards:

Python 3.10+
    
    
    from typing import Annotated
    
    from fastapi import BackgroundTasks, Depends, FastAPI
    
    app = FastAPI()
    
    
    def write_log(message: str):
        with open("log.txt", mode="a") as log:
            log.write(message)
    
    
    def get_query(background_tasks: BackgroundTasks, q: str | None = None):
        if q:
            message = f"found query: {q}\n"
            background_tasks.add_task(write_log, message)
        return q
    
    
    @app.post("/send-notification/{email}")
    async def send_notification(
        email: str, background_tasks: BackgroundTasks, q: Annotated[str, Depends(get_query)]
    ):
        message = f"message to {email}\n"
        background_tasks.add_task(write_log, message)
        return {"message": "Message sent"}
    

ü§ì Other versions and variants

Python 3.9+Python 3.10+ - non-AnnotatedPython 3.9+ - non-Annotated
    
    
    from typing import Annotated, Union
    
    from fastapi import BackgroundTasks, Depends, FastAPI
    
    app = FastAPI()
    
    
    def write_log(message: str):
        with open("log.txt", mode="a") as log:
            log.write(message)
    
    
    def get_query(background_tasks: BackgroundTasks, q: Union[str, None] = None):
        if q:
            message = f"found query: {q}\n"
            background_tasks.add_task(write_log, message)
        return q
    
    
    @app.post("/send-notification/{email}")
    async def send_notification(
        email: str, background_tasks: BackgroundTasks, q: Annotated[str, Depends(get_query)]
    ):
        message = f"message to {email}\n"
        background_tasks.add_task(write_log, message)
        return {"message": "Message sent"}
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import BackgroundTasks, Depends, FastAPI
    
    app = FastAPI()
    
    
    def write_log(message: str):
        with open("log.txt", mode="a") as log:
            log.write(message)
    
    
    def get_query(background_tasks: BackgroundTasks, q: str | None = None):
        if q:
            message = f"found query: {q}\n"
            background_tasks.add_task(write_log, message)
        return q
    
    
    @app.post("/send-notification/{email}")
    async def send_notification(
        email: str, background_tasks: BackgroundTasks, q: str = Depends(get_query)
    ):
        message = f"message to {email}\n"
        background_tasks.add_task(write_log, message)
        return {"message": "Message sent"}
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from typing import Union
    
    from fastapi import BackgroundTasks, Depends, FastAPI
    
    app = FastAPI()
    
    
    def write_log(message: str):
        with open("log.txt", mode="a") as log:
            log.write(message)
    
    
    def get_query(background_tasks: BackgroundTasks, q: Union[str, None] = None):
        if q:
            message = f"found query: {q}\n"
            background_tasks.add_task(write_log, message)
        return q
    
    
    @app.post("/send-notification/{email}")
    async def send_notification(
        email: str, background_tasks: BackgroundTasks, q: str = Depends(get_query)
    ):
        message = f"message to {email}\n"
        background_tasks.add_task(write_log, message)
        return {"message": "Message sent"}
    

In this example, the messages will be written to the `log.txt` file _after_ the response is sent.

If there was a query in the request, it will be written to the log in a background task.

And then another background task generated at the _path operation function_ will write a message using the `email` path parameter.

## Technical Details[¶](#technical-details "Permanent link")

The class `BackgroundTasks` comes directly from [`starlette.background`](https://www.starlette.dev/background/).

It is imported/included directly into FastAPI so that you can import it from `fastapi` and avoid accidentally importing the alternative `BackgroundTask` (without the `s` at the end) from `starlette.background`.

By only using `BackgroundTasks` (and not `BackgroundTask`), it's then possible to use it as a _path operation function_ parameter and have **FastAPI** handle the rest for you, just like when using the `Request` object directly.

It's still possible to use `BackgroundTask` alone in FastAPI, but you have to create the object in your code and return a Starlette `Response` including it.

You can see more details in [Starlette's official docs for Background Tasks](https://www.starlette.dev/background/).

## Caveat[¶](#caveat "Permanent link")

If you need to perform heavy background computation and you don't necessarily need it to be run by the same process (for example, you don't need to share memory, variables, etc), you might benefit from using other bigger tools like [Celery](https://docs.celeryq.dev).

They tend to require more complex configurations, a message/job queue manager, like RabbitMQ or Redis, but they allow you to run background tasks in multiple processes, and especially, in multiple servers.

But if you need to access variables and objects from the same **FastAPI** app, or you need to perform small background tasks (like sending an email notification), you can simply just use `BackgroundTasks`.

## Recap[¶](#recap "Permanent link")

Import and use `BackgroundTasks` with parameters in _path operation functions_ and dependencies to add background tasks.

---

###### Metadata and Docs URLs¶

# Metadata and Docs URLs[¶](#metadata-and-docs-urls "Permanent link")

You can customize several metadata configurations in your **FastAPI** application.

## Metadata for API[¶](#metadata-for-api "Permanent link")

You can set the following fields that are used in the OpenAPI specification and the automatic API docs UIs:

Parameter | Type | Description  
---|---|---  
`title` | `str` | The title of the API.  
`summary` | `str` | A short summary of the API. Available since OpenAPI 3.1.0, FastAPI 0.99.0.  
`description` | `str` | A short description of the API. It can use Markdown.  
`version` | `string` | The version of the API. This is the version of your own application, not of OpenAPI. For example `2.5.0`.  
`terms_of_service` | `str` | A URL to the Terms of Service for the API. If provided, this has to be a URL.  
`contact` | `dict` | The contact information for the exposed API. It can contain several fields. `contact` fields| Parameter| Type| Description  
---|---|---  
`name`| `str`| The identifying name of the contact person/organization.  
`url`| `str`| The URL pointing to the contact information. MUST be in the format of a URL.  
`email`| `str`| The email address of the contact person/organization. MUST be in the format of an email address.  
`license_info` | `dict` | The license information for the exposed API. It can contain several fields. `license_info` fields| Parameter| Type| Description  
---|---|---  
`name`| `str`| **REQUIRED** (if a `license_info` is set). The license name used for the API.  
`identifier`| `str`| An [SPDX](https://spdx.org/licenses/) license expression for the API. The `identifier` field is mutually exclusive of the `url` field. Available since OpenAPI 3.1.0, FastAPI 0.99.0.  
`url`| `str`| A URL to the license used for the API. MUST be in the format of a URL.  
  
You can set them as follows:

Python 3.9+
    
    
    from fastapi import FastAPI
    
    description = """
    ChimichangApp API helps you do awesome stuff. üöÄ
    
    ## Items
    
    You can **read items**.
    
    ## Users
    
    You will be able to:
    
    * **Create users** (_not implemented_).
    * **Read users** (_not implemented_).
    """
    
    app = FastAPI(
        title="ChimichangApp",
        description=description,
        summary="Deadpool's favorite app. Nuff said.",
        version="0.0.1",
        terms_of_service="http://example.com/terms/",
        contact={
            "name": "Deadpoolio the Amazing",
            "url": "http://x-force.example.com/contact/",
            "email": "dp@x-force.example.com",
        },
        license_info={
            "name": "Apache 2.0",
            "url": "https://www.apache.org/licenses/LICENSE-2.0.html",
        },
    )
    
    
    @app.get("/items/")
    async def read_items():
        return [{"name": "Katana"}]
    

Tip

You can write Markdown in the `description` field and it will be rendered in the output.

With this configuration, the automatic API docs would look like:

![](/img/tutorial/metadata/image01.png)

## License identifier[¶](#license-identifier "Permanent link")

Since OpenAPI 3.1.0 and FastAPI 0.99.0, you can also set the `license_info` with an `identifier` instead of a `url`.

For example:

Python 3.9+
    
    
    from fastapi import FastAPI
    
    description = """
    ChimichangApp API helps you do awesome stuff. üöÄ
    
    ## Items
    
    You can **read items**.
    
    ## Users
    
    You will be able to:
    
    * **Create users** (_not implemented_).
    * **Read users** (_not implemented_).
    """
    
    app = FastAPI(
        title="ChimichangApp",
        description=description,
        summary="Deadpool's favorite app. Nuff said.",
        version="0.0.1",
        terms_of_service="http://example.com/terms/",
        contact={
            "name": "Deadpoolio the Amazing",
            "url": "http://x-force.example.com/contact/",
            "email": "dp@x-force.example.com",
        },
        license_info={
            "name": "Apache 2.0",
            "identifier": "Apache-2.0",
        },
    )
    
    
    @app.get("/items/")
    async def read_items():
        return [{"name": "Katana"}]
    

## Metadata for tags[¶](#metadata-for-tags "Permanent link")

You can also add additional metadata for the different tags used to group your path operations with the parameter `openapi_tags`.

It takes a list containing one dictionary for each tag.

Each dictionary can contain:

  * `name` (**required**): a `str` with the same tag name you use in the `tags` parameter in your _path operations_ and `APIRouter`s.
  * `description`: a `str` with a short description for the tag. It can have Markdown and will be shown in the docs UI.
  * `externalDocs`: a `dict` describing external documentation with:
    * `description`: a `str` with a short description for the external docs.
    * `url` (**required**): a `str` with the URL for the external documentation.

### Create metadata for tags[¶](#create-metadata-for-tags "Permanent link")

Let's try that in an example with tags for `users` and `items`.

Create metadata for your tags and pass it to the `openapi_tags` parameter:

Python 3.9+
    
    
    from fastapi import FastAPI
    
    tags_metadata = [
        {
            "name": "users",
            "description": "Operations with users. The **login** logic is also here.",
        },
        {
            "name": "items",
            "description": "Manage items. So _fancy_ they have their own docs.",
            "externalDocs": {
                "description": "Items external docs",
                "url": "https://fastapi.tiangolo.com/",
            },
        },
    ]
    
    app = FastAPI(openapi_tags=tags_metadata)
    
    
    @app.get("/users/", tags=["users"])
    async def get_users():
        return [{"name": "Harry"}, {"name": "Ron"}]
    
    
    @app.get("/items/", tags=["items"])
    async def get_items():
        return [{"name": "wand"}, {"name": "flying broom"}]
    

Notice that you can use Markdown inside of the descriptions, for example "login" will be shown in bold (**login**) and "fancy" will be shown in italics (_fancy_).

Tip

You don't have to add metadata for all the tags that you use.

### Use your tags[¶](#use-your-tags "Permanent link")

Use the `tags` parameter with your _path operations_ (and `APIRouter`s) to assign them to different tags:

Python 3.9+
    
    
    from fastapi import FastAPI
    
    tags_metadata = [
        {
            "name": "users",
            "description": "Operations with users. The **login** logic is also here.",
        },
        {
            "name": "items",
            "description": "Manage items. So _fancy_ they have their own docs.",
            "externalDocs": {
                "description": "Items external docs",
                "url": "https://fastapi.tiangolo.com/",
            },
        },
    ]
    
    app = FastAPI(openapi_tags=tags_metadata)
    
    
    @app.get("/users/", tags=["users"])
    async def get_users():
        return [{"name": "Harry"}, {"name": "Ron"}]
    
    
    @app.get("/items/", tags=["items"])
    async def get_items():
        return [{"name": "wand"}, {"name": "flying broom"}]
    

Info

Read more about tags in [Path Operation Configuration](../path-operation-configuration/#tags).

### Check the docs[¶](#check-the-docs "Permanent link")

Now, if you check the docs, they will show all the additional metadata:

![](/img/tutorial/metadata/image02.png)

### Order of tags[¶](#order-of-tags "Permanent link")

The order of each tag metadata dictionary also defines the order shown in the docs UI.

For example, even though `users` would go after `items` in alphabetical order, it is shown before them, because we added their metadata as the first dictionary in the list.

## OpenAPI URL[¶](#openapi-url "Permanent link")

By default, the OpenAPI schema is served at `/openapi.json`.

But you can configure it with the parameter `openapi_url`.

For example, to set it to be served at `/api/v1/openapi.json`:

Python 3.9+
    
    
    from fastapi import FastAPI
    
    app = FastAPI(openapi_url="/api/v1/openapi.json")
    
    
    @app.get("/items/")
    async def read_items():
        return [{"name": "Foo"}]
    

If you want to disable the OpenAPI schema completely you can set `openapi_url=None`, that will also disable the documentation user interfaces that use it.

## Docs URLs[¶](#docs-urls "Permanent link")

You can configure the two documentation user interfaces included:

  * **Swagger UI** : served at `/docs`.
    * You can set its URL with the parameter `docs_url`.
    * You can disable it by setting `docs_url=None`.
  * **ReDoc** : served at `/redoc`.
    * You can set its URL with the parameter `redoc_url`.
    * You can disable it by setting `redoc_url=None`.

For example, to set Swagger UI to be served at `/documentation` and disable ReDoc:

Python 3.9+
    
    
    from fastapi import FastAPI
    
    app = FastAPI(docs_url="/documentation", redoc_url=None)
    
    
    @app.get("/items/")
    async def read_items():
        return [{"name": "Foo"}]

---

###### Static Files¶

# Static Files[¶](#static-files "Permanent link")

You can serve static files automatically from a directory using `StaticFiles`.

## Use `StaticFiles`[¶](#use-staticfiles "Permanent link")

  * Import `StaticFiles`.
  * "Mount" a `StaticFiles()` instance in a specific path.

Python 3.9+
    
    
    from fastapi import FastAPI
    from fastapi.staticfiles import StaticFiles
    
    app = FastAPI()
    
    app.mount("/static", StaticFiles(directory="static"), name="static")
    

Technical Details

You could also use `from starlette.staticfiles import StaticFiles`.

**FastAPI** provides the same `starlette.staticfiles` as `fastapi.staticfiles` just as a convenience for you, the developer. But it actually comes directly from Starlette.

### What is "Mounting"[¶](#what-is-mounting "Permanent link")

"Mounting" means adding a complete "independent" application in a specific path, that then takes care of handling all the sub-paths.

This is different from using an `APIRouter` as a mounted application is completely independent. The OpenAPI and docs from your main application won't include anything from the mounted application, etc.

You can read more about this in the [Advanced User Guide](../../advanced/).

## Details[¶](#details "Permanent link")

The first `"/static"` refers to the sub-path this "sub-application" will be "mounted" on. So, any path that starts with `"/static"` will be handled by it.

The `directory="static"` refers to the name of the directory that contains your static files.

The `name="static"` gives it a name that can be used internally by **FastAPI**.

All these parameters can be different than "`static`", adjust them with the needs and specific details of your own application.

## More info[¶](#more-info "Permanent link")

For more details and options check [Starlette's docs about Static Files](https://www.starlette.dev/staticfiles/).

---

###### Testing¶

# Testing[¶](#testing "Permanent link")

Thanks to [Starlette](https://www.starlette.dev/testclient/), testing **FastAPI** applications is easy and enjoyable.

It is based on [HTTPX](https://www.python-httpx.org), which in turn is designed based on Requests, so it's very familiar and intuitive.

With it, you can use [pytest](https://docs.pytest.org/) directly with **FastAPI**.

## Using `TestClient`[¶](#using-testclient "Permanent link")

Info

To use `TestClient`, first install [`httpx`](https://www.python-httpx.org).

Make sure you create a [virtual environment](../../virtual-environments/), activate it, and then install it, for example:
    
    
    $ pip install httpx
    

Import `TestClient`.

Create a `TestClient` by passing your **FastAPI** application to it.

Create functions with a name that starts with `test_` (this is standard `pytest` conventions).

Use the `TestClient` object the same way as you do with `httpx`.

Write simple `assert` statements with the standard Python expressions that you need to check (again, standard `pytest`).

Python 3.9+
    
    
    from fastapi import FastAPI
    from fastapi.testclient import TestClient
    
    app = FastAPI()
    
    
    @app.get("/")
    async def read_main():
        return {"msg": "Hello World"}
    
    
    client = TestClient(app)
    
    
    def test_read_main():
        response = client.get("/")
        assert response.status_code == 200
        assert response.json() == {"msg": "Hello World"}
    

Tip

Notice that the testing functions are normal `def`, not `async def`.

And the calls to the client are also normal calls, not using `await`.

This allows you to use `pytest` directly without complications.

Technical Details

You could also use `from starlette.testclient import TestClient`.

**FastAPI** provides the same `starlette.testclient` as `fastapi.testclient` just as a convenience for you, the developer. But it comes directly from Starlette.

Tip

If you want to call `async` functions in your tests apart from sending requests to your FastAPI application (e.g. asynchronous database functions), have a look at the [Async Tests](../../advanced/async-tests/) in the advanced tutorial.

## Separating tests[¶](#separating-tests "Permanent link")

In a real application, you probably would have your tests in a different file.

And your **FastAPI** application might also be composed of several files/modules, etc.

### **FastAPI** app file[¶](#fastapi-app-file "Permanent link")

Let's say you have a file structure as described in [Bigger Applications](../bigger-applications/):
    
    
    .
    ‚îú‚îÄ‚îÄ app
    ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ __init__.py
    ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ main.py
    

In the file `main.py` you have your **FastAPI** app:

Python 3.9+
    
    
    from fastapi import FastAPI
    
    app = FastAPI()
    
    
    @app.get("/")
    async def read_main():
        return {"msg": "Hello World"}
    

### Testing file[¶](#testing-file "Permanent link")

Then you could have a file `test_main.py` with your tests. It could live on the same Python package (the same directory with a `__init__.py` file):
    
    
    .
    ‚îú‚îÄ‚îÄ app
    ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ __init__.py
    ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ main.py
    ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ test_main.py
    

Because this file is in the same package, you can use relative imports to import the object `app` from the `main` module (`main.py`):

Python 3.9+
    
    
    from fastapi.testclient import TestClient
    
    from .main import app
    
    client = TestClient(app)
    
    
    def test_read_main():
        response = client.get("/")
        assert response.status_code == 200
        assert response.json() == {"msg": "Hello World"}
    

...and have the code for the tests just like before.

## Testing: extended example[¶](#testing-extended-example "Permanent link")

Now let's extend this example and add more details to see how to test different parts.

### Extended **FastAPI** app file[¶](#extended-fastapi-app-file "Permanent link")

Let's continue with the same file structure as before:
    
    
    .
    ‚îú‚îÄ‚îÄ app
    ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ __init__.py
    ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ main.py
    ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ test_main.py
    

Let's say that now the file `main.py` with your **FastAPI** app has some other **path operations**.

It has a `GET` operation that could return an error.

It has a `POST` operation that could return several errors.

Both _path operations_ require an `X-Token` header.

Python 3.10+
    
    
    from typing import Annotated
    
    from fastapi import FastAPI, Header, HTTPException
    from pydantic import BaseModel
    
    fake_secret_token = "coneofsilence"
    
    fake_db = {
        "foo": {"id": "foo", "title": "Foo", "description": "There goes my hero"},
        "bar": {"id": "bar", "title": "Bar", "description": "The bartenders"},
    }
    
    app = FastAPI()
    
    
    class Item(BaseModel):
        id: str
        title: str
        description: str | None = None
    
    
    @app.get("/items/{item_id}", response_model=Item)
    async def read_main(item_id: str, x_token: Annotated[str, Header()]):
        if x_token != fake_secret_token:
            raise HTTPException(status_code=400, detail="Invalid X-Token header")
        if item_id not in fake_db:
            raise HTTPException(status_code=404, detail="Item not found")
        return fake_db[item_id]
    
    
    @app.post("/items/")
    async def create_item(item: Item, x_token: Annotated[str, Header()]) -> Item:
        if x_token != fake_secret_token:
            raise HTTPException(status_code=400, detail="Invalid X-Token header")
        if item.id in fake_db:
            raise HTTPException(status_code=409, detail="Item already exists")
        fake_db[item.id] = item.model_dump()
        return item
    

ü§ì Other versions and variants

Python 3.9+Python 3.10+ - non-AnnotatedPython 3.9+ - non-Annotated
    
    
    from typing import Annotated, Union
    
    from fastapi import FastAPI, Header, HTTPException
    from pydantic import BaseModel
    
    fake_secret_token = "coneofsilence"
    
    fake_db = {
        "foo": {"id": "foo", "title": "Foo", "description": "There goes my hero"},
        "bar": {"id": "bar", "title": "Bar", "description": "The bartenders"},
    }
    
    app = FastAPI()
    
    
    class Item(BaseModel):
        id: str
        title: str
        description: Union[str, None] = None
    
    
    @app.get("/items/{item_id}", response_model=Item)
    async def read_main(item_id: str, x_token: Annotated[str, Header()]):
        if x_token != fake_secret_token:
            raise HTTPException(status_code=400, detail="Invalid X-Token header")
        if item_id not in fake_db:
            raise HTTPException(status_code=404, detail="Item not found")
        return fake_db[item_id]
    
    
    @app.post("/items/")
    async def create_item(item: Item, x_token: Annotated[str, Header()]) -> Item:
        if x_token != fake_secret_token:
            raise HTTPException(status_code=400, detail="Invalid X-Token header")
        if item.id in fake_db:
            raise HTTPException(status_code=409, detail="Item already exists")
        fake_db[item.id] = item.model_dump()
        return item
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import FastAPI, Header, HTTPException
    from pydantic import BaseModel
    
    fake_secret_token = "coneofsilence"
    
    fake_db = {
        "foo": {"id": "foo", "title": "Foo", "description": "There goes my hero"},
        "bar": {"id": "bar", "title": "Bar", "description": "The bartenders"},
    }
    
    app = FastAPI()
    
    
    class Item(BaseModel):
        id: str
        title: str
        description: str | None = None
    
    
    @app.get("/items/{item_id}", response_model=Item)
    async def read_main(item_id: str, x_token: str = Header()):
        if x_token != fake_secret_token:
            raise HTTPException(status_code=400, detail="Invalid X-Token header")
        if item_id not in fake_db:
            raise HTTPException(status_code=404, detail="Item not found")
        return fake_db[item_id]
    
    
    @app.post("/items/")
    async def create_item(item: Item, x_token: str = Header()) -> Item:
        if x_token != fake_secret_token:
            raise HTTPException(status_code=400, detail="Invalid X-Token header")
        if item.id in fake_db:
            raise HTTPException(status_code=409, detail="Item already exists")
        fake_db[item.id] = item.model_dump()
        return item
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from typing import Union
    
    from fastapi import FastAPI, Header, HTTPException
    from pydantic import BaseModel
    
    fake_secret_token = "coneofsilence"
    
    fake_db = {
        "foo": {"id": "foo", "title": "Foo", "description": "There goes my hero"},
        "bar": {"id": "bar", "title": "Bar", "description": "The bartenders"},
    }
    
    app = FastAPI()
    
    
    class Item(BaseModel):
        id: str
        title: str
        description: Union[str, None] = None
    
    
    @app.get("/items/{item_id}", response_model=Item)
    async def read_main(item_id: str, x_token: str = Header()):
        if x_token != fake_secret_token:
            raise HTTPException(status_code=400, detail="Invalid X-Token header")
        if item_id not in fake_db:
            raise HTTPException(status_code=404, detail="Item not found")
        return fake_db[item_id]
    
    
    @app.post("/items/")
    async def create_item(item: Item, x_token: str = Header()) -> Item:
        if x_token != fake_secret_token:
            raise HTTPException(status_code=400, detail="Invalid X-Token header")
        if item.id in fake_db:
            raise HTTPException(status_code=409, detail="Item already exists")
        fake_db[item.id] = item.model_dump()
        return item
    

### Extended testing file[¶](#extended-testing-file "Permanent link")

You could then update `test_main.py` with the extended tests:

Python 3.10+
    
    
    from fastapi.testclient import TestClient
    
    from .main import app
    
    client = TestClient(app)
    
    
    def test_read_item():
        response = client.get("/items/foo", headers={"X-Token": "coneofsilence"})
        assert response.status_code == 200
        assert response.json() == {
            "id": "foo",
            "title": "Foo",
            "description": "There goes my hero",
        }
    
    
    def test_read_item_bad_token():
        response = client.get("/items/foo", headers={"X-Token": "hailhydra"})
        assert response.status_code == 400
        assert response.json() == {"detail": "Invalid X-Token header"}
    
    
    def test_read_nonexistent_item():
        response = client.get("/items/baz", headers={"X-Token": "coneofsilence"})
        assert response.status_code == 404
        assert response.json() == {"detail": "Item not found"}
    
    
    def test_create_item():
        response = client.post(
            "/items/",
            headers={"X-Token": "coneofsilence"},
            json={"id": "foobar", "title": "Foo Bar", "description": "The Foo Barters"},
        )
        assert response.status_code == 200
        assert response.json() == {
            "id": "foobar",
            "title": "Foo Bar",
            "description": "The Foo Barters",
        }
    
    
    def test_create_item_bad_token():
        response = client.post(
            "/items/",
            headers={"X-Token": "hailhydra"},
            json={"id": "bazz", "title": "Bazz", "description": "Drop the bazz"},
        )
        assert response.status_code == 400
        assert response.json() == {"detail": "Invalid X-Token header"}
    
    
    def test_create_existing_item():
        response = client.post(
            "/items/",
            headers={"X-Token": "coneofsilence"},
            json={
                "id": "foo",
                "title": "The Foo ID Stealers",
                "description": "There goes my stealer",
            },
        )
        assert response.status_code == 409
        assert response.json() == {"detail": "Item already exists"}
    

ü§ì Other versions and variants

Python 3.9+Python 3.10+ - non-AnnotatedPython 3.9+ - non-Annotated
    
    
    from fastapi.testclient import TestClient
    
    from .main import app
    
    client = TestClient(app)
    
    
    def test_read_item():
        response = client.get("/items/foo", headers={"X-Token": "coneofsilence"})
        assert response.status_code == 200
        assert response.json() == {
            "id": "foo",
            "title": "Foo",
            "description": "There goes my hero",
        }
    
    
    def test_read_item_bad_token():
        response = client.get("/items/foo", headers={"X-Token": "hailhydra"})
        assert response.status_code == 400
        assert response.json() == {"detail": "Invalid X-Token header"}
    
    
    def test_read_nonexistent_item():
        response = client.get("/items/baz", headers={"X-Token": "coneofsilence"})
        assert response.status_code == 404
        assert response.json() == {"detail": "Item not found"}
    
    
    def test_create_item():
        response = client.post(
            "/items/",
            headers={"X-Token": "coneofsilence"},
            json={"id": "foobar", "title": "Foo Bar", "description": "The Foo Barters"},
        )
        assert response.status_code == 200
        assert response.json() == {
            "id": "foobar",
            "title": "Foo Bar",
            "description": "The Foo Barters",
        }
    
    
    def test_create_item_bad_token():
        response = client.post(
            "/items/",
            headers={"X-Token": "hailhydra"},
            json={"id": "bazz", "title": "Bazz", "description": "Drop the bazz"},
        )
        assert response.status_code == 400
        assert response.json() == {"detail": "Invalid X-Token header"}
    
    
    def test_create_existing_item():
        response = client.post(
            "/items/",
            headers={"X-Token": "coneofsilence"},
            json={
                "id": "foo",
                "title": "The Foo ID Stealers",
                "description": "There goes my stealer",
            },
        )
        assert response.status_code == 409
        assert response.json() == {"detail": "Item already exists"}
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi.testclient import TestClient
    
    from .main import app
    
    client = TestClient(app)
    
    
    def test_read_item():
        response = client.get("/items/foo", headers={"X-Token": "coneofsilence"})
        assert response.status_code == 200
        assert response.json() == {
            "id": "foo",
            "title": "Foo",
            "description": "There goes my hero",
        }
    
    
    def test_read_item_bad_token():
        response = client.get("/items/foo", headers={"X-Token": "hailhydra"})
        assert response.status_code == 400
        assert response.json() == {"detail": "Invalid X-Token header"}
    
    
    def test_read_nonexistent_item():
        response = client.get("/items/baz", headers={"X-Token": "coneofsilence"})
        assert response.status_code == 404
        assert response.json() == {"detail": "Item not found"}
    
    
    def test_create_item():
        response = client.post(
            "/items/",
            headers={"X-Token": "coneofsilence"},
            json={"id": "foobar", "title": "Foo Bar", "description": "The Foo Barters"},
        )
        assert response.status_code == 200
        assert response.json() == {
            "id": "foobar",
            "title": "Foo Bar",
            "description": "The Foo Barters",
        }
    
    
    def test_create_item_bad_token():
        response = client.post(
            "/items/",
            headers={"X-Token": "hailhydra"},
            json={"id": "bazz", "title": "Bazz", "description": "Drop the bazz"},
        )
        assert response.status_code == 400
        assert response.json() == {"detail": "Invalid X-Token header"}
    
    
    def test_create_existing_item():
        response = client.post(
            "/items/",
            headers={"X-Token": "coneofsilence"},
            json={
                "id": "foo",
                "title": "The Foo ID Stealers",
                "description": "There goes my stealer",
            },
        )
        assert response.status_code == 409
        assert response.json() == {"detail": "Item already exists"}
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi.testclient import TestClient
    
    from .main import app
    
    client = TestClient(app)
    
    
    def test_read_item():
        response = client.get("/items/foo", headers={"X-Token": "coneofsilence"})
        assert response.status_code == 200
        assert response.json() == {
            "id": "foo",
            "title": "Foo",
            "description": "There goes my hero",
        }
    
    
    def test_read_item_bad_token():
        response = client.get("/items/foo", headers={"X-Token": "hailhydra"})
        assert response.status_code == 400
        assert response.json() == {"detail": "Invalid X-Token header"}
    
    
    def test_read_nonexistent_item():
        response = client.get("/items/baz", headers={"X-Token": "coneofsilence"})
        assert response.status_code == 404
        assert response.json() == {"detail": "Item not found"}
    
    
    def test_create_item():
        response = client.post(
            "/items/",
            headers={"X-Token": "coneofsilence"},
            json={"id": "foobar", "title": "Foo Bar", "description": "The Foo Barters"},
        )
        assert response.status_code == 200
        assert response.json() == {
            "id": "foobar",
            "title": "Foo Bar",
            "description": "The Foo Barters",
        }
    
    
    def test_create_item_bad_token():
        response = client.post(
            "/items/",
            headers={"X-Token": "hailhydra"},
            json={"id": "bazz", "title": "Bazz", "description": "Drop the bazz"},
        )
        assert response.status_code == 400
        assert response.json() == {"detail": "Invalid X-Token header"}
    
    
    def test_create_existing_item():
        response = client.post(
            "/items/",
            headers={"X-Token": "coneofsilence"},
            json={
                "id": "foo",
                "title": "The Foo ID Stealers",
                "description": "There goes my stealer",
            },
        )
        assert response.status_code == 409
        assert response.json() == {"detail": "Item already exists"}
    

Whenever you need the client to pass information in the request and you don't know how to, you can search (Google) how to do it in `httpx`, or even how to do it with `requests`, as HTTPX's design is based on Requests' design.

Then you just do the same in your tests.

E.g.:

  * To pass a _path_ or _query_ parameter, add it to the URL itself.
  * To pass a JSON body, pass a Python object (e.g. a `dict`) to the parameter `json`.
  * If you need to send _Form Data_ instead of JSON, use the `data` parameter instead.
  * To pass _headers_ , use a `dict` in the `headers` parameter.
  * For _cookies_ , a `dict` in the `cookies` parameter.

For more information about how to pass data to the backend (using `httpx` or the `TestClient`) check the [HTTPX documentation](https://www.python-httpx.org).

Info

Note that the `TestClient` receives data that can be converted to JSON, not Pydantic models.

If you have a Pydantic model in your test and you want to send its data to the application during testing, you can use the `jsonable_encoder` described in [JSON Compatible Encoder](../encoder/).

## Run it[¶](#run-it "Permanent link")

After that, you just need to install `pytest`.

Make sure you create a [virtual environment](../../virtual-environments/), activate it, and then install it, for example:
    
    
    $ pip install pytest
    
    ---> 100%
    

It will detect the files and tests automatically, execute them, and report the results back to you.

Run the tests with:
    
    
    $ pytest
    
    ================ test session starts ================
    platform linux -- Python 3.6.9, pytest-5.3.5, py-1.8.1, pluggy-0.13.1
    rootdir: /home/user/code/superawesome-cli/app
    plugins: forked-1.1.3, xdist-1.31.0, cov-2.8.1
    collected 6 items
    
    ---> 100%
    
    test_main.py <span style="color: green; white-space: pre;">......                            [100%]</span>
    
    <span style="color: green;">================= 1 passed in 0.03s =================</span>

---

###### Debugging¶

# Debugging[¶](#debugging "Permanent link")

You can connect the debugger in your editor, for example with Visual Studio Code or PyCharm.

## Call `uvicorn`[¶](#call-uvicorn "Permanent link")

In your FastAPI application, import and run `uvicorn` directly:

Python 3.9+
    
    
    import uvicorn
    from fastapi import FastAPI
    
    app = FastAPI()
    
    
    @app.get("/")
    def root():
        a = "a"
        b = "b" + a
        return {"hello world": b}
    
    
    if __name__ == "__main__":
        uvicorn.run(app, host="0.0.0.0", port=8000)
    

### About `__name__ == "__main__"`[¶](#about-name-main "Permanent link")

The main purpose of the `__name__ == "__main__"` is to have some code that is executed when your file is called with:
    
    
    $ python myapp.py
    

but is not called when another file imports it, like in:
    
    
    from myapp import app
    

#### More details[¶](#more-details "Permanent link")

Let's say your file is named `myapp.py`.

If you run it with:
    
    
    $ python myapp.py
    

then the internal variable `__name__` in your file, created automatically by Python, will have as value the string `"__main__"`.

So, the section:
    
    
        uvicorn.run(app, host="0.0.0.0", port=8000)
    

will run.

* * *

This won't happen if you import that module (file).

So, if you have another file `importer.py` with:
    
    
    from myapp import app
    
    # Some more code
    

in that case, the automatically created variable `__name__` inside of `myapp.py` will not have the value `"__main__"`.

So, the line:
    
    
        uvicorn.run(app, host="0.0.0.0", port=8000)
    

will not be executed.

Info

For more information, check [the official Python docs](https://docs.python.org/3/library/__main__.html).

## Run your code with your debugger[¶](#run-your-code-with-your-debugger "Permanent link")

Because you are running the Uvicorn server directly from your code, you can call your Python program (your FastAPI application) directly from the debugger.

* * *

For example, in Visual Studio Code, you can:

  * Go to the "Debug" panel.
  * "Add configuration...".
  * Select "Python"
  * Run the debugger with the option "`Python: Current File (Integrated Terminal)`".

It will then start the server with your **FastAPI** code, stop at your breakpoints, etc.

Here's how it might look:

![](/img/tutorial/debugging/image01.png)

* * *

If you use Pycharm, you can:

  * Open the "Run" menu.
  * Select the option "Debug...".
  * Then a context menu shows up.
  * Select the file to debug (in this case, `main.py`).

It will then start the server with your **FastAPI** code, stop at your breakpoints, etc.

Here's how it might look:

![](/img/tutorial/debugging/image02.png)

---

###### Advanced User Guide¶

# Advanced User Guide[¶](#advanced-user-guide "Permanent link")

## Additional Features[¶](#additional-features "Permanent link")

The main [Tutorial - User Guide](../tutorial/) should be enough to give you a tour through all the main features of **FastAPI**.

In the next sections you will see other options, configurations, and additional features.

Tip

The next sections are **not necessarily "advanced"**.

And it's possible that for your use case, the solution is in one of them.

## Read the Tutorial first[¶](#read-the-tutorial-first "Permanent link")

You could still use most of the features in **FastAPI** with the knowledge from the main [Tutorial - User Guide](../tutorial/).

And the next sections assume you already read it, and assume that you know those main ideas.

---

###### Path Operation Advanced Configuration¶

# Path Operation Advanced Configuration[¶](#path-operation-advanced-configuration "Permanent link")

## OpenAPI operationId[¶](#openapi-operationid "Permanent link")

Warning

If you are not an "expert" in OpenAPI, you probably don't need this.

You can set the OpenAPI `operationId` to be used in your _path operation_ with the parameter `operation_id`.

You would have to make sure that it is unique for each operation.

Python 3.9+
    
    
    from fastapi import FastAPI
    
    app = FastAPI()
    
    
    @app.get("/items/", operation_id="some_specific_id_you_define")
    async def read_items():
        return [{"item_id": "Foo"}]
    

### Using the _path operation function_ name as the operationId[¶](#using-the-path-operation-function-name-as-the-operationid "Permanent link")

If you want to use your APIs' function names as `operationId`s, you can iterate over all of them and override each _path operation's_ `operation_id` using their `APIRoute.name`.

You should do it after adding all your _path operations_.

Python 3.9+
    
    
    from fastapi import FastAPI
    from fastapi.routing import APIRoute
    
    app = FastAPI()
    
    
    @app.get("/items/")
    async def read_items():
        return [{"item_id": "Foo"}]
    
    
    def use_route_names_as_operation_ids(app: FastAPI) -> None:
        """
        Simplify operation IDs so that generated API clients have simpler function
        names.
    
        Should be called only after all routes have been added.
        """
        for route in app.routes:
            if isinstance(route, APIRoute):
                route.operation_id = route.name  # in this case, 'read_items'
    
    
    use_route_names_as_operation_ids(app)
    

Tip

If you manually call `app.openapi()`, you should update the `operationId`s before that.

Warning

If you do this, you have to make sure each one of your _path operation functions_ has a unique name.

Even if they are in different modules (Python files).

## Exclude from OpenAPI[¶](#exclude-from-openapi "Permanent link")

To exclude a _path operation_ from the generated OpenAPI schema (and thus, from the automatic documentation systems), use the parameter `include_in_schema` and set it to `False`:

Python 3.9+
    
    
    from fastapi import FastAPI
    
    app = FastAPI()
    
    
    @app.get("/items/", include_in_schema=False)
    async def read_items():
        return [{"item_id": "Foo"}]
    

## Advanced description from docstring[¶](#advanced-description-from-docstring "Permanent link")

You can limit the lines used from the docstring of a _path operation function_ for OpenAPI.

Adding an `\f` (an escaped "form feed" character) causes **FastAPI** to truncate the output used for OpenAPI at this point.

It won't show up in the documentation, but other tools (such as Sphinx) will be able to use the rest.

Python 3.10+
    
    
    from fastapi import FastAPI
    from pydantic import BaseModel
    
    app = FastAPI()
    
    
    class Item(BaseModel):
        name: str
        description: str | None = None
        price: float
        tax: float | None = None
        tags: set[str] = set()
    
    
    @app.post("/items/", summary="Create an item")
    async def create_item(item: Item) -> Item:
        """
        Create an item with all the information:
    
        - **name**: each item must have a name
        - **description**: a long description
        - **price**: required
        - **tax**: if the item doesn't have tax, you can omit this
        - **tags**: a set of unique tag strings for this item
        \f
        :param item: User input.
        """
        return item
    

ü§ì Other versions and variants

Python 3.9+
    
    
    from typing import Union
    
    from fastapi import FastAPI
    from pydantic import BaseModel
    
    app = FastAPI()
    
    
    class Item(BaseModel):
        name: str
        description: Union[str, None] = None
        price: float
        tax: Union[float, None] = None
        tags: set[str] = set()
    
    
    @app.post("/items/", summary="Create an item")
    async def create_item(item: Item) -> Item:
        """
        Create an item with all the information:
    
        - **name**: each item must have a name
        - **description**: a long description
        - **price**: required
        - **tax**: if the item doesn't have tax, you can omit this
        - **tags**: a set of unique tag strings for this item
        \f
        :param item: User input.
        """
        return item
    

## Additional Responses[¶](#additional-responses "Permanent link")

You probably have seen how to declare the `response_model` and `status_code` for a _path operation_.

That defines the metadata about the main response of a _path operation_.

You can also declare additional responses with their models, status codes, etc.

There's a whole chapter here in the documentation about it, you can read it at [Additional Responses in OpenAPI](../additional-responses/).

## OpenAPI Extra[¶](#openapi-extra "Permanent link")

When you declare a _path operation_ in your application, **FastAPI** automatically generates the relevant metadata about that _path operation_ to be included in the OpenAPI schema.

Technical details

In the OpenAPI specification it is called the [Operation Object](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.3.md#operation-object).

It has all the information about the _path operation_ and is used to generate the automatic documentation.

It includes the `tags`, `parameters`, `requestBody`, `responses`, etc.

This _path operation_ -specific OpenAPI schema is normally generated automatically by **FastAPI** , but you can also extend it.

Tip

This is a low level extension point.

If you only need to declare additional responses, a more convenient way to do it is with [Additional Responses in OpenAPI](../additional-responses/).

You can extend the OpenAPI schema for a _path operation_ using the parameter `openapi_extra`.

### OpenAPI Extensions[¶](#openapi-extensions "Permanent link")

This `openapi_extra` can be helpful, for example, to declare [OpenAPI Extensions](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.3.md#specificationExtensions):

Python 3.9+
    
    
    from fastapi import FastAPI
    
    app = FastAPI()
    
    
    @app.get("/items/", openapi_extra={"x-aperture-labs-portal": "blue"})
    async def read_items():
        return [{"item_id": "portal-gun"}]
    

If you open the automatic API docs, your extension will show up at the bottom of the specific _path operation_.

![](/img/tutorial/path-operation-advanced-configuration/image01.png)

And if you see the resulting OpenAPI (at `/openapi.json` in your API), you will see your extension as part of the specific _path operation_ too:
    
    
    {
        "openapi": "3.1.0",
        "info": {
            "title": "FastAPI",
            "version": "0.1.0"
        },
        "paths": {
            "/items/": {
                "get": {
                    "summary": "Read Items",
                    "operationId": "read_items_items__get",
                    "responses": {
                        "200": {
                            "description": "Successful Response",
                            "content": {
                                "application/json": {
                                    "schema": {}
                                }
                            }
                        }
                    },
                    "x-aperture-labs-portal": "blue"
                }
            }
        }
    }
    

### Custom OpenAPI _path operation_ schema[¶](#custom-openapi-path-operation-schema "Permanent link")

The dictionary in `openapi_extra` will be deeply merged with the automatically generated OpenAPI schema for the _path operation_.

So, you could add additional data to the automatically generated schema.

For example, you could decide to read and validate the request with your own code, without using the automatic features of FastAPI with Pydantic, but you could still want to define the request in the OpenAPI schema.

You could do that with `openapi_extra`:

Python 3.9+
    
    
    from fastapi import FastAPI, Request
    
    app = FastAPI()
    
    
    def magic_data_reader(raw_body: bytes):
        return {
            "size": len(raw_body),
            "content": {
                "name": "Maaaagic",
                "price": 42,
                "description": "Just kiddin', no magic here. ‚ú®",
            },
        }
    
    
    @app.post(
        "/items/",
        openapi_extra={
            "requestBody": {
                "content": {
                    "application/json": {
                        "schema": {
                            "required": ["name", "price"],
                            "type": "object",
                            "properties": {
                                "name": {"type": "string"},
                                "price": {"type": "number"},
                                "description": {"type": "string"},
                            },
                        }
                    }
                },
                "required": True,
            },
        },
    )
    async def create_item(request: Request):
        raw_body = await request.body()
        data = magic_data_reader(raw_body)
        return data
    

In this example, we didn't declare any Pydantic model. In fact, the request body is not even parsed as JSON, it is read directly as `bytes`, and the function `magic_data_reader()` would be in charge of parsing it in some way.

Nevertheless, we can declare the expected schema for the request body.

### Custom OpenAPI content type[¶](#custom-openapi-content-type "Permanent link")

Using this same trick, you could use a Pydantic model to define the JSON Schema that is then included in the custom OpenAPI schema section for the _path operation_.

And you could do this even if the data type in the request is not JSON.

For example, in this application we don't use FastAPI's integrated functionality to extract the JSON Schema from Pydantic models nor the automatic validation for JSON. In fact, we are declaring the request content type as YAML, not JSON:

Python 3.9+
    
    
    import yaml
    from fastapi import FastAPI, HTTPException, Request
    from pydantic import BaseModel, ValidationError
    
    app = FastAPI()
    
    
    class Item(BaseModel):
        name: str
        tags: list[str]
    
    
    @app.post(
        "/items/",
        openapi_extra={
            "requestBody": {
                "content": {"application/x-yaml": {"schema": Item.model_json_schema()}},
                "required": True,
            },
        },
    )
    async def create_item(request: Request):
        raw_body = await request.body()
        try:
            data = yaml.safe_load(raw_body)
        except yaml.YAMLError:
            raise HTTPException(status_code=422, detail="Invalid YAML")
        try:
            item = Item.model_validate(data)
        except ValidationError as e:
            raise HTTPException(status_code=422, detail=e.errors(include_url=False))
        return item
    

Nevertheless, although we are not using the default integrated functionality, we are still using a Pydantic model to manually generate the JSON Schema for the data that we want to receive in YAML.

Then we use the request directly, and extract the body as `bytes`. This means that FastAPI won't even try to parse the request payload as JSON.

And then in our code, we parse that YAML content directly, and then we are again using the same Pydantic model to validate the YAML content:

Python 3.9+
    
    
    import yaml
    from fastapi import FastAPI, HTTPException, Request
    from pydantic import BaseModel, ValidationError
    
    app = FastAPI()
    
    
    class Item(BaseModel):
        name: str
        tags: list[str]
    
    
    @app.post(
        "/items/",
        openapi_extra={
            "requestBody": {
                "content": {"application/x-yaml": {"schema": Item.model_json_schema()}},
                "required": True,
            },
        },
    )
    async def create_item(request: Request):
        raw_body = await request.body()
        try:
            data = yaml.safe_load(raw_body)
        except yaml.YAMLError:
            raise HTTPException(status_code=422, detail="Invalid YAML")
        try:
            item = Item.model_validate(data)
        except ValidationError as e:
            raise HTTPException(status_code=422, detail=e.errors(include_url=False))
        return item
    

Tip

Here we reuse the same Pydantic model.

But the same way, we could have validated it in some other way.
  *[parsed]: converted from some plain format, like bytes, into Python objects

---

###### Additional Status Codes¶

# Additional Status Codes[¶](#additional-status-codes "Permanent link")

By default, **FastAPI** will return the responses using a `JSONResponse`, putting the content you return from your _path operation_ inside of that `JSONResponse`.

It will use the default status code or the one you set in your _path operation_.

## Additional status codes[¶](#additional-status-codes_1 "Permanent link")

If you want to return additional status codes apart from the main one, you can do that by returning a `Response` directly, like a `JSONResponse`, and set the additional status code directly.

For example, let's say that you want to have a _path operation_ that allows to update items, and returns HTTP status codes of 200 "OK" when successful.

But you also want it to accept new items. And when the items didn't exist before, it creates them, and returns an HTTP status code of 201 "Created".

To achieve that, import `JSONResponse`, and return your content there directly, setting the `status_code` that you want:

Python 3.10+
    
    
    from typing import Annotated
    
    from fastapi import Body, FastAPI, status
    from fastapi.responses import JSONResponse
    
    app = FastAPI()
    
    items = {"foo": {"name": "Fighters", "size": 6}, "bar": {"name": "Tenders", "size": 3}}
    
    
    @app.put("/items/{item_id}")
    async def upsert_item(
        item_id: str,
        name: Annotated[str | None, Body()] = None,
        size: Annotated[int | None, Body()] = None,
    ):
        if item_id in items:
            item = items[item_id]
            item["name"] = name
            item["size"] = size
            return item
        else:
            item = {"name": name, "size": size}
            items[item_id] = item
            return JSONResponse(status_code=status.HTTP_201_CREATED, content=item)
    

ü§ì Other versions and variants

Python 3.9+Python 3.10+ - non-AnnotatedPython 3.9+ - non-Annotated
    
    
    from typing import Annotated, Union
    
    from fastapi import Body, FastAPI, status
    from fastapi.responses import JSONResponse
    
    app = FastAPI()
    
    items = {"foo": {"name": "Fighters", "size": 6}, "bar": {"name": "Tenders", "size": 3}}
    
    
    @app.put("/items/{item_id}")
    async def upsert_item(
        item_id: str,
        name: Annotated[Union[str, None], Body()] = None,
        size: Annotated[Union[int, None], Body()] = None,
    ):
        if item_id in items:
            item = items[item_id]
            item["name"] = name
            item["size"] = size
            return item
        else:
            item = {"name": name, "size": size}
            items[item_id] = item
            return JSONResponse(status_code=status.HTTP_201_CREATED, content=item)
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import Body, FastAPI, status
    from fastapi.responses import JSONResponse
    
    app = FastAPI()
    
    items = {"foo": {"name": "Fighters", "size": 6}, "bar": {"name": "Tenders", "size": 3}}
    
    
    @app.put("/items/{item_id}")
    async def upsert_item(
        item_id: str,
        name: str | None = Body(default=None),
        size: int | None = Body(default=None),
    ):
        if item_id in items:
            item = items[item_id]
            item["name"] = name
            item["size"] = size
            return item
        else:
            item = {"name": name, "size": size}
            items[item_id] = item
            return JSONResponse(status_code=status.HTTP_201_CREATED, content=item)
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from typing import Union
    
    from fastapi import Body, FastAPI, status
    from fastapi.responses import JSONResponse
    
    app = FastAPI()
    
    items = {"foo": {"name": "Fighters", "size": 6}, "bar": {"name": "Tenders", "size": 3}}
    
    
    @app.put("/items/{item_id}")
    async def upsert_item(
        item_id: str,
        name: Union[str, None] = Body(default=None),
        size: Union[int, None] = Body(default=None),
    ):
        if item_id in items:
            item = items[item_id]
            item["name"] = name
            item["size"] = size
            return item
        else:
            item = {"name": name, "size": size}
            items[item_id] = item
            return JSONResponse(status_code=status.HTTP_201_CREATED, content=item)
    

Warning

When you return a `Response` directly, like in the example above, it will be returned directly.

It won't be serialized with a model, etc.

Make sure it has the data you want it to have, and that the values are valid JSON (if you are using `JSONResponse`).

Technical Details

You could also use `from starlette.responses import JSONResponse`.

**FastAPI** provides the same `starlette.responses` as `fastapi.responses` just as a convenience for you, the developer. But most of the available responses come directly from Starlette. The same with `status`.

## OpenAPI and API docs[¶](#openapi-and-api-docs "Permanent link")

If you return additional status codes and responses directly, they won't be included in the OpenAPI schema (the API docs), because FastAPI doesn't have a way to know beforehand what you are going to return.

But you can document that in your code, using: [Additional Responses](../additional-responses/).

---

###### Return a Response Directly¶

# Return a Response Directly[¶](#return-a-response-directly "Permanent link")

When you create a **FastAPI** _path operation_ you can normally return any data from it: a `dict`, a `list`, a Pydantic model, a database model, etc.

By default, **FastAPI** would automatically convert that return value to JSON using the `jsonable_encoder` explained in [JSON Compatible Encoder](../../tutorial/encoder/).

Then, behind the scenes, it would put that JSON-compatible data (e.g. a `dict`) inside of a `JSONResponse` that would be used to send the response to the client.

But you can return a `JSONResponse` directly from your _path operations_.

It might be useful, for example, to return custom headers or cookies.

## Return a `Response`[¶](#return-a-response "Permanent link")

In fact, you can return any `Response` or any sub-class of it.

Tip

`JSONResponse` itself is a sub-class of `Response`.

And when you return a `Response`, **FastAPI** will pass it directly.

It won't do any data conversion with Pydantic models, it won't convert the contents to any type, etc.

This gives you a lot of flexibility. You can return any data type, override any data declaration or validation, etc.

## Using the `jsonable_encoder` in a `Response`[¶](#using-the-jsonable-encoder-in-a-response "Permanent link")

Because **FastAPI** doesn't make any changes to a `Response` you return, you have to make sure its contents are ready for it.

For example, you cannot put a Pydantic model in a `JSONResponse` without first converting it to a `dict` with all the data types (like `datetime`, `UUID`, etc) converted to JSON-compatible types.

For those cases, you can use the `jsonable_encoder` to convert your data before passing it to a response:

Python 3.10+
    
    
    from datetime import datetime
    
    from fastapi import FastAPI
    from fastapi.encoders import jsonable_encoder
    from fastapi.responses import JSONResponse
    from pydantic import BaseModel
    
    
    class Item(BaseModel):
        title: str
        timestamp: datetime
        description: str | None = None
    
    
    app = FastAPI()
    
    
    @app.put("/items/{id}")
    def update_item(id: str, item: Item):
        json_compatible_item_data = jsonable_encoder(item)
        return JSONResponse(content=json_compatible_item_data)
    

ü§ì Other versions and variants

Python 3.9+
    
    
    from datetime import datetime
    from typing import Union
    
    from fastapi import FastAPI
    from fastapi.encoders import jsonable_encoder
    from fastapi.responses import JSONResponse
    from pydantic import BaseModel
    
    
    class Item(BaseModel):
        title: str
        timestamp: datetime
        description: Union[str, None] = None
    
    
    app = FastAPI()
    
    
    @app.put("/items/{id}")
    def update_item(id: str, item: Item):
        json_compatible_item_data = jsonable_encoder(item)
        return JSONResponse(content=json_compatible_item_data)
    

Technical Details

You could also use `from starlette.responses import JSONResponse`.

**FastAPI** provides the same `starlette.responses` as `fastapi.responses` just as a convenience for you, the developer. But most of the available responses come directly from Starlette.

## Returning a custom `Response`[¶](#returning-a-custom-response "Permanent link")

The example above shows all the parts you need, but it's not very useful yet, as you could have just returned the `item` directly, and **FastAPI** would put it in a `JSONResponse` for you, converting it to a `dict`, etc. All that by default.

Now, let's see how you could use that to return a custom response.

Let's say that you want to return an [XML](https://en.wikipedia.org/wiki/XML) response.

You could put your XML content in a string, put that in a `Response`, and return it:

Python 3.9+
    
    
    from fastapi import FastAPI, Response
    
    app = FastAPI()
    
    
    @app.get("/legacy/")
    def get_legacy_data():
        data = """<?xml version="1.0"?>
        <shampoo>
        <Header>
            Apply shampoo here.
        </Header>
        <Body>
            You'll have to use soap here.
        </Body>
        </shampoo>
        """
        return Response(content=data, media_type="application/xml")
    

## Notes[¶](#notes "Permanent link")

When you return a `Response` directly its data is not validated, converted (serialized), or documented automatically.

But you can still document it as described in [Additional Responses in OpenAPI](../additional-responses/).

You can see in later sections how to use/declare these custom `Response`s while still having automatic data conversion, documentation, etc.

---

###### Custom Response - HTML, Stream, File, others¶

# Custom Response - HTML, Stream, File, others[¶](#custom-response-html-stream-file-others "Permanent link")

By default, **FastAPI** will return the responses using `JSONResponse`.

You can override it by returning a `Response` directly as seen in [Return a Response directly](../response-directly/).

But if you return a `Response` directly (or any subclass, like `JSONResponse`), the data won't be automatically converted (even if you declare a `response_model`), and the documentation won't be automatically generated (for example, including the specific "media type", in the HTTP header `Content-Type` as part of the generated OpenAPI).

But you can also declare the `Response` that you want to be used (e.g. any `Response` subclass), in the _path operation decorator_ using the `response_class` parameter.

The contents that you return from your _path operation function_ will be put inside of that `Response`.

And if that `Response` has a JSON media type (`application/json`), like is the case with the `JSONResponse` and `UJSONResponse`, the data you return will be automatically converted (and filtered) with any Pydantic `response_model` that you declared in the _path operation decorator_.

Note

If you use a response class with no media type, FastAPI will expect your response to have no content, so it will not document the response format in its generated OpenAPI docs.

## Use `ORJSONResponse`[¶](#use-orjsonresponse "Permanent link")

For example, if you are squeezing performance, you can install and use [`orjson`](https://github.com/ijl/orjson) and set the response to be `ORJSONResponse`.

Import the `Response` class (sub-class) you want to use and declare it in the _path operation decorator_.

For large responses, returning a `Response` directly is much faster than returning a dictionary.

This is because by default, FastAPI will inspect every item inside and make sure it is serializable as JSON, using the same [JSON Compatible Encoder](../../tutorial/encoder/) explained in the tutorial. This is what allows you to return **arbitrary objects** , for example database models.

But if you are certain that the content that you are returning is **serializable with JSON** , you can pass it directly to the response class and avoid the extra overhead that FastAPI would have by passing your return content through the `jsonable_encoder` before passing it to the response class.

Python 3.9+
    
    
    from fastapi import FastAPI
    from fastapi.responses import ORJSONResponse
    
    app = FastAPI()
    
    
    @app.get("/items/", response_class=ORJSONResponse)
    async def read_items():
        return ORJSONResponse([{"item_id": "Foo"}])
    

Info

The parameter `response_class` will also be used to define the "media type" of the response.

In this case, the HTTP header `Content-Type` will be set to `application/json`.

And it will be documented as such in OpenAPI.

Tip

The `ORJSONResponse` is only available in FastAPI, not in Starlette.

## HTML Response[¶](#html-response "Permanent link")

To return a response with HTML directly from **FastAPI** , use `HTMLResponse`.

  * Import `HTMLResponse`.
  * Pass `HTMLResponse` as the parameter `response_class` of your _path operation decorator_.

Python 3.9+
    
    
    from fastapi import FastAPI
    from fastapi.responses import HTMLResponse
    
    app = FastAPI()
    
    
    @app.get("/items/", response_class=HTMLResponse)
    async def read_items():
        return """
        <html>
            <head>
                <title>Some HTML in here</title>
            </head>
            <body>
                <h1>Look ma! HTML!</h1>
            </body>
        </html>
        """
    

Info

The parameter `response_class` will also be used to define the "media type" of the response.

In this case, the HTTP header `Content-Type` will be set to `text/html`.

And it will be documented as such in OpenAPI.

### Return a `Response`[¶](#return-a-response "Permanent link")

As seen in [Return a Response directly](../response-directly/), you can also override the response directly in your _path operation_ , by returning it.

The same example from above, returning an `HTMLResponse`, could look like:

Python 3.9+
    
    
    from fastapi import FastAPI
    from fastapi.responses import HTMLResponse
    
    app = FastAPI()
    
    
    @app.get("/items/")
    async def read_items():
        html_content = """
        <html>
            <head>
                <title>Some HTML in here</title>
            </head>
            <body>
                <h1>Look ma! HTML!</h1>
            </body>
        </html>
        """
        return HTMLResponse(content=html_content, status_code=200)
    

Warning

A `Response` returned directly by your _path operation function_ won't be documented in OpenAPI (for example, the `Content-Type` won't be documented) and won't be visible in the automatic interactive docs.

Info

Of course, the actual `Content-Type` header, status code, etc, will come from the `Response` object you returned.

### Document in OpenAPI and override `Response`[¶](#document-in-openapi-and-override-response "Permanent link")

If you want to override the response from inside of the function but at the same time document the "media type" in OpenAPI, you can use the `response_class` parameter AND return a `Response` object.

The `response_class` will then be used only to document the OpenAPI _path operation_ , but your `Response` will be used as is.

#### Return an `HTMLResponse` directly[¶](#return-an-htmlresponse-directly "Permanent link")

For example, it could be something like:

Python 3.9+
    
    
    from fastapi import FastAPI
    from fastapi.responses import HTMLResponse
    
    app = FastAPI()
    
    
    def generate_html_response():
        html_content = """
        <html>
            <head>
                <title>Some HTML in here</title>
            </head>
            <body>
                <h1>Look ma! HTML!</h1>
            </body>
        </html>
        """
        return HTMLResponse(content=html_content, status_code=200)
    
    
    @app.get("/items/", response_class=HTMLResponse)
    async def read_items():
        return generate_html_response()
    

In this example, the function `generate_html_response()` already generates and returns a `Response` instead of returning the HTML in a `str`.

By returning the result of calling `generate_html_response()`, you are already returning a `Response` that will override the default **FastAPI** behavior.

But as you passed the `HTMLResponse` in the `response_class` too, **FastAPI** will know how to document it in OpenAPI and the interactive docs as HTML with `text/html`:

![](/img/tutorial/custom-response/image01.png)

## Available responses[¶](#available-responses "Permanent link")

Here are some of the available responses.

Keep in mind that you can use `Response` to return anything else, or even create a custom sub-class.

Technical Details

You could also use `from starlette.responses import HTMLResponse`.

**FastAPI** provides the same `starlette.responses` as `fastapi.responses` just as a convenience for you, the developer. But most of the available responses come directly from Starlette.

### `Response`[¶](#response "Permanent link")

The main `Response` class, all the other responses inherit from it.

You can return it directly.

It accepts the following parameters:

  * `content` \- A `str` or `bytes`.
  * `status_code` \- An `int` HTTP status code.
  * `headers` \- A `dict` of strings.
  * `media_type` \- A `str` giving the media type. E.g. `"text/html"`.

FastAPI (actually Starlette) will automatically include a Content-Length header. It will also include a Content-Type header, based on the `media_type` and appending a charset for text types.

Python 3.9+
    
    
    from fastapi import FastAPI, Response
    
    app = FastAPI()
    
    
    @app.get("/legacy/")
    def get_legacy_data():
        data = """<?xml version="1.0"?>
        <shampoo>
        <Header>
            Apply shampoo here.
        </Header>
        <Body>
            You'll have to use soap here.
        </Body>
        </shampoo>
        """
        return Response(content=data, media_type="application/xml")
    

### `HTMLResponse`[¶](#htmlresponse "Permanent link")

Takes some text or bytes and returns an HTML response, as you read above.

### `PlainTextResponse`[¶](#plaintextresponse "Permanent link")

Takes some text or bytes and returns a plain text response.

Python 3.9+
    
    
    from fastapi import FastAPI
    from fastapi.responses import PlainTextResponse
    
    app = FastAPI()
    
    
    @app.get("/", response_class=PlainTextResponse)
    async def main():
        return "Hello World"
    

### `JSONResponse`[¶](#jsonresponse "Permanent link")

Takes some data and returns an `application/json` encoded response.

This is the default response used in **FastAPI** , as you read above.

### `ORJSONResponse`[¶](#orjsonresponse "Permanent link")

A fast alternative JSON response using [`orjson`](https://github.com/ijl/orjson), as you read above.

Info

This requires installing `orjson` for example with `pip install orjson`.

### `UJSONResponse`[¶](#ujsonresponse "Permanent link")

An alternative JSON response using [`ujson`](https://github.com/ultrajson/ultrajson).

Info

This requires installing `ujson` for example with `pip install ujson`.

Warning

`ujson` is less careful than Python's built-in implementation in how it handles some edge-cases.

Python 3.9+
    
    
    from fastapi import FastAPI
    from fastapi.responses import UJSONResponse
    
    app = FastAPI()
    
    
    @app.get("/items/", response_class=UJSONResponse)
    async def read_items():
        return [{"item_id": "Foo"}]
    

Tip

It's possible that `ORJSONResponse` might be a faster alternative.

### `RedirectResponse`[¶](#redirectresponse "Permanent link")

Returns an HTTP redirect. Uses a 307 status code (Temporary Redirect) by default.

You can return a `RedirectResponse` directly:

Python 3.9+
    
    
    from fastapi import FastAPI
    from fastapi.responses import RedirectResponse
    
    app = FastAPI()
    
    
    @app.get("/typer")
    async def redirect_typer():
        return RedirectResponse("https://typer.tiangolo.com")
    

* * *

Or you can use it in the `response_class` parameter:

Python 3.9+
    
    
    from fastapi import FastAPI
    from fastapi.responses import RedirectResponse
    
    app = FastAPI()
    
    
    @app.get("/fastapi", response_class=RedirectResponse)
    async def redirect_fastapi():
        return "https://fastapi.tiangolo.com"
    

If you do that, then you can return the URL directly from your _path operation_ function.

In this case, the `status_code` used will be the default one for the `RedirectResponse`, which is `307`.

* * *

You can also use the `status_code` parameter combined with the `response_class` parameter:

Python 3.9+
    
    
    from fastapi import FastAPI
    from fastapi.responses import RedirectResponse
    
    app = FastAPI()
    
    
    @app.get("/pydantic", response_class=RedirectResponse, status_code=302)
    async def redirect_pydantic():
        return "https://docs.pydantic.dev/"
    

### `StreamingResponse`[¶](#streamingresponse "Permanent link")

Takes an async generator or a normal generator/iterator and streams the response body.

Python 3.9+
    
    
    from fastapi import FastAPI
    from fastapi.responses import StreamingResponse
    
    app = FastAPI()
    
    
    async def fake_video_streamer():
        for i in range(10):
            yield b"some fake video bytes"
    
    
    @app.get("/")
    async def main():
        return StreamingResponse(fake_video_streamer())
    

#### Using `StreamingResponse` with file-like objects[¶](#using-streamingresponse-with-file-like-objects "Permanent link")

If you have a [file-like](https://docs.python.org/3/glossary.html#term-file-like-object) object (e.g. the object returned by `open()`), you can create a generator function to iterate over that file-like object.

That way, you don't have to read it all first in memory, and you can pass that generator function to the `StreamingResponse`, and return it.

This includes many libraries to interact with cloud storage, video processing, and others.

Python 3.9+
    
    
    from fastapi import FastAPI
    from fastapi.responses import StreamingResponse
    
    some_file_path = "large-video-file.mp4"
    app = FastAPI()
    
    
    @app.get("/")
    def main():
        def iterfile():  # (1)
            with open(some_file_path, mode="rb") as file_like:  # (2)
                yield from file_like  # (3)
    
        return StreamingResponse(iterfile(), media_type="video/mp4")
    

  1. This is the generator function. It's a "generator function" because it contains `yield` statements inside.
  2. By using a `with` block, we make sure that the file-like object is closed after the generator function is done. So, after it finishes sending the response.
  3. This `yield from` tells the function to iterate over that thing named `file_like`. And then, for each part iterated, yield that part as coming from this generator function (`iterfile`).

So, it is a generator function that transfers the "generating" work to something else internally.

By doing it this way, we can put it in a `with` block, and that way, ensure that the file-like object is closed after finishing.

Tip

Notice that here as we are using standard `open()` that doesn't support `async` and `await`, we declare the path operation with normal `def`.

### `FileResponse`[¶](#fileresponse "Permanent link")

Asynchronously streams a file as the response.

Takes a different set of arguments to instantiate than the other response types:

  * `path` \- The file path to the file to stream.
  * `headers` \- Any custom headers to include, as a dictionary.
  * `media_type` \- A string giving the media type. If unset, the filename or path will be used to infer a media type.
  * `filename` \- If set, this will be included in the response `Content-Disposition`.

File responses will include appropriate `Content-Length`, `Last-Modified` and `ETag` headers.

Python 3.9+
    
    
    from fastapi import FastAPI
    from fastapi.responses import FileResponse
    
    some_file_path = "large-video-file.mp4"
    app = FastAPI()
    
    
    @app.get("/")
    async def main():
        return FileResponse(some_file_path)
    

You can also use the `response_class` parameter:

Python 3.9+
    
    
    from fastapi import FastAPI
    from fastapi.responses import FileResponse
    
    some_file_path = "large-video-file.mp4"
    app = FastAPI()
    
    
    @app.get("/", response_class=FileResponse)
    async def main():
        return some_file_path
    

In this case, you can return the file path directly from your _path operation_ function.

## Custom response class[¶](#custom-response-class "Permanent link")

You can create your own custom response class, inheriting from `Response` and using it.

For example, let's say that you want to use [`orjson`](https://github.com/ijl/orjson), but with some custom settings not used in the included `ORJSONResponse` class.

Let's say you want it to return indented and formatted JSON, so you want to use the orjson option `orjson.OPT_INDENT_2`.

You could create a `CustomORJSONResponse`. The main thing you have to do is create a `Response.render(content)` method that returns the content as `bytes`:

Python 3.9+
    
    
    from typing import Any
    
    import orjson
    from fastapi import FastAPI, Response
    
    app = FastAPI()
    
    
    class CustomORJSONResponse(Response):
        media_type = "application/json"
    
        def render(self, content: Any) -> bytes:
            assert orjson is not None, "orjson must be installed"
            return orjson.dumps(content, option=orjson.OPT_INDENT_2)
    
    
    @app.get("/", response_class=CustomORJSONResponse)
    async def main():
        return {"message": "Hello World"}
    

Now instead of returning:
    
    
    {"message": "Hello World"}
    

...this response will return:
    
    
    {
      "message": "Hello World"
    }
    

Of course, you will probably find much better ways to take advantage of this than formatting JSON. üòâ

## Default response class[¶](#default-response-class "Permanent link")

When creating a **FastAPI** class instance or an `APIRouter` you can specify which response class to use by default.

The parameter that defines this is `default_response_class`.

In the example below, **FastAPI** will use `ORJSONResponse` by default, in all _path operations_ , instead of `JSONResponse`.

Python 3.9+
    
    
    from fastapi import FastAPI
    from fastapi.responses import ORJSONResponse
    
    app = FastAPI(default_response_class=ORJSONResponse)
    
    
    @app.get("/items/")
    async def read_items():
        return [{"item_id": "Foo"}]
    

Tip

You can still override `response_class` in _path operations_ as before.

## Additional documentation[¶](#additional-documentation "Permanent link")

You can also declare the media type and many other details in OpenAPI using `responses`: [Additional Responses in OpenAPI](../additional-responses/).

---

###### Additional Responses in OpenAPI¶

# Additional Responses in OpenAPI[¶](#additional-responses-in-openapi "Permanent link")

Warning

This is a rather advanced topic.

If you are starting with **FastAPI** , you might not need this.

You can declare additional responses, with additional status codes, media types, descriptions, etc.

Those additional responses will be included in the OpenAPI schema, so they will also appear in the API docs.

But for those additional responses you have to make sure you return a `Response` like `JSONResponse` directly, with your status code and content.

## Additional Response with `model`[¶](#additional-response-with-model "Permanent link")

You can pass to your _path operation decorators_ a parameter `responses`.

It receives a `dict`: the keys are status codes for each response (like `200`), and the values are other `dict`s with the information for each of them.

Each of those response `dict`s can have a key `model`, containing a Pydantic model, just like `response_model`.

**FastAPI** will take that model, generate its JSON Schema and include it in the correct place in OpenAPI.

For example, to declare another response with a status code `404` and a Pydantic model `Message`, you can write:

Python 3.9+
    
    
    from fastapi import FastAPI
    from fastapi.responses import JSONResponse
    from pydantic import BaseModel
    
    
    class Item(BaseModel):
        id: str
        value: str
    
    
    class Message(BaseModel):
        message: str
    
    
    app = FastAPI()
    
    
    @app.get("/items/{item_id}", response_model=Item, responses={404: {"model": Message}})
    async def read_item(item_id: str):
        if item_id == "foo":
            return {"id": "foo", "value": "there goes my hero"}
        return JSONResponse(status_code=404, content={"message": "Item not found"})
    

Note

Keep in mind that you have to return the `JSONResponse` directly.

Info

The `model` key is not part of OpenAPI.

**FastAPI** will take the Pydantic model from there, generate the JSON Schema, and put it in the correct place.

The correct place is:

  * In the key `content`, that has as value another JSON object (`dict`) that contains:
    * A key with the media type, e.g. `application/json`, that contains as value another JSON object, that contains:
      * A key `schema`, that has as the value the JSON Schema from the model, here's the correct place.
        * **FastAPI** adds a reference here to the global JSON Schemas in another place in your OpenAPI instead of including it directly. This way, other applications and clients can use those JSON Schemas directly, provide better code generation tools, etc.

The generated responses in the OpenAPI for this _path operation_ will be:
    
    
    {
        "responses": {
            "404": {
                "description": "Additional Response",
                "content": {
                    "application/json": {
                        "schema": {
                            "$ref": "#/components/schemas/Message"
                        }
                    }
                }
            },
            "200": {
                "description": "Successful Response",
                "content": {
                    "application/json": {
                        "schema": {
                            "$ref": "#/components/schemas/Item"
                        }
                    }
                }
            },
            "422": {
                "description": "Validation Error",
                "content": {
                    "application/json": {
                        "schema": {
                            "$ref": "#/components/schemas/HTTPValidationError"
                        }
                    }
                }
            }
        }
    }
    

The schemas are referenced to another place inside the OpenAPI schema:
    
    
    {
        "components": {
            "schemas": {
                "Message": {
                    "title": "Message",
                    "required": [
                        "message"
                    ],
                    "type": "object",
                    "properties": {
                        "message": {
                            "title": "Message",
                            "type": "string"
                        }
                    }
                },
                "Item": {
                    "title": "Item",
                    "required": [
                        "id",
                        "value"
                    ],
                    "type": "object",
                    "properties": {
                        "id": {
                            "title": "Id",
                            "type": "string"
                        },
                        "value": {
                            "title": "Value",
                            "type": "string"
                        }
                    }
                },
                "ValidationError": {
                    "title": "ValidationError",
                    "required": [
                        "loc",
                        "msg",
                        "type"
                    ],
                    "type": "object",
                    "properties": {
                        "loc": {
                            "title": "Location",
                            "type": "array",
                            "items": {
                                "type": "string"
                            }
                        },
                        "msg": {
                            "title": "Message",
                            "type": "string"
                        },
                        "type": {
                            "title": "Error Type",
                            "type": "string"
                        }
                    }
                },
                "HTTPValidationError": {
                    "title": "HTTPValidationError",
                    "type": "object",
                    "properties": {
                        "detail": {
                            "title": "Detail",
                            "type": "array",
                            "items": {
                                "$ref": "#/components/schemas/ValidationError"
                            }
                        }
                    }
                }
            }
        }
    }
    

## Additional media types for the main response[¶](#additional-media-types-for-the-main-response "Permanent link")

You can use this same `responses` parameter to add different media types for the same main response.

For example, you can add an additional media type of `image/png`, declaring that your _path operation_ can return a JSON object (with media type `application/json`) or a PNG image:

Python 3.10+
    
    
    from fastapi import FastAPI
    from fastapi.responses import FileResponse
    from pydantic import BaseModel
    
    
    class Item(BaseModel):
        id: str
        value: str
    
    
    app = FastAPI()
    
    
    @app.get(
        "/items/{item_id}",
        response_model=Item,
        responses={
            200: {
                "content": {"image/png": {}},
                "description": "Return the JSON item or an image.",
            }
        },
    )
    async def read_item(item_id: str, img: bool | None = None):
        if img:
            return FileResponse("image.png", media_type="image/png")
        else:
            return {"id": "foo", "value": "there goes my hero"}
    

ü§ì Other versions and variants

Python 3.9+
    
    
    from typing import Union
    
    from fastapi import FastAPI
    from fastapi.responses import FileResponse
    from pydantic import BaseModel
    
    
    class Item(BaseModel):
        id: str
        value: str
    
    
    app = FastAPI()
    
    
    @app.get(
        "/items/{item_id}",
        response_model=Item,
        responses={
            200: {
                "content": {"image/png": {}},
                "description": "Return the JSON item or an image.",
            }
        },
    )
    async def read_item(item_id: str, img: Union[bool, None] = None):
        if img:
            return FileResponse("image.png", media_type="image/png")
        else:
            return {"id": "foo", "value": "there goes my hero"}
    

Note

Notice that you have to return the image using a `FileResponse` directly.

Info

Unless you specify a different media type explicitly in your `responses` parameter, FastAPI will assume the response has the same media type as the main response class (default `application/json`).

But if you have specified a custom response class with `None` as its media type, FastAPI will use `application/json` for any additional response that has an associated model.

## Combining information[¶](#combining-information "Permanent link")

You can also combine response information from multiple places, including the `response_model`, `status_code`, and `responses` parameters.

You can declare a `response_model`, using the default status code `200` (or a custom one if you need), and then declare additional information for that same response in `responses`, directly in the OpenAPI schema.

**FastAPI** will keep the additional information from `responses`, and combine it with the JSON Schema from your model.

For example, you can declare a response with a status code `404` that uses a Pydantic model and has a custom `description`.

And a response with a status code `200` that uses your `response_model`, but includes a custom `example`:

Python 3.9+
    
    
    from fastapi import FastAPI
    from fastapi.responses import JSONResponse
    from pydantic import BaseModel
    
    
    class Item(BaseModel):
        id: str
        value: str
    
    
    class Message(BaseModel):
        message: str
    
    
    app = FastAPI()
    
    
    @app.get(
        "/items/{item_id}",
        response_model=Item,
        responses={
            404: {"model": Message, "description": "The item was not found"},
            200: {
                "description": "Item requested by ID",
                "content": {
                    "application/json": {
                        "example": {"id": "bar", "value": "The bar tenders"}
                    }
                },
            },
        },
    )
    async def read_item(item_id: str):
        if item_id == "foo":
            return {"id": "foo", "value": "there goes my hero"}
        else:
            return JSONResponse(status_code=404, content={"message": "Item not found"})
    

It will all be combined and included in your OpenAPI, and shown in the API docs:

![](/img/tutorial/additional-responses/image01.png)

## Combine predefined responses and custom ones[¶](#combine-predefined-responses-and-custom-ones "Permanent link")

You might want to have some predefined responses that apply to many _path operations_ , but you want to combine them with custom responses needed by each _path operation_.

For those cases, you can use the Python technique of "unpacking" a `dict` with `**dict_to_unpack`:
    
    
    old_dict = {
        "old key": "old value",
        "second old key": "second old value",
    }
    new_dict = {**old_dict, "new key": "new value"}
    

Here, `new_dict` will contain all the key-value pairs from `old_dict` plus the new key-value pair:
    
    
    {
        "old key": "old value",
        "second old key": "second old value",
        "new key": "new value",
    }
    

You can use that technique to reuse some predefined responses in your _path operations_ and combine them with additional custom ones.

For example:

Python 3.10+
    
    
    from fastapi import FastAPI
    from fastapi.responses import FileResponse
    from pydantic import BaseModel
    
    
    class Item(BaseModel):
        id: str
        value: str
    
    
    responses = {
        404: {"description": "Item not found"},
        302: {"description": "The item was moved"},
        403: {"description": "Not enough privileges"},
    }
    
    
    app = FastAPI()
    
    
    @app.get(
        "/items/{item_id}",
        response_model=Item,
        responses={**responses, 200: {"content": {"image/png": {}}}},
    )
    async def read_item(item_id: str, img: bool | None = None):
        if img:
            return FileResponse("image.png", media_type="image/png")
        else:
            return {"id": "foo", "value": "there goes my hero"}
    

ü§ì Other versions and variants

Python 3.9+
    
    
    from typing import Union
    
    from fastapi import FastAPI
    from fastapi.responses import FileResponse
    from pydantic import BaseModel
    
    
    class Item(BaseModel):
        id: str
        value: str
    
    
    responses = {
        404: {"description": "Item not found"},
        302: {"description": "The item was moved"},
        403: {"description": "Not enough privileges"},
    }
    
    
    app = FastAPI()
    
    
    @app.get(
        "/items/{item_id}",
        response_model=Item,
        responses={**responses, 200: {"content": {"image/png": {}}}},
    )
    async def read_item(item_id: str, img: Union[bool, None] = None):
        if img:
            return FileResponse("image.png", media_type="image/png")
        else:
            return {"id": "foo", "value": "there goes my hero"}
    

## More information about OpenAPI responses[¶](#more-information-about-openapi-responses "Permanent link")

To see what exactly you can include in the responses, you can check these sections in the OpenAPI specification:

  * [OpenAPI Responses Object](https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.1.0.md#responses-object), it includes the `Response Object`.
  * [OpenAPI Response Object](https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.1.0.md#response-object), you can include anything from this directly in each response inside your `responses` parameter. Including `description`, `headers`, `content` (inside of this is that you declare different media types and JSON Schemas), and `links`.

---

###### Response Cookies¶

# Response Cookies[¶](#response-cookies "Permanent link")

## Use a `Response` parameter[¶](#use-a-response-parameter "Permanent link")

You can declare a parameter of type `Response` in your _path operation function_.

And then you can set cookies in that _temporal_ response object.

Python 3.9+
    
    
    from fastapi import FastAPI, Response
    
    app = FastAPI()
    
    
    @app.post("/cookie-and-object/")
    def create_cookie(response: Response):
        response.set_cookie(key="fakesession", value="fake-cookie-session-value")
        return {"message": "Come to the dark side, we have cookies"}
    

And then you can return any object you need, as you normally would (a `dict`, a database model, etc).

And if you declared a `response_model`, it will still be used to filter and convert the object you returned.

**FastAPI** will use that _temporal_ response to extract the cookies (also headers and status code), and will put them in the final response that contains the value you returned, filtered by any `response_model`.

You can also declare the `Response` parameter in dependencies, and set cookies (and headers) in them.

## Return a `Response` directly[¶](#return-a-response-directly "Permanent link")

You can also create cookies when returning a `Response` directly in your code.

To do that, you can create a response as described in [Return a Response Directly](../response-directly/).

Then set Cookies in it, and then return it:

Python 3.9+
    
    
    from fastapi import FastAPI
    from fastapi.responses import JSONResponse
    
    app = FastAPI()
    
    
    @app.post("/cookie/")
    def create_cookie():
        content = {"message": "Come to the dark side, we have cookies"}
        response = JSONResponse(content=content)
        response.set_cookie(key="fakesession", value="fake-cookie-session-value")
        return response
    

Tip

Keep in mind that if you return a response directly instead of using the `Response` parameter, FastAPI will return it directly.

So, you will have to make sure your data is of the correct type. E.g. it is compatible with JSON, if you are returning a `JSONResponse`.

And also that you are not sending any data that should have been filtered by a `response_model`.

### More info[¶](#more-info "Permanent link")

Technical Details

You could also use `from starlette.responses import Response` or `from starlette.responses import JSONResponse`.

**FastAPI** provides the same `starlette.responses` as `fastapi.responses` just as a convenience for you, the developer. But most of the available responses come directly from Starlette.

And as the `Response` can be used frequently to set headers and cookies, **FastAPI** also provides it at `fastapi.Response`.

To see all the available parameters and options, check the [documentation in Starlette](https://www.starlette.dev/responses/#set-cookie).

---

###### Response Headers¶

# Response Headers[¶](#response-headers "Permanent link")

## Use a `Response` parameter[¶](#use-a-response-parameter "Permanent link")

You can declare a parameter of type `Response` in your _path operation function_ (as you can do for cookies).

And then you can set headers in that _temporal_ response object.

Python 3.9+
    
    
    from fastapi import FastAPI, Response
    
    app = FastAPI()
    
    
    @app.get("/headers-and-object/")
    def get_headers(response: Response):
        response.headers["X-Cat-Dog"] = "alone in the world"
        return {"message": "Hello World"}
    

And then you can return any object you need, as you normally would (a `dict`, a database model, etc).

And if you declared a `response_model`, it will still be used to filter and convert the object you returned.

**FastAPI** will use that _temporal_ response to extract the headers (also cookies and status code), and will put them in the final response that contains the value you returned, filtered by any `response_model`.

You can also declare the `Response` parameter in dependencies, and set headers (and cookies) in them.

## Return a `Response` directly[¶](#return-a-response-directly "Permanent link")

You can also add headers when you return a `Response` directly.

Create a response as described in [Return a Response Directly](../response-directly/) and pass the headers as an additional parameter:

Python 3.9+
    
    
    from fastapi import FastAPI
    from fastapi.responses import JSONResponse
    
    app = FastAPI()
    
    
    @app.get("/headers/")
    def get_headers():
        content = {"message": "Hello World"}
        headers = {"X-Cat-Dog": "alone in the world", "Content-Language": "en-US"}
        return JSONResponse(content=content, headers=headers)
    

Technical Details

You could also use `from starlette.responses import Response` or `from starlette.responses import JSONResponse`.

**FastAPI** provides the same `starlette.responses` as `fastapi.responses` just as a convenience for you, the developer. But most of the available responses come directly from Starlette.

And as the `Response` can be used frequently to set headers and cookies, **FastAPI** also provides it at `fastapi.Response`.

## Custom Headers[¶](#custom-headers "Permanent link")

Keep in mind that custom proprietary headers can be added [using the `X-` prefix](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers).

But if you have custom headers that you want a client in a browser to be able to see, you need to add them to your CORS configurations (read more in [CORS (Cross-Origin Resource Sharing)](../../tutorial/cors/)), using the parameter `expose_headers` documented in [Starlette's CORS docs](https://www.starlette.dev/middleware/#corsmiddleware).

---

###### Response - Change Status Code¶

# Response - Change Status Code[¶](#response-change-status-code "Permanent link")

You probably read before that you can set a default [Response Status Code](../../tutorial/response-status-code/).

But in some cases you need to return a different status code than the default.

## Use case[¶](#use-case "Permanent link")

For example, imagine that you want to return an HTTP status code of "OK" `200` by default.

But if the data didn't exist, you want to create it, and return an HTTP status code of "CREATED" `201`.

But you still want to be able to filter and convert the data you return with a `response_model`.

For those cases, you can use a `Response` parameter.

## Use a `Response` parameter[¶](#use-a-response-parameter "Permanent link")

You can declare a parameter of type `Response` in your _path operation function_ (as you can do for cookies and headers).

And then you can set the `status_code` in that _temporal_ response object.

Python 3.9+
    
    
    from fastapi import FastAPI, Response, status
    
    app = FastAPI()
    
    tasks = {"foo": "Listen to the Bar Fighters"}
    
    
    @app.put("/get-or-create-task/{task_id}", status_code=200)
    def get_or_create_task(task_id: str, response: Response):
        if task_id not in tasks:
            tasks[task_id] = "This didn't exist before"
            response.status_code = status.HTTP_201_CREATED
        return tasks[task_id]
    

And then you can return any object you need, as you normally would (a `dict`, a database model, etc).

And if you declared a `response_model`, it will still be used to filter and convert the object you returned.

**FastAPI** will use that _temporal_ response to extract the status code (also cookies and headers), and will put them in the final response that contains the value you returned, filtered by any `response_model`.

You can also declare the `Response` parameter in dependencies, and set the status code in them. But keep in mind that the last one to be set will win.

---

###### Advanced Dependencies¶

# Advanced Dependencies[¶](#advanced-dependencies "Permanent link")

## Parameterized dependencies[¶](#parameterized-dependencies "Permanent link")

All the dependencies we have seen are a fixed function or class.

But there could be cases where you want to be able to set parameters on the dependency, without having to declare many different functions or classes.

Let's imagine that we want to have a dependency that checks if the query parameter `q` contains some fixed content.

But we want to be able to parameterize that fixed content.

## A "callable" instance[¶](#a-callable-instance "Permanent link")

In Python there's a way to make an instance of a class a "callable".

Not the class itself (which is already a callable), but an instance of that class.

To do that, we declare a method `__call__`:

Python 3.9+
    
    
    from typing import Annotated
    
    from fastapi import Depends, FastAPI
    
    app = FastAPI()
    
    
    class FixedContentQueryChecker:
        def __init__(self, fixed_content: str):
            self.fixed_content = fixed_content
    
        def __call__(self, q: str = ""):
            if q:
                return self.fixed_content in q
            return False
    
    
    checker = FixedContentQueryChecker("bar")
    
    
    @app.get("/query-checker/")
    async def read_query_check(fixed_content_included: Annotated[bool, Depends(checker)]):
        return {"fixed_content_in_query": fixed_content_included}
    

ü§ì Other versions and variants

Python 3.9+ - non-Annotated

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import Depends, FastAPI
    
    app = FastAPI()
    
    
    class FixedContentQueryChecker:
        def __init__(self, fixed_content: str):
            self.fixed_content = fixed_content
    
        def __call__(self, q: str = ""):
            if q:
                return self.fixed_content in q
            return False
    
    
    checker = FixedContentQueryChecker("bar")
    
    
    @app.get("/query-checker/")
    async def read_query_check(fixed_content_included: bool = Depends(checker)):
        return {"fixed_content_in_query": fixed_content_included}
    

In this case, this `__call__` is what **FastAPI** will use to check for additional parameters and sub-dependencies, and this is what will be called to pass a value to the parameter in your _path operation function_ later.

## Parameterize the instance[¶](#parameterize-the-instance "Permanent link")

And now, we can use `__init__` to declare the parameters of the instance that we can use to "parameterize" the dependency:

Python 3.9+
    
    
    from typing import Annotated
    
    from fastapi import Depends, FastAPI
    
    app = FastAPI()
    
    
    class FixedContentQueryChecker:
        def __init__(self, fixed_content: str):
            self.fixed_content = fixed_content
    
        def __call__(self, q: str = ""):
            if q:
                return self.fixed_content in q
            return False
    
    
    checker = FixedContentQueryChecker("bar")
    
    
    @app.get("/query-checker/")
    async def read_query_check(fixed_content_included: Annotated[bool, Depends(checker)]):
        return {"fixed_content_in_query": fixed_content_included}
    

ü§ì Other versions and variants

Python 3.9+ - non-Annotated

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import Depends, FastAPI
    
    app = FastAPI()
    
    
    class FixedContentQueryChecker:
        def __init__(self, fixed_content: str):
            self.fixed_content = fixed_content
    
        def __call__(self, q: str = ""):
            if q:
                return self.fixed_content in q
            return False
    
    
    checker = FixedContentQueryChecker("bar")
    
    
    @app.get("/query-checker/")
    async def read_query_check(fixed_content_included: bool = Depends(checker)):
        return {"fixed_content_in_query": fixed_content_included}
    

In this case, **FastAPI** won't ever touch or care about `__init__`, we will use it directly in our code.

## Create an instance[¶](#create-an-instance "Permanent link")

We could create an instance of this class with:

Python 3.9+
    
    
    from typing import Annotated
    
    from fastapi import Depends, FastAPI
    
    app = FastAPI()
    
    
    class FixedContentQueryChecker:
        def __init__(self, fixed_content: str):
            self.fixed_content = fixed_content
    
        def __call__(self, q: str = ""):
            if q:
                return self.fixed_content in q
            return False
    
    
    checker = FixedContentQueryChecker("bar")
    
    
    @app.get("/query-checker/")
    async def read_query_check(fixed_content_included: Annotated[bool, Depends(checker)]):
        return {"fixed_content_in_query": fixed_content_included}
    

ü§ì Other versions and variants

Python 3.9+ - non-Annotated

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import Depends, FastAPI
    
    app = FastAPI()
    
    
    class FixedContentQueryChecker:
        def __init__(self, fixed_content: str):
            self.fixed_content = fixed_content
    
        def __call__(self, q: str = ""):
            if q:
                return self.fixed_content in q
            return False
    
    
    checker = FixedContentQueryChecker("bar")
    
    
    @app.get("/query-checker/")
    async def read_query_check(fixed_content_included: bool = Depends(checker)):
        return {"fixed_content_in_query": fixed_content_included}
    

And that way we are able to "parameterize" our dependency, that now has `"bar"` inside of it, as the attribute `checker.fixed_content`.

## Use the instance as a dependency[¶](#use-the-instance-as-a-dependency "Permanent link")

Then, we could use this `checker` in a `Depends(checker)`, instead of `Depends(FixedContentQueryChecker)`, because the dependency is the instance, `checker`, not the class itself.

And when solving the dependency, **FastAPI** will call this `checker` like:
    
    
    checker(q="somequery")
    

...and pass whatever that returns as the value of the dependency in our _path operation function_ as the parameter `fixed_content_included`:

Python 3.9+
    
    
    from typing import Annotated
    
    from fastapi import Depends, FastAPI
    
    app = FastAPI()
    
    
    class FixedContentQueryChecker:
        def __init__(self, fixed_content: str):
            self.fixed_content = fixed_content
    
        def __call__(self, q: str = ""):
            if q:
                return self.fixed_content in q
            return False
    
    
    checker = FixedContentQueryChecker("bar")
    
    
    @app.get("/query-checker/")
    async def read_query_check(fixed_content_included: Annotated[bool, Depends(checker)]):
        return {"fixed_content_in_query": fixed_content_included}
    

ü§ì Other versions and variants

Python 3.9+ - non-Annotated

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import Depends, FastAPI
    
    app = FastAPI()
    
    
    class FixedContentQueryChecker:
        def __init__(self, fixed_content: str):
            self.fixed_content = fixed_content
    
        def __call__(self, q: str = ""):
            if q:
                return self.fixed_content in q
            return False
    
    
    checker = FixedContentQueryChecker("bar")
    
    
    @app.get("/query-checker/")
    async def read_query_check(fixed_content_included: bool = Depends(checker)):
        return {"fixed_content_in_query": fixed_content_included}
    

Tip

All this might seem contrived. And it might not be very clear how is it useful yet.

These examples are intentionally simple, but show how it all works.

In the chapters about security, there are utility functions that are implemented in this same way.

If you understood all this, you already know how those utility tools for security work underneath.

## Dependencies with `yield`, `HTTPException`, `except` and Background Tasks[¶](#dependencies-with-yield-httpexception-except-and-background-tasks "Permanent link")

Warning

You most probably don't need these technical details.

These details are useful mainly if you had a FastAPI application older than 0.121.0 and you are facing issues with dependencies with `yield`.

Dependencies with `yield` have evolved over time to account for the different use cases and to fix some issues, here's a summary of what has changed.

### Dependencies with `yield` and `scope`[¶](#dependencies-with-yield-and-scope "Permanent link")

In version 0.121.0, FastAPI added support for `Depends(scope="function")` for dependencies with `yield`.

Using `Depends(scope="function")`, the exit code after `yield` is executed right after the _path operation function_ is finished, before the response is sent back to the client.

And when using `Depends(scope="request")` (the default), the exit code after `yield` is executed after the response is sent.

You can read more about it in the docs for [Dependencies with `yield` \- Early exit and `scope`](../../tutorial/dependencies/dependencies-with-yield/#early-exit-and-scope).

### Dependencies with `yield` and `StreamingResponse`, Technical Details[¶](#dependencies-with-yield-and-streamingresponse-technical-details "Permanent link")

Before FastAPI 0.118.0, if you used a dependency with `yield`, it would run the exit code after the _path operation function_ returned but right before sending the response.

The intention was to avoid holding resources for longer than necessary, waiting for the response to travel through the network.

This change also meant that if you returned a `StreamingResponse`, the exit code of the dependency with `yield` would have been already run.

For example, if you had a database session in a dependency with `yield`, the `StreamingResponse` would not be able to use that session while streaming data because the session would have already been closed in the exit code after `yield`.

This behavior was reverted in 0.118.0, to make the exit code after `yield` be executed after the response is sent.

Info

As you will see below, this is very similar to the behavior before version 0.106.0, but with several improvements and bug fixes for corner cases.

#### Use Cases with Early Exit Code[¶](#use-cases-with-early-exit-code "Permanent link")

There are some use cases with specific conditions that could benefit from the old behavior of running the exit code of dependencies with `yield` before sending the response.

For example, imagine you have code that uses a database session in a dependency with `yield` only to verify a user, but the database session is never used again in the _path operation function_ , only in the dependency, **and** the response takes a long time to be sent, like a `StreamingResponse` that sends data slowly, but for some reason doesn't use the database.

In this case, the database session would be held until the response is finished being sent, but if you don't use it, then it wouldn't be necessary to hold it.

Here's how it could look like:

Python 3.10+
    
    
    import time
    from typing import Annotated
    
    from fastapi import Depends, FastAPI, HTTPException
    from fastapi.responses import StreamingResponse
    from sqlmodel import Field, Session, SQLModel, create_engine
    
    engine = create_engine("postgresql+psycopg://postgres:postgres@localhost/db")
    
    
    class User(SQLModel, table=True):
        id: int | None = Field(default=None, primary_key=True)
        name: str
    
    
    app = FastAPI()
    
    
    def get_session():
        with Session(engine) as session:
            yield session
    
    
    def get_user(user_id: int, session: Annotated[Session, Depends(get_session)]):
        user = session.get(User, user_id)
        if not user:
            raise HTTPException(status_code=403, detail="Not authorized")
    
    
    def generate_stream(query: str):
        for ch in query:
            yield ch
            time.sleep(0.1)
    
    
    @app.get("/generate", dependencies=[Depends(get_user)])
    def generate(query: str):
        return StreamingResponse(content=generate_stream(query))
    

The exit code, the automatic closing of the `Session` in:

Python 3.10+
    
    
    # Code above omitted üëÜ
    
    def get_session():
        with Session(engine) as session:
            yield session
    
    # Code below omitted üëá
    

üëÄ Full file preview

Python 3.10+
    
    
    import time
    from typing import Annotated
    
    from fastapi import Depends, FastAPI, HTTPException
    from fastapi.responses import StreamingResponse
    from sqlmodel import Field, Session, SQLModel, create_engine
    
    engine = create_engine("postgresql+psycopg://postgres:postgres@localhost/db")
    
    
    class User(SQLModel, table=True):
        id: int | None = Field(default=None, primary_key=True)
        name: str
    
    
    app = FastAPI()
    
    
    def get_session():
        with Session(engine) as session:
            yield session
    
    
    def get_user(user_id: int, session: Annotated[Session, Depends(get_session)]):
        user = session.get(User, user_id)
        if not user:
            raise HTTPException(status_code=403, detail="Not authorized")
    
    
    def generate_stream(query: str):
        for ch in query:
            yield ch
            time.sleep(0.1)
    
    
    @app.get("/generate", dependencies=[Depends(get_user)])
    def generate(query: str):
        return StreamingResponse(content=generate_stream(query))
    

...would be run after the response finishes sending the slow data:

Python 3.10+
    
    
    # Code above omitted üëÜ
    
    def generate_stream(query: str):
        for ch in query:
            yield ch
            time.sleep(0.1)
    
    
    @app.get("/generate", dependencies=[Depends(get_user)])
    def generate(query: str):
        return StreamingResponse(content=generate_stream(query))
    

üëÄ Full file preview

Python 3.10+
    
    
    import time
    from typing import Annotated
    
    from fastapi import Depends, FastAPI, HTTPException
    from fastapi.responses import StreamingResponse
    from sqlmodel import Field, Session, SQLModel, create_engine
    
    engine = create_engine("postgresql+psycopg://postgres:postgres@localhost/db")
    
    
    class User(SQLModel, table=True):
        id: int | None = Field(default=None, primary_key=True)
        name: str
    
    
    app = FastAPI()
    
    
    def get_session():
        with Session(engine) as session:
            yield session
    
    
    def get_user(user_id: int, session: Annotated[Session, Depends(get_session)]):
        user = session.get(User, user_id)
        if not user:
            raise HTTPException(status_code=403, detail="Not authorized")
    
    
    def generate_stream(query: str):
        for ch in query:
            yield ch
            time.sleep(0.1)
    
    
    @app.get("/generate", dependencies=[Depends(get_user)])
    def generate(query: str):
        return StreamingResponse(content=generate_stream(query))
    

But as `generate_stream()` doesn't use the database session, it is not really necessary to keep the session open while sending the response.

If you have this specific use case using SQLModel (or SQLAlchemy), you could explicitly close the session after you don't need it anymore:

Python 3.10+
    
    
    # Code above omitted üëÜ
    
    def get_user(user_id: int, session: Annotated[Session, Depends(get_session)]):
        user = session.get(User, user_id)
        if not user:
            raise HTTPException(status_code=403, detail="Not authorized")
        session.close()
    
    # Code below omitted üëá
    

üëÄ Full file preview

Python 3.10+
    
    
    import time
    from typing import Annotated
    
    from fastapi import Depends, FastAPI, HTTPException
    from fastapi.responses import StreamingResponse
    from sqlmodel import Field, Session, SQLModel, create_engine
    
    engine = create_engine("postgresql+psycopg://postgres:postgres@localhost/db")
    
    
    class User(SQLModel, table=True):
        id: int | None = Field(default=None, primary_key=True)
        name: str
    
    
    app = FastAPI()
    
    
    def get_session():
        with Session(engine) as session:
            yield session
    
    
    def get_user(user_id: int, session: Annotated[Session, Depends(get_session)]):
        user = session.get(User, user_id)
        if not user:
            raise HTTPException(status_code=403, detail="Not authorized")
        session.close()
    
    
    def generate_stream(query: str):
        for ch in query:
            yield ch
            time.sleep(0.1)
    
    
    @app.get("/generate", dependencies=[Depends(get_user)])
    def generate(query: str):
        return StreamingResponse(content=generate_stream(query))
    

That way the session would release the database connection, so other requests could use it.

If you have a different use case that needs to exit early from a dependency with `yield`, please create a [GitHub Discussion Question](https://github.com/fastapi/fastapi/discussions/new?category=questions) with your specific use case and why you would benefit from having early closing for dependencies with `yield`.

If there are compelling use cases for early closing in dependencies with `yield`, I would consider adding a new way to opt in to early closing.

### Dependencies with `yield` and `except`, Technical Details[¶](#dependencies-with-yield-and-except-technical-details "Permanent link")

Before FastAPI 0.110.0, if you used a dependency with `yield`, and then you captured an exception with `except` in that dependency, and you didn't raise the exception again, the exception would be automatically raised/forwarded to any exception handlers or the internal server error handler.

This was changed in version 0.110.0 to fix unhandled memory consumption from forwarded exceptions without a handler (internal server errors), and to make it consistent with the behavior of regular Python code.

### Background Tasks and Dependencies with `yield`, Technical Details[¶](#background-tasks-and-dependencies-with-yield-technical-details "Permanent link")

Before FastAPI 0.106.0, raising exceptions after `yield` was not possible, the exit code in dependencies with `yield` was executed _after_ the response was sent, so [Exception Handlers](../../tutorial/handling-errors/#install-custom-exception-handlers) would have already run.

This was designed this way mainly to allow using the same objects "yielded" by dependencies inside of background tasks, because the exit code would be executed after the background tasks were finished.

This was changed in FastAPI 0.106.0 with the intention to not hold resources while waiting for the response to travel through the network.

Tip

Additionally, a background task is normally an independent set of logic that should be handled separately, with its own resources (e.g. its own database connection).

So, this way you will probably have cleaner code.

If you used to rely on this behavior, now you should create the resources for background tasks inside the background task itself, and use internally only data that doesn't depend on the resources of dependencies with `yield`.

For example, instead of using the same database session, you would create a new database session inside of the background task, and you would obtain the objects from the database using this new session. And then instead of passing the object from the database as a parameter to the background task function, you would pass the ID of that object and then obtain the object again inside the background task function.

---

###### Advanced Security¶

# Advanced Security[¶](#advanced-security "Permanent link")

## Additional Features[¶](#additional-features "Permanent link")

There are some extra features to handle security apart from the ones covered in the [Tutorial - User Guide: Security](../../tutorial/security/).

Tip

The next sections are **not necessarily "advanced"**.

And it's possible that for your use case, the solution is in one of them.

## Read the Tutorial first[¶](#read-the-tutorial-first "Permanent link")

The next sections assume you already read the main [Tutorial - User Guide: Security](../../tutorial/security/).

They are all based on the same concepts, but allow some extra functionalities.

---

###### OAuth2 scopes¶

# OAuth2 scopes[¶](#oauth2-scopes "Permanent link")

You can use OAuth2 scopes directly with **FastAPI** , they are integrated to work seamlessly.

This would allow you to have a more fine-grained permission system, following the OAuth2 standard, integrated into your OpenAPI application (and the API docs).

OAuth2 with scopes is the mechanism used by many big authentication providers, like Facebook, Google, GitHub, Microsoft, X (Twitter), etc. They use it to provide specific permissions to users and applications.

Every time you "log in with" Facebook, Google, GitHub, Microsoft, X (Twitter), that application is using OAuth2 with scopes.

In this section you will see how to manage authentication and authorization with the same OAuth2 with scopes in your **FastAPI** application.

Warning

This is a more or less advanced section. If you are just starting, you can skip it.

You don't necessarily need OAuth2 scopes, and you can handle authentication and authorization however you want.

But OAuth2 with scopes can be nicely integrated into your API (with OpenAPI) and your API docs.

Nevertheless, you still enforce those scopes, or any other security/authorization requirement, however you need, in your code.

In many cases, OAuth2 with scopes can be an overkill.

But if you know you need it, or you are curious, keep reading.

## OAuth2 scopes and OpenAPI[¶](#oauth2-scopes-and-openapi "Permanent link")

The OAuth2 specification defines "scopes" as a list of strings separated by spaces.

The content of each of these strings can have any format, but should not contain spaces.

These scopes represent "permissions".

In OpenAPI (e.g. the API docs), you can define "security schemes".

When one of these security schemes uses OAuth2, you can also declare and use scopes.

Each "scope" is just a string (without spaces).

They are normally used to declare specific security permissions, for example:

  * `users:read` or `users:write` are common examples.
  * `instagram_basic` is used by Facebook / Instagram.
  * `https://www.googleapis.com/auth/drive` is used by Google.

Info

In OAuth2 a "scope" is just a string that declares a specific permission required.

It doesn't matter if it has other characters like `:` or if it is a URL.

Those details are implementation specific.

For OAuth2 they are just strings.

## Global view[¶](#global-view "Permanent link")

First, let's quickly see the parts that change from the examples in the main **Tutorial - User Guide** for [OAuth2 with Password (and hashing), Bearer with JWT tokens](../../../tutorial/security/oauth2-jwt/). Now using OAuth2 scopes:

Python 3.10+
    
    
    from datetime import datetime, timedelta, timezone
    from typing import Annotated
    
    import jwt
    from fastapi import Depends, FastAPI, HTTPException, Security, status
    from fastapi.security import (
        OAuth2PasswordBearer,
        OAuth2PasswordRequestForm,
        SecurityScopes,
    )
    from jwt.exceptions import InvalidTokenError
    from pwdlib import PasswordHash
    from pydantic import BaseModel, ValidationError
    
    # to get a string like this run:
    # openssl rand -hex 32
    SECRET_KEY = "09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
    ALGORITHM = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES = 30
    
    
    fake_users_db = {
        "johndoe": {
            "username": "johndoe",
            "full_name": "John Doe",
            "email": "johndoe@example.com",
            "hashed_password": "$argon2id$v=19$m=65536,t=3,p=4$wagCPXjifgvUFBzq4hqe3w$CYaIb8sB+wtD+Vu/P4uod1+Qof8h+1g7bbDlBID48Rc",
            "disabled": False,
        },
        "alice": {
            "username": "alice",
            "full_name": "Alice Chains",
            "email": "alicechains@example.com",
            "hashed_password": "$argon2id$v=19$m=65536,t=3,p=4$g2/AV1zwopqUntPKJavBFw$BwpRGDCyUHLvHICnwijyX8ROGoiUPwNKZ7915MeYfCE",
            "disabled": True,
        },
    }
    
    
    class Token(BaseModel):
        access_token: str
        token_type: str
    
    
    class TokenData(BaseModel):
        username: str | None = None
        scopes: list[str] = []
    
    
    class User(BaseModel):
        username: str
        email: str | None = None
        full_name: str | None = None
        disabled: bool | None = None
    
    
    class UserInDB(User):
        hashed_password: str
    
    
    password_hash = PasswordHash.recommended()
    
    oauth2_scheme = OAuth2PasswordBearer(
        tokenUrl="token",
        scopes={"me": "Read information about the current user.", "items": "Read items."},
    )
    
    app = FastAPI()
    
    
    def verify_password(plain_password, hashed_password):
        return password_hash.verify(plain_password, hashed_password)
    
    
    def get_password_hash(password):
        return password_hash.hash(password)
    
    
    def get_user(db, username: str):
        if username in db:
            user_dict = db[username]
            return UserInDB(**user_dict)
    
    
    def authenticate_user(fake_db, username: str, password: str):
        user = get_user(fake_db, username)
        if not user:
            return False
        if not verify_password(password, user.hashed_password):
            return False
        return user
    
    
    def create_access_token(data: dict, expires_delta: timedelta | None = None):
        to_encode = data.copy()
        if expires_delta:
            expire = datetime.now(timezone.utc) + expires_delta
        else:
            expire = datetime.now(timezone.utc) + timedelta(minutes=15)
        to_encode.update({"exp": expire})
        encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
        return encoded_jwt
    
    
    async def get_current_user(
        security_scopes: SecurityScopes, token: Annotated[str, Depends(oauth2_scheme)]
    ):
        if security_scopes.scopes:
            authenticate_value = f'Bearer scope="{security_scopes.scope_str}"'
        else:
            authenticate_value = "Bearer"
        credentials_exception = HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Could not validate credentials",
            headers={"WWW-Authenticate": authenticate_value},
        )
        try:
            payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
            username = payload.get("sub")
            if username is None:
                raise credentials_exception
            scope: str = payload.get("scope", "")
            token_scopes = scope.split(" ")
            token_data = TokenData(scopes=token_scopes, username=username)
        except (InvalidTokenError, ValidationError):
            raise credentials_exception
        user = get_user(fake_users_db, username=token_data.username)
        if user is None:
            raise credentials_exception
        for scope in security_scopes.scopes:
            if scope not in token_data.scopes:
                raise HTTPException(
                    status_code=status.HTTP_401_UNAUTHORIZED,
                    detail="Not enough permissions",
                    headers={"WWW-Authenticate": authenticate_value},
                )
        return user
    
    
    async def get_current_active_user(
        current_user: Annotated[User, Security(get_current_user, scopes=["me"])],
    ):
        if current_user.disabled:
            raise HTTPException(status_code=400, detail="Inactive user")
        return current_user
    
    
    @app.post("/token")
    async def login_for_access_token(
        form_data: Annotated[OAuth2PasswordRequestForm, Depends()],
    ) -> Token:
        user = authenticate_user(fake_users_db, form_data.username, form_data.password)
        if not user:
            raise HTTPException(status_code=400, detail="Incorrect username or password")
        access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
        access_token = create_access_token(
            data={"sub": user.username, "scope": " ".join(form_data.scopes)},
            expires_delta=access_token_expires,
        )
        return Token(access_token=access_token, token_type="bearer")
    
    
    @app.get("/users/me/")
    async def read_users_me(
        current_user: Annotated[User, Depends(get_current_active_user)],
    ) -> User:
        return current_user
    
    
    @app.get("/users/me/items/")
    async def read_own_items(
        current_user: Annotated[User, Security(get_current_active_user, scopes=["items"])],
    ):
        return [{"item_id": "Foo", "owner": current_user.username}]
    
    
    @app.get("/status/")
    async def read_system_status(current_user: Annotated[User, Depends(get_current_user)]):
        return {"status": "ok"}
    

ü§ì Other versions and variants

Python 3.9+Python 3.10+ - non-AnnotatedPython 3.9+ - non-Annotated
    
    
    from datetime import datetime, timedelta, timezone
    from typing import Annotated, Union
    
    import jwt
    from fastapi import Depends, FastAPI, HTTPException, Security, status
    from fastapi.security import (
        OAuth2PasswordBearer,
        OAuth2PasswordRequestForm,
        SecurityScopes,
    )
    from jwt.exceptions import InvalidTokenError
    from pwdlib import PasswordHash
    from pydantic import BaseModel, ValidationError
    
    # to get a string like this run:
    # openssl rand -hex 32
    SECRET_KEY = "09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
    ALGORITHM = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES = 30
    
    
    fake_users_db = {
        "johndoe": {
            "username": "johndoe",
            "full_name": "John Doe",
            "email": "johndoe@example.com",
            "hashed_password": "$argon2id$v=19$m=65536,t=3,p=4$wagCPXjifgvUFBzq4hqe3w$CYaIb8sB+wtD+Vu/P4uod1+Qof8h+1g7bbDlBID48Rc",
            "disabled": False,
        },
        "alice": {
            "username": "alice",
            "full_name": "Alice Chains",
            "email": "alicechains@example.com",
            "hashed_password": "$argon2id$v=19$m=65536,t=3,p=4$g2/AV1zwopqUntPKJavBFw$BwpRGDCyUHLvHICnwijyX8ROGoiUPwNKZ7915MeYfCE",
            "disabled": True,
        },
    }
    
    
    class Token(BaseModel):
        access_token: str
        token_type: str
    
    
    class TokenData(BaseModel):
        username: Union[str, None] = None
        scopes: list[str] = []
    
    
    class User(BaseModel):
        username: str
        email: Union[str, None] = None
        full_name: Union[str, None] = None
        disabled: Union[bool, None] = None
    
    
    class UserInDB(User):
        hashed_password: str
    
    
    password_hash = PasswordHash.recommended()
    
    oauth2_scheme = OAuth2PasswordBearer(
        tokenUrl="token",
        scopes={"me": "Read information about the current user.", "items": "Read items."},
    )
    
    app = FastAPI()
    
    
    def verify_password(plain_password, hashed_password):
        return password_hash.verify(plain_password, hashed_password)
    
    
    def get_password_hash(password):
        return password_hash.hash(password)
    
    
    def get_user(db, username: str):
        if username in db:
            user_dict = db[username]
            return UserInDB(**user_dict)
    
    
    def authenticate_user(fake_db, username: str, password: str):
        user = get_user(fake_db, username)
        if not user:
            return False
        if not verify_password(password, user.hashed_password):
            return False
        return user
    
    
    def create_access_token(data: dict, expires_delta: Union[timedelta, None] = None):
        to_encode = data.copy()
        if expires_delta:
            expire = datetime.now(timezone.utc) + expires_delta
        else:
            expire = datetime.now(timezone.utc) + timedelta(minutes=15)
        to_encode.update({"exp": expire})
        encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
        return encoded_jwt
    
    
    async def get_current_user(
        security_scopes: SecurityScopes, token: Annotated[str, Depends(oauth2_scheme)]
    ):
        if security_scopes.scopes:
            authenticate_value = f'Bearer scope="{security_scopes.scope_str}"'
        else:
            authenticate_value = "Bearer"
        credentials_exception = HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Could not validate credentials",
            headers={"WWW-Authenticate": authenticate_value},
        )
        try:
            payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
            username = payload.get("sub")
            if username is None:
                raise credentials_exception
            scope: str = payload.get("scope", "")
            token_scopes = scope.split(" ")
            token_data = TokenData(scopes=token_scopes, username=username)
        except (InvalidTokenError, ValidationError):
            raise credentials_exception
        user = get_user(fake_users_db, username=token_data.username)
        if user is None:
            raise credentials_exception
        for scope in security_scopes.scopes:
            if scope not in token_data.scopes:
                raise HTTPException(
                    status_code=status.HTTP_401_UNAUTHORIZED,
                    detail="Not enough permissions",
                    headers={"WWW-Authenticate": authenticate_value},
                )
        return user
    
    
    async def get_current_active_user(
        current_user: Annotated[User, Security(get_current_user, scopes=["me"])],
    ):
        if current_user.disabled:
            raise HTTPException(status_code=400, detail="Inactive user")
        return current_user
    
    
    @app.post("/token")
    async def login_for_access_token(
        form_data: Annotated[OAuth2PasswordRequestForm, Depends()],
    ) -> Token:
        user = authenticate_user(fake_users_db, form_data.username, form_data.password)
        if not user:
            raise HTTPException(status_code=400, detail="Incorrect username or password")
        access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
        access_token = create_access_token(
            data={"sub": user.username, "scope": " ".join(form_data.scopes)},
            expires_delta=access_token_expires,
        )
        return Token(access_token=access_token, token_type="bearer")
    
    
    @app.get("/users/me/")
    async def read_users_me(
        current_user: Annotated[User, Depends(get_current_active_user)],
    ) -> User:
        return current_user
    
    
    @app.get("/users/me/items/")
    async def read_own_items(
        current_user: Annotated[User, Security(get_current_active_user, scopes=["items"])],
    ):
        return [{"item_id": "Foo", "owner": current_user.username}]
    
    
    @app.get("/status/")
    async def read_system_status(current_user: Annotated[User, Depends(get_current_user)]):
        return {"status": "ok"}
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from datetime import datetime, timedelta, timezone
    
    import jwt
    from fastapi import Depends, FastAPI, HTTPException, Security, status
    from fastapi.security import (
        OAuth2PasswordBearer,
        OAuth2PasswordRequestForm,
        SecurityScopes,
    )
    from jwt.exceptions import InvalidTokenError
    from pwdlib import PasswordHash
    from pydantic import BaseModel, ValidationError
    
    # to get a string like this run:
    # openssl rand -hex 32
    SECRET_KEY = "09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
    ALGORITHM = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES = 30
    
    
    fake_users_db = {
        "johndoe": {
            "username": "johndoe",
            "full_name": "John Doe",
            "email": "johndoe@example.com",
            "hashed_password": "$argon2id$v=19$m=65536,t=3,p=4$wagCPXjifgvUFBzq4hqe3w$CYaIb8sB+wtD+Vu/P4uod1+Qof8h+1g7bbDlBID48Rc",
            "disabled": False,
        },
        "alice": {
            "username": "alice",
            "full_name": "Alice Chains",
            "email": "alicechains@example.com",
            "hashed_password": "$argon2id$v=19$m=65536,t=3,p=4$g2/AV1zwopqUntPKJavBFw$BwpRGDCyUHLvHICnwijyX8ROGoiUPwNKZ7915MeYfCE",
            "disabled": True,
        },
    }
    
    
    class Token(BaseModel):
        access_token: str
        token_type: str
    
    
    class TokenData(BaseModel):
        username: str | None = None
        scopes: list[str] = []
    
    
    class User(BaseModel):
        username: str
        email: str | None = None
        full_name: str | None = None
        disabled: bool | None = None
    
    
    class UserInDB(User):
        hashed_password: str
    
    
    password_hash = PasswordHash.recommended()
    
    oauth2_scheme = OAuth2PasswordBearer(
        tokenUrl="token",
        scopes={"me": "Read information about the current user.", "items": "Read items."},
    )
    
    app = FastAPI()
    
    
    def verify_password(plain_password, hashed_password):
        return password_hash.verify(plain_password, hashed_password)
    
    
    def get_password_hash(password):
        return password_hash.hash(password)
    
    
    def get_user(db, username: str):
        if username in db:
            user_dict = db[username]
            return UserInDB(**user_dict)
    
    
    def authenticate_user(fake_db, username: str, password: str):
        user = get_user(fake_db, username)
        if not user:
            return False
        if not verify_password(password, user.hashed_password):
            return False
        return user
    
    
    def create_access_token(data: dict, expires_delta: timedelta | None = None):
        to_encode = data.copy()
        if expires_delta:
            expire = datetime.now(timezone.utc) + expires_delta
        else:
            expire = datetime.now(timezone.utc) + timedelta(minutes=15)
        to_encode.update({"exp": expire})
        encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
        return encoded_jwt
    
    
    async def get_current_user(
        security_scopes: SecurityScopes, token: str = Depends(oauth2_scheme)
    ):
        if security_scopes.scopes:
            authenticate_value = f'Bearer scope="{security_scopes.scope_str}"'
        else:
            authenticate_value = "Bearer"
        credentials_exception = HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Could not validate credentials",
            headers={"WWW-Authenticate": authenticate_value},
        )
        try:
            payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
            username: str = payload.get("sub")
            if username is None:
                raise credentials_exception
            scope: str = payload.get("scope", "")
            token_scopes = scope.split(" ")
            token_data = TokenData(scopes=token_scopes, username=username)
        except (InvalidTokenError, ValidationError):
            raise credentials_exception
        user = get_user(fake_users_db, username=token_data.username)
        if user is None:
            raise credentials_exception
        for scope in security_scopes.scopes:
            if scope not in token_data.scopes:
                raise HTTPException(
                    status_code=status.HTTP_401_UNAUTHORIZED,
                    detail="Not enough permissions",
                    headers={"WWW-Authenticate": authenticate_value},
                )
        return user
    
    
    async def get_current_active_user(
        current_user: User = Security(get_current_user, scopes=["me"]),
    ):
        if current_user.disabled:
            raise HTTPException(status_code=400, detail="Inactive user")
        return current_user
    
    
    @app.post("/token")
    async def login_for_access_token(
        form_data: OAuth2PasswordRequestForm = Depends(),
    ) -> Token:
        user = authenticate_user(fake_users_db, form_data.username, form_data.password)
        if not user:
            raise HTTPException(status_code=400, detail="Incorrect username or password")
        access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
        access_token = create_access_token(
            data={"sub": user.username, "scope": " ".join(form_data.scopes)},
            expires_delta=access_token_expires,
        )
        return Token(access_token=access_token, token_type="bearer")
    
    
    @app.get("/users/me/")
    async def read_users_me(current_user: User = Depends(get_current_active_user)) -> User:
        return current_user
    
    
    @app.get("/users/me/items/")
    async def read_own_items(
        current_user: User = Security(get_current_active_user, scopes=["items"]),
    ):
        return [{"item_id": "Foo", "owner": current_user.username}]
    
    
    @app.get("/status/")
    async def read_system_status(current_user: User = Depends(get_current_user)):
        return {"status": "ok"}
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from datetime import datetime, timedelta, timezone
    from typing import Union
    
    import jwt
    from fastapi import Depends, FastAPI, HTTPException, Security, status
    from fastapi.security import (
        OAuth2PasswordBearer,
        OAuth2PasswordRequestForm,
        SecurityScopes,
    )
    from jwt.exceptions import InvalidTokenError
    from pwdlib import PasswordHash
    from pydantic import BaseModel, ValidationError
    
    # to get a string like this run:
    # openssl rand -hex 32
    SECRET_KEY = "09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
    ALGORITHM = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES = 30
    
    
    fake_users_db = {
        "johndoe": {
            "username": "johndoe",
            "full_name": "John Doe",
            "email": "johndoe@example.com",
            "hashed_password": "$argon2id$v=19$m=65536,t=3,p=4$wagCPXjifgvUFBzq4hqe3w$CYaIb8sB+wtD+Vu/P4uod1+Qof8h+1g7bbDlBID48Rc",
            "disabled": False,
        },
        "alice": {
            "username": "alice",
            "full_name": "Alice Chains",
            "email": "alicechains@example.com",
            "hashed_password": "$argon2id$v=19$m=65536,t=3,p=4$g2/AV1zwopqUntPKJavBFw$BwpRGDCyUHLvHICnwijyX8ROGoiUPwNKZ7915MeYfCE",
            "disabled": True,
        },
    }
    
    
    class Token(BaseModel):
        access_token: str
        token_type: str
    
    
    class TokenData(BaseModel):
        username: Union[str, None] = None
        scopes: list[str] = []
    
    
    class User(BaseModel):
        username: str
        email: Union[str, None] = None
        full_name: Union[str, None] = None
        disabled: Union[bool, None] = None
    
    
    class UserInDB(User):
        hashed_password: str
    
    
    password_hash = PasswordHash.recommended()
    
    oauth2_scheme = OAuth2PasswordBearer(
        tokenUrl="token",
        scopes={"me": "Read information about the current user.", "items": "Read items."},
    )
    
    app = FastAPI()
    
    
    def verify_password(plain_password, hashed_password):
        return password_hash.verify(plain_password, hashed_password)
    
    
    def get_password_hash(password):
        return password_hash.hash(password)
    
    
    def get_user(db, username: str):
        if username in db:
            user_dict = db[username]
            return UserInDB(**user_dict)
    
    
    def authenticate_user(fake_db, username: str, password: str):
        user = get_user(fake_db, username)
        if not user:
            return False
        if not verify_password(password, user.hashed_password):
            return False
        return user
    
    
    def create_access_token(data: dict, expires_delta: Union[timedelta, None] = None):
        to_encode = data.copy()
        if expires_delta:
            expire = datetime.now(timezone.utc) + expires_delta
        else:
            expire = datetime.now(timezone.utc) + timedelta(minutes=15)
        to_encode.update({"exp": expire})
        encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
        return encoded_jwt
    
    
    async def get_current_user(
        security_scopes: SecurityScopes, token: str = Depends(oauth2_scheme)
    ):
        if security_scopes.scopes:
            authenticate_value = f'Bearer scope="{security_scopes.scope_str}"'
        else:
            authenticate_value = "Bearer"
        credentials_exception = HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Could not validate credentials",
            headers={"WWW-Authenticate": authenticate_value},
        )
        try:
            payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
            username: str = payload.get("sub")
            if username is None:
                raise credentials_exception
            scope: str = payload.get("scope", "")
            token_scopes = scope.split(" ")
            token_data = TokenData(scopes=token_scopes, username=username)
        except (InvalidTokenError, ValidationError):
            raise credentials_exception
        user = get_user(fake_users_db, username=token_data.username)
        if user is None:
            raise credentials_exception
        for scope in security_scopes.scopes:
            if scope not in token_data.scopes:
                raise HTTPException(
                    status_code=status.HTTP_401_UNAUTHORIZED,
                    detail="Not enough permissions",
                    headers={"WWW-Authenticate": authenticate_value},
                )
        return user
    
    
    async def get_current_active_user(
        current_user: User = Security(get_current_user, scopes=["me"]),
    ):
        if current_user.disabled:
            raise HTTPException(status_code=400, detail="Inactive user")
        return current_user
    
    
    @app.post("/token")
    async def login_for_access_token(
        form_data: OAuth2PasswordRequestForm = Depends(),
    ) -> Token:
        user = authenticate_user(fake_users_db, form_data.username, form_data.password)
        if not user:
            raise HTTPException(status_code=400, detail="Incorrect username or password")
        access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
        access_token = create_access_token(
            data={"sub": user.username, "scope": " ".join(form_data.scopes)},
            expires_delta=access_token_expires,
        )
        return Token(access_token=access_token, token_type="bearer")
    
    
    @app.get("/users/me/")
    async def read_users_me(current_user: User = Depends(get_current_active_user)) -> User:
        return current_user
    
    
    @app.get("/users/me/items/")
    async def read_own_items(
        current_user: User = Security(get_current_active_user, scopes=["items"]),
    ):
        return [{"item_id": "Foo", "owner": current_user.username}]
    
    
    @app.get("/status/")
    async def read_system_status(current_user: User = Depends(get_current_user)):
        return {"status": "ok"}
    

Now let's review those changes step by step.

## OAuth2 Security scheme[¶](#oauth2-security-scheme "Permanent link")

The first change is that now we are declaring the OAuth2 security scheme with two available scopes, `me` and `items`.

The `scopes` parameter receives a `dict` with each scope as a key and the description as the value:

Python 3.10+
    
    
    from datetime import datetime, timedelta, timezone
    from typing import Annotated
    
    import jwt
    from fastapi import Depends, FastAPI, HTTPException, Security, status
    from fastapi.security import (
        OAuth2PasswordBearer,
        OAuth2PasswordRequestForm,
        SecurityScopes,
    )
    from jwt.exceptions import InvalidTokenError
    from pwdlib import PasswordHash
    from pydantic import BaseModel, ValidationError
    
    # to get a string like this run:
    # openssl rand -hex 32
    SECRET_KEY = "09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
    ALGORITHM = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES = 30
    
    
    fake_users_db = {
        "johndoe": {
            "username": "johndoe",
            "full_name": "John Doe",
            "email": "johndoe@example.com",
            "hashed_password": "$argon2id$v=19$m=65536,t=3,p=4$wagCPXjifgvUFBzq4hqe3w$CYaIb8sB+wtD+Vu/P4uod1+Qof8h+1g7bbDlBID48Rc",
            "disabled": False,
        },
        "alice": {
            "username": "alice",
            "full_name": "Alice Chains",
            "email": "alicechains@example.com",
            "hashed_password": "$argon2id$v=19$m=65536,t=3,p=4$g2/AV1zwopqUntPKJavBFw$BwpRGDCyUHLvHICnwijyX8ROGoiUPwNKZ7915MeYfCE",
            "disabled": True,
        },
    }
    
    
    class Token(BaseModel):
        access_token: str
        token_type: str
    
    
    class TokenData(BaseModel):
        username: str | None = None
        scopes: list[str] = []
    
    
    class User(BaseModel):
        username: str
        email: str | None = None
        full_name: str | None = None
        disabled: bool | None = None
    
    
    class UserInDB(User):
        hashed_password: str
    
    
    password_hash = PasswordHash.recommended()
    
    oauth2_scheme = OAuth2PasswordBearer(
        tokenUrl="token",
        scopes={"me": "Read information about the current user.", "items": "Read items."},
    )
    
    app = FastAPI()
    
    
    def verify_password(plain_password, hashed_password):
        return password_hash.verify(plain_password, hashed_password)
    
    
    def get_password_hash(password):
        return password_hash.hash(password)
    
    
    def get_user(db, username: str):
        if username in db:
            user_dict = db[username]
            return UserInDB(**user_dict)
    
    
    def authenticate_user(fake_db, username: str, password: str):
        user = get_user(fake_db, username)
        if not user:
            return False
        if not verify_password(password, user.hashed_password):
            return False
        return user
    
    
    def create_access_token(data: dict, expires_delta: timedelta | None = None):
        to_encode = data.copy()
        if expires_delta:
            expire = datetime.now(timezone.utc) + expires_delta
        else:
            expire = datetime.now(timezone.utc) + timedelta(minutes=15)
        to_encode.update({"exp": expire})
        encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
        return encoded_jwt
    
    
    async def get_current_user(
        security_scopes: SecurityScopes, token: Annotated[str, Depends(oauth2_scheme)]
    ):
        if security_scopes.scopes:
            authenticate_value = f'Bearer scope="{security_scopes.scope_str}"'
        else:
            authenticate_value = "Bearer"
        credentials_exception = HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Could not validate credentials",
            headers={"WWW-Authenticate": authenticate_value},
        )
        try:
            payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
            username = payload.get("sub")
            if username is None:
                raise credentials_exception
            scope: str = payload.get("scope", "")
            token_scopes = scope.split(" ")
            token_data = TokenData(scopes=token_scopes, username=username)
        except (InvalidTokenError, ValidationError):
            raise credentials_exception
        user = get_user(fake_users_db, username=token_data.username)
        if user is None:
            raise credentials_exception
        for scope in security_scopes.scopes:
            if scope not in token_data.scopes:
                raise HTTPException(
                    status_code=status.HTTP_401_UNAUTHORIZED,
                    detail="Not enough permissions",
                    headers={"WWW-Authenticate": authenticate_value},
                )
        return user
    
    
    async def get_current_active_user(
        current_user: Annotated[User, Security(get_current_user, scopes=["me"])],
    ):
        if current_user.disabled:
            raise HTTPException(status_code=400, detail="Inactive user")
        return current_user
    
    
    @app.post("/token")
    async def login_for_access_token(
        form_data: Annotated[OAuth2PasswordRequestForm, Depends()],
    ) -> Token:
        user = authenticate_user(fake_users_db, form_data.username, form_data.password)
        if not user:
            raise HTTPException(status_code=400, detail="Incorrect username or password")
        access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
        access_token = create_access_token(
            data={"sub": user.username, "scope": " ".join(form_data.scopes)},
            expires_delta=access_token_expires,
        )
        return Token(access_token=access_token, token_type="bearer")
    
    
    @app.get("/users/me/")
    async def read_users_me(
        current_user: Annotated[User, Depends(get_current_active_user)],
    ) -> User:
        return current_user
    
    
    @app.get("/users/me/items/")
    async def read_own_items(
        current_user: Annotated[User, Security(get_current_active_user, scopes=["items"])],
    ):
        return [{"item_id": "Foo", "owner": current_user.username}]
    
    
    @app.get("/status/")
    async def read_system_status(current_user: Annotated[User, Depends(get_current_user)]):
        return {"status": "ok"}
    

ü§ì Other versions and variants

Python 3.9+Python 3.10+ - non-AnnotatedPython 3.9+ - non-Annotated
    
    
    from datetime import datetime, timedelta, timezone
    from typing import Annotated, Union
    
    import jwt
    from fastapi import Depends, FastAPI, HTTPException, Security, status
    from fastapi.security import (
        OAuth2PasswordBearer,
        OAuth2PasswordRequestForm,
        SecurityScopes,
    )
    from jwt.exceptions import InvalidTokenError
    from pwdlib import PasswordHash
    from pydantic import BaseModel, ValidationError
    
    # to get a string like this run:
    # openssl rand -hex 32
    SECRET_KEY = "09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
    ALGORITHM = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES = 30
    
    
    fake_users_db = {
        "johndoe": {
            "username": "johndoe",
            "full_name": "John Doe",
            "email": "johndoe@example.com",
            "hashed_password": "$argon2id$v=19$m=65536,t=3,p=4$wagCPXjifgvUFBzq4hqe3w$CYaIb8sB+wtD+Vu/P4uod1+Qof8h+1g7bbDlBID48Rc",
            "disabled": False,
        },
        "alice": {
            "username": "alice",
            "full_name": "Alice Chains",
            "email": "alicechains@example.com",
            "hashed_password": "$argon2id$v=19$m=65536,t=3,p=4$g2/AV1zwopqUntPKJavBFw$BwpRGDCyUHLvHICnwijyX8ROGoiUPwNKZ7915MeYfCE",
            "disabled": True,
        },
    }
    
    
    class Token(BaseModel):
        access_token: str
        token_type: str
    
    
    class TokenData(BaseModel):
        username: Union[str, None] = None
        scopes: list[str] = []
    
    
    class User(BaseModel):
        username: str
        email: Union[str, None] = None
        full_name: Union[str, None] = None
        disabled: Union[bool, None] = None
    
    
    class UserInDB(User):
        hashed_password: str
    
    
    password_hash = PasswordHash.recommended()
    
    oauth2_scheme = OAuth2PasswordBearer(
        tokenUrl="token",
        scopes={"me": "Read information about the current user.", "items": "Read items."},
    )
    
    app = FastAPI()
    
    
    def verify_password(plain_password, hashed_password):
        return password_hash.verify(plain_password, hashed_password)
    
    
    def get_password_hash(password):
        return password_hash.hash(password)
    
    
    def get_user(db, username: str):
        if username in db:
            user_dict = db[username]
            return UserInDB(**user_dict)
    
    
    def authenticate_user(fake_db, username: str, password: str):
        user = get_user(fake_db, username)
        if not user:
            return False
        if not verify_password(password, user.hashed_password):
            return False
        return user
    
    
    def create_access_token(data: dict, expires_delta: Union[timedelta, None] = None):
        to_encode = data.copy()
        if expires_delta:
            expire = datetime.now(timezone.utc) + expires_delta
        else:
            expire = datetime.now(timezone.utc) + timedelta(minutes=15)
        to_encode.update({"exp": expire})
        encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
        return encoded_jwt
    
    
    async def get_current_user(
        security_scopes: SecurityScopes, token: Annotated[str, Depends(oauth2_scheme)]
    ):
        if security_scopes.scopes:
            authenticate_value = f'Bearer scope="{security_scopes.scope_str}"'
        else:
            authenticate_value = "Bearer"
        credentials_exception = HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Could not validate credentials",
            headers={"WWW-Authenticate": authenticate_value},
        )
        try:
            payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
            username = payload.get("sub")
            if username is None:
                raise credentials_exception
            scope: str = payload.get("scope", "")
            token_scopes = scope.split(" ")
            token_data = TokenData(scopes=token_scopes, username=username)
        except (InvalidTokenError, ValidationError):
            raise credentials_exception
        user = get_user(fake_users_db, username=token_data.username)
        if user is None:
            raise credentials_exception
        for scope in security_scopes.scopes:
            if scope not in token_data.scopes:
                raise HTTPException(
                    status_code=status.HTTP_401_UNAUTHORIZED,
                    detail="Not enough permissions",
                    headers={"WWW-Authenticate": authenticate_value},
                )
        return user
    
    
    async def get_current_active_user(
        current_user: Annotated[User, Security(get_current_user, scopes=["me"])],
    ):
        if current_user.disabled:
            raise HTTPException(status_code=400, detail="Inactive user")
        return current_user
    
    
    @app.post("/token")
    async def login_for_access_token(
        form_data: Annotated[OAuth2PasswordRequestForm, Depends()],
    ) -> Token:
        user = authenticate_user(fake_users_db, form_data.username, form_data.password)
        if not user:
            raise HTTPException(status_code=400, detail="Incorrect username or password")
        access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
        access_token = create_access_token(
            data={"sub": user.username, "scope": " ".join(form_data.scopes)},
            expires_delta=access_token_expires,
        )
        return Token(access_token=access_token, token_type="bearer")
    
    
    @app.get("/users/me/")
    async def read_users_me(
        current_user: Annotated[User, Depends(get_current_active_user)],
    ) -> User:
        return current_user
    
    
    @app.get("/users/me/items/")
    async def read_own_items(
        current_user: Annotated[User, Security(get_current_active_user, scopes=["items"])],
    ):
        return [{"item_id": "Foo", "owner": current_user.username}]
    
    
    @app.get("/status/")
    async def read_system_status(current_user: Annotated[User, Depends(get_current_user)]):
        return {"status": "ok"}
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from datetime import datetime, timedelta, timezone
    
    import jwt
    from fastapi import Depends, FastAPI, HTTPException, Security, status
    from fastapi.security import (
        OAuth2PasswordBearer,
        OAuth2PasswordRequestForm,
        SecurityScopes,
    )
    from jwt.exceptions import InvalidTokenError
    from pwdlib import PasswordHash
    from pydantic import BaseModel, ValidationError
    
    # to get a string like this run:
    # openssl rand -hex 32
    SECRET_KEY = "09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
    ALGORITHM = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES = 30
    
    
    fake_users_db = {
        "johndoe": {
            "username": "johndoe",
            "full_name": "John Doe",
            "email": "johndoe@example.com",
            "hashed_password": "$argon2id$v=19$m=65536,t=3,p=4$wagCPXjifgvUFBzq4hqe3w$CYaIb8sB+wtD+Vu/P4uod1+Qof8h+1g7bbDlBID48Rc",
            "disabled": False,
        },
        "alice": {
            "username": "alice",
            "full_name": "Alice Chains",
            "email": "alicechains@example.com",
            "hashed_password": "$argon2id$v=19$m=65536,t=3,p=4$g2/AV1zwopqUntPKJavBFw$BwpRGDCyUHLvHICnwijyX8ROGoiUPwNKZ7915MeYfCE",
            "disabled": True,
        },
    }
    
    
    class Token(BaseModel):
        access_token: str
        token_type: str
    
    
    class TokenData(BaseModel):
        username: str | None = None
        scopes: list[str] = []
    
    
    class User(BaseModel):
        username: str
        email: str | None = None
        full_name: str | None = None
        disabled: bool | None = None
    
    
    class UserInDB(User):
        hashed_password: str
    
    
    password_hash = PasswordHash.recommended()
    
    oauth2_scheme = OAuth2PasswordBearer(
        tokenUrl="token",
        scopes={"me": "Read information about the current user.", "items": "Read items."},
    )
    
    app = FastAPI()
    
    
    def verify_password(plain_password, hashed_password):
        return password_hash.verify(plain_password, hashed_password)
    
    
    def get_password_hash(password):
        return password_hash.hash(password)
    
    
    def get_user(db, username: str):
        if username in db:
            user_dict = db[username]
            return UserInDB(**user_dict)
    
    
    def authenticate_user(fake_db, username: str, password: str):
        user = get_user(fake_db, username)
        if not user:
            return False
        if not verify_password(password, user.hashed_password):
            return False
        return user
    
    
    def create_access_token(data: dict, expires_delta: timedelta | None = None):
        to_encode = data.copy()
        if expires_delta:
            expire = datetime.now(timezone.utc) + expires_delta
        else:
            expire = datetime.now(timezone.utc) + timedelta(minutes=15)
        to_encode.update({"exp": expire})
        encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
        return encoded_jwt
    
    
    async def get_current_user(
        security_scopes: SecurityScopes, token: str = Depends(oauth2_scheme)
    ):
        if security_scopes.scopes:
            authenticate_value = f'Bearer scope="{security_scopes.scope_str}"'
        else:
            authenticate_value = "Bearer"
        credentials_exception = HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Could not validate credentials",
            headers={"WWW-Authenticate": authenticate_value},
        )
        try:
            payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
            username: str = payload.get("sub")
            if username is None:
                raise credentials_exception
            scope: str = payload.get("scope", "")
            token_scopes = scope.split(" ")
            token_data = TokenData(scopes=token_scopes, username=username)
        except (InvalidTokenError, ValidationError):
            raise credentials_exception
        user = get_user(fake_users_db, username=token_data.username)
        if user is None:
            raise credentials_exception
        for scope in security_scopes.scopes:
            if scope not in token_data.scopes:
                raise HTTPException(
                    status_code=status.HTTP_401_UNAUTHORIZED,
                    detail="Not enough permissions",
                    headers={"WWW-Authenticate": authenticate_value},
                )
        return user
    
    
    async def get_current_active_user(
        current_user: User = Security(get_current_user, scopes=["me"]),
    ):
        if current_user.disabled:
            raise HTTPException(status_code=400, detail="Inactive user")
        return current_user
    
    
    @app.post("/token")
    async def login_for_access_token(
        form_data: OAuth2PasswordRequestForm = Depends(),
    ) -> Token:
        user = authenticate_user(fake_users_db, form_data.username, form_data.password)
        if not user:
            raise HTTPException(status_code=400, detail="Incorrect username or password")
        access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
        access_token = create_access_token(
            data={"sub": user.username, "scope": " ".join(form_data.scopes)},
            expires_delta=access_token_expires,
        )
        return Token(access_token=access_token, token_type="bearer")
    
    
    @app.get("/users/me/")
    async def read_users_me(current_user: User = Depends(get_current_active_user)) -> User:
        return current_user
    
    
    @app.get("/users/me/items/")
    async def read_own_items(
        current_user: User = Security(get_current_active_user, scopes=["items"]),
    ):
        return [{"item_id": "Foo", "owner": current_user.username}]
    
    
    @app.get("/status/")
    async def read_system_status(current_user: User = Depends(get_current_user)):
        return {"status": "ok"}
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from datetime import datetime, timedelta, timezone
    from typing import Union
    
    import jwt
    from fastapi import Depends, FastAPI, HTTPException, Security, status
    from fastapi.security import (
        OAuth2PasswordBearer,
        OAuth2PasswordRequestForm,
        SecurityScopes,
    )
    from jwt.exceptions import InvalidTokenError
    from pwdlib import PasswordHash
    from pydantic import BaseModel, ValidationError
    
    # to get a string like this run:
    # openssl rand -hex 32
    SECRET_KEY = "09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
    ALGORITHM = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES = 30
    
    
    fake_users_db = {
        "johndoe": {
            "username": "johndoe",
            "full_name": "John Doe",
            "email": "johndoe@example.com",
            "hashed_password": "$argon2id$v=19$m=65536,t=3,p=4$wagCPXjifgvUFBzq4hqe3w$CYaIb8sB+wtD+Vu/P4uod1+Qof8h+1g7bbDlBID48Rc",
            "disabled": False,
        },
        "alice": {
            "username": "alice",
            "full_name": "Alice Chains",
            "email": "alicechains@example.com",
            "hashed_password": "$argon2id$v=19$m=65536,t=3,p=4$g2/AV1zwopqUntPKJavBFw$BwpRGDCyUHLvHICnwijyX8ROGoiUPwNKZ7915MeYfCE",
            "disabled": True,
        },
    }
    
    
    class Token(BaseModel):
        access_token: str
        token_type: str
    
    
    class TokenData(BaseModel):
        username: Union[str, None] = None
        scopes: list[str] = []
    
    
    class User(BaseModel):
        username: str
        email: Union[str, None] = None
        full_name: Union[str, None] = None
        disabled: Union[bool, None] = None
    
    
    class UserInDB(User):
        hashed_password: str
    
    
    password_hash = PasswordHash.recommended()
    
    oauth2_scheme = OAuth2PasswordBearer(
        tokenUrl="token",
        scopes={"me": "Read information about the current user.", "items": "Read items."},
    )
    
    app = FastAPI()
    
    
    def verify_password(plain_password, hashed_password):
        return password_hash.verify(plain_password, hashed_password)
    
    
    def get_password_hash(password):
        return password_hash.hash(password)
    
    
    def get_user(db, username: str):
        if username in db:
            user_dict = db[username]
            return UserInDB(**user_dict)
    
    
    def authenticate_user(fake_db, username: str, password: str):
        user = get_user(fake_db, username)
        if not user:
            return False
        if not verify_password(password, user.hashed_password):
            return False
        return user
    
    
    def create_access_token(data: dict, expires_delta: Union[timedelta, None] = None):
        to_encode = data.copy()
        if expires_delta:
            expire = datetime.now(timezone.utc) + expires_delta
        else:
            expire = datetime.now(timezone.utc) + timedelta(minutes=15)
        to_encode.update({"exp": expire})
        encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
        return encoded_jwt
    
    
    async def get_current_user(
        security_scopes: SecurityScopes, token: str = Depends(oauth2_scheme)
    ):
        if security_scopes.scopes:
            authenticate_value = f'Bearer scope="{security_scopes.scope_str}"'
        else:
            authenticate_value = "Bearer"
        credentials_exception = HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Could not validate credentials",
            headers={"WWW-Authenticate": authenticate_value},
        )
        try:
            payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
            username: str = payload.get("sub")
            if username is None:
                raise credentials_exception
            scope: str = payload.get("scope", "")
            token_scopes = scope.split(" ")
            token_data = TokenData(scopes=token_scopes, username=username)
        except (InvalidTokenError, ValidationError):
            raise credentials_exception
        user = get_user(fake_users_db, username=token_data.username)
        if user is None:
            raise credentials_exception
        for scope in security_scopes.scopes:
            if scope not in token_data.scopes:
                raise HTTPException(
                    status_code=status.HTTP_401_UNAUTHORIZED,
                    detail="Not enough permissions",
                    headers={"WWW-Authenticate": authenticate_value},
                )
        return user
    
    
    async def get_current_active_user(
        current_user: User = Security(get_current_user, scopes=["me"]),
    ):
        if current_user.disabled:
            raise HTTPException(status_code=400, detail="Inactive user")
        return current_user
    
    
    @app.post("/token")
    async def login_for_access_token(
        form_data: OAuth2PasswordRequestForm = Depends(),
    ) -> Token:
        user = authenticate_user(fake_users_db, form_data.username, form_data.password)
        if not user:
            raise HTTPException(status_code=400, detail="Incorrect username or password")
        access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
        access_token = create_access_token(
            data={"sub": user.username, "scope": " ".join(form_data.scopes)},
            expires_delta=access_token_expires,
        )
        return Token(access_token=access_token, token_type="bearer")
    
    
    @app.get("/users/me/")
    async def read_users_me(current_user: User = Depends(get_current_active_user)) -> User:
        return current_user
    
    
    @app.get("/users/me/items/")
    async def read_own_items(
        current_user: User = Security(get_current_active_user, scopes=["items"]),
    ):
        return [{"item_id": "Foo", "owner": current_user.username}]
    
    
    @app.get("/status/")
    async def read_system_status(current_user: User = Depends(get_current_user)):
        return {"status": "ok"}
    

Because we are now declaring those scopes, they will show up in the API docs when you log-in/authorize.

And you will be able to select which scopes you want to give access to: `me` and `items`.

This is the same mechanism used when you give permissions while logging in with Facebook, Google, GitHub, etc:

![](/img/tutorial/security/image11.png)

## JWT token with scopes[¶](#jwt-token-with-scopes "Permanent link")

Now, modify the token _path operation_ to return the scopes requested.

We are still using the same `OAuth2PasswordRequestForm`. It includes a property `scopes` with a `list` of `str`, with each scope it received in the request.

And we return the scopes as part of the JWT token.

Danger

For simplicity, here we are just adding the scopes received directly to the token.

But in your application, for security, you should make sure you only add the scopes that the user is actually able to have, or the ones you have predefined.

Python 3.10+
    
    
    from datetime import datetime, timedelta, timezone
    from typing import Annotated
    
    import jwt
    from fastapi import Depends, FastAPI, HTTPException, Security, status
    from fastapi.security import (
        OAuth2PasswordBearer,
        OAuth2PasswordRequestForm,
        SecurityScopes,
    )
    from jwt.exceptions import InvalidTokenError
    from pwdlib import PasswordHash
    from pydantic import BaseModel, ValidationError
    
    # to get a string like this run:
    # openssl rand -hex 32
    SECRET_KEY = "09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
    ALGORITHM = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES = 30
    
    
    fake_users_db = {
        "johndoe": {
            "username": "johndoe",
            "full_name": "John Doe",
            "email": "johndoe@example.com",
            "hashed_password": "$argon2id$v=19$m=65536,t=3,p=4$wagCPXjifgvUFBzq4hqe3w$CYaIb8sB+wtD+Vu/P4uod1+Qof8h+1g7bbDlBID48Rc",
            "disabled": False,
        },
        "alice": {
            "username": "alice",
            "full_name": "Alice Chains",
            "email": "alicechains@example.com",
            "hashed_password": "$argon2id$v=19$m=65536,t=3,p=4$g2/AV1zwopqUntPKJavBFw$BwpRGDCyUHLvHICnwijyX8ROGoiUPwNKZ7915MeYfCE",
            "disabled": True,
        },
    }
    
    
    class Token(BaseModel):
        access_token: str
        token_type: str
    
    
    class TokenData(BaseModel):
        username: str | None = None
        scopes: list[str] = []
    
    
    class User(BaseModel):
        username: str
        email: str | None = None
        full_name: str | None = None
        disabled: bool | None = None
    
    
    class UserInDB(User):
        hashed_password: str
    
    
    password_hash = PasswordHash.recommended()
    
    oauth2_scheme = OAuth2PasswordBearer(
        tokenUrl="token",
        scopes={"me": "Read information about the current user.", "items": "Read items."},
    )
    
    app = FastAPI()
    
    
    def verify_password(plain_password, hashed_password):
        return password_hash.verify(plain_password, hashed_password)
    
    
    def get_password_hash(password):
        return password_hash.hash(password)
    
    
    def get_user(db, username: str):
        if username in db:
            user_dict = db[username]
            return UserInDB(**user_dict)
    
    
    def authenticate_user(fake_db, username: str, password: str):
        user = get_user(fake_db, username)
        if not user:
            return False
        if not verify_password(password, user.hashed_password):
            return False
        return user
    
    
    def create_access_token(data: dict, expires_delta: timedelta | None = None):
        to_encode = data.copy()
        if expires_delta:
            expire = datetime.now(timezone.utc) + expires_delta
        else:
            expire = datetime.now(timezone.utc) + timedelta(minutes=15)
        to_encode.update({"exp": expire})
        encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
        return encoded_jwt
    
    
    async def get_current_user(
        security_scopes: SecurityScopes, token: Annotated[str, Depends(oauth2_scheme)]
    ):
        if security_scopes.scopes:
            authenticate_value = f'Bearer scope="{security_scopes.scope_str}"'
        else:
            authenticate_value = "Bearer"
        credentials_exception = HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Could not validate credentials",
            headers={"WWW-Authenticate": authenticate_value},
        )
        try:
            payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
            username = payload.get("sub")
            if username is None:
                raise credentials_exception
            scope: str = payload.get("scope", "")
            token_scopes = scope.split(" ")
            token_data = TokenData(scopes=token_scopes, username=username)
        except (InvalidTokenError, ValidationError):
            raise credentials_exception
        user = get_user(fake_users_db, username=token_data.username)
        if user is None:
            raise credentials_exception
        for scope in security_scopes.scopes:
            if scope not in token_data.scopes:
                raise HTTPException(
                    status_code=status.HTTP_401_UNAUTHORIZED,
                    detail="Not enough permissions",
                    headers={"WWW-Authenticate": authenticate_value},
                )
        return user
    
    
    async def get_current_active_user(
        current_user: Annotated[User, Security(get_current_user, scopes=["me"])],
    ):
        if current_user.disabled:
            raise HTTPException(status_code=400, detail="Inactive user")
        return current_user
    
    
    @app.post("/token")
    async def login_for_access_token(
        form_data: Annotated[OAuth2PasswordRequestForm, Depends()],
    ) -> Token:
        user = authenticate_user(fake_users_db, form_data.username, form_data.password)
        if not user:
            raise HTTPException(status_code=400, detail="Incorrect username or password")
        access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
        access_token = create_access_token(
            data={"sub": user.username, "scope": " ".join(form_data.scopes)},
            expires_delta=access_token_expires,
        )
        return Token(access_token=access_token, token_type="bearer")
    
    
    @app.get("/users/me/")
    async def read_users_me(
        current_user: Annotated[User, Depends(get_current_active_user)],
    ) -> User:
        return current_user
    
    
    @app.get("/users/me/items/")
    async def read_own_items(
        current_user: Annotated[User, Security(get_current_active_user, scopes=["items"])],
    ):
        return [{"item_id": "Foo", "owner": current_user.username}]
    
    
    @app.get("/status/")
    async def read_system_status(current_user: Annotated[User, Depends(get_current_user)]):
        return {"status": "ok"}
    

ü§ì Other versions and variants

Python 3.9+Python 3.10+ - non-AnnotatedPython 3.9+ - non-Annotated
    
    
    from datetime import datetime, timedelta, timezone
    from typing import Annotated, Union
    
    import jwt
    from fastapi import Depends, FastAPI, HTTPException, Security, status
    from fastapi.security import (
        OAuth2PasswordBearer,
        OAuth2PasswordRequestForm,
        SecurityScopes,
    )
    from jwt.exceptions import InvalidTokenError
    from pwdlib import PasswordHash
    from pydantic import BaseModel, ValidationError
    
    # to get a string like this run:
    # openssl rand -hex 32
    SECRET_KEY = "09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
    ALGORITHM = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES = 30
    
    
    fake_users_db = {
        "johndoe": {
            "username": "johndoe",
            "full_name": "John Doe",
            "email": "johndoe@example.com",
            "hashed_password": "$argon2id$v=19$m=65536,t=3,p=4$wagCPXjifgvUFBzq4hqe3w$CYaIb8sB+wtD+Vu/P4uod1+Qof8h+1g7bbDlBID48Rc",
            "disabled": False,
        },
        "alice": {
            "username": "alice",
            "full_name": "Alice Chains",
            "email": "alicechains@example.com",
            "hashed_password": "$argon2id$v=19$m=65536,t=3,p=4$g2/AV1zwopqUntPKJavBFw$BwpRGDCyUHLvHICnwijyX8ROGoiUPwNKZ7915MeYfCE",
            "disabled": True,
        },
    }
    
    
    class Token(BaseModel):
        access_token: str
        token_type: str
    
    
    class TokenData(BaseModel):
        username: Union[str, None] = None
        scopes: list[str] = []
    
    
    class User(BaseModel):
        username: str
        email: Union[str, None] = None
        full_name: Union[str, None] = None
        disabled: Union[bool, None] = None
    
    
    class UserInDB(User):
        hashed_password: str
    
    
    password_hash = PasswordHash.recommended()
    
    oauth2_scheme = OAuth2PasswordBearer(
        tokenUrl="token",
        scopes={"me": "Read information about the current user.", "items": "Read items."},
    )
    
    app = FastAPI()
    
    
    def verify_password(plain_password, hashed_password):
        return password_hash.verify(plain_password, hashed_password)
    
    
    def get_password_hash(password):
        return password_hash.hash(password)
    
    
    def get_user(db, username: str):
        if username in db:
            user_dict = db[username]
            return UserInDB(**user_dict)
    
    
    def authenticate_user(fake_db, username: str, password: str):
        user = get_user(fake_db, username)
        if not user:
            return False
        if not verify_password(password, user.hashed_password):
            return False
        return user
    
    
    def create_access_token(data: dict, expires_delta: Union[timedelta, None] = None):
        to_encode = data.copy()
        if expires_delta:
            expire = datetime.now(timezone.utc) + expires_delta
        else:
            expire = datetime.now(timezone.utc) + timedelta(minutes=15)
        to_encode.update({"exp": expire})
        encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
        return encoded_jwt
    
    
    async def get_current_user(
        security_scopes: SecurityScopes, token: Annotated[str, Depends(oauth2_scheme)]
    ):
        if security_scopes.scopes:
            authenticate_value = f'Bearer scope="{security_scopes.scope_str}"'
        else:
            authenticate_value = "Bearer"
        credentials_exception = HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Could not validate credentials",
            headers={"WWW-Authenticate": authenticate_value},
        )
        try:
            payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
            username = payload.get("sub")
            if username is None:
                raise credentials_exception
            scope: str = payload.get("scope", "")
            token_scopes = scope.split(" ")
            token_data = TokenData(scopes=token_scopes, username=username)
        except (InvalidTokenError, ValidationError):
            raise credentials_exception
        user = get_user(fake_users_db, username=token_data.username)
        if user is None:
            raise credentials_exception
        for scope in security_scopes.scopes:
            if scope not in token_data.scopes:
                raise HTTPException(
                    status_code=status.HTTP_401_UNAUTHORIZED,
                    detail="Not enough permissions",
                    headers={"WWW-Authenticate": authenticate_value},
                )
        return user
    
    
    async def get_current_active_user(
        current_user: Annotated[User, Security(get_current_user, scopes=["me"])],
    ):
        if current_user.disabled:
            raise HTTPException(status_code=400, detail="Inactive user")
        return current_user
    
    
    @app.post("/token")
    async def login_for_access_token(
        form_data: Annotated[OAuth2PasswordRequestForm, Depends()],
    ) -> Token:
        user = authenticate_user(fake_users_db, form_data.username, form_data.password)
        if not user:
            raise HTTPException(status_code=400, detail="Incorrect username or password")
        access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
        access_token = create_access_token(
            data={"sub": user.username, "scope": " ".join(form_data.scopes)},
            expires_delta=access_token_expires,
        )
        return Token(access_token=access_token, token_type="bearer")
    
    
    @app.get("/users/me/")
    async def read_users_me(
        current_user: Annotated[User, Depends(get_current_active_user)],
    ) -> User:
        return current_user
    
    
    @app.get("/users/me/items/")
    async def read_own_items(
        current_user: Annotated[User, Security(get_current_active_user, scopes=["items"])],
    ):
        return [{"item_id": "Foo", "owner": current_user.username}]
    
    
    @app.get("/status/")
    async def read_system_status(current_user: Annotated[User, Depends(get_current_user)]):
        return {"status": "ok"}
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from datetime import datetime, timedelta, timezone
    
    import jwt
    from fastapi import Depends, FastAPI, HTTPException, Security, status
    from fastapi.security import (
        OAuth2PasswordBearer,
        OAuth2PasswordRequestForm,
        SecurityScopes,
    )
    from jwt.exceptions import InvalidTokenError
    from pwdlib import PasswordHash
    from pydantic import BaseModel, ValidationError
    
    # to get a string like this run:
    # openssl rand -hex 32
    SECRET_KEY = "09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
    ALGORITHM = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES = 30
    
    
    fake_users_db = {
        "johndoe": {
            "username": "johndoe",
            "full_name": "John Doe",
            "email": "johndoe@example.com",
            "hashed_password": "$argon2id$v=19$m=65536,t=3,p=4$wagCPXjifgvUFBzq4hqe3w$CYaIb8sB+wtD+Vu/P4uod1+Qof8h+1g7bbDlBID48Rc",
            "disabled": False,
        },
        "alice": {
            "username": "alice",
            "full_name": "Alice Chains",
            "email": "alicechains@example.com",
            "hashed_password": "$argon2id$v=19$m=65536,t=3,p=4$g2/AV1zwopqUntPKJavBFw$BwpRGDCyUHLvHICnwijyX8ROGoiUPwNKZ7915MeYfCE",
            "disabled": True,
        },
    }
    
    
    class Token(BaseModel):
        access_token: str
        token_type: str
    
    
    class TokenData(BaseModel):
        username: str | None = None
        scopes: list[str] = []
    
    
    class User(BaseModel):
        username: str
        email: str | None = None
        full_name: str | None = None
        disabled: bool | None = None
    
    
    class UserInDB(User):
        hashed_password: str
    
    
    password_hash = PasswordHash.recommended()
    
    oauth2_scheme = OAuth2PasswordBearer(
        tokenUrl="token",
        scopes={"me": "Read information about the current user.", "items": "Read items."},
    )
    
    app = FastAPI()
    
    
    def verify_password(plain_password, hashed_password):
        return password_hash.verify(plain_password, hashed_password)
    
    
    def get_password_hash(password):
        return password_hash.hash(password)
    
    
    def get_user(db, username: str):
        if username in db:
            user_dict = db[username]
            return UserInDB(**user_dict)
    
    
    def authenticate_user(fake_db, username: str, password: str):
        user = get_user(fake_db, username)
        if not user:
            return False
        if not verify_password(password, user.hashed_password):
            return False
        return user
    
    
    def create_access_token(data: dict, expires_delta: timedelta | None = None):
        to_encode = data.copy()
        if expires_delta:
            expire = datetime.now(timezone.utc) + expires_delta
        else:
            expire = datetime.now(timezone.utc) + timedelta(minutes=15)
        to_encode.update({"exp": expire})
        encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
        return encoded_jwt
    
    
    async def get_current_user(
        security_scopes: SecurityScopes, token: str = Depends(oauth2_scheme)
    ):
        if security_scopes.scopes:
            authenticate_value = f'Bearer scope="{security_scopes.scope_str}"'
        else:
            authenticate_value = "Bearer"
        credentials_exception = HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Could not validate credentials",
            headers={"WWW-Authenticate": authenticate_value},
        )
        try:
            payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
            username: str = payload.get("sub")
            if username is None:
                raise credentials_exception
            scope: str = payload.get("scope", "")
            token_scopes = scope.split(" ")
            token_data = TokenData(scopes=token_scopes, username=username)
        except (InvalidTokenError, ValidationError):
            raise credentials_exception
        user = get_user(fake_users_db, username=token_data.username)
        if user is None:
            raise credentials_exception
        for scope in security_scopes.scopes:
            if scope not in token_data.scopes:
                raise HTTPException(
                    status_code=status.HTTP_401_UNAUTHORIZED,
                    detail="Not enough permissions",
                    headers={"WWW-Authenticate": authenticate_value},
                )
        return user
    
    
    async def get_current_active_user(
        current_user: User = Security(get_current_user, scopes=["me"]),
    ):
        if current_user.disabled:
            raise HTTPException(status_code=400, detail="Inactive user")
        return current_user
    
    
    @app.post("/token")
    async def login_for_access_token(
        form_data: OAuth2PasswordRequestForm = Depends(),
    ) -> Token:
        user = authenticate_user(fake_users_db, form_data.username, form_data.password)
        if not user:
            raise HTTPException(status_code=400, detail="Incorrect username or password")
        access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
        access_token = create_access_token(
            data={"sub": user.username, "scope": " ".join(form_data.scopes)},
            expires_delta=access_token_expires,
        )
        return Token(access_token=access_token, token_type="bearer")
    
    
    @app.get("/users/me/")
    async def read_users_me(current_user: User = Depends(get_current_active_user)) -> User:
        return current_user
    
    
    @app.get("/users/me/items/")
    async def read_own_items(
        current_user: User = Security(get_current_active_user, scopes=["items"]),
    ):
        return [{"item_id": "Foo", "owner": current_user.username}]
    
    
    @app.get("/status/")
    async def read_system_status(current_user: User = Depends(get_current_user)):
        return {"status": "ok"}
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from datetime import datetime, timedelta, timezone
    from typing import Union
    
    import jwt
    from fastapi import Depends, FastAPI, HTTPException, Security, status
    from fastapi.security import (
        OAuth2PasswordBearer,
        OAuth2PasswordRequestForm,
        SecurityScopes,
    )
    from jwt.exceptions import InvalidTokenError
    from pwdlib import PasswordHash
    from pydantic import BaseModel, ValidationError
    
    # to get a string like this run:
    # openssl rand -hex 32
    SECRET_KEY = "09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
    ALGORITHM = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES = 30
    
    
    fake_users_db = {
        "johndoe": {
            "username": "johndoe",
            "full_name": "John Doe",
            "email": "johndoe@example.com",
            "hashed_password": "$argon2id$v=19$m=65536,t=3,p=4$wagCPXjifgvUFBzq4hqe3w$CYaIb8sB+wtD+Vu/P4uod1+Qof8h+1g7bbDlBID48Rc",
            "disabled": False,
        },
        "alice": {
            "username": "alice",
            "full_name": "Alice Chains",
            "email": "alicechains@example.com",
            "hashed_password": "$argon2id$v=19$m=65536,t=3,p=4$g2/AV1zwopqUntPKJavBFw$BwpRGDCyUHLvHICnwijyX8ROGoiUPwNKZ7915MeYfCE",
            "disabled": True,
        },
    }
    
    
    class Token(BaseModel):
        access_token: str
        token_type: str
    
    
    class TokenData(BaseModel):
        username: Union[str, None] = None
        scopes: list[str] = []
    
    
    class User(BaseModel):
        username: str
        email: Union[str, None] = None
        full_name: Union[str, None] = None
        disabled: Union[bool, None] = None
    
    
    class UserInDB(User):
        hashed_password: str
    
    
    password_hash = PasswordHash.recommended()
    
    oauth2_scheme = OAuth2PasswordBearer(
        tokenUrl="token",
        scopes={"me": "Read information about the current user.", "items": "Read items."},
    )
    
    app = FastAPI()
    
    
    def verify_password(plain_password, hashed_password):
        return password_hash.verify(plain_password, hashed_password)
    
    
    def get_password_hash(password):
        return password_hash.hash(password)
    
    
    def get_user(db, username: str):
        if username in db:
            user_dict = db[username]
            return UserInDB(**user_dict)
    
    
    def authenticate_user(fake_db, username: str, password: str):
        user = get_user(fake_db, username)
        if not user:
            return False
        if not verify_password(password, user.hashed_password):
            return False
        return user
    
    
    def create_access_token(data: dict, expires_delta: Union[timedelta, None] = None):
        to_encode = data.copy()
        if expires_delta:
            expire = datetime.now(timezone.utc) + expires_delta
        else:
            expire = datetime.now(timezone.utc) + timedelta(minutes=15)
        to_encode.update({"exp": expire})
        encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
        return encoded_jwt
    
    
    async def get_current_user(
        security_scopes: SecurityScopes, token: str = Depends(oauth2_scheme)
    ):
        if security_scopes.scopes:
            authenticate_value = f'Bearer scope="{security_scopes.scope_str}"'
        else:
            authenticate_value = "Bearer"
        credentials_exception = HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Could not validate credentials",
            headers={"WWW-Authenticate": authenticate_value},
        )
        try:
            payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
            username: str = payload.get("sub")
            if username is None:
                raise credentials_exception
            scope: str = payload.get("scope", "")
            token_scopes = scope.split(" ")
            token_data = TokenData(scopes=token_scopes, username=username)
        except (InvalidTokenError, ValidationError):
            raise credentials_exception
        user = get_user(fake_users_db, username=token_data.username)
        if user is None:
            raise credentials_exception
        for scope in security_scopes.scopes:
            if scope not in token_data.scopes:
                raise HTTPException(
                    status_code=status.HTTP_401_UNAUTHORIZED,
                    detail="Not enough permissions",
                    headers={"WWW-Authenticate": authenticate_value},
                )
        return user
    
    
    async def get_current_active_user(
        current_user: User = Security(get_current_user, scopes=["me"]),
    ):
        if current_user.disabled:
            raise HTTPException(status_code=400, detail="Inactive user")
        return current_user
    
    
    @app.post("/token")
    async def login_for_access_token(
        form_data: OAuth2PasswordRequestForm = Depends(),
    ) -> Token:
        user = authenticate_user(fake_users_db, form_data.username, form_data.password)
        if not user:
            raise HTTPException(status_code=400, detail="Incorrect username or password")
        access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
        access_token = create_access_token(
            data={"sub": user.username, "scope": " ".join(form_data.scopes)},
            expires_delta=access_token_expires,
        )
        return Token(access_token=access_token, token_type="bearer")
    
    
    @app.get("/users/me/")
    async def read_users_me(current_user: User = Depends(get_current_active_user)) -> User:
        return current_user
    
    
    @app.get("/users/me/items/")
    async def read_own_items(
        current_user: User = Security(get_current_active_user, scopes=["items"]),
    ):
        return [{"item_id": "Foo", "owner": current_user.username}]
    
    
    @app.get("/status/")
    async def read_system_status(current_user: User = Depends(get_current_user)):
        return {"status": "ok"}
    

## Declare scopes in _path operations_ and dependencies[¶](#declare-scopes-in-path-operations-and-dependencies "Permanent link")

Now we declare that the _path operation_ for `/users/me/items/` requires the scope `items`.

For this, we import and use `Security` from `fastapi`.

You can use `Security` to declare dependencies (just like `Depends`), but `Security` also receives a parameter `scopes` with a list of scopes (strings).

In this case, we pass a dependency function `get_current_active_user` to `Security` (the same way we would do with `Depends`).

But we also pass a `list` of scopes, in this case with just one scope: `items` (it could have more).

And the dependency function `get_current_active_user` can also declare sub-dependencies, not only with `Depends` but also with `Security`. Declaring its own sub-dependency function (`get_current_user`), and more scope requirements.

In this case, it requires the scope `me` (it could require more than one scope).

Note

You don't necessarily need to add different scopes in different places.

We are doing it here to demonstrate how **FastAPI** handles scopes declared at different levels.

Python 3.10+
    
    
    from datetime import datetime, timedelta, timezone
    from typing import Annotated
    
    import jwt
    from fastapi import Depends, FastAPI, HTTPException, Security, status
    from fastapi.security import (
        OAuth2PasswordBearer,
        OAuth2PasswordRequestForm,
        SecurityScopes,
    )
    from jwt.exceptions import InvalidTokenError
    from pwdlib import PasswordHash
    from pydantic import BaseModel, ValidationError
    
    # to get a string like this run:
    # openssl rand -hex 32
    SECRET_KEY = "09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
    ALGORITHM = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES = 30
    
    
    fake_users_db = {
        "johndoe": {
            "username": "johndoe",
            "full_name": "John Doe",
            "email": "johndoe@example.com",
            "hashed_password": "$argon2id$v=19$m=65536,t=3,p=4$wagCPXjifgvUFBzq4hqe3w$CYaIb8sB+wtD+Vu/P4uod1+Qof8h+1g7bbDlBID48Rc",
            "disabled": False,
        },
        "alice": {
            "username": "alice",
            "full_name": "Alice Chains",
            "email": "alicechains@example.com",
            "hashed_password": "$argon2id$v=19$m=65536,t=3,p=4$g2/AV1zwopqUntPKJavBFw$BwpRGDCyUHLvHICnwijyX8ROGoiUPwNKZ7915MeYfCE",
            "disabled": True,
        },
    }
    
    
    class Token(BaseModel):
        access_token: str
        token_type: str
    
    
    class TokenData(BaseModel):
        username: str | None = None
        scopes: list[str] = []
    
    
    class User(BaseModel):
        username: str
        email: str | None = None
        full_name: str | None = None
        disabled: bool | None = None
    
    
    class UserInDB(User):
        hashed_password: str
    
    
    password_hash = PasswordHash.recommended()
    
    oauth2_scheme = OAuth2PasswordBearer(
        tokenUrl="token",
        scopes={"me": "Read information about the current user.", "items": "Read items."},
    )
    
    app = FastAPI()
    
    
    def verify_password(plain_password, hashed_password):
        return password_hash.verify(plain_password, hashed_password)
    
    
    def get_password_hash(password):
        return password_hash.hash(password)
    
    
    def get_user(db, username: str):
        if username in db:
            user_dict = db[username]
            return UserInDB(**user_dict)
    
    
    def authenticate_user(fake_db, username: str, password: str):
        user = get_user(fake_db, username)
        if not user:
            return False
        if not verify_password(password, user.hashed_password):
            return False
        return user
    
    
    def create_access_token(data: dict, expires_delta: timedelta | None = None):
        to_encode = data.copy()
        if expires_delta:
            expire = datetime.now(timezone.utc) + expires_delta
        else:
            expire = datetime.now(timezone.utc) + timedelta(minutes=15)
        to_encode.update({"exp": expire})
        encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
        return encoded_jwt
    
    
    async def get_current_user(
        security_scopes: SecurityScopes, token: Annotated[str, Depends(oauth2_scheme)]
    ):
        if security_scopes.scopes:
            authenticate_value = f'Bearer scope="{security_scopes.scope_str}"'
        else:
            authenticate_value = "Bearer"
        credentials_exception = HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Could not validate credentials",
            headers={"WWW-Authenticate": authenticate_value},
        )
        try:
            payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
            username = payload.get("sub")
            if username is None:
                raise credentials_exception
            scope: str = payload.get("scope", "")
            token_scopes = scope.split(" ")
            token_data = TokenData(scopes=token_scopes, username=username)
        except (InvalidTokenError, ValidationError):
            raise credentials_exception
        user = get_user(fake_users_db, username=token_data.username)
        if user is None:
            raise credentials_exception
        for scope in security_scopes.scopes:
            if scope not in token_data.scopes:
                raise HTTPException(
                    status_code=status.HTTP_401_UNAUTHORIZED,
                    detail="Not enough permissions",
                    headers={"WWW-Authenticate": authenticate_value},
                )
        return user
    
    
    async def get_current_active_user(
        current_user: Annotated[User, Security(get_current_user, scopes=["me"])],
    ):
        if current_user.disabled:
            raise HTTPException(status_code=400, detail="Inactive user")
        return current_user
    
    
    @app.post("/token")
    async def login_for_access_token(
        form_data: Annotated[OAuth2PasswordRequestForm, Depends()],
    ) -> Token:
        user = authenticate_user(fake_users_db, form_data.username, form_data.password)
        if not user:
            raise HTTPException(status_code=400, detail="Incorrect username or password")
        access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
        access_token = create_access_token(
            data={"sub": user.username, "scope": " ".join(form_data.scopes)},
            expires_delta=access_token_expires,
        )
        return Token(access_token=access_token, token_type="bearer")
    
    
    @app.get("/users/me/")
    async def read_users_me(
        current_user: Annotated[User, Depends(get_current_active_user)],
    ) -> User:
        return current_user
    
    
    @app.get("/users/me/items/")
    async def read_own_items(
        current_user: Annotated[User, Security(get_current_active_user, scopes=["items"])],
    ):
        return [{"item_id": "Foo", "owner": current_user.username}]
    
    
    @app.get("/status/")
    async def read_system_status(current_user: Annotated[User, Depends(get_current_user)]):
        return {"status": "ok"}
    

ü§ì Other versions and variants

Python 3.9+Python 3.10+ - non-AnnotatedPython 3.9+ - non-Annotated
    
    
    from datetime import datetime, timedelta, timezone
    from typing import Annotated, Union
    
    import jwt
    from fastapi import Depends, FastAPI, HTTPException, Security, status
    from fastapi.security import (
        OAuth2PasswordBearer,
        OAuth2PasswordRequestForm,
        SecurityScopes,
    )
    from jwt.exceptions import InvalidTokenError
    from pwdlib import PasswordHash
    from pydantic import BaseModel, ValidationError
    
    # to get a string like this run:
    # openssl rand -hex 32
    SECRET_KEY = "09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
    ALGORITHM = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES = 30
    
    
    fake_users_db = {
        "johndoe": {
            "username": "johndoe",
            "full_name": "John Doe",
            "email": "johndoe@example.com",
            "hashed_password": "$argon2id$v=19$m=65536,t=3,p=4$wagCPXjifgvUFBzq4hqe3w$CYaIb8sB+wtD+Vu/P4uod1+Qof8h+1g7bbDlBID48Rc",
            "disabled": False,
        },
        "alice": {
            "username": "alice",
            "full_name": "Alice Chains",
            "email": "alicechains@example.com",
            "hashed_password": "$argon2id$v=19$m=65536,t=3,p=4$g2/AV1zwopqUntPKJavBFw$BwpRGDCyUHLvHICnwijyX8ROGoiUPwNKZ7915MeYfCE",
            "disabled": True,
        },
    }
    
    
    class Token(BaseModel):
        access_token: str
        token_type: str
    
    
    class TokenData(BaseModel):
        username: Union[str, None] = None
        scopes: list[str] = []
    
    
    class User(BaseModel):
        username: str
        email: Union[str, None] = None
        full_name: Union[str, None] = None
        disabled: Union[bool, None] = None
    
    
    class UserInDB(User):
        hashed_password: str
    
    
    password_hash = PasswordHash.recommended()
    
    oauth2_scheme = OAuth2PasswordBearer(
        tokenUrl="token",
        scopes={"me": "Read information about the current user.", "items": "Read items."},
    )
    
    app = FastAPI()
    
    
    def verify_password(plain_password, hashed_password):
        return password_hash.verify(plain_password, hashed_password)
    
    
    def get_password_hash(password):
        return password_hash.hash(password)
    
    
    def get_user(db, username: str):
        if username in db:
            user_dict = db[username]
            return UserInDB(**user_dict)
    
    
    def authenticate_user(fake_db, username: str, password: str):
        user = get_user(fake_db, username)
        if not user:
            return False
        if not verify_password(password, user.hashed_password):
            return False
        return user
    
    
    def create_access_token(data: dict, expires_delta: Union[timedelta, None] = None):
        to_encode = data.copy()
        if expires_delta:
            expire = datetime.now(timezone.utc) + expires_delta
        else:
            expire = datetime.now(timezone.utc) + timedelta(minutes=15)
        to_encode.update({"exp": expire})
        encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
        return encoded_jwt
    
    
    async def get_current_user(
        security_scopes: SecurityScopes, token: Annotated[str, Depends(oauth2_scheme)]
    ):
        if security_scopes.scopes:
            authenticate_value = f'Bearer scope="{security_scopes.scope_str}"'
        else:
            authenticate_value = "Bearer"
        credentials_exception = HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Could not validate credentials",
            headers={"WWW-Authenticate": authenticate_value},
        )
        try:
            payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
            username = payload.get("sub")
            if username is None:
                raise credentials_exception
            scope: str = payload.get("scope", "")
            token_scopes = scope.split(" ")
            token_data = TokenData(scopes=token_scopes, username=username)
        except (InvalidTokenError, ValidationError):
            raise credentials_exception
        user = get_user(fake_users_db, username=token_data.username)
        if user is None:
            raise credentials_exception
        for scope in security_scopes.scopes:
            if scope not in token_data.scopes:
                raise HTTPException(
                    status_code=status.HTTP_401_UNAUTHORIZED,
                    detail="Not enough permissions",
                    headers={"WWW-Authenticate": authenticate_value},
                )
        return user
    
    
    async def get_current_active_user(
        current_user: Annotated[User, Security(get_current_user, scopes=["me"])],
    ):
        if current_user.disabled:
            raise HTTPException(status_code=400, detail="Inactive user")
        return current_user
    
    
    @app.post("/token")
    async def login_for_access_token(
        form_data: Annotated[OAuth2PasswordRequestForm, Depends()],
    ) -> Token:
        user = authenticate_user(fake_users_db, form_data.username, form_data.password)
        if not user:
            raise HTTPException(status_code=400, detail="Incorrect username or password")
        access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
        access_token = create_access_token(
            data={"sub": user.username, "scope": " ".join(form_data.scopes)},
            expires_delta=access_token_expires,
        )
        return Token(access_token=access_token, token_type="bearer")
    
    
    @app.get("/users/me/")
    async def read_users_me(
        current_user: Annotated[User, Depends(get_current_active_user)],
    ) -> User:
        return current_user
    
    
    @app.get("/users/me/items/")
    async def read_own_items(
        current_user: Annotated[User, Security(get_current_active_user, scopes=["items"])],
    ):
        return [{"item_id": "Foo", "owner": current_user.username}]
    
    
    @app.get("/status/")
    async def read_system_status(current_user: Annotated[User, Depends(get_current_user)]):
        return {"status": "ok"}
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from datetime import datetime, timedelta, timezone
    
    import jwt
    from fastapi import Depends, FastAPI, HTTPException, Security, status
    from fastapi.security import (
        OAuth2PasswordBearer,
        OAuth2PasswordRequestForm,
        SecurityScopes,
    )
    from jwt.exceptions import InvalidTokenError
    from pwdlib import PasswordHash
    from pydantic import BaseModel, ValidationError
    
    # to get a string like this run:
    # openssl rand -hex 32
    SECRET_KEY = "09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
    ALGORITHM = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES = 30
    
    
    fake_users_db = {
        "johndoe": {
            "username": "johndoe",
            "full_name": "John Doe",
            "email": "johndoe@example.com",
            "hashed_password": "$argon2id$v=19$m=65536,t=3,p=4$wagCPXjifgvUFBzq4hqe3w$CYaIb8sB+wtD+Vu/P4uod1+Qof8h+1g7bbDlBID48Rc",
            "disabled": False,
        },
        "alice": {
            "username": "alice",
            "full_name": "Alice Chains",
            "email": "alicechains@example.com",
            "hashed_password": "$argon2id$v=19$m=65536,t=3,p=4$g2/AV1zwopqUntPKJavBFw$BwpRGDCyUHLvHICnwijyX8ROGoiUPwNKZ7915MeYfCE",
            "disabled": True,
        },
    }
    
    
    class Token(BaseModel):
        access_token: str
        token_type: str
    
    
    class TokenData(BaseModel):
        username: str | None = None
        scopes: list[str] = []
    
    
    class User(BaseModel):
        username: str
        email: str | None = None
        full_name: str | None = None
        disabled: bool | None = None
    
    
    class UserInDB(User):
        hashed_password: str
    
    
    password_hash = PasswordHash.recommended()
    
    oauth2_scheme = OAuth2PasswordBearer(
        tokenUrl="token",
        scopes={"me": "Read information about the current user.", "items": "Read items."},
    )
    
    app = FastAPI()
    
    
    def verify_password(plain_password, hashed_password):
        return password_hash.verify(plain_password, hashed_password)
    
    
    def get_password_hash(password):
        return password_hash.hash(password)
    
    
    def get_user(db, username: str):
        if username in db:
            user_dict = db[username]
            return UserInDB(**user_dict)
    
    
    def authenticate_user(fake_db, username: str, password: str):
        user = get_user(fake_db, username)
        if not user:
            return False
        if not verify_password(password, user.hashed_password):
            return False
        return user
    
    
    def create_access_token(data: dict, expires_delta: timedelta | None = None):
        to_encode = data.copy()
        if expires_delta:
            expire = datetime.now(timezone.utc) + expires_delta
        else:
            expire = datetime.now(timezone.utc) + timedelta(minutes=15)
        to_encode.update({"exp": expire})
        encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
        return encoded_jwt
    
    
    async def get_current_user(
        security_scopes: SecurityScopes, token: str = Depends(oauth2_scheme)
    ):
        if security_scopes.scopes:
            authenticate_value = f'Bearer scope="{security_scopes.scope_str}"'
        else:
            authenticate_value = "Bearer"
        credentials_exception = HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Could not validate credentials",
            headers={"WWW-Authenticate": authenticate_value},
        )
        try:
            payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
            username: str = payload.get("sub")
            if username is None:
                raise credentials_exception
            scope: str = payload.get("scope", "")
            token_scopes = scope.split(" ")
            token_data = TokenData(scopes=token_scopes, username=username)
        except (InvalidTokenError, ValidationError):
            raise credentials_exception
        user = get_user(fake_users_db, username=token_data.username)
        if user is None:
            raise credentials_exception
        for scope in security_scopes.scopes:
            if scope not in token_data.scopes:
                raise HTTPException(
                    status_code=status.HTTP_401_UNAUTHORIZED,
                    detail="Not enough permissions",
                    headers={"WWW-Authenticate": authenticate_value},
                )
        return user
    
    
    async def get_current_active_user(
        current_user: User = Security(get_current_user, scopes=["me"]),
    ):
        if current_user.disabled:
            raise HTTPException(status_code=400, detail="Inactive user")
        return current_user
    
    
    @app.post("/token")
    async def login_for_access_token(
        form_data: OAuth2PasswordRequestForm = Depends(),
    ) -> Token:
        user = authenticate_user(fake_users_db, form_data.username, form_data.password)
        if not user:
            raise HTTPException(status_code=400, detail="Incorrect username or password")
        access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
        access_token = create_access_token(
            data={"sub": user.username, "scope": " ".join(form_data.scopes)},
            expires_delta=access_token_expires,
        )
        return Token(access_token=access_token, token_type="bearer")
    
    
    @app.get("/users/me/")
    async def read_users_me(current_user: User = Depends(get_current_active_user)) -> User:
        return current_user
    
    
    @app.get("/users/me/items/")
    async def read_own_items(
        current_user: User = Security(get_current_active_user, scopes=["items"]),
    ):
        return [{"item_id": "Foo", "owner": current_user.username}]
    
    
    @app.get("/status/")
    async def read_system_status(current_user: User = Depends(get_current_user)):
        return {"status": "ok"}
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from datetime import datetime, timedelta, timezone
    from typing import Union
    
    import jwt
    from fastapi import Depends, FastAPI, HTTPException, Security, status
    from fastapi.security import (
        OAuth2PasswordBearer,
        OAuth2PasswordRequestForm,
        SecurityScopes,
    )
    from jwt.exceptions import InvalidTokenError
    from pwdlib import PasswordHash
    from pydantic import BaseModel, ValidationError
    
    # to get a string like this run:
    # openssl rand -hex 32
    SECRET_KEY = "09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
    ALGORITHM = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES = 30
    
    
    fake_users_db = {
        "johndoe": {
            "username": "johndoe",
            "full_name": "John Doe",
            "email": "johndoe@example.com",
            "hashed_password": "$argon2id$v=19$m=65536,t=3,p=4$wagCPXjifgvUFBzq4hqe3w$CYaIb8sB+wtD+Vu/P4uod1+Qof8h+1g7bbDlBID48Rc",
            "disabled": False,
        },
        "alice": {
            "username": "alice",
            "full_name": "Alice Chains",
            "email": "alicechains@example.com",
            "hashed_password": "$argon2id$v=19$m=65536,t=3,p=4$g2/AV1zwopqUntPKJavBFw$BwpRGDCyUHLvHICnwijyX8ROGoiUPwNKZ7915MeYfCE",
            "disabled": True,
        },
    }
    
    
    class Token(BaseModel):
        access_token: str
        token_type: str
    
    
    class TokenData(BaseModel):
        username: Union[str, None] = None
        scopes: list[str] = []
    
    
    class User(BaseModel):
        username: str
        email: Union[str, None] = None
        full_name: Union[str, None] = None
        disabled: Union[bool, None] = None
    
    
    class UserInDB(User):
        hashed_password: str
    
    
    password_hash = PasswordHash.recommended()
    
    oauth2_scheme = OAuth2PasswordBearer(
        tokenUrl="token",
        scopes={"me": "Read information about the current user.", "items": "Read items."},
    )
    
    app = FastAPI()
    
    
    def verify_password(plain_password, hashed_password):
        return password_hash.verify(plain_password, hashed_password)
    
    
    def get_password_hash(password):
        return password_hash.hash(password)
    
    
    def get_user(db, username: str):
        if username in db:
            user_dict = db[username]
            return UserInDB(**user_dict)
    
    
    def authenticate_user(fake_db, username: str, password: str):
        user = get_user(fake_db, username)
        if not user:
            return False
        if not verify_password(password, user.hashed_password):
            return False
        return user
    
    
    def create_access_token(data: dict, expires_delta: Union[timedelta, None] = None):
        to_encode = data.copy()
        if expires_delta:
            expire = datetime.now(timezone.utc) + expires_delta
        else:
            expire = datetime.now(timezone.utc) + timedelta(minutes=15)
        to_encode.update({"exp": expire})
        encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
        return encoded_jwt
    
    
    async def get_current_user(
        security_scopes: SecurityScopes, token: str = Depends(oauth2_scheme)
    ):
        if security_scopes.scopes:
            authenticate_value = f'Bearer scope="{security_scopes.scope_str}"'
        else:
            authenticate_value = "Bearer"
        credentials_exception = HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Could not validate credentials",
            headers={"WWW-Authenticate": authenticate_value},
        )
        try:
            payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
            username: str = payload.get("sub")
            if username is None:
                raise credentials_exception
            scope: str = payload.get("scope", "")
            token_scopes = scope.split(" ")
            token_data = TokenData(scopes=token_scopes, username=username)
        except (InvalidTokenError, ValidationError):
            raise credentials_exception
        user = get_user(fake_users_db, username=token_data.username)
        if user is None:
            raise credentials_exception
        for scope in security_scopes.scopes:
            if scope not in token_data.scopes:
                raise HTTPException(
                    status_code=status.HTTP_401_UNAUTHORIZED,
                    detail="Not enough permissions",
                    headers={"WWW-Authenticate": authenticate_value},
                )
        return user
    
    
    async def get_current_active_user(
        current_user: User = Security(get_current_user, scopes=["me"]),
    ):
        if current_user.disabled:
            raise HTTPException(status_code=400, detail="Inactive user")
        return current_user
    
    
    @app.post("/token")
    async def login_for_access_token(
        form_data: OAuth2PasswordRequestForm = Depends(),
    ) -> Token:
        user = authenticate_user(fake_users_db, form_data.username, form_data.password)
        if not user:
            raise HTTPException(status_code=400, detail="Incorrect username or password")
        access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
        access_token = create_access_token(
            data={"sub": user.username, "scope": " ".join(form_data.scopes)},
            expires_delta=access_token_expires,
        )
        return Token(access_token=access_token, token_type="bearer")
    
    
    @app.get("/users/me/")
    async def read_users_me(current_user: User = Depends(get_current_active_user)) -> User:
        return current_user
    
    
    @app.get("/users/me/items/")
    async def read_own_items(
        current_user: User = Security(get_current_active_user, scopes=["items"]),
    ):
        return [{"item_id": "Foo", "owner": current_user.username}]
    
    
    @app.get("/status/")
    async def read_system_status(current_user: User = Depends(get_current_user)):
        return {"status": "ok"}
    

Technical Details

`Security` is actually a subclass of `Depends`, and it has just one extra parameter that we'll see later.

But by using `Security` instead of `Depends`, **FastAPI** will know that it can declare security scopes, use them internally, and document the API with OpenAPI.

But when you import `Query`, `Path`, `Depends`, `Security` and others from `fastapi`, those are actually functions that return special classes.

## Use `SecurityScopes`[¶](#use-securityscopes "Permanent link")

Now update the dependency `get_current_user`.

This is the one used by the dependencies above.

Here's where we are using the same OAuth2 scheme we created before, declaring it as a dependency: `oauth2_scheme`.

Because this dependency function doesn't have any scope requirements itself, we can use `Depends` with `oauth2_scheme`, we don't have to use `Security` when we don't need to specify security scopes.

We also declare a special parameter of type `SecurityScopes`, imported from `fastapi.security`.

This `SecurityScopes` class is similar to `Request` (`Request` was used to get the request object directly).

Python 3.10+
    
    
    from datetime import datetime, timedelta, timezone
    from typing import Annotated
    
    import jwt
    from fastapi import Depends, FastAPI, HTTPException, Security, status
    from fastapi.security import (
        OAuth2PasswordBearer,
        OAuth2PasswordRequestForm,
        SecurityScopes,
    )
    from jwt.exceptions import InvalidTokenError
    from pwdlib import PasswordHash
    from pydantic import BaseModel, ValidationError
    
    # to get a string like this run:
    # openssl rand -hex 32
    SECRET_KEY = "09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
    ALGORITHM = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES = 30
    
    
    fake_users_db = {
        "johndoe": {
            "username": "johndoe",
            "full_name": "John Doe",
            "email": "johndoe@example.com",
            "hashed_password": "$argon2id$v=19$m=65536,t=3,p=4$wagCPXjifgvUFBzq4hqe3w$CYaIb8sB+wtD+Vu/P4uod1+Qof8h+1g7bbDlBID48Rc",
            "disabled": False,
        },
        "alice": {
            "username": "alice",
            "full_name": "Alice Chains",
            "email": "alicechains@example.com",
            "hashed_password": "$argon2id$v=19$m=65536,t=3,p=4$g2/AV1zwopqUntPKJavBFw$BwpRGDCyUHLvHICnwijyX8ROGoiUPwNKZ7915MeYfCE",
            "disabled": True,
        },
    }
    
    
    class Token(BaseModel):
        access_token: str
        token_type: str
    
    
    class TokenData(BaseModel):
        username: str | None = None
        scopes: list[str] = []
    
    
    class User(BaseModel):
        username: str
        email: str | None = None
        full_name: str | None = None
        disabled: bool | None = None
    
    
    class UserInDB(User):
        hashed_password: str
    
    
    password_hash = PasswordHash.recommended()
    
    oauth2_scheme = OAuth2PasswordBearer(
        tokenUrl="token",
        scopes={"me": "Read information about the current user.", "items": "Read items."},
    )
    
    app = FastAPI()
    
    
    def verify_password(plain_password, hashed_password):
        return password_hash.verify(plain_password, hashed_password)
    
    
    def get_password_hash(password):
        return password_hash.hash(password)
    
    
    def get_user(db, username: str):
        if username in db:
            user_dict = db[username]
            return UserInDB(**user_dict)
    
    
    def authenticate_user(fake_db, username: str, password: str):
        user = get_user(fake_db, username)
        if not user:
            return False
        if not verify_password(password, user.hashed_password):
            return False
        return user
    
    
    def create_access_token(data: dict, expires_delta: timedelta | None = None):
        to_encode = data.copy()
        if expires_delta:
            expire = datetime.now(timezone.utc) + expires_delta
        else:
            expire = datetime.now(timezone.utc) + timedelta(minutes=15)
        to_encode.update({"exp": expire})
        encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
        return encoded_jwt
    
    
    async def get_current_user(
        security_scopes: SecurityScopes, token: Annotated[str, Depends(oauth2_scheme)]
    ):
        if security_scopes.scopes:
            authenticate_value = f'Bearer scope="{security_scopes.scope_str}"'
        else:
            authenticate_value = "Bearer"
        credentials_exception = HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Could not validate credentials",
            headers={"WWW-Authenticate": authenticate_value},
        )
        try:
            payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
            username = payload.get("sub")
            if username is None:
                raise credentials_exception
            scope: str = payload.get("scope", "")
            token_scopes = scope.split(" ")
            token_data = TokenData(scopes=token_scopes, username=username)
        except (InvalidTokenError, ValidationError):
            raise credentials_exception
        user = get_user(fake_users_db, username=token_data.username)
        if user is None:
            raise credentials_exception
        for scope in security_scopes.scopes:
            if scope not in token_data.scopes:
                raise HTTPException(
                    status_code=status.HTTP_401_UNAUTHORIZED,
                    detail="Not enough permissions",
                    headers={"WWW-Authenticate": authenticate_value},
                )
        return user
    
    
    async def get_current_active_user(
        current_user: Annotated[User, Security(get_current_user, scopes=["me"])],
    ):
        if current_user.disabled:
            raise HTTPException(status_code=400, detail="Inactive user")
        return current_user
    
    
    @app.post("/token")
    async def login_for_access_token(
        form_data: Annotated[OAuth2PasswordRequestForm, Depends()],
    ) -> Token:
        user = authenticate_user(fake_users_db, form_data.username, form_data.password)
        if not user:
            raise HTTPException(status_code=400, detail="Incorrect username or password")
        access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
        access_token = create_access_token(
            data={"sub": user.username, "scope": " ".join(form_data.scopes)},
            expires_delta=access_token_expires,
        )
        return Token(access_token=access_token, token_type="bearer")
    
    
    @app.get("/users/me/")
    async def read_users_me(
        current_user: Annotated[User, Depends(get_current_active_user)],
    ) -> User:
        return current_user
    
    
    @app.get("/users/me/items/")
    async def read_own_items(
        current_user: Annotated[User, Security(get_current_active_user, scopes=["items"])],
    ):
        return [{"item_id": "Foo", "owner": current_user.username}]
    
    
    @app.get("/status/")
    async def read_system_status(current_user: Annotated[User, Depends(get_current_user)]):
        return {"status": "ok"}
    

ü§ì Other versions and variants

Python 3.9+Python 3.10+ - non-AnnotatedPython 3.9+ - non-Annotated
    
    
    from datetime import datetime, timedelta, timezone
    from typing import Annotated, Union
    
    import jwt
    from fastapi import Depends, FastAPI, HTTPException, Security, status
    from fastapi.security import (
        OAuth2PasswordBearer,
        OAuth2PasswordRequestForm,
        SecurityScopes,
    )
    from jwt.exceptions import InvalidTokenError
    from pwdlib import PasswordHash
    from pydantic import BaseModel, ValidationError
    
    # to get a string like this run:
    # openssl rand -hex 32
    SECRET_KEY = "09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
    ALGORITHM = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES = 30
    
    
    fake_users_db = {
        "johndoe": {
            "username": "johndoe",
            "full_name": "John Doe",
            "email": "johndoe@example.com",
            "hashed_password": "$argon2id$v=19$m=65536,t=3,p=4$wagCPXjifgvUFBzq4hqe3w$CYaIb8sB+wtD+Vu/P4uod1+Qof8h+1g7bbDlBID48Rc",
            "disabled": False,
        },
        "alice": {
            "username": "alice",
            "full_name": "Alice Chains",
            "email": "alicechains@example.com",
            "hashed_password": "$argon2id$v=19$m=65536,t=3,p=4$g2/AV1zwopqUntPKJavBFw$BwpRGDCyUHLvHICnwijyX8ROGoiUPwNKZ7915MeYfCE",
            "disabled": True,
        },
    }
    
    
    class Token(BaseModel):
        access_token: str
        token_type: str
    
    
    class TokenData(BaseModel):
        username: Union[str, None] = None
        scopes: list[str] = []
    
    
    class User(BaseModel):
        username: str
        email: Union[str, None] = None
        full_name: Union[str, None] = None
        disabled: Union[bool, None] = None
    
    
    class UserInDB(User):
        hashed_password: str
    
    
    password_hash = PasswordHash.recommended()
    
    oauth2_scheme = OAuth2PasswordBearer(
        tokenUrl="token",
        scopes={"me": "Read information about the current user.", "items": "Read items."},
    )
    
    app = FastAPI()
    
    
    def verify_password(plain_password, hashed_password):
        return password_hash.verify(plain_password, hashed_password)
    
    
    def get_password_hash(password):
        return password_hash.hash(password)
    
    
    def get_user(db, username: str):
        if username in db:
            user_dict = db[username]
            return UserInDB(**user_dict)
    
    
    def authenticate_user(fake_db, username: str, password: str):
        user = get_user(fake_db, username)
        if not user:
            return False
        if not verify_password(password, user.hashed_password):
            return False
        return user
    
    
    def create_access_token(data: dict, expires_delta: Union[timedelta, None] = None):
        to_encode = data.copy()
        if expires_delta:
            expire = datetime.now(timezone.utc) + expires_delta
        else:
            expire = datetime.now(timezone.utc) + timedelta(minutes=15)
        to_encode.update({"exp": expire})
        encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
        return encoded_jwt
    
    
    async def get_current_user(
        security_scopes: SecurityScopes, token: Annotated[str, Depends(oauth2_scheme)]
    ):
        if security_scopes.scopes:
            authenticate_value = f'Bearer scope="{security_scopes.scope_str}"'
        else:
            authenticate_value = "Bearer"
        credentials_exception = HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Could not validate credentials",
            headers={"WWW-Authenticate": authenticate_value},
        )
        try:
            payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
            username = payload.get("sub")
            if username is None:
                raise credentials_exception
            scope: str = payload.get("scope", "")
            token_scopes = scope.split(" ")
            token_data = TokenData(scopes=token_scopes, username=username)
        except (InvalidTokenError, ValidationError):
            raise credentials_exception
        user = get_user(fake_users_db, username=token_data.username)
        if user is None:
            raise credentials_exception
        for scope in security_scopes.scopes:
            if scope not in token_data.scopes:
                raise HTTPException(
                    status_code=status.HTTP_401_UNAUTHORIZED,
                    detail="Not enough permissions",
                    headers={"WWW-Authenticate": authenticate_value},
                )
        return user
    
    
    async def get_current_active_user(
        current_user: Annotated[User, Security(get_current_user, scopes=["me"])],
    ):
        if current_user.disabled:
            raise HTTPException(status_code=400, detail="Inactive user")
        return current_user
    
    
    @app.post("/token")
    async def login_for_access_token(
        form_data: Annotated[OAuth2PasswordRequestForm, Depends()],
    ) -> Token:
        user = authenticate_user(fake_users_db, form_data.username, form_data.password)
        if not user:
            raise HTTPException(status_code=400, detail="Incorrect username or password")
        access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
        access_token = create_access_token(
            data={"sub": user.username, "scope": " ".join(form_data.scopes)},
            expires_delta=access_token_expires,
        )
        return Token(access_token=access_token, token_type="bearer")
    
    
    @app.get("/users/me/")
    async def read_users_me(
        current_user: Annotated[User, Depends(get_current_active_user)],
    ) -> User:
        return current_user
    
    
    @app.get("/users/me/items/")
    async def read_own_items(
        current_user: Annotated[User, Security(get_current_active_user, scopes=["items"])],
    ):
        return [{"item_id": "Foo", "owner": current_user.username}]
    
    
    @app.get("/status/")
    async def read_system_status(current_user: Annotated[User, Depends(get_current_user)]):
        return {"status": "ok"}
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from datetime import datetime, timedelta, timezone
    
    import jwt
    from fastapi import Depends, FastAPI, HTTPException, Security, status
    from fastapi.security import (
        OAuth2PasswordBearer,
        OAuth2PasswordRequestForm,
        SecurityScopes,
    )
    from jwt.exceptions import InvalidTokenError
    from pwdlib import PasswordHash
    from pydantic import BaseModel, ValidationError
    
    # to get a string like this run:
    # openssl rand -hex 32
    SECRET_KEY = "09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
    ALGORITHM = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES = 30
    
    
    fake_users_db = {
        "johndoe": {
            "username": "johndoe",
            "full_name": "John Doe",
            "email": "johndoe@example.com",
            "hashed_password": "$argon2id$v=19$m=65536,t=3,p=4$wagCPXjifgvUFBzq4hqe3w$CYaIb8sB+wtD+Vu/P4uod1+Qof8h+1g7bbDlBID48Rc",
            "disabled": False,
        },
        "alice": {
            "username": "alice",
            "full_name": "Alice Chains",
            "email": "alicechains@example.com",
            "hashed_password": "$argon2id$v=19$m=65536,t=3,p=4$g2/AV1zwopqUntPKJavBFw$BwpRGDCyUHLvHICnwijyX8ROGoiUPwNKZ7915MeYfCE",
            "disabled": True,
        },
    }
    
    
    class Token(BaseModel):
        access_token: str
        token_type: str
    
    
    class TokenData(BaseModel):
        username: str | None = None
        scopes: list[str] = []
    
    
    class User(BaseModel):
        username: str
        email: str | None = None
        full_name: str | None = None
        disabled: bool | None = None
    
    
    class UserInDB(User):
        hashed_password: str
    
    
    password_hash = PasswordHash.recommended()
    
    oauth2_scheme = OAuth2PasswordBearer(
        tokenUrl="token",
        scopes={"me": "Read information about the current user.", "items": "Read items."},
    )
    
    app = FastAPI()
    
    
    def verify_password(plain_password, hashed_password):
        return password_hash.verify(plain_password, hashed_password)
    
    
    def get_password_hash(password):
        return password_hash.hash(password)
    
    
    def get_user(db, username: str):
        if username in db:
            user_dict = db[username]
            return UserInDB(**user_dict)
    
    
    def authenticate_user(fake_db, username: str, password: str):
        user = get_user(fake_db, username)
        if not user:
            return False
        if not verify_password(password, user.hashed_password):
            return False
        return user
    
    
    def create_access_token(data: dict, expires_delta: timedelta | None = None):
        to_encode = data.copy()
        if expires_delta:
            expire = datetime.now(timezone.utc) + expires_delta
        else:
            expire = datetime.now(timezone.utc) + timedelta(minutes=15)
        to_encode.update({"exp": expire})
        encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
        return encoded_jwt
    
    
    async def get_current_user(
        security_scopes: SecurityScopes, token: str = Depends(oauth2_scheme)
    ):
        if security_scopes.scopes:
            authenticate_value = f'Bearer scope="{security_scopes.scope_str}"'
        else:
            authenticate_value = "Bearer"
        credentials_exception = HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Could not validate credentials",
            headers={"WWW-Authenticate": authenticate_value},
        )
        try:
            payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
            username: str = payload.get("sub")
            if username is None:
                raise credentials_exception
            scope: str = payload.get("scope", "")
            token_scopes = scope.split(" ")
            token_data = TokenData(scopes=token_scopes, username=username)
        except (InvalidTokenError, ValidationError):
            raise credentials_exception
        user = get_user(fake_users_db, username=token_data.username)
        if user is None:
            raise credentials_exception
        for scope in security_scopes.scopes:
            if scope not in token_data.scopes:
                raise HTTPException(
                    status_code=status.HTTP_401_UNAUTHORIZED,
                    detail="Not enough permissions",
                    headers={"WWW-Authenticate": authenticate_value},
                )
        return user
    
    
    async def get_current_active_user(
        current_user: User = Security(get_current_user, scopes=["me"]),
    ):
        if current_user.disabled:
            raise HTTPException(status_code=400, detail="Inactive user")
        return current_user
    
    
    @app.post("/token")
    async def login_for_access_token(
        form_data: OAuth2PasswordRequestForm = Depends(),
    ) -> Token:
        user = authenticate_user(fake_users_db, form_data.username, form_data.password)
        if not user:
            raise HTTPException(status_code=400, detail="Incorrect username or password")
        access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
        access_token = create_access_token(
            data={"sub": user.username, "scope": " ".join(form_data.scopes)},
            expires_delta=access_token_expires,
        )
        return Token(access_token=access_token, token_type="bearer")
    
    
    @app.get("/users/me/")
    async def read_users_me(current_user: User = Depends(get_current_active_user)) -> User:
        return current_user
    
    
    @app.get("/users/me/items/")
    async def read_own_items(
        current_user: User = Security(get_current_active_user, scopes=["items"]),
    ):
        return [{"item_id": "Foo", "owner": current_user.username}]
    
    
    @app.get("/status/")
    async def read_system_status(current_user: User = Depends(get_current_user)):
        return {"status": "ok"}
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from datetime import datetime, timedelta, timezone
    from typing import Union
    
    import jwt
    from fastapi import Depends, FastAPI, HTTPException, Security, status
    from fastapi.security import (
        OAuth2PasswordBearer,
        OAuth2PasswordRequestForm,
        SecurityScopes,
    )
    from jwt.exceptions import InvalidTokenError
    from pwdlib import PasswordHash
    from pydantic import BaseModel, ValidationError
    
    # to get a string like this run:
    # openssl rand -hex 32
    SECRET_KEY = "09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
    ALGORITHM = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES = 30
    
    
    fake_users_db = {
        "johndoe": {
            "username": "johndoe",
            "full_name": "John Doe",
            "email": "johndoe@example.com",
            "hashed_password": "$argon2id$v=19$m=65536,t=3,p=4$wagCPXjifgvUFBzq4hqe3w$CYaIb8sB+wtD+Vu/P4uod1+Qof8h+1g7bbDlBID48Rc",
            "disabled": False,
        },
        "alice": {
            "username": "alice",
            "full_name": "Alice Chains",
            "email": "alicechains@example.com",
            "hashed_password": "$argon2id$v=19$m=65536,t=3,p=4$g2/AV1zwopqUntPKJavBFw$BwpRGDCyUHLvHICnwijyX8ROGoiUPwNKZ7915MeYfCE",
            "disabled": True,
        },
    }
    
    
    class Token(BaseModel):
        access_token: str
        token_type: str
    
    
    class TokenData(BaseModel):
        username: Union[str, None] = None
        scopes: list[str] = []
    
    
    class User(BaseModel):
        username: str
        email: Union[str, None] = None
        full_name: Union[str, None] = None
        disabled: Union[bool, None] = None
    
    
    class UserInDB(User):
        hashed_password: str
    
    
    password_hash = PasswordHash.recommended()
    
    oauth2_scheme = OAuth2PasswordBearer(
        tokenUrl="token",
        scopes={"me": "Read information about the current user.", "items": "Read items."},
    )
    
    app = FastAPI()
    
    
    def verify_password(plain_password, hashed_password):
        return password_hash.verify(plain_password, hashed_password)
    
    
    def get_password_hash(password):
        return password_hash.hash(password)
    
    
    def get_user(db, username: str):
        if username in db:
            user_dict = db[username]
            return UserInDB(**user_dict)
    
    
    def authenticate_user(fake_db, username: str, password: str):
        user = get_user(fake_db, username)
        if not user:
            return False
        if not verify_password(password, user.hashed_password):
            return False
        return user
    
    
    def create_access_token(data: dict, expires_delta: Union[timedelta, None] = None):
        to_encode = data.copy()
        if expires_delta:
            expire = datetime.now(timezone.utc) + expires_delta
        else:
            expire = datetime.now(timezone.utc) + timedelta(minutes=15)
        to_encode.update({"exp": expire})
        encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
        return encoded_jwt
    
    
    async def get_current_user(
        security_scopes: SecurityScopes, token: str = Depends(oauth2_scheme)
    ):
        if security_scopes.scopes:
            authenticate_value = f'Bearer scope="{security_scopes.scope_str}"'
        else:
            authenticate_value = "Bearer"
        credentials_exception = HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Could not validate credentials",
            headers={"WWW-Authenticate": authenticate_value},
        )
        try:
            payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
            username: str = payload.get("sub")
            if username is None:
                raise credentials_exception
            scope: str = payload.get("scope", "")
            token_scopes = scope.split(" ")
            token_data = TokenData(scopes=token_scopes, username=username)
        except (InvalidTokenError, ValidationError):
            raise credentials_exception
        user = get_user(fake_users_db, username=token_data.username)
        if user is None:
            raise credentials_exception
        for scope in security_scopes.scopes:
            if scope not in token_data.scopes:
                raise HTTPException(
                    status_code=status.HTTP_401_UNAUTHORIZED,
                    detail="Not enough permissions",
                    headers={"WWW-Authenticate": authenticate_value},
                )
        return user
    
    
    async def get_current_active_user(
        current_user: User = Security(get_current_user, scopes=["me"]),
    ):
        if current_user.disabled:
            raise HTTPException(status_code=400, detail="Inactive user")
        return current_user
    
    
    @app.post("/token")
    async def login_for_access_token(
        form_data: OAuth2PasswordRequestForm = Depends(),
    ) -> Token:
        user = authenticate_user(fake_users_db, form_data.username, form_data.password)
        if not user:
            raise HTTPException(status_code=400, detail="Incorrect username or password")
        access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
        access_token = create_access_token(
            data={"sub": user.username, "scope": " ".join(form_data.scopes)},
            expires_delta=access_token_expires,
        )
        return Token(access_token=access_token, token_type="bearer")
    
    
    @app.get("/users/me/")
    async def read_users_me(current_user: User = Depends(get_current_active_user)) -> User:
        return current_user
    
    
    @app.get("/users/me/items/")
    async def read_own_items(
        current_user: User = Security(get_current_active_user, scopes=["items"]),
    ):
        return [{"item_id": "Foo", "owner": current_user.username}]
    
    
    @app.get("/status/")
    async def read_system_status(current_user: User = Depends(get_current_user)):
        return {"status": "ok"}
    

## Use the `scopes`[¶](#use-the-scopes "Permanent link")

The parameter `security_scopes` will be of type `SecurityScopes`.

It will have a property `scopes` with a list containing all the scopes required by itself and all the dependencies that use this as a sub-dependency. That means, all the "dependants"... this might sound confusing, it is explained again later below.

The `security_scopes` object (of class `SecurityScopes`) also provides a `scope_str` attribute with a single string, containing those scopes separated by spaces (we are going to use it).

We create an `HTTPException` that we can reuse (`raise`) later at several points.

In this exception, we include the scopes required (if any) as a string separated by spaces (using `scope_str`). We put that string containing the scopes in the `WWW-Authenticate` header (this is part of the spec).

Python 3.10+
    
    
    from datetime import datetime, timedelta, timezone
    from typing import Annotated
    
    import jwt
    from fastapi import Depends, FastAPI, HTTPException, Security, status
    from fastapi.security import (
        OAuth2PasswordBearer,
        OAuth2PasswordRequestForm,
        SecurityScopes,
    )
    from jwt.exceptions import InvalidTokenError
    from pwdlib import PasswordHash
    from pydantic import BaseModel, ValidationError
    
    # to get a string like this run:
    # openssl rand -hex 32
    SECRET_KEY = "09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
    ALGORITHM = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES = 30
    
    
    fake_users_db = {
        "johndoe": {
            "username": "johndoe",
            "full_name": "John Doe",
            "email": "johndoe@example.com",
            "hashed_password": "$argon2id$v=19$m=65536,t=3,p=4$wagCPXjifgvUFBzq4hqe3w$CYaIb8sB+wtD+Vu/P4uod1+Qof8h+1g7bbDlBID48Rc",
            "disabled": False,
        },
        "alice": {
            "username": "alice",
            "full_name": "Alice Chains",
            "email": "alicechains@example.com",
            "hashed_password": "$argon2id$v=19$m=65536,t=3,p=4$g2/AV1zwopqUntPKJavBFw$BwpRGDCyUHLvHICnwijyX8ROGoiUPwNKZ7915MeYfCE",
            "disabled": True,
        },
    }
    
    
    class Token(BaseModel):
        access_token: str
        token_type: str
    
    
    class TokenData(BaseModel):
        username: str | None = None
        scopes: list[str] = []
    
    
    class User(BaseModel):
        username: str
        email: str | None = None
        full_name: str | None = None
        disabled: bool | None = None
    
    
    class UserInDB(User):
        hashed_password: str
    
    
    password_hash = PasswordHash.recommended()
    
    oauth2_scheme = OAuth2PasswordBearer(
        tokenUrl="token",
        scopes={"me": "Read information about the current user.", "items": "Read items."},
    )
    
    app = FastAPI()
    
    
    def verify_password(plain_password, hashed_password):
        return password_hash.verify(plain_password, hashed_password)
    
    
    def get_password_hash(password):
        return password_hash.hash(password)
    
    
    def get_user(db, username: str):
        if username in db:
            user_dict = db[username]
            return UserInDB(**user_dict)
    
    
    def authenticate_user(fake_db, username: str, password: str):
        user = get_user(fake_db, username)
        if not user:
            return False
        if not verify_password(password, user.hashed_password):
            return False
        return user
    
    
    def create_access_token(data: dict, expires_delta: timedelta | None = None):
        to_encode = data.copy()
        if expires_delta:
            expire = datetime.now(timezone.utc) + expires_delta
        else:
            expire = datetime.now(timezone.utc) + timedelta(minutes=15)
        to_encode.update({"exp": expire})
        encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
        return encoded_jwt
    
    
    async def get_current_user(
        security_scopes: SecurityScopes, token: Annotated[str, Depends(oauth2_scheme)]
    ):
        if security_scopes.scopes:
            authenticate_value = f'Bearer scope="{security_scopes.scope_str}"'
        else:
            authenticate_value = "Bearer"
        credentials_exception = HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Could not validate credentials",
            headers={"WWW-Authenticate": authenticate_value},
        )
        try:
            payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
            username = payload.get("sub")
            if username is None:
                raise credentials_exception
            scope: str = payload.get("scope", "")
            token_scopes = scope.split(" ")
            token_data = TokenData(scopes=token_scopes, username=username)
        except (InvalidTokenError, ValidationError):
            raise credentials_exception
        user = get_user(fake_users_db, username=token_data.username)
        if user is None:
            raise credentials_exception
        for scope in security_scopes.scopes:
            if scope not in token_data.scopes:
                raise HTTPException(
                    status_code=status.HTTP_401_UNAUTHORIZED,
                    detail="Not enough permissions",
                    headers={"WWW-Authenticate": authenticate_value},
                )
        return user
    
    
    async def get_current_active_user(
        current_user: Annotated[User, Security(get_current_user, scopes=["me"])],
    ):
        if current_user.disabled:
            raise HTTPException(status_code=400, detail="Inactive user")
        return current_user
    
    
    @app.post("/token")
    async def login_for_access_token(
        form_data: Annotated[OAuth2PasswordRequestForm, Depends()],
    ) -> Token:
        user = authenticate_user(fake_users_db, form_data.username, form_data.password)
        if not user:
            raise HTTPException(status_code=400, detail="Incorrect username or password")
        access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
        access_token = create_access_token(
            data={"sub": user.username, "scope": " ".join(form_data.scopes)},
            expires_delta=access_token_expires,
        )
        return Token(access_token=access_token, token_type="bearer")
    
    
    @app.get("/users/me/")
    async def read_users_me(
        current_user: Annotated[User, Depends(get_current_active_user)],
    ) -> User:
        return current_user
    
    
    @app.get("/users/me/items/")
    async def read_own_items(
        current_user: Annotated[User, Security(get_current_active_user, scopes=["items"])],
    ):
        return [{"item_id": "Foo", "owner": current_user.username}]
    
    
    @app.get("/status/")
    async def read_system_status(current_user: Annotated[User, Depends(get_current_user)]):
        return {"status": "ok"}
    

ü§ì Other versions and variants

Python 3.9+Python 3.10+ - non-AnnotatedPython 3.9+ - non-Annotated
    
    
    from datetime import datetime, timedelta, timezone
    from typing import Annotated, Union
    
    import jwt
    from fastapi import Depends, FastAPI, HTTPException, Security, status
    from fastapi.security import (
        OAuth2PasswordBearer,
        OAuth2PasswordRequestForm,
        SecurityScopes,
    )
    from jwt.exceptions import InvalidTokenError
    from pwdlib import PasswordHash
    from pydantic import BaseModel, ValidationError
    
    # to get a string like this run:
    # openssl rand -hex 32
    SECRET_KEY = "09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
    ALGORITHM = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES = 30
    
    
    fake_users_db = {
        "johndoe": {
            "username": "johndoe",
            "full_name": "John Doe",
            "email": "johndoe@example.com",
            "hashed_password": "$argon2id$v=19$m=65536,t=3,p=4$wagCPXjifgvUFBzq4hqe3w$CYaIb8sB+wtD+Vu/P4uod1+Qof8h+1g7bbDlBID48Rc",
            "disabled": False,
        },
        "alice": {
            "username": "alice",
            "full_name": "Alice Chains",
            "email": "alicechains@example.com",
            "hashed_password": "$argon2id$v=19$m=65536,t=3,p=4$g2/AV1zwopqUntPKJavBFw$BwpRGDCyUHLvHICnwijyX8ROGoiUPwNKZ7915MeYfCE",
            "disabled": True,
        },
    }
    
    
    class Token(BaseModel):
        access_token: str
        token_type: str
    
    
    class TokenData(BaseModel):
        username: Union[str, None] = None
        scopes: list[str] = []
    
    
    class User(BaseModel):
        username: str
        email: Union[str, None] = None
        full_name: Union[str, None] = None
        disabled: Union[bool, None] = None
    
    
    class UserInDB(User):
        hashed_password: str
    
    
    password_hash = PasswordHash.recommended()
    
    oauth2_scheme = OAuth2PasswordBearer(
        tokenUrl="token",
        scopes={"me": "Read information about the current user.", "items": "Read items."},
    )
    
    app = FastAPI()
    
    
    def verify_password(plain_password, hashed_password):
        return password_hash.verify(plain_password, hashed_password)
    
    
    def get_password_hash(password):
        return password_hash.hash(password)
    
    
    def get_user(db, username: str):
        if username in db:
            user_dict = db[username]
            return UserInDB(**user_dict)
    
    
    def authenticate_user(fake_db, username: str, password: str):
        user = get_user(fake_db, username)
        if not user:
            return False
        if not verify_password(password, user.hashed_password):
            return False
        return user
    
    
    def create_access_token(data: dict, expires_delta: Union[timedelta, None] = None):
        to_encode = data.copy()
        if expires_delta:
            expire = datetime.now(timezone.utc) + expires_delta
        else:
            expire = datetime.now(timezone.utc) + timedelta(minutes=15)
        to_encode.update({"exp": expire})
        encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
        return encoded_jwt
    
    
    async def get_current_user(
        security_scopes: SecurityScopes, token: Annotated[str, Depends(oauth2_scheme)]
    ):
        if security_scopes.scopes:
            authenticate_value = f'Bearer scope="{security_scopes.scope_str}"'
        else:
            authenticate_value = "Bearer"
        credentials_exception = HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Could not validate credentials",
            headers={"WWW-Authenticate": authenticate_value},
        )
        try:
            payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
            username = payload.get("sub")
            if username is None:
                raise credentials_exception
            scope: str = payload.get("scope", "")
            token_scopes = scope.split(" ")
            token_data = TokenData(scopes=token_scopes, username=username)
        except (InvalidTokenError, ValidationError):
            raise credentials_exception
        user = get_user(fake_users_db, username=token_data.username)
        if user is None:
            raise credentials_exception
        for scope in security_scopes.scopes:
            if scope not in token_data.scopes:
                raise HTTPException(
                    status_code=status.HTTP_401_UNAUTHORIZED,
                    detail="Not enough permissions",
                    headers={"WWW-Authenticate": authenticate_value},
                )
        return user
    
    
    async def get_current_active_user(
        current_user: Annotated[User, Security(get_current_user, scopes=["me"])],
    ):
        if current_user.disabled:
            raise HTTPException(status_code=400, detail="Inactive user")
        return current_user
    
    
    @app.post("/token")
    async def login_for_access_token(
        form_data: Annotated[OAuth2PasswordRequestForm, Depends()],
    ) -> Token:
        user = authenticate_user(fake_users_db, form_data.username, form_data.password)
        if not user:
            raise HTTPException(status_code=400, detail="Incorrect username or password")
        access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
        access_token = create_access_token(
            data={"sub": user.username, "scope": " ".join(form_data.scopes)},
            expires_delta=access_token_expires,
        )
        return Token(access_token=access_token, token_type="bearer")
    
    
    @app.get("/users/me/")
    async def read_users_me(
        current_user: Annotated[User, Depends(get_current_active_user)],
    ) -> User:
        return current_user
    
    
    @app.get("/users/me/items/")
    async def read_own_items(
        current_user: Annotated[User, Security(get_current_active_user, scopes=["items"])],
    ):
        return [{"item_id": "Foo", "owner": current_user.username}]
    
    
    @app.get("/status/")
    async def read_system_status(current_user: Annotated[User, Depends(get_current_user)]):
        return {"status": "ok"}
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from datetime import datetime, timedelta, timezone
    
    import jwt
    from fastapi import Depends, FastAPI, HTTPException, Security, status
    from fastapi.security import (
        OAuth2PasswordBearer,
        OAuth2PasswordRequestForm,
        SecurityScopes,
    )
    from jwt.exceptions import InvalidTokenError
    from pwdlib import PasswordHash
    from pydantic import BaseModel, ValidationError
    
    # to get a string like this run:
    # openssl rand -hex 32
    SECRET_KEY = "09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
    ALGORITHM = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES = 30
    
    
    fake_users_db = {
        "johndoe": {
            "username": "johndoe",
            "full_name": "John Doe",
            "email": "johndoe@example.com",
            "hashed_password": "$argon2id$v=19$m=65536,t=3,p=4$wagCPXjifgvUFBzq4hqe3w$CYaIb8sB+wtD+Vu/P4uod1+Qof8h+1g7bbDlBID48Rc",
            "disabled": False,
        },
        "alice": {
            "username": "alice",
            "full_name": "Alice Chains",
            "email": "alicechains@example.com",
            "hashed_password": "$argon2id$v=19$m=65536,t=3,p=4$g2/AV1zwopqUntPKJavBFw$BwpRGDCyUHLvHICnwijyX8ROGoiUPwNKZ7915MeYfCE",
            "disabled": True,
        },
    }
    
    
    class Token(BaseModel):
        access_token: str
        token_type: str
    
    
    class TokenData(BaseModel):
        username: str | None = None
        scopes: list[str] = []
    
    
    class User(BaseModel):
        username: str
        email: str | None = None
        full_name: str | None = None
        disabled: bool | None = None
    
    
    class UserInDB(User):
        hashed_password: str
    
    
    password_hash = PasswordHash.recommended()
    
    oauth2_scheme = OAuth2PasswordBearer(
        tokenUrl="token",
        scopes={"me": "Read information about the current user.", "items": "Read items."},
    )
    
    app = FastAPI()
    
    
    def verify_password(plain_password, hashed_password):
        return password_hash.verify(plain_password, hashed_password)
    
    
    def get_password_hash(password):
        return password_hash.hash(password)
    
    
    def get_user(db, username: str):
        if username in db:
            user_dict = db[username]
            return UserInDB(**user_dict)
    
    
    def authenticate_user(fake_db, username: str, password: str):
        user = get_user(fake_db, username)
        if not user:
            return False
        if not verify_password(password, user.hashed_password):
            return False
        return user
    
    
    def create_access_token(data: dict, expires_delta: timedelta | None = None):
        to_encode = data.copy()
        if expires_delta:
            expire = datetime.now(timezone.utc) + expires_delta
        else:
            expire = datetime.now(timezone.utc) + timedelta(minutes=15)
        to_encode.update({"exp": expire})
        encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
        return encoded_jwt
    
    
    async def get_current_user(
        security_scopes: SecurityScopes, token: str = Depends(oauth2_scheme)
    ):
        if security_scopes.scopes:
            authenticate_value = f'Bearer scope="{security_scopes.scope_str}"'
        else:
            authenticate_value = "Bearer"
        credentials_exception = HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Could not validate credentials",
            headers={"WWW-Authenticate": authenticate_value},
        )
        try:
            payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
            username: str = payload.get("sub")
            if username is None:
                raise credentials_exception
            scope: str = payload.get("scope", "")
            token_scopes = scope.split(" ")
            token_data = TokenData(scopes=token_scopes, username=username)
        except (InvalidTokenError, ValidationError):
            raise credentials_exception
        user = get_user(fake_users_db, username=token_data.username)
        if user is None:
            raise credentials_exception
        for scope in security_scopes.scopes:
            if scope not in token_data.scopes:
                raise HTTPException(
                    status_code=status.HTTP_401_UNAUTHORIZED,
                    detail="Not enough permissions",
                    headers={"WWW-Authenticate": authenticate_value},
                )
        return user
    
    
    async def get_current_active_user(
        current_user: User = Security(get_current_user, scopes=["me"]),
    ):
        if current_user.disabled:
            raise HTTPException(status_code=400, detail="Inactive user")
        return current_user
    
    
    @app.post("/token")
    async def login_for_access_token(
        form_data: OAuth2PasswordRequestForm = Depends(),
    ) -> Token:
        user = authenticate_user(fake_users_db, form_data.username, form_data.password)
        if not user:
            raise HTTPException(status_code=400, detail="Incorrect username or password")
        access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
        access_token = create_access_token(
            data={"sub": user.username, "scope": " ".join(form_data.scopes)},
            expires_delta=access_token_expires,
        )
        return Token(access_token=access_token, token_type="bearer")
    
    
    @app.get("/users/me/")
    async def read_users_me(current_user: User = Depends(get_current_active_user)) -> User:
        return current_user
    
    
    @app.get("/users/me/items/")
    async def read_own_items(
        current_user: User = Security(get_current_active_user, scopes=["items"]),
    ):
        return [{"item_id": "Foo", "owner": current_user.username}]
    
    
    @app.get("/status/")
    async def read_system_status(current_user: User = Depends(get_current_user)):
        return {"status": "ok"}
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from datetime import datetime, timedelta, timezone
    from typing import Union
    
    import jwt
    from fastapi import Depends, FastAPI, HTTPException, Security, status
    from fastapi.security import (
        OAuth2PasswordBearer,
        OAuth2PasswordRequestForm,
        SecurityScopes,
    )
    from jwt.exceptions import InvalidTokenError
    from pwdlib import PasswordHash
    from pydantic import BaseModel, ValidationError
    
    # to get a string like this run:
    # openssl rand -hex 32
    SECRET_KEY = "09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
    ALGORITHM = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES = 30
    
    
    fake_users_db = {
        "johndoe": {
            "username": "johndoe",
            "full_name": "John Doe",
            "email": "johndoe@example.com",
            "hashed_password": "$argon2id$v=19$m=65536,t=3,p=4$wagCPXjifgvUFBzq4hqe3w$CYaIb8sB+wtD+Vu/P4uod1+Qof8h+1g7bbDlBID48Rc",
            "disabled": False,
        },
        "alice": {
            "username": "alice",
            "full_name": "Alice Chains",
            "email": "alicechains@example.com",
            "hashed_password": "$argon2id$v=19$m=65536,t=3,p=4$g2/AV1zwopqUntPKJavBFw$BwpRGDCyUHLvHICnwijyX8ROGoiUPwNKZ7915MeYfCE",
            "disabled": True,
        },
    }
    
    
    class Token(BaseModel):
        access_token: str
        token_type: str
    
    
    class TokenData(BaseModel):
        username: Union[str, None] = None
        scopes: list[str] = []
    
    
    class User(BaseModel):
        username: str
        email: Union[str, None] = None
        full_name: Union[str, None] = None
        disabled: Union[bool, None] = None
    
    
    class UserInDB(User):
        hashed_password: str
    
    
    password_hash = PasswordHash.recommended()
    
    oauth2_scheme = OAuth2PasswordBearer(
        tokenUrl="token",
        scopes={"me": "Read information about the current user.", "items": "Read items."},
    )
    
    app = FastAPI()
    
    
    def verify_password(plain_password, hashed_password):
        return password_hash.verify(plain_password, hashed_password)
    
    
    def get_password_hash(password):
        return password_hash.hash(password)
    
    
    def get_user(db, username: str):
        if username in db:
            user_dict = db[username]
            return UserInDB(**user_dict)
    
    
    def authenticate_user(fake_db, username: str, password: str):
        user = get_user(fake_db, username)
        if not user:
            return False
        if not verify_password(password, user.hashed_password):
            return False
        return user
    
    
    def create_access_token(data: dict, expires_delta: Union[timedelta, None] = None):
        to_encode = data.copy()
        if expires_delta:
            expire = datetime.now(timezone.utc) + expires_delta
        else:
            expire = datetime.now(timezone.utc) + timedelta(minutes=15)
        to_encode.update({"exp": expire})
        encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
        return encoded_jwt
    
    
    async def get_current_user(
        security_scopes: SecurityScopes, token: str = Depends(oauth2_scheme)
    ):
        if security_scopes.scopes:
            authenticate_value = f'Bearer scope="{security_scopes.scope_str}"'
        else:
            authenticate_value = "Bearer"
        credentials_exception = HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Could not validate credentials",
            headers={"WWW-Authenticate": authenticate_value},
        )
        try:
            payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
            username: str = payload.get("sub")
            if username is None:
                raise credentials_exception
            scope: str = payload.get("scope", "")
            token_scopes = scope.split(" ")
            token_data = TokenData(scopes=token_scopes, username=username)
        except (InvalidTokenError, ValidationError):
            raise credentials_exception
        user = get_user(fake_users_db, username=token_data.username)
        if user is None:
            raise credentials_exception
        for scope in security_scopes.scopes:
            if scope not in token_data.scopes:
                raise HTTPException(
                    status_code=status.HTTP_401_UNAUTHORIZED,
                    detail="Not enough permissions",
                    headers={"WWW-Authenticate": authenticate_value},
                )
        return user
    
    
    async def get_current_active_user(
        current_user: User = Security(get_current_user, scopes=["me"]),
    ):
        if current_user.disabled:
            raise HTTPException(status_code=400, detail="Inactive user")
        return current_user
    
    
    @app.post("/token")
    async def login_for_access_token(
        form_data: OAuth2PasswordRequestForm = Depends(),
    ) -> Token:
        user = authenticate_user(fake_users_db, form_data.username, form_data.password)
        if not user:
            raise HTTPException(status_code=400, detail="Incorrect username or password")
        access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
        access_token = create_access_token(
            data={"sub": user.username, "scope": " ".join(form_data.scopes)},
            expires_delta=access_token_expires,
        )
        return Token(access_token=access_token, token_type="bearer")
    
    
    @app.get("/users/me/")
    async def read_users_me(current_user: User = Depends(get_current_active_user)) -> User:
        return current_user
    
    
    @app.get("/users/me/items/")
    async def read_own_items(
        current_user: User = Security(get_current_active_user, scopes=["items"]),
    ):
        return [{"item_id": "Foo", "owner": current_user.username}]
    
    
    @app.get("/status/")
    async def read_system_status(current_user: User = Depends(get_current_user)):
        return {"status": "ok"}
    

## Verify the `username` and data shape[¶](#verify-the-username-and-data-shape "Permanent link")

We verify that we get a `username`, and extract the scopes.

And then we validate that data with the Pydantic model (catching the `ValidationError` exception), and if we get an error reading the JWT token or validating the data with Pydantic, we raise the `HTTPException` we created before.

For that, we update the Pydantic model `TokenData` with a new property `scopes`.

By validating the data with Pydantic we can make sure that we have, for example, exactly a `list` of `str` with the scopes and a `str` with the `username`.

Instead of, for example, a `dict`, or something else, as it could break the application at some point later, making it a security risk.

We also verify that we have a user with that username, and if not, we raise that same exception we created before.

Python 3.10+
    
    
    from datetime import datetime, timedelta, timezone
    from typing import Annotated
    
    import jwt
    from fastapi import Depends, FastAPI, HTTPException, Security, status
    from fastapi.security import (
        OAuth2PasswordBearer,
        OAuth2PasswordRequestForm,
        SecurityScopes,
    )
    from jwt.exceptions import InvalidTokenError
    from pwdlib import PasswordHash
    from pydantic import BaseModel, ValidationError
    
    # to get a string like this run:
    # openssl rand -hex 32
    SECRET_KEY = "09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
    ALGORITHM = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES = 30
    
    
    fake_users_db = {
        "johndoe": {
            "username": "johndoe",
            "full_name": "John Doe",
            "email": "johndoe@example.com",
            "hashed_password": "$argon2id$v=19$m=65536,t=3,p=4$wagCPXjifgvUFBzq4hqe3w$CYaIb8sB+wtD+Vu/P4uod1+Qof8h+1g7bbDlBID48Rc",
            "disabled": False,
        },
        "alice": {
            "username": "alice",
            "full_name": "Alice Chains",
            "email": "alicechains@example.com",
            "hashed_password": "$argon2id$v=19$m=65536,t=3,p=4$g2/AV1zwopqUntPKJavBFw$BwpRGDCyUHLvHICnwijyX8ROGoiUPwNKZ7915MeYfCE",
            "disabled": True,
        },
    }
    
    
    class Token(BaseModel):
        access_token: str
        token_type: str
    
    
    class TokenData(BaseModel):
        username: str | None = None
        scopes: list[str] = []
    
    
    class User(BaseModel):
        username: str
        email: str | None = None
        full_name: str | None = None
        disabled: bool | None = None
    
    
    class UserInDB(User):
        hashed_password: str
    
    
    password_hash = PasswordHash.recommended()
    
    oauth2_scheme = OAuth2PasswordBearer(
        tokenUrl="token",
        scopes={"me": "Read information about the current user.", "items": "Read items."},
    )
    
    app = FastAPI()
    
    
    def verify_password(plain_password, hashed_password):
        return password_hash.verify(plain_password, hashed_password)
    
    
    def get_password_hash(password):
        return password_hash.hash(password)
    
    
    def get_user(db, username: str):
        if username in db:
            user_dict = db[username]
            return UserInDB(**user_dict)
    
    
    def authenticate_user(fake_db, username: str, password: str):
        user = get_user(fake_db, username)
        if not user:
            return False
        if not verify_password(password, user.hashed_password):
            return False
        return user
    
    
    def create_access_token(data: dict, expires_delta: timedelta | None = None):
        to_encode = data.copy()
        if expires_delta:
            expire = datetime.now(timezone.utc) + expires_delta
        else:
            expire = datetime.now(timezone.utc) + timedelta(minutes=15)
        to_encode.update({"exp": expire})
        encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
        return encoded_jwt
    
    
    async def get_current_user(
        security_scopes: SecurityScopes, token: Annotated[str, Depends(oauth2_scheme)]
    ):
        if security_scopes.scopes:
            authenticate_value = f'Bearer scope="{security_scopes.scope_str}"'
        else:
            authenticate_value = "Bearer"
        credentials_exception = HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Could not validate credentials",
            headers={"WWW-Authenticate": authenticate_value},
        )
        try:
            payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
            username = payload.get("sub")
            if username is None:
                raise credentials_exception
            scope: str = payload.get("scope", "")
            token_scopes = scope.split(" ")
            token_data = TokenData(scopes=token_scopes, username=username)
        except (InvalidTokenError, ValidationError):
            raise credentials_exception
        user = get_user(fake_users_db, username=token_data.username)
        if user is None:
            raise credentials_exception
        for scope in security_scopes.scopes:
            if scope not in token_data.scopes:
                raise HTTPException(
                    status_code=status.HTTP_401_UNAUTHORIZED,
                    detail="Not enough permissions",
                    headers={"WWW-Authenticate": authenticate_value},
                )
        return user
    
    
    async def get_current_active_user(
        current_user: Annotated[User, Security(get_current_user, scopes=["me"])],
    ):
        if current_user.disabled:
            raise HTTPException(status_code=400, detail="Inactive user")
        return current_user
    
    
    @app.post("/token")
    async def login_for_access_token(
        form_data: Annotated[OAuth2PasswordRequestForm, Depends()],
    ) -> Token:
        user = authenticate_user(fake_users_db, form_data.username, form_data.password)
        if not user:
            raise HTTPException(status_code=400, detail="Incorrect username or password")
        access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
        access_token = create_access_token(
            data={"sub": user.username, "scope": " ".join(form_data.scopes)},
            expires_delta=access_token_expires,
        )
        return Token(access_token=access_token, token_type="bearer")
    
    
    @app.get("/users/me/")
    async def read_users_me(
        current_user: Annotated[User, Depends(get_current_active_user)],
    ) -> User:
        return current_user
    
    
    @app.get("/users/me/items/")
    async def read_own_items(
        current_user: Annotated[User, Security(get_current_active_user, scopes=["items"])],
    ):
        return [{"item_id": "Foo", "owner": current_user.username}]
    
    
    @app.get("/status/")
    async def read_system_status(current_user: Annotated[User, Depends(get_current_user)]):
        return {"status": "ok"}
    

ü§ì Other versions and variants

Python 3.9+Python 3.10+ - non-AnnotatedPython 3.9+ - non-Annotated
    
    
    from datetime import datetime, timedelta, timezone
    from typing import Annotated, Union
    
    import jwt
    from fastapi import Depends, FastAPI, HTTPException, Security, status
    from fastapi.security import (
        OAuth2PasswordBearer,
        OAuth2PasswordRequestForm,
        SecurityScopes,
    )
    from jwt.exceptions import InvalidTokenError
    from pwdlib import PasswordHash
    from pydantic import BaseModel, ValidationError
    
    # to get a string like this run:
    # openssl rand -hex 32
    SECRET_KEY = "09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
    ALGORITHM = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES = 30
    
    
    fake_users_db = {
        "johndoe": {
            "username": "johndoe",
            "full_name": "John Doe",
            "email": "johndoe@example.com",
            "hashed_password": "$argon2id$v=19$m=65536,t=3,p=4$wagCPXjifgvUFBzq4hqe3w$CYaIb8sB+wtD+Vu/P4uod1+Qof8h+1g7bbDlBID48Rc",
            "disabled": False,
        },
        "alice": {
            "username": "alice",
            "full_name": "Alice Chains",
            "email": "alicechains@example.com",
            "hashed_password": "$argon2id$v=19$m=65536,t=3,p=4$g2/AV1zwopqUntPKJavBFw$BwpRGDCyUHLvHICnwijyX8ROGoiUPwNKZ7915MeYfCE",
            "disabled": True,
        },
    }
    
    
    class Token(BaseModel):
        access_token: str
        token_type: str
    
    
    class TokenData(BaseModel):
        username: Union[str, None] = None
        scopes: list[str] = []
    
    
    class User(BaseModel):
        username: str
        email: Union[str, None] = None
        full_name: Union[str, None] = None
        disabled: Union[bool, None] = None
    
    
    class UserInDB(User):
        hashed_password: str
    
    
    password_hash = PasswordHash.recommended()
    
    oauth2_scheme = OAuth2PasswordBearer(
        tokenUrl="token",
        scopes={"me": "Read information about the current user.", "items": "Read items."},
    )
    
    app = FastAPI()
    
    
    def verify_password(plain_password, hashed_password):
        return password_hash.verify(plain_password, hashed_password)
    
    
    def get_password_hash(password):
        return password_hash.hash(password)
    
    
    def get_user(db, username: str):
        if username in db:
            user_dict = db[username]
            return UserInDB(**user_dict)
    
    
    def authenticate_user(fake_db, username: str, password: str):
        user = get_user(fake_db, username)
        if not user:
            return False
        if not verify_password(password, user.hashed_password):
            return False
        return user
    
    
    def create_access_token(data: dict, expires_delta: Union[timedelta, None] = None):
        to_encode = data.copy()
        if expires_delta:
            expire = datetime.now(timezone.utc) + expires_delta
        else:
            expire = datetime.now(timezone.utc) + timedelta(minutes=15)
        to_encode.update({"exp": expire})
        encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
        return encoded_jwt
    
    
    async def get_current_user(
        security_scopes: SecurityScopes, token: Annotated[str, Depends(oauth2_scheme)]
    ):
        if security_scopes.scopes:
            authenticate_value = f'Bearer scope="{security_scopes.scope_str}"'
        else:
            authenticate_value = "Bearer"
        credentials_exception = HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Could not validate credentials",
            headers={"WWW-Authenticate": authenticate_value},
        )
        try:
            payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
            username = payload.get("sub")
            if username is None:
                raise credentials_exception
            scope: str = payload.get("scope", "")
            token_scopes = scope.split(" ")
            token_data = TokenData(scopes=token_scopes, username=username)
        except (InvalidTokenError, ValidationError):
            raise credentials_exception
        user = get_user(fake_users_db, username=token_data.username)
        if user is None:
            raise credentials_exception
        for scope in security_scopes.scopes:
            if scope not in token_data.scopes:
                raise HTTPException(
                    status_code=status.HTTP_401_UNAUTHORIZED,
                    detail="Not enough permissions",
                    headers={"WWW-Authenticate": authenticate_value},
                )
        return user
    
    
    async def get_current_active_user(
        current_user: Annotated[User, Security(get_current_user, scopes=["me"])],
    ):
        if current_user.disabled:
            raise HTTPException(status_code=400, detail="Inactive user")
        return current_user
    
    
    @app.post("/token")
    async def login_for_access_token(
        form_data: Annotated[OAuth2PasswordRequestForm, Depends()],
    ) -> Token:
        user = authenticate_user(fake_users_db, form_data.username, form_data.password)
        if not user:
            raise HTTPException(status_code=400, detail="Incorrect username or password")
        access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
        access_token = create_access_token(
            data={"sub": user.username, "scope": " ".join(form_data.scopes)},
            expires_delta=access_token_expires,
        )
        return Token(access_token=access_token, token_type="bearer")
    
    
    @app.get("/users/me/")
    async def read_users_me(
        current_user: Annotated[User, Depends(get_current_active_user)],
    ) -> User:
        return current_user
    
    
    @app.get("/users/me/items/")
    async def read_own_items(
        current_user: Annotated[User, Security(get_current_active_user, scopes=["items"])],
    ):
        return [{"item_id": "Foo", "owner": current_user.username}]
    
    
    @app.get("/status/")
    async def read_system_status(current_user: Annotated[User, Depends(get_current_user)]):
        return {"status": "ok"}
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from datetime import datetime, timedelta, timezone
    
    import jwt
    from fastapi import Depends, FastAPI, HTTPException, Security, status
    from fastapi.security import (
        OAuth2PasswordBearer,
        OAuth2PasswordRequestForm,
        SecurityScopes,
    )
    from jwt.exceptions import InvalidTokenError
    from pwdlib import PasswordHash
    from pydantic import BaseModel, ValidationError
    
    # to get a string like this run:
    # openssl rand -hex 32
    SECRET_KEY = "09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
    ALGORITHM = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES = 30
    
    
    fake_users_db = {
        "johndoe": {
            "username": "johndoe",
            "full_name": "John Doe",
            "email": "johndoe@example.com",
            "hashed_password": "$argon2id$v=19$m=65536,t=3,p=4$wagCPXjifgvUFBzq4hqe3w$CYaIb8sB+wtD+Vu/P4uod1+Qof8h+1g7bbDlBID48Rc",
            "disabled": False,
        },
        "alice": {
            "username": "alice",
            "full_name": "Alice Chains",
            "email": "alicechains@example.com",
            "hashed_password": "$argon2id$v=19$m=65536,t=3,p=4$g2/AV1zwopqUntPKJavBFw$BwpRGDCyUHLvHICnwijyX8ROGoiUPwNKZ7915MeYfCE",
            "disabled": True,
        },
    }
    
    
    class Token(BaseModel):
        access_token: str
        token_type: str
    
    
    class TokenData(BaseModel):
        username: str | None = None
        scopes: list[str] = []
    
    
    class User(BaseModel):
        username: str
        email: str | None = None
        full_name: str | None = None
        disabled: bool | None = None
    
    
    class UserInDB(User):
        hashed_password: str
    
    
    password_hash = PasswordHash.recommended()
    
    oauth2_scheme = OAuth2PasswordBearer(
        tokenUrl="token",
        scopes={"me": "Read information about the current user.", "items": "Read items."},
    )
    
    app = FastAPI()
    
    
    def verify_password(plain_password, hashed_password):
        return password_hash.verify(plain_password, hashed_password)
    
    
    def get_password_hash(password):
        return password_hash.hash(password)
    
    
    def get_user(db, username: str):
        if username in db:
            user_dict = db[username]
            return UserInDB(**user_dict)
    
    
    def authenticate_user(fake_db, username: str, password: str):
        user = get_user(fake_db, username)
        if not user:
            return False
        if not verify_password(password, user.hashed_password):
            return False
        return user
    
    
    def create_access_token(data: dict, expires_delta: timedelta | None = None):
        to_encode = data.copy()
        if expires_delta:
            expire = datetime.now(timezone.utc) + expires_delta
        else:
            expire = datetime.now(timezone.utc) + timedelta(minutes=15)
        to_encode.update({"exp": expire})
        encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
        return encoded_jwt
    
    
    async def get_current_user(
        security_scopes: SecurityScopes, token: str = Depends(oauth2_scheme)
    ):
        if security_scopes.scopes:
            authenticate_value = f'Bearer scope="{security_scopes.scope_str}"'
        else:
            authenticate_value = "Bearer"
        credentials_exception = HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Could not validate credentials",
            headers={"WWW-Authenticate": authenticate_value},
        )
        try:
            payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
            username: str = payload.get("sub")
            if username is None:
                raise credentials_exception
            scope: str = payload.get("scope", "")
            token_scopes = scope.split(" ")
            token_data = TokenData(scopes=token_scopes, username=username)
        except (InvalidTokenError, ValidationError):
            raise credentials_exception
        user = get_user(fake_users_db, username=token_data.username)
        if user is None:
            raise credentials_exception
        for scope in security_scopes.scopes:
            if scope not in token_data.scopes:
                raise HTTPException(
                    status_code=status.HTTP_401_UNAUTHORIZED,
                    detail="Not enough permissions",
                    headers={"WWW-Authenticate": authenticate_value},
                )
        return user
    
    
    async def get_current_active_user(
        current_user: User = Security(get_current_user, scopes=["me"]),
    ):
        if current_user.disabled:
            raise HTTPException(status_code=400, detail="Inactive user")
        return current_user
    
    
    @app.post("/token")
    async def login_for_access_token(
        form_data: OAuth2PasswordRequestForm = Depends(),
    ) -> Token:
        user = authenticate_user(fake_users_db, form_data.username, form_data.password)
        if not user:
            raise HTTPException(status_code=400, detail="Incorrect username or password")
        access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
        access_token = create_access_token(
            data={"sub": user.username, "scope": " ".join(form_data.scopes)},
            expires_delta=access_token_expires,
        )
        return Token(access_token=access_token, token_type="bearer")
    
    
    @app.get("/users/me/")
    async def read_users_me(current_user: User = Depends(get_current_active_user)) -> User:
        return current_user
    
    
    @app.get("/users/me/items/")
    async def read_own_items(
        current_user: User = Security(get_current_active_user, scopes=["items"]),
    ):
        return [{"item_id": "Foo", "owner": current_user.username}]
    
    
    @app.get("/status/")
    async def read_system_status(current_user: User = Depends(get_current_user)):
        return {"status": "ok"}
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from datetime import datetime, timedelta, timezone
    from typing import Union
    
    import jwt
    from fastapi import Depends, FastAPI, HTTPException, Security, status
    from fastapi.security import (
        OAuth2PasswordBearer,
        OAuth2PasswordRequestForm,
        SecurityScopes,
    )
    from jwt.exceptions import InvalidTokenError
    from pwdlib import PasswordHash
    from pydantic import BaseModel, ValidationError
    
    # to get a string like this run:
    # openssl rand -hex 32
    SECRET_KEY = "09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
    ALGORITHM = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES = 30
    
    
    fake_users_db = {
        "johndoe": {
            "username": "johndoe",
            "full_name": "John Doe",
            "email": "johndoe@example.com",
            "hashed_password": "$argon2id$v=19$m=65536,t=3,p=4$wagCPXjifgvUFBzq4hqe3w$CYaIb8sB+wtD+Vu/P4uod1+Qof8h+1g7bbDlBID48Rc",
            "disabled": False,
        },
        "alice": {
            "username": "alice",
            "full_name": "Alice Chains",
            "email": "alicechains@example.com",
            "hashed_password": "$argon2id$v=19$m=65536,t=3,p=4$g2/AV1zwopqUntPKJavBFw$BwpRGDCyUHLvHICnwijyX8ROGoiUPwNKZ7915MeYfCE",
            "disabled": True,
        },
    }
    
    
    class Token(BaseModel):
        access_token: str
        token_type: str
    
    
    class TokenData(BaseModel):
        username: Union[str, None] = None
        scopes: list[str] = []
    
    
    class User(BaseModel):
        username: str
        email: Union[str, None] = None
        full_name: Union[str, None] = None
        disabled: Union[bool, None] = None
    
    
    class UserInDB(User):
        hashed_password: str
    
    
    password_hash = PasswordHash.recommended()
    
    oauth2_scheme = OAuth2PasswordBearer(
        tokenUrl="token",
        scopes={"me": "Read information about the current user.", "items": "Read items."},
    )
    
    app = FastAPI()
    
    
    def verify_password(plain_password, hashed_password):
        return password_hash.verify(plain_password, hashed_password)
    
    
    def get_password_hash(password):
        return password_hash.hash(password)
    
    
    def get_user(db, username: str):
        if username in db:
            user_dict = db[username]
            return UserInDB(**user_dict)
    
    
    def authenticate_user(fake_db, username: str, password: str):
        user = get_user(fake_db, username)
        if not user:
            return False
        if not verify_password(password, user.hashed_password):
            return False
        return user
    
    
    def create_access_token(data: dict, expires_delta: Union[timedelta, None] = None):
        to_encode = data.copy()
        if expires_delta:
            expire = datetime.now(timezone.utc) + expires_delta
        else:
            expire = datetime.now(timezone.utc) + timedelta(minutes=15)
        to_encode.update({"exp": expire})
        encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
        return encoded_jwt
    
    
    async def get_current_user(
        security_scopes: SecurityScopes, token: str = Depends(oauth2_scheme)
    ):
        if security_scopes.scopes:
            authenticate_value = f'Bearer scope="{security_scopes.scope_str}"'
        else:
            authenticate_value = "Bearer"
        credentials_exception = HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Could not validate credentials",
            headers={"WWW-Authenticate": authenticate_value},
        )
        try:
            payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
            username: str = payload.get("sub")
            if username is None:
                raise credentials_exception
            scope: str = payload.get("scope", "")
            token_scopes = scope.split(" ")
            token_data = TokenData(scopes=token_scopes, username=username)
        except (InvalidTokenError, ValidationError):
            raise credentials_exception
        user = get_user(fake_users_db, username=token_data.username)
        if user is None:
            raise credentials_exception
        for scope in security_scopes.scopes:
            if scope not in token_data.scopes:
                raise HTTPException(
                    status_code=status.HTTP_401_UNAUTHORIZED,
                    detail="Not enough permissions",
                    headers={"WWW-Authenticate": authenticate_value},
                )
        return user
    
    
    async def get_current_active_user(
        current_user: User = Security(get_current_user, scopes=["me"]),
    ):
        if current_user.disabled:
            raise HTTPException(status_code=400, detail="Inactive user")
        return current_user
    
    
    @app.post("/token")
    async def login_for_access_token(
        form_data: OAuth2PasswordRequestForm = Depends(),
    ) -> Token:
        user = authenticate_user(fake_users_db, form_data.username, form_data.password)
        if not user:
            raise HTTPException(status_code=400, detail="Incorrect username or password")
        access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
        access_token = create_access_token(
            data={"sub": user.username, "scope": " ".join(form_data.scopes)},
            expires_delta=access_token_expires,
        )
        return Token(access_token=access_token, token_type="bearer")
    
    
    @app.get("/users/me/")
    async def read_users_me(current_user: User = Depends(get_current_active_user)) -> User:
        return current_user
    
    
    @app.get("/users/me/items/")
    async def read_own_items(
        current_user: User = Security(get_current_active_user, scopes=["items"]),
    ):
        return [{"item_id": "Foo", "owner": current_user.username}]
    
    
    @app.get("/status/")
    async def read_system_status(current_user: User = Depends(get_current_user)):
        return {"status": "ok"}
    

## Verify the `scopes`[¶](#verify-the-scopes "Permanent link")

We now verify that all the scopes required, by this dependency and all the dependants (including _path operations_), are included in the scopes provided in the token received, otherwise raise an `HTTPException`.

For this, we use `security_scopes.scopes`, that contains a `list` with all these scopes as `str`.

Python 3.10+
    
    
    from datetime import datetime, timedelta, timezone
    from typing import Annotated
    
    import jwt
    from fastapi import Depends, FastAPI, HTTPException, Security, status
    from fastapi.security import (
        OAuth2PasswordBearer,
        OAuth2PasswordRequestForm,
        SecurityScopes,
    )
    from jwt.exceptions import InvalidTokenError
    from pwdlib import PasswordHash
    from pydantic import BaseModel, ValidationError
    
    # to get a string like this run:
    # openssl rand -hex 32
    SECRET_KEY = "09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
    ALGORITHM = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES = 30
    
    
    fake_users_db = {
        "johndoe": {
            "username": "johndoe",
            "full_name": "John Doe",
            "email": "johndoe@example.com",
            "hashed_password": "$argon2id$v=19$m=65536,t=3,p=4$wagCPXjifgvUFBzq4hqe3w$CYaIb8sB+wtD+Vu/P4uod1+Qof8h+1g7bbDlBID48Rc",
            "disabled": False,
        },
        "alice": {
            "username": "alice",
            "full_name": "Alice Chains",
            "email": "alicechains@example.com",
            "hashed_password": "$argon2id$v=19$m=65536,t=3,p=4$g2/AV1zwopqUntPKJavBFw$BwpRGDCyUHLvHICnwijyX8ROGoiUPwNKZ7915MeYfCE",
            "disabled": True,
        },
    }
    
    
    class Token(BaseModel):
        access_token: str
        token_type: str
    
    
    class TokenData(BaseModel):
        username: str | None = None
        scopes: list[str] = []
    
    
    class User(BaseModel):
        username: str
        email: str | None = None
        full_name: str | None = None
        disabled: bool | None = None
    
    
    class UserInDB(User):
        hashed_password: str
    
    
    password_hash = PasswordHash.recommended()
    
    oauth2_scheme = OAuth2PasswordBearer(
        tokenUrl="token",
        scopes={"me": "Read information about the current user.", "items": "Read items."},
    )
    
    app = FastAPI()
    
    
    def verify_password(plain_password, hashed_password):
        return password_hash.verify(plain_password, hashed_password)
    
    
    def get_password_hash(password):
        return password_hash.hash(password)
    
    
    def get_user(db, username: str):
        if username in db:
            user_dict = db[username]
            return UserInDB(**user_dict)
    
    
    def authenticate_user(fake_db, username: str, password: str):
        user = get_user(fake_db, username)
        if not user:
            return False
        if not verify_password(password, user.hashed_password):
            return False
        return user
    
    
    def create_access_token(data: dict, expires_delta: timedelta | None = None):
        to_encode = data.copy()
        if expires_delta:
            expire = datetime.now(timezone.utc) + expires_delta
        else:
            expire = datetime.now(timezone.utc) + timedelta(minutes=15)
        to_encode.update({"exp": expire})
        encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
        return encoded_jwt
    
    
    async def get_current_user(
        security_scopes: SecurityScopes, token: Annotated[str, Depends(oauth2_scheme)]
    ):
        if security_scopes.scopes:
            authenticate_value = f'Bearer scope="{security_scopes.scope_str}"'
        else:
            authenticate_value = "Bearer"
        credentials_exception = HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Could not validate credentials",
            headers={"WWW-Authenticate": authenticate_value},
        )
        try:
            payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
            username = payload.get("sub")
            if username is None:
                raise credentials_exception
            scope: str = payload.get("scope", "")
            token_scopes = scope.split(" ")
            token_data = TokenData(scopes=token_scopes, username=username)
        except (InvalidTokenError, ValidationError):
            raise credentials_exception
        user = get_user(fake_users_db, username=token_data.username)
        if user is None:
            raise credentials_exception
        for scope in security_scopes.scopes:
            if scope not in token_data.scopes:
                raise HTTPException(
                    status_code=status.HTTP_401_UNAUTHORIZED,
                    detail="Not enough permissions",
                    headers={"WWW-Authenticate": authenticate_value},
                )
        return user
    
    
    async def get_current_active_user(
        current_user: Annotated[User, Security(get_current_user, scopes=["me"])],
    ):
        if current_user.disabled:
            raise HTTPException(status_code=400, detail="Inactive user")
        return current_user
    
    
    @app.post("/token")
    async def login_for_access_token(
        form_data: Annotated[OAuth2PasswordRequestForm, Depends()],
    ) -> Token:
        user = authenticate_user(fake_users_db, form_data.username, form_data.password)
        if not user:
            raise HTTPException(status_code=400, detail="Incorrect username or password")
        access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
        access_token = create_access_token(
            data={"sub": user.username, "scope": " ".join(form_data.scopes)},
            expires_delta=access_token_expires,
        )
        return Token(access_token=access_token, token_type="bearer")
    
    
    @app.get("/users/me/")
    async def read_users_me(
        current_user: Annotated[User, Depends(get_current_active_user)],
    ) -> User:
        return current_user
    
    
    @app.get("/users/me/items/")
    async def read_own_items(
        current_user: Annotated[User, Security(get_current_active_user, scopes=["items"])],
    ):
        return [{"item_id": "Foo", "owner": current_user.username}]
    
    
    @app.get("/status/")
    async def read_system_status(current_user: Annotated[User, Depends(get_current_user)]):
        return {"status": "ok"}
    

ü§ì Other versions and variants

Python 3.9+Python 3.10+ - non-AnnotatedPython 3.9+ - non-Annotated
    
    
    from datetime import datetime, timedelta, timezone
    from typing import Annotated, Union
    
    import jwt
    from fastapi import Depends, FastAPI, HTTPException, Security, status
    from fastapi.security import (
        OAuth2PasswordBearer,
        OAuth2PasswordRequestForm,
        SecurityScopes,
    )
    from jwt.exceptions import InvalidTokenError
    from pwdlib import PasswordHash
    from pydantic import BaseModel, ValidationError
    
    # to get a string like this run:
    # openssl rand -hex 32
    SECRET_KEY = "09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
    ALGORITHM = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES = 30
    
    
    fake_users_db = {
        "johndoe": {
            "username": "johndoe",
            "full_name": "John Doe",
            "email": "johndoe@example.com",
            "hashed_password": "$argon2id$v=19$m=65536,t=3,p=4$wagCPXjifgvUFBzq4hqe3w$CYaIb8sB+wtD+Vu/P4uod1+Qof8h+1g7bbDlBID48Rc",
            "disabled": False,
        },
        "alice": {
            "username": "alice",
            "full_name": "Alice Chains",
            "email": "alicechains@example.com",
            "hashed_password": "$argon2id$v=19$m=65536,t=3,p=4$g2/AV1zwopqUntPKJavBFw$BwpRGDCyUHLvHICnwijyX8ROGoiUPwNKZ7915MeYfCE",
            "disabled": True,
        },
    }
    
    
    class Token(BaseModel):
        access_token: str
        token_type: str
    
    
    class TokenData(BaseModel):
        username: Union[str, None] = None
        scopes: list[str] = []
    
    
    class User(BaseModel):
        username: str
        email: Union[str, None] = None
        full_name: Union[str, None] = None
        disabled: Union[bool, None] = None
    
    
    class UserInDB(User):
        hashed_password: str
    
    
    password_hash = PasswordHash.recommended()
    
    oauth2_scheme = OAuth2PasswordBearer(
        tokenUrl="token",
        scopes={"me": "Read information about the current user.", "items": "Read items."},
    )
    
    app = FastAPI()
    
    
    def verify_password(plain_password, hashed_password):
        return password_hash.verify(plain_password, hashed_password)
    
    
    def get_password_hash(password):
        return password_hash.hash(password)
    
    
    def get_user(db, username: str):
        if username in db:
            user_dict = db[username]
            return UserInDB(**user_dict)
    
    
    def authenticate_user(fake_db, username: str, password: str):
        user = get_user(fake_db, username)
        if not user:
            return False
        if not verify_password(password, user.hashed_password):
            return False
        return user
    
    
    def create_access_token(data: dict, expires_delta: Union[timedelta, None] = None):
        to_encode = data.copy()
        if expires_delta:
            expire = datetime.now(timezone.utc) + expires_delta
        else:
            expire = datetime.now(timezone.utc) + timedelta(minutes=15)
        to_encode.update({"exp": expire})
        encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
        return encoded_jwt
    
    
    async def get_current_user(
        security_scopes: SecurityScopes, token: Annotated[str, Depends(oauth2_scheme)]
    ):
        if security_scopes.scopes:
            authenticate_value = f'Bearer scope="{security_scopes.scope_str}"'
        else:
            authenticate_value = "Bearer"
        credentials_exception = HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Could not validate credentials",
            headers={"WWW-Authenticate": authenticate_value},
        )
        try:
            payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
            username = payload.get("sub")
            if username is None:
                raise credentials_exception
            scope: str = payload.get("scope", "")
            token_scopes = scope.split(" ")
            token_data = TokenData(scopes=token_scopes, username=username)
        except (InvalidTokenError, ValidationError):
            raise credentials_exception
        user = get_user(fake_users_db, username=token_data.username)
        if user is None:
            raise credentials_exception
        for scope in security_scopes.scopes:
            if scope not in token_data.scopes:
                raise HTTPException(
                    status_code=status.HTTP_401_UNAUTHORIZED,
                    detail="Not enough permissions",
                    headers={"WWW-Authenticate": authenticate_value},
                )
        return user
    
    
    async def get_current_active_user(
        current_user: Annotated[User, Security(get_current_user, scopes=["me"])],
    ):
        if current_user.disabled:
            raise HTTPException(status_code=400, detail="Inactive user")
        return current_user
    
    
    @app.post("/token")
    async def login_for_access_token(
        form_data: Annotated[OAuth2PasswordRequestForm, Depends()],
    ) -> Token:
        user = authenticate_user(fake_users_db, form_data.username, form_data.password)
        if not user:
            raise HTTPException(status_code=400, detail="Incorrect username or password")
        access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
        access_token = create_access_token(
            data={"sub": user.username, "scope": " ".join(form_data.scopes)},
            expires_delta=access_token_expires,
        )
        return Token(access_token=access_token, token_type="bearer")
    
    
    @app.get("/users/me/")
    async def read_users_me(
        current_user: Annotated[User, Depends(get_current_active_user)],
    ) -> User:
        return current_user
    
    
    @app.get("/users/me/items/")
    async def read_own_items(
        current_user: Annotated[User, Security(get_current_active_user, scopes=["items"])],
    ):
        return [{"item_id": "Foo", "owner": current_user.username}]
    
    
    @app.get("/status/")
    async def read_system_status(current_user: Annotated[User, Depends(get_current_user)]):
        return {"status": "ok"}
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from datetime import datetime, timedelta, timezone
    
    import jwt
    from fastapi import Depends, FastAPI, HTTPException, Security, status
    from fastapi.security import (
        OAuth2PasswordBearer,
        OAuth2PasswordRequestForm,
        SecurityScopes,
    )
    from jwt.exceptions import InvalidTokenError
    from pwdlib import PasswordHash
    from pydantic import BaseModel, ValidationError
    
    # to get a string like this run:
    # openssl rand -hex 32
    SECRET_KEY = "09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
    ALGORITHM = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES = 30
    
    
    fake_users_db = {
        "johndoe": {
            "username": "johndoe",
            "full_name": "John Doe",
            "email": "johndoe@example.com",
            "hashed_password": "$argon2id$v=19$m=65536,t=3,p=4$wagCPXjifgvUFBzq4hqe3w$CYaIb8sB+wtD+Vu/P4uod1+Qof8h+1g7bbDlBID48Rc",
            "disabled": False,
        },
        "alice": {
            "username": "alice",
            "full_name": "Alice Chains",
            "email": "alicechains@example.com",
            "hashed_password": "$argon2id$v=19$m=65536,t=3,p=4$g2/AV1zwopqUntPKJavBFw$BwpRGDCyUHLvHICnwijyX8ROGoiUPwNKZ7915MeYfCE",
            "disabled": True,
        },
    }
    
    
    class Token(BaseModel):
        access_token: str
        token_type: str
    
    
    class TokenData(BaseModel):
        username: str | None = None
        scopes: list[str] = []
    
    
    class User(BaseModel):
        username: str
        email: str | None = None
        full_name: str | None = None
        disabled: bool | None = None
    
    
    class UserInDB(User):
        hashed_password: str
    
    
    password_hash = PasswordHash.recommended()
    
    oauth2_scheme = OAuth2PasswordBearer(
        tokenUrl="token",
        scopes={"me": "Read information about the current user.", "items": "Read items."},
    )
    
    app = FastAPI()
    
    
    def verify_password(plain_password, hashed_password):
        return password_hash.verify(plain_password, hashed_password)
    
    
    def get_password_hash(password):
        return password_hash.hash(password)
    
    
    def get_user(db, username: str):
        if username in db:
            user_dict = db[username]
            return UserInDB(**user_dict)
    
    
    def authenticate_user(fake_db, username: str, password: str):
        user = get_user(fake_db, username)
        if not user:
            return False
        if not verify_password(password, user.hashed_password):
            return False
        return user
    
    
    def create_access_token(data: dict, expires_delta: timedelta | None = None):
        to_encode = data.copy()
        if expires_delta:
            expire = datetime.now(timezone.utc) + expires_delta
        else:
            expire = datetime.now(timezone.utc) + timedelta(minutes=15)
        to_encode.update({"exp": expire})
        encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
        return encoded_jwt
    
    
    async def get_current_user(
        security_scopes: SecurityScopes, token: str = Depends(oauth2_scheme)
    ):
        if security_scopes.scopes:
            authenticate_value = f'Bearer scope="{security_scopes.scope_str}"'
        else:
            authenticate_value = "Bearer"
        credentials_exception = HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Could not validate credentials",
            headers={"WWW-Authenticate": authenticate_value},
        )
        try:
            payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
            username: str = payload.get("sub")
            if username is None:
                raise credentials_exception
            scope: str = payload.get("scope", "")
            token_scopes = scope.split(" ")
            token_data = TokenData(scopes=token_scopes, username=username)
        except (InvalidTokenError, ValidationError):
            raise credentials_exception
        user = get_user(fake_users_db, username=token_data.username)
        if user is None:
            raise credentials_exception
        for scope in security_scopes.scopes:
            if scope not in token_data.scopes:
                raise HTTPException(
                    status_code=status.HTTP_401_UNAUTHORIZED,
                    detail="Not enough permissions",
                    headers={"WWW-Authenticate": authenticate_value},
                )
        return user
    
    
    async def get_current_active_user(
        current_user: User = Security(get_current_user, scopes=["me"]),
    ):
        if current_user.disabled:
            raise HTTPException(status_code=400, detail="Inactive user")
        return current_user
    
    
    @app.post("/token")
    async def login_for_access_token(
        form_data: OAuth2PasswordRequestForm = Depends(),
    ) -> Token:
        user = authenticate_user(fake_users_db, form_data.username, form_data.password)
        if not user:
            raise HTTPException(status_code=400, detail="Incorrect username or password")
        access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
        access_token = create_access_token(
            data={"sub": user.username, "scope": " ".join(form_data.scopes)},
            expires_delta=access_token_expires,
        )
        return Token(access_token=access_token, token_type="bearer")
    
    
    @app.get("/users/me/")
    async def read_users_me(current_user: User = Depends(get_current_active_user)) -> User:
        return current_user
    
    
    @app.get("/users/me/items/")
    async def read_own_items(
        current_user: User = Security(get_current_active_user, scopes=["items"]),
    ):
        return [{"item_id": "Foo", "owner": current_user.username}]
    
    
    @app.get("/status/")
    async def read_system_status(current_user: User = Depends(get_current_user)):
        return {"status": "ok"}
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from datetime import datetime, timedelta, timezone
    from typing import Union
    
    import jwt
    from fastapi import Depends, FastAPI, HTTPException, Security, status
    from fastapi.security import (
        OAuth2PasswordBearer,
        OAuth2PasswordRequestForm,
        SecurityScopes,
    )
    from jwt.exceptions import InvalidTokenError
    from pwdlib import PasswordHash
    from pydantic import BaseModel, ValidationError
    
    # to get a string like this run:
    # openssl rand -hex 32
    SECRET_KEY = "09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
    ALGORITHM = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES = 30
    
    
    fake_users_db = {
        "johndoe": {
            "username": "johndoe",
            "full_name": "John Doe",
            "email": "johndoe@example.com",
            "hashed_password": "$argon2id$v=19$m=65536,t=3,p=4$wagCPXjifgvUFBzq4hqe3w$CYaIb8sB+wtD+Vu/P4uod1+Qof8h+1g7bbDlBID48Rc",
            "disabled": False,
        },
        "alice": {
            "username": "alice",
            "full_name": "Alice Chains",
            "email": "alicechains@example.com",
            "hashed_password": "$argon2id$v=19$m=65536,t=3,p=4$g2/AV1zwopqUntPKJavBFw$BwpRGDCyUHLvHICnwijyX8ROGoiUPwNKZ7915MeYfCE",
            "disabled": True,
        },
    }
    
    
    class Token(BaseModel):
        access_token: str
        token_type: str
    
    
    class TokenData(BaseModel):
        username: Union[str, None] = None
        scopes: list[str] = []
    
    
    class User(BaseModel):
        username: str
        email: Union[str, None] = None
        full_name: Union[str, None] = None
        disabled: Union[bool, None] = None
    
    
    class UserInDB(User):
        hashed_password: str
    
    
    password_hash = PasswordHash.recommended()
    
    oauth2_scheme = OAuth2PasswordBearer(
        tokenUrl="token",
        scopes={"me": "Read information about the current user.", "items": "Read items."},
    )
    
    app = FastAPI()
    
    
    def verify_password(plain_password, hashed_password):
        return password_hash.verify(plain_password, hashed_password)
    
    
    def get_password_hash(password):
        return password_hash.hash(password)
    
    
    def get_user(db, username: str):
        if username in db:
            user_dict = db[username]
            return UserInDB(**user_dict)
    
    
    def authenticate_user(fake_db, username: str, password: str):
        user = get_user(fake_db, username)
        if not user:
            return False
        if not verify_password(password, user.hashed_password):
            return False
        return user
    
    
    def create_access_token(data: dict, expires_delta: Union[timedelta, None] = None):
        to_encode = data.copy()
        if expires_delta:
            expire = datetime.now(timezone.utc) + expires_delta
        else:
            expire = datetime.now(timezone.utc) + timedelta(minutes=15)
        to_encode.update({"exp": expire})
        encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
        return encoded_jwt
    
    
    async def get_current_user(
        security_scopes: SecurityScopes, token: str = Depends(oauth2_scheme)
    ):
        if security_scopes.scopes:
            authenticate_value = f'Bearer scope="{security_scopes.scope_str}"'
        else:
            authenticate_value = "Bearer"
        credentials_exception = HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Could not validate credentials",
            headers={"WWW-Authenticate": authenticate_value},
        )
        try:
            payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
            username: str = payload.get("sub")
            if username is None:
                raise credentials_exception
            scope: str = payload.get("scope", "")
            token_scopes = scope.split(" ")
            token_data = TokenData(scopes=token_scopes, username=username)
        except (InvalidTokenError, ValidationError):
            raise credentials_exception
        user = get_user(fake_users_db, username=token_data.username)
        if user is None:
            raise credentials_exception
        for scope in security_scopes.scopes:
            if scope not in token_data.scopes:
                raise HTTPException(
                    status_code=status.HTTP_401_UNAUTHORIZED,
                    detail="Not enough permissions",
                    headers={"WWW-Authenticate": authenticate_value},
                )
        return user
    
    
    async def get_current_active_user(
        current_user: User = Security(get_current_user, scopes=["me"]),
    ):
        if current_user.disabled:
            raise HTTPException(status_code=400, detail="Inactive user")
        return current_user
    
    
    @app.post("/token")
    async def login_for_access_token(
        form_data: OAuth2PasswordRequestForm = Depends(),
    ) -> Token:
        user = authenticate_user(fake_users_db, form_data.username, form_data.password)
        if not user:
            raise HTTPException(status_code=400, detail="Incorrect username or password")
        access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
        access_token = create_access_token(
            data={"sub": user.username, "scope": " ".join(form_data.scopes)},
            expires_delta=access_token_expires,
        )
        return Token(access_token=access_token, token_type="bearer")
    
    
    @app.get("/users/me/")
    async def read_users_me(current_user: User = Depends(get_current_active_user)) -> User:
        return current_user
    
    
    @app.get("/users/me/items/")
    async def read_own_items(
        current_user: User = Security(get_current_active_user, scopes=["items"]),
    ):
        return [{"item_id": "Foo", "owner": current_user.username}]
    
    
    @app.get("/status/")
    async def read_system_status(current_user: User = Depends(get_current_user)):
        return {"status": "ok"}
    

## Dependency tree and scopes[¶](#dependency-tree-and-scopes "Permanent link")

Let's review again this dependency tree and the scopes.

As the `get_current_active_user` dependency has as a sub-dependency on `get_current_user`, the scope `"me"` declared at `get_current_active_user` will be included in the list of required scopes in the `security_scopes.scopes` passed to `get_current_user`.

The _path operation_ itself also declares a scope, `"items"`, so this will also be in the list of `security_scopes.scopes` passed to `get_current_user`.

Here's how the hierarchy of dependencies and scopes looks like:

  * The _path operation_ `read_own_items` has:
    * Required scopes `["items"]` with the dependency:
    * `get_current_active_user`:
      * The dependency function `get_current_active_user` has:
        * Required scopes `["me"]` with the dependency:
        * `get_current_user`:
          * The dependency function `get_current_user` has:
            * No scopes required by itself.
            * A dependency using `oauth2_scheme`.
            * A `security_scopes` parameter of type `SecurityScopes`:
              * This `security_scopes` parameter has a property `scopes` with a `list` containing all these scopes declared above, so:
                * `security_scopes.scopes` will contain `["me", "items"]` for the _path operation_ `read_own_items`.
                * `security_scopes.scopes` will contain `["me"]` for the _path operation_ `read_users_me`, because it is declared in the dependency `get_current_active_user`.
                * `security_scopes.scopes` will contain `[]` (nothing) for the _path operation_ `read_system_status`, because it didn't declare any `Security` with `scopes`, and its dependency, `get_current_user`, doesn't declare any `scopes` either.

Tip

The important and "magic" thing here is that `get_current_user` will have a different list of `scopes` to check for each _path operation_.

All depending on the `scopes` declared in each _path operation_ and each dependency in the dependency tree for that specific _path operation_.

## More details about `SecurityScopes`[¶](#more-details-about-securityscopes "Permanent link")

You can use `SecurityScopes` at any point, and in multiple places, it doesn't have to be at the "root" dependency.

It will always have the security scopes declared in the current `Security` dependencies and all the dependants for **that specific** _path operation_ and **that specific** dependency tree.

Because the `SecurityScopes` will have all the scopes declared by dependants, you can use it to verify that a token has the required scopes in a central dependency function, and then declare different scope requirements in different _path operations_.

They will be checked independently for each _path operation_.

## Check it[¶](#check-it "Permanent link")

If you open the API docs, you can authenticate and specify which scopes you want to authorize.

![](/img/tutorial/security/image11.png)

If you don't select any scope, you will be "authenticated", but when you try to access `/users/me/` or `/users/me/items/` you will get an error saying that you don't have enough permissions. You will still be able to access `/status/`.

And if you select the scope `me` but not the scope `items`, you will be able to access `/users/me/` but not `/users/me/items/`.

That's what would happen to a third party application that tried to access one of these _path operations_ with a token provided by a user, depending on how many permissions the user gave the application.

## About third party integrations[¶](#about-third-party-integrations "Permanent link")

In this example we are using the OAuth2 "password" flow.

This is appropriate when we are logging in to our own application, probably with our own frontend.

Because we can trust it to receive the `username` and `password`, as we control it.

But if you are building an OAuth2 application that others would connect to (i.e., if you are building an authentication provider equivalent to Facebook, Google, GitHub, etc.) you should use one of the other flows.

The most common is the implicit flow.

The most secure is the code flow, but it's more complex to implement as it requires more steps. As it is more complex, many providers end up suggesting the implicit flow.

Note

It's common that each authentication provider names their flows in a different way, to make it part of their brand.

But in the end, they are implementing the same OAuth2 standard.

**FastAPI** includes utilities for all these OAuth2 authentication flows in `fastapi.security.oauth2`.

## `Security` in decorator `dependencies`[¶](#security-in-decorator-dependencies "Permanent link")

The same way you can define a `list` of `Depends` in the decorator's `dependencies` parameter (as explained in [Dependencies in path operation decorators](../../../tutorial/dependencies/dependencies-in-path-operation-decorators/)), you could also use `Security` with `scopes` there.

---

###### HTTP Basic Auth¶

# HTTP Basic Auth[¶](#http-basic-auth "Permanent link")

For the simplest cases, you can use HTTP Basic Auth.

In HTTP Basic Auth, the application expects a header that contains a username and a password.

If it doesn't receive it, it returns an HTTP 401 "Unauthorized" error.

And returns a header `WWW-Authenticate` with a value of `Basic`, and an optional `realm` parameter.

That tells the browser to show the integrated prompt for a username and password.

Then, when you type that username and password, the browser sends them in the header automatically.

## Simple HTTP Basic Auth[¶](#simple-http-basic-auth "Permanent link")

  * Import `HTTPBasic` and `HTTPBasicCredentials`.
  * Create a "`security` scheme" using `HTTPBasic`.
  * Use that `security` with a dependency in your _path operation_.
  * It returns an object of type `HTTPBasicCredentials`:
    * It contains the `username` and `password` sent.

Python 3.9+
    
    
    from typing import Annotated
    
    from fastapi import Depends, FastAPI
    from fastapi.security import HTTPBasic, HTTPBasicCredentials
    
    app = FastAPI()
    
    security = HTTPBasic()
    
    
    @app.get("/users/me")
    def read_current_user(credentials: Annotated[HTTPBasicCredentials, Depends(security)]):
        return {"username": credentials.username, "password": credentials.password}
    

ü§ì Other versions and variants

Python 3.9+ - non-Annotated

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import Depends, FastAPI
    from fastapi.security import HTTPBasic, HTTPBasicCredentials
    
    app = FastAPI()
    
    security = HTTPBasic()
    
    
    @app.get("/users/me")
    def read_current_user(credentials: HTTPBasicCredentials = Depends(security)):
        return {"username": credentials.username, "password": credentials.password}
    

When you try to open the URL for the first time (or click the "Execute" button in the docs) the browser will ask you for your username and password:

![](/img/tutorial/security/image12.png)

## Check the username[¶](#check-the-username "Permanent link")

Here's a more complete example.

Use a dependency to check if the username and password are correct.

For this, use the Python standard module [`secrets`](https://docs.python.org/3/library/secrets.html) to check the username and password.

`secrets.compare_digest()` needs to take `bytes` or a `str` that only contains ASCII characters (the ones in English), this means it wouldn't work with characters like `√°`, as in `Sebasti√°n`.

To handle that, we first convert the `username` and `password` to `bytes` encoding them with UTF-8.

Then we can use `secrets.compare_digest()` to ensure that `credentials.username` is `"stanleyjobson"`, and that `credentials.password` is `"swordfish"`.

Python 3.9+
    
    
    import secrets
    from typing import Annotated
    
    from fastapi import Depends, FastAPI, HTTPException, status
    from fastapi.security import HTTPBasic, HTTPBasicCredentials
    
    app = FastAPI()
    
    security = HTTPBasic()
    
    
    def get_current_username(
        credentials: Annotated[HTTPBasicCredentials, Depends(security)],
    ):
        current_username_bytes = credentials.username.encode("utf8")
        correct_username_bytes = b"stanleyjobson"
        is_correct_username = secrets.compare_digest(
            current_username_bytes, correct_username_bytes
        )
        current_password_bytes = credentials.password.encode("utf8")
        correct_password_bytes = b"swordfish"
        is_correct_password = secrets.compare_digest(
            current_password_bytes, correct_password_bytes
        )
        if not (is_correct_username and is_correct_password):
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Incorrect username or password",
                headers={"WWW-Authenticate": "Basic"},
            )
        return credentials.username
    
    
    @app.get("/users/me")
    def read_current_user(username: Annotated[str, Depends(get_current_username)]):
        return {"username": username}
    

ü§ì Other versions and variants

Python 3.9+ - non-Annotated

Tip

Prefer to use the `Annotated` version if possible.
    
    
    import secrets
    
    from fastapi import Depends, FastAPI, HTTPException, status
    from fastapi.security import HTTPBasic, HTTPBasicCredentials
    
    app = FastAPI()
    
    security = HTTPBasic()
    
    
    def get_current_username(credentials: HTTPBasicCredentials = Depends(security)):
        current_username_bytes = credentials.username.encode("utf8")
        correct_username_bytes = b"stanleyjobson"
        is_correct_username = secrets.compare_digest(
            current_username_bytes, correct_username_bytes
        )
        current_password_bytes = credentials.password.encode("utf8")
        correct_password_bytes = b"swordfish"
        is_correct_password = secrets.compare_digest(
            current_password_bytes, correct_password_bytes
        )
        if not (is_correct_username and is_correct_password):
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Incorrect username or password",
                headers={"WWW-Authenticate": "Basic"},
            )
        return credentials.username
    
    
    @app.get("/users/me")
    def read_current_user(username: str = Depends(get_current_username)):
        return {"username": username}
    

This would be similar to:
    
    
    if not (credentials.username == "stanleyjobson") or not (credentials.password == "swordfish"):
        # Return some error
        ...
    

But by using the `secrets.compare_digest()` it will be secure against a type of attacks called "timing attacks".

### Timing Attacks[¶](#timing-attacks "Permanent link")

But what's a "timing attack"?

Let's imagine some attackers are trying to guess the username and password.

And they send a request with a username `johndoe` and a password `love123`.

Then the Python code in your application would be equivalent to something like:
    
    
    if "johndoe" == "stanleyjobson" and "love123" == "swordfish":
        ...
    

But right at the moment Python compares the first `j` in `johndoe` to the first `s` in `stanleyjobson`, it will return `False`, because it already knows that those two strings are not the same, thinking that "there's no need to waste more computation comparing the rest of the letters". And your application will say "Incorrect username or password".

But then the attackers try with username `stanleyjobsox` and password `love123`.

And your application code does something like:
    
    
    if "stanleyjobsox" == "stanleyjobson" and "love123" == "swordfish":
        ...
    

Python will have to compare the whole `stanleyjobso` in both `stanleyjobsox` and `stanleyjobson` before realizing that both strings are not the same. So it will take some extra microseconds to reply back "Incorrect username or password".

#### The time to answer helps the attackers[¶](#the-time-to-answer-helps-the-attackers "Permanent link")

At that point, by noticing that the server took some microseconds longer to send the "Incorrect username or password" response, the attackers will know that they got _something_ right, some of the initial letters were right.

And then they can try again knowing that it's probably something more similar to `stanleyjobsox` than to `johndoe`.

#### A "professional" attack[¶](#a-professional-attack "Permanent link")

Of course, the attackers would not try all this by hand, they would write a program to do it, possibly with thousands or millions of tests per second. And they would get just one extra correct letter at a time.

But doing that, in some minutes or hours the attackers would have guessed the correct username and password, with the "help" of our application, just using the time taken to answer.

#### Fix it with `secrets.compare_digest()`[¶](#fix-it-with-secrets-compare-digest "Permanent link")

But in our code we are actually using `secrets.compare_digest()`.

In short, it will take the same time to compare `stanleyjobsox` to `stanleyjobson` than it takes to compare `johndoe` to `stanleyjobson`. And the same for the password.

That way, using `secrets.compare_digest()` in your application code, it will be safe against this whole range of security attacks.

### Return the error[¶](#return-the-error "Permanent link")

After detecting that the credentials are incorrect, return an `HTTPException` with a status code 401 (the same returned when no credentials are provided) and add the header `WWW-Authenticate` to make the browser show the login prompt again:

Python 3.9+
    
    
    import secrets
    from typing import Annotated
    
    from fastapi import Depends, FastAPI, HTTPException, status
    from fastapi.security import HTTPBasic, HTTPBasicCredentials
    
    app = FastAPI()
    
    security = HTTPBasic()
    
    
    def get_current_username(
        credentials: Annotated[HTTPBasicCredentials, Depends(security)],
    ):
        current_username_bytes = credentials.username.encode("utf8")
        correct_username_bytes = b"stanleyjobson"
        is_correct_username = secrets.compare_digest(
            current_username_bytes, correct_username_bytes
        )
        current_password_bytes = credentials.password.encode("utf8")
        correct_password_bytes = b"swordfish"
        is_correct_password = secrets.compare_digest(
            current_password_bytes, correct_password_bytes
        )
        if not (is_correct_username and is_correct_password):
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Incorrect username or password",
                headers={"WWW-Authenticate": "Basic"},
            )
        return credentials.username
    
    
    @app.get("/users/me")
    def read_current_user(username: Annotated[str, Depends(get_current_username)]):
        return {"username": username}
    

ü§ì Other versions and variants

Python 3.9+ - non-Annotated

Tip

Prefer to use the `Annotated` version if possible.
    
    
    import secrets
    
    from fastapi import Depends, FastAPI, HTTPException, status
    from fastapi.security import HTTPBasic, HTTPBasicCredentials
    
    app = FastAPI()
    
    security = HTTPBasic()
    
    
    def get_current_username(credentials: HTTPBasicCredentials = Depends(security)):
        current_username_bytes = credentials.username.encode("utf8")
        correct_username_bytes = b"stanleyjobson"
        is_correct_username = secrets.compare_digest(
            current_username_bytes, correct_username_bytes
        )
        current_password_bytes = credentials.password.encode("utf8")
        correct_password_bytes = b"swordfish"
        is_correct_password = secrets.compare_digest(
            current_password_bytes, correct_password_bytes
        )
        if not (is_correct_username and is_correct_password):
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Incorrect username or password",
                headers={"WWW-Authenticate": "Basic"},
            )
        return credentials.username
    
    
    @app.get("/users/me")
    def read_current_user(username: str = Depends(get_current_username)):
        return {"username": username}

---

###### Using the Request Directly¶

# Using the Request Directly[¶](#using-the-request-directly "Permanent link")

Up to now, you have been declaring the parts of the request that you need with their types.

Taking data from:

  * The path as parameters.
  * Headers.
  * Cookies.
  * etc.

And by doing so, **FastAPI** is validating that data, converting it and generating documentation for your API automatically.

But there are situations where you might need to access the `Request` object directly.

## Details about the `Request` object[¶](#details-about-the-request-object "Permanent link")

As **FastAPI** is actually **Starlette** underneath, with a layer of several tools on top, you can use Starlette's [`Request`](https://www.starlette.dev/requests/) object directly when you need to.

It would also mean that if you get data from the `Request` object directly (for example, read the body) it won't be validated, converted or documented (with OpenAPI, for the automatic API user interface) by FastAPI.

Although any other parameter declared normally (for example, the body with a Pydantic model) would still be validated, converted, annotated, etc.

But there are specific cases where it's useful to get the `Request` object.

## Use the `Request` object directly[¶](#use-the-request-object-directly "Permanent link")

Let's imagine you want to get the client's IP address/host inside of your _path operation function_.

For that you need to access the request directly.

Python 3.9+
    
    
    from fastapi import FastAPI, Request
    
    app = FastAPI()
    
    
    @app.get("/items/{item_id}")
    def read_root(item_id: str, request: Request):
        client_host = request.client.host
        return {"client_host": client_host, "item_id": item_id}
    

By declaring a _path operation function_ parameter with the type being the `Request` **FastAPI** will know to pass the `Request` in that parameter.

Tip

Note that in this case, we are declaring a path parameter beside the request parameter.

So, the path parameter will be extracted, validated, converted to the specified type and annotated with OpenAPI.

The same way, you can declare any other parameter as normally, and additionally, get the `Request` too.

## `Request` documentation[¶](#request-documentation "Permanent link")

You can read more details about the [`Request` object in the official Starlette documentation site](https://www.starlette.dev/requests/).

Technical Details

You could also use `from starlette.requests import Request`.

**FastAPI** provides it directly just as a convenience for you, the developer. But it comes directly from Starlette.

---

###### Using Dataclasses¶

# Using Dataclasses[¶](#using-dataclasses "Permanent link")

FastAPI is built on top of **Pydantic** , and I have been showing you how to use Pydantic models to declare requests and responses.

But FastAPI also supports using [`dataclasses`](https://docs.python.org/3/library/dataclasses.html) the same way:

Python 3.10+
    
    
    from dataclasses import dataclass
    
    from fastapi import FastAPI
    
    
    @dataclass
    class Item:
        name: str
        price: float
        description: str | None = None
        tax: float | None = None
    
    
    app = FastAPI()
    
    
    @app.post("/items/")
    async def create_item(item: Item):
        return item
    

ü§ì Other versions and variants

Python 3.9+
    
    
    from dataclasses import dataclass
    from typing import Union
    
    from fastapi import FastAPI
    
    
    @dataclass
    class Item:
        name: str
        price: float
        description: Union[str, None] = None
        tax: Union[float, None] = None
    
    
    app = FastAPI()
    
    
    @app.post("/items/")
    async def create_item(item: Item):
        return item
    

This is still supported thanks to **Pydantic** , as it has [internal support for `dataclasses`](https://docs.pydantic.dev/latest/concepts/dataclasses/#use-of-stdlib-dataclasses-with-basemodel).

So, even with the code above that doesn't use Pydantic explicitly, FastAPI is using Pydantic to convert those standard dataclasses to Pydantic's own flavor of dataclasses.

And of course, it supports the same:

  * data validation
  * data serialization
  * data documentation, etc.

This works the same way as with Pydantic models. And it is actually achieved in the same way underneath, using Pydantic.

Info

Keep in mind that dataclasses can't do everything Pydantic models can do.

So, you might still need to use Pydantic models.

But if you have a bunch of dataclasses laying around, this is a nice trick to use them to power a web API using FastAPI. ü§ì

## Dataclasses in `response_model`[¶](#dataclasses-in-response-model "Permanent link")

You can also use `dataclasses` in the `response_model` parameter:

Python 3.10+
    
    
    from dataclasses import dataclass, field
    
    from fastapi import FastAPI
    
    
    @dataclass
    class Item:
        name: str
        price: float
        tags: list[str] = field(default_factory=list)
        description: str | None = None
        tax: float | None = None
    
    
    app = FastAPI()
    
    
    @app.get("/items/next", response_model=Item)
    async def read_next_item():
        return {
            "name": "Island In The Moon",
            "price": 12.99,
            "description": "A place to be playin' and havin' fun",
            "tags": ["breater"],
        }
    

ü§ì Other versions and variants

Python 3.9+
    
    
    from dataclasses import dataclass, field
    from typing import Union
    
    from fastapi import FastAPI
    
    
    @dataclass
    class Item:
        name: str
        price: float
        tags: list[str] = field(default_factory=list)
        description: Union[str, None] = None
        tax: Union[float, None] = None
    
    
    app = FastAPI()
    
    
    @app.get("/items/next", response_model=Item)
    async def read_next_item():
        return {
            "name": "Island In The Moon",
            "price": 12.99,
            "description": "A place to be playin' and havin' fun",
            "tags": ["breater"],
        }
    

The dataclass will be automatically converted to a Pydantic dataclass.

This way, its schema will show up in the API docs user interface:

![](/img/tutorial/dataclasses/image01.png)

## Dataclasses in Nested Data Structures[¶](#dataclasses-in-nested-data-structures "Permanent link")

You can also combine `dataclasses` with other type annotations to make nested data structures.

In some cases, you might still have to use Pydantic's version of `dataclasses`. For example, if you have errors with the automatically generated API documentation.

In that case, you can simply swap the standard `dataclasses` with `pydantic.dataclasses`, which is a drop-in replacement:

Python 3.10+
    
    
    from dataclasses import field  # (1)
    
    from fastapi import FastAPI
    from pydantic.dataclasses import dataclass  # (2)
    
    
    @dataclass
    class Item:
        name: str
        description: str | None = None
    
    
    @dataclass
    class Author:
        name: str
        items: list[Item] = field(default_factory=list)  # (3)
    
    
    app = FastAPI()
    
    
    @app.post("/authors/{author_id}/items/", response_model=Author)  # (4)
    async def create_author_items(author_id: str, items: list[Item]):  # (5)
        return {"name": author_id, "items": items}  # (6)
    
    
    @app.get("/authors/", response_model=list[Author])  # (7)
    def get_authors():  # (8)
        return [  # (9)
            {
                "name": "Breaters",
                "items": [
                    {
                        "name": "Island In The Moon",
                        "description": "A place to be playin' and havin' fun",
                    },
                    {"name": "Holy Buddies"},
                ],
            },
            {
                "name": "System of an Up",
                "items": [
                    {
                        "name": "Salt",
                        "description": "The kombucha mushroom people's favorite",
                    },
                    {"name": "Pad Thai"},
                    {
                        "name": "Lonely Night",
                        "description": "The mostests lonliest nightiest of allest",
                    },
                ],
            },
        ]
    

ü§ì Other versions and variants

Python 3.9+
    
    
    from dataclasses import field  # (1)
    from typing import Union
    
    from fastapi import FastAPI
    from pydantic.dataclasses import dataclass  # (2)
    
    
    @dataclass
    class Item:
        name: str
        description: Union[str, None] = None
    
    
    @dataclass
    class Author:
        name: str
        items: list[Item] = field(default_factory=list)  # (3)
    
    
    app = FastAPI()
    
    
    @app.post("/authors/{author_id}/items/", response_model=Author)  # (4)
    async def create_author_items(author_id: str, items: list[Item]):  # (5)
        return {"name": author_id, "items": items}  # (6)
    
    
    @app.get("/authors/", response_model=list[Author])  # (7)
    def get_authors():  # (8)
        return [  # (9)
            {
                "name": "Breaters",
                "items": [
                    {
                        "name": "Island In The Moon",
                        "description": "A place to be playin' and havin' fun",
                    },
                    {"name": "Holy Buddies"},
                ],
            },
            {
                "name": "System of an Up",
                "items": [
                    {
                        "name": "Salt",
                        "description": "The kombucha mushroom people's favorite",
                    },
                    {"name": "Pad Thai"},
                    {
                        "name": "Lonely Night",
                        "description": "The mostests lonliest nightiest of allest",
                    },
                ],
            },
        ]
    

  1. We still import `field` from standard `dataclasses`.

  2. `pydantic.dataclasses` is a drop-in replacement for `dataclasses`.

  3. The `Author` dataclass includes a list of `Item` dataclasses.

  4. The `Author` dataclass is used as the `response_model` parameter.

  5. You can use other standard type annotations with dataclasses as the request body.

In this case, it's a list of `Item` dataclasses.

  6. Here we are returning a dictionary that contains `items` which is a list of dataclasses.

FastAPI is still capable of serializing the data to JSON.

  7. Here the `response_model` is using a type annotation of a list of `Author` dataclasses.

Again, you can combine `dataclasses` with standard type annotations.

  8. Notice that this _path operation function_ uses regular `def` instead of `async def`.

As always, in FastAPI you can combine `def` and `async def` as needed.

If you need a refresher about when to use which, check out the section _"In a hurry?"_ in the docs about [`async` and `await`](../../async/#in-a-hurry).

  9. This _path operation function_ is not returning dataclasses (although it could), but a list of dictionaries with internal data.

FastAPI will use the `response_model` parameter (that includes dataclasses) to convert the response.

You can combine `dataclasses` with other type annotations in many different combinations to form complex data structures.

Check the in-code annotation tips above to see more specific details.

## Learn More[¶](#learn-more "Permanent link")

You can also combine `dataclasses` with other Pydantic models, inherit from them, include them in your own models, etc.

To learn more, check the [Pydantic docs about dataclasses](https://docs.pydantic.dev/latest/concepts/dataclasses/).

## Version[¶](#version "Permanent link")

This is available since FastAPI version `0.67.0`. üîñ
  *[serializing]: converting the data to a format that can be transmitted

---

###### Advanced Middleware¶

# Advanced Middleware[¶](#advanced-middleware "Permanent link")

In the main tutorial you read how to add [Custom Middleware](../../tutorial/middleware/) to your application.

And then you also read how to handle [CORS with the `CORSMiddleware`](../../tutorial/cors/).

In this section we'll see how to use other middlewares.

## Adding ASGI middlewares[¶](#adding-asgi-middlewares "Permanent link")

As **FastAPI** is based on Starlette and implements the ASGI specification, you can use any ASGI middleware.

A middleware doesn't have to be made for FastAPI or Starlette to work, as long as it follows the ASGI spec.

In general, ASGI middlewares are classes that expect to receive an ASGI app as the first argument.

So, in the documentation for third-party ASGI middlewares they will probably tell you to do something like:
    
    
    from unicorn import UnicornMiddleware
    
    app = SomeASGIApp()
    
    new_app = UnicornMiddleware(app, some_config="rainbow")
    

But FastAPI (actually Starlette) provides a simpler way to do it that makes sure that the internal middlewares handle server errors and custom exception handlers work properly.

For that, you use `app.add_middleware()` (as in the example for CORS).
    
    
    from fastapi import FastAPI
    from unicorn import UnicornMiddleware
    
    app = FastAPI()
    
    app.add_middleware(UnicornMiddleware, some_config="rainbow")
    

`app.add_middleware()` receives a middleware class as the first argument and any additional arguments to be passed to the middleware.

## Integrated middlewares[¶](#integrated-middlewares "Permanent link")

**FastAPI** includes several middlewares for common use cases, we'll see next how to use them.

Technical Details

For the next examples, you could also use `from starlette.middleware.something import SomethingMiddleware`.

**FastAPI** provides several middlewares in `fastapi.middleware` just as a convenience for you, the developer. But most of the available middlewares come directly from Starlette.

## `HTTPSRedirectMiddleware`[¶](#httpsredirectmiddleware "Permanent link")

Enforces that all incoming requests must either be `https` or `wss`.

Any incoming request to `http` or `ws` will be redirected to the secure scheme instead.

Python 3.9+
    
    
    from fastapi import FastAPI
    from fastapi.middleware.httpsredirect import HTTPSRedirectMiddleware
    
    app = FastAPI()
    
    app.add_middleware(HTTPSRedirectMiddleware)
    
    
    @app.get("/")
    async def main():
        return {"message": "Hello World"}
    

## `TrustedHostMiddleware`[¶](#trustedhostmiddleware "Permanent link")

Enforces that all incoming requests have a correctly set `Host` header, in order to guard against HTTP Host Header attacks.

Python 3.9+
    
    
    from fastapi import FastAPI
    from fastapi.middleware.trustedhost import TrustedHostMiddleware
    
    app = FastAPI()
    
    app.add_middleware(
        TrustedHostMiddleware, allowed_hosts=["example.com", "*.example.com"]
    )
    
    
    @app.get("/")
    async def main():
        return {"message": "Hello World"}
    

The following arguments are supported:

  * `allowed_hosts` \- A list of domain names that should be allowed as hostnames. Wildcard domains such as `*.example.com` are supported for matching subdomains. To allow any hostname either use `allowed_hosts=["*"]` or omit the middleware.
  * `www_redirect` \- If set to True, requests to non-www versions of the allowed hosts will be redirected to their www counterparts. Defaults to `True`.

If an incoming request does not validate correctly then a `400` response will be sent.

## `GZipMiddleware`[¶](#gzipmiddleware "Permanent link")

Handles GZip responses for any request that includes `"gzip"` in the `Accept-Encoding` header.

The middleware will handle both standard and streaming responses.

Python 3.9+
    
    
    from fastapi import FastAPI
    from fastapi.middleware.gzip import GZipMiddleware
    
    app = FastAPI()
    
    app.add_middleware(GZipMiddleware, minimum_size=1000, compresslevel=5)
    
    
    @app.get("/")
    async def main():
        return "somebigcontent"
    

The following arguments are supported:

  * `minimum_size` \- Do not GZip responses that are smaller than this minimum size in bytes. Defaults to `500`.
  * `compresslevel` \- Used during GZip compression. It is an integer ranging from 1 to 9. Defaults to `9`. Lower value results in faster compression but larger file sizes, while higher value results in slower compression but smaller file sizes.

## Other middlewares[¶](#other-middlewares "Permanent link")

There are many other ASGI middlewares.

For example:

  * [Uvicorn's `ProxyHeadersMiddleware`](https://github.com/encode/uvicorn/blob/master/uvicorn/middleware/proxy_headers.py)
  * [MessagePack](https://github.com/florimondmanca/msgpack-asgi)

To see other available middlewares check [Starlette's Middleware docs](https://www.starlette.dev/middleware/) and the [ASGI Awesome List](https://github.com/florimondmanca/awesome-asgi).
  *[ASGI]: Asynchronous Server Gateway Interface

---

###### Sub Applications - Mounts¶

# Sub Applications - Mounts[¶](#sub-applications-mounts "Permanent link")

If you need to have two independent FastAPI applications, with their own independent OpenAPI and their own docs UIs, you can have a main app and "mount" one (or more) sub-application(s).

## Mounting a **FastAPI** application[¶](#mounting-a-fastapi-application "Permanent link")

"Mounting" means adding a completely "independent" application in a specific path, that then takes care of handling everything under that path, with the _path operations_ declared in that sub-application.

### Top-level application[¶](#top-level-application "Permanent link")

First, create the main, top-level, **FastAPI** application, and its _path operations_ :

Python 3.9+
    
    
    from fastapi import FastAPI
    
    app = FastAPI()
    
    
    @app.get("/app")
    def read_main():
        return {"message": "Hello World from main app"}
    
    
    subapi = FastAPI()
    
    
    @subapi.get("/sub")
    def read_sub():
        return {"message": "Hello World from sub API"}
    
    
    app.mount("/subapi", subapi)
    

### Sub-application[¶](#sub-application "Permanent link")

Then, create your sub-application, and its _path operations_.

This sub-application is just another standard FastAPI application, but this is the one that will be "mounted":

Python 3.9+
    
    
    from fastapi import FastAPI
    
    app = FastAPI()
    
    
    @app.get("/app")
    def read_main():
        return {"message": "Hello World from main app"}
    
    
    subapi = FastAPI()
    
    
    @subapi.get("/sub")
    def read_sub():
        return {"message": "Hello World from sub API"}
    
    
    app.mount("/subapi", subapi)
    

### Mount the sub-application[¶](#mount-the-sub-application "Permanent link")

In your top-level application, `app`, mount the sub-application, `subapi`.

In this case, it will be mounted at the path `/subapi`:

Python 3.9+
    
    
    from fastapi import FastAPI
    
    app = FastAPI()
    
    
    @app.get("/app")
    def read_main():
        return {"message": "Hello World from main app"}
    
    
    subapi = FastAPI()
    
    
    @subapi.get("/sub")
    def read_sub():
        return {"message": "Hello World from sub API"}
    
    
    app.mount("/subapi", subapi)
    

### Check the automatic API docs[¶](#check-the-automatic-api-docs "Permanent link")

Now, run the `fastapi` command with your file:
    
    
    $ fastapi dev main.py
    
    <span style="color: green;">INFO</span>:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
    

And open the docs at <http://127.0.0.1:8000/docs>.

You will see the automatic API docs for the main app, including only its own _path operations_ :

![](/img/tutorial/sub-applications/image01.png)

And then, open the docs for the sub-application, at <http://127.0.0.1:8000/subapi/docs>.

You will see the automatic API docs for the sub-application, including only its own _path operations_ , all under the correct sub-path prefix `/subapi`:

![](/img/tutorial/sub-applications/image02.png)

If you try interacting with any of the two user interfaces, they will work correctly, because the browser will be able to talk to each specific app or sub-app.

### Technical Details: `root_path`[¶](#technical-details-root-path "Permanent link")

When you mount a sub-application as described above, FastAPI will take care of communicating the mount path for the sub-application using a mechanism from the ASGI specification called a `root_path`.

That way, the sub-application will know to use that path prefix for the docs UI.

And the sub-application could also have its own mounted sub-applications and everything would work correctly, because FastAPI handles all these `root_path`s automatically.

You will learn more about the `root_path` and how to use it explicitly in the section about [Behind a Proxy](../behind-a-proxy/).

---

###### Behind a Proxy¶

# Behind a Proxy[¶](#behind-a-proxy "Permanent link")

In many situations, you would use a **proxy** like Traefik or Nginx in front of your FastAPI app.

These proxies could handle HTTPS certificates and other things.

## Proxy Forwarded Headers[¶](#proxy-forwarded-headers "Permanent link")

A **proxy** in front of your application would normally set some headers on the fly before sending the requests to your **server** to let the server know that the request was **forwarded** by the proxy, letting it know the original (public) URL, including the domain, that it is using HTTPS, etc.

The **server** program (for example **Uvicorn** via **FastAPI CLI**) is capable of interpreting these headers, and then passing that information to your application.

But for security, as the server doesn't know it is behind a trusted proxy, it won't interpret those headers.

Technical Details

The proxy headers are:

  * [X-Forwarded-For](https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/X-Forwarded-For)
  * [X-Forwarded-Proto](https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/X-Forwarded-Proto)
  * [X-Forwarded-Host](https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/X-Forwarded-Host)

### Enable Proxy Forwarded Headers[¶](#enable-proxy-forwarded-headers "Permanent link")

You can start FastAPI CLI with the _CLI Option_ `--forwarded-allow-ips` and pass the IP addresses that should be trusted to read those forwarded headers.

If you set it to `--forwarded-allow-ips="*"` it would trust all the incoming IPs.

If your **server** is behind a trusted **proxy** and only the proxy talks to it, this would make it accept whatever is the IP of that **proxy**.
    
    
    $ fastapi run --forwarded-allow-ips="*"
    
    <span style="color: green;">INFO</span>:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
    

### Redirects with HTTPS[¶](#redirects-with-https "Permanent link")

For example, let's say you define a _path operation_ `/items/`:

Python 3.9+
    
    
    from fastapi import FastAPI
    
    app = FastAPI()
    
    
    @app.get("/items/")
    def read_items():
        return ["plumbus", "portal gun"]
    

If the client tries to go to `/items`, by default, it would be redirected to `/items/`.

But before setting the _CLI Option_ `--forwarded-allow-ips` it could redirect to `http://localhost:8000/items/`.

But maybe your application is hosted at `https://mysuperapp.com`, and the redirection should be to `https://mysuperapp.com/items/`.

By setting `--proxy-headers` now FastAPI would be able to redirect to the right location. üòé
    
    
    https://mysuperapp.com/items/
    

Tip

If you want to learn more about HTTPS, check the guide [About HTTPS](../../deployment/https/).

### How Proxy Forwarded Headers Work[¶](#how-proxy-forwarded-headers-work "Permanent link")

Here's a visual representation of how the **proxy** adds forwarded headers between the client and the **application server** :
    
    
    sequenceDiagram
        participant Client
        participant Proxy as Proxy/Load Balancer
        participant Server as FastAPI Server
    
        Client->>Proxy: HTTPS Request<br/>Host: mysuperapp.com<br/>Path: /items
    
        Note over Proxy: Proxy adds forwarded headers
    
        Proxy->>Server: HTTP Request<br/>X-Forwarded-For: [client IP]<br/>X-Forwarded-Proto: https<br/>X-Forwarded-Host: mysuperapp.com<br/>Path: /items
    
        Note over Server: Server interprets headers<br/>(if --forwarded-allow-ips is set)
    
        Server->>Proxy: HTTP Response<br/>with correct HTTPS URLs
    
        Proxy->>Client: HTTPS Response

The **proxy** intercepts the original client request and adds the special _forwarded_ headers (`X-Forwarded-*`) before passing the request to the **application server**.

These headers preserve information about the original request that would otherwise be lost:

  * **X-Forwarded-For** : The original client's IP address
  * **X-Forwarded-Proto** : The original protocol (`https`)
  * **X-Forwarded-Host** : The original host (`mysuperapp.com`)

When **FastAPI CLI** is configured with `--forwarded-allow-ips`, it trusts these headers and uses them, for example to generate the correct URLs in redirects.

## Proxy with a stripped path prefix[¶](#proxy-with-a-stripped-path-prefix "Permanent link")

You could have a proxy that adds a path prefix to your application.

In these cases you can use `root_path` to configure your application.

The `root_path` is a mechanism provided by the ASGI specification (that FastAPI is built on, through Starlette).

The `root_path` is used to handle these specific cases.

And it's also used internally when mounting sub-applications.

Having a proxy with a stripped path prefix, in this case, means that you could declare a path at `/app` in your code, but then, you add a layer on top (the proxy) that would put your **FastAPI** application under a path like `/api/v1`.

In this case, the original path `/app` would actually be served at `/api/v1/app`.

Even though all your code is written assuming there's just `/app`.

Python 3.9+
    
    
    from fastapi import FastAPI, Request
    
    app = FastAPI()
    
    
    @app.get("/app")
    def read_main(request: Request):
        return {"message": "Hello World", "root_path": request.scope.get("root_path")}
    

And the proxy would be **"stripping"** the **path prefix** on the fly before transmitting the request to the app server (probably Uvicorn via FastAPI CLI), keeping your application convinced that it is being served at `/app`, so that you don't have to update all your code to include the prefix `/api/v1`.

Up to here, everything would work as normally.

But then, when you open the integrated docs UI (the frontend), it would expect to get the OpenAPI schema at `/openapi.json`, instead of `/api/v1/openapi.json`.

So, the frontend (that runs in the browser) would try to reach `/openapi.json` and wouldn't be able to get the OpenAPI schema.

Because we have a proxy with a path prefix of `/api/v1` for our app, the frontend needs to fetch the OpenAPI schema at `/api/v1/openapi.json`.
    
    
    graph LR
    
    browser("Browser")
    proxy["Proxy on http://0.0.0.0:9999/api/v1/app"]
    server["Server on http://127.0.0.1:8000/app"]
    
    browser --> proxy
    proxy --> server

Tip

The IP `0.0.0.0` is commonly used to mean that the program listens on all the IPs available in that machine/server.

The docs UI would also need the OpenAPI schema to declare that this API `server` is located at `/api/v1` (behind the proxy). For example:
    
    
    {
        "openapi": "3.1.0",
        // More stuff here
        "servers": [
            {
                "url": "/api/v1"
            }
        ],
        "paths": {
                // More stuff here
        }
    }
    

In this example, the "Proxy" could be something like **Traefik**. And the server would be something like FastAPI CLI with **Uvicorn** , running your FastAPI application.

### Providing the `root_path`[¶](#providing-the-root-path "Permanent link")

To achieve this, you can use the command line option `--root-path` like:
    
    
    $ fastapi run main.py --forwarded-allow-ips="*" --root-path /api/v1
    
    <span style="color: green;">INFO</span>:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
    

If you use Hypercorn, it also has the option `--root-path`.

Technical Details

The ASGI specification defines a `root_path` for this use case.

And the `--root-path` command line option provides that `root_path`.

### Checking the current `root_path`[¶](#checking-the-current-root-path "Permanent link")

You can get the current `root_path` used by your application for each request, it is part of the `scope` dictionary (that's part of the ASGI spec).

Here we are including it in the message just for demonstration purposes.

Python 3.9+
    
    
    from fastapi import FastAPI, Request
    
    app = FastAPI()
    
    
    @app.get("/app")
    def read_main(request: Request):
        return {"message": "Hello World", "root_path": request.scope.get("root_path")}
    

Then, if you start Uvicorn with:
    
    
    $ fastapi run main.py --forwarded-allow-ips="*" --root-path /api/v1
    
    <span style="color: green;">INFO</span>:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
    

The response would be something like:
    
    
    {
        "message": "Hello World",
        "root_path": "/api/v1"
    }
    

### Setting the `root_path` in the FastAPI app[¶](#setting-the-root-path-in-the-fastapi-app "Permanent link")

Alternatively, if you don't have a way to provide a command line option like `--root-path` or equivalent, you can set the `root_path` parameter when creating your FastAPI app:

Python 3.9+
    
    
    from fastapi import FastAPI, Request
    
    app = FastAPI(root_path="/api/v1")
    
    
    @app.get("/app")
    def read_main(request: Request):
        return {"message": "Hello World", "root_path": request.scope.get("root_path")}
    

Passing the `root_path` to `FastAPI` would be the equivalent of passing the `--root-path` command line option to Uvicorn or Hypercorn.

### About `root_path`[¶](#about-root-path "Permanent link")

Keep in mind that the server (Uvicorn) won't use that `root_path` for anything else than passing it to the app.

But if you go with your browser to <http://127.0.0.1:8000/app> you will see the normal response:
    
    
    {
        "message": "Hello World",
        "root_path": "/api/v1"
    }
    

So, it won't expect to be accessed at `http://127.0.0.1:8000/api/v1/app`.

Uvicorn will expect the proxy to access Uvicorn at `http://127.0.0.1:8000/app`, and then it would be the proxy's responsibility to add the extra `/api/v1` prefix on top.

## About proxies with a stripped path prefix[¶](#about-proxies-with-a-stripped-path-prefix "Permanent link")

Keep in mind that a proxy with stripped path prefix is only one of the ways to configure it.

Probably in many cases the default will be that the proxy doesn't have a stripped path prefix.

In a case like that (without a stripped path prefix), the proxy would listen on something like `https://myawesomeapp.com`, and then if the browser goes to `https://myawesomeapp.com/api/v1/app` and your server (e.g. Uvicorn) listens on `http://127.0.0.1:8000` the proxy (without a stripped path prefix) would access Uvicorn at the same path: `http://127.0.0.1:8000/api/v1/app`.

## Testing locally with Traefik[¶](#testing-locally-with-traefik "Permanent link")

You can easily run the experiment locally with a stripped path prefix using [Traefik](https://docs.traefik.io/).

[Download Traefik](https://github.com/containous/traefik/releases), it's a single binary, you can extract the compressed file and run it directly from the terminal.

Then create a file `traefik.toml` with:
    
    
    [entryPoints]
      [entryPoints.http]
        address = ":9999"
    
    [providers]
      [providers.file]
        filename = "routes.toml"
    

This tells Traefik to listen on port 9999 and to use another file `routes.toml`.

Tip

We are using port 9999 instead of the standard HTTP port 80 so that you don't have to run it with admin (`sudo`) privileges.

Now create that other file `routes.toml`:
    
    
    [http]
      [http.middlewares]
    
        [http.middlewares.api-stripprefix.stripPrefix]
          prefixes = ["/api/v1"]
    
      [http.routers]
    
        [http.routers.app-http]
          entryPoints = ["http"]
          service = "app"
          rule = "PathPrefix(`/api/v1`)"
          middlewares = ["api-stripprefix"]
    
      [http.services]
    
        [http.services.app]
          [http.services.app.loadBalancer]
            [[http.services.app.loadBalancer.servers]]
              url = "http://127.0.0.1:8000"
    

This file configures Traefik to use the path prefix `/api/v1`.

And then Traefik will redirect its requests to your Uvicorn running on `http://127.0.0.1:8000`.

Now start Traefik:
    
    
    $ ./traefik --configFile=traefik.toml
    
    INFO[0000] Configuration loaded from file: /home/user/awesomeapi/traefik.toml
    

And now start your app, using the `--root-path` option:
    
    
    $ fastapi run main.py --forwarded-allow-ips="*" --root-path /api/v1
    
    <span style="color: green;">INFO</span>:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
    

### Check the responses[¶](#check-the-responses "Permanent link")

Now, if you go to the URL with the port for Uvicorn: <http://127.0.0.1:8000/app>, you will see the normal response:
    
    
    {
        "message": "Hello World",
        "root_path": "/api/v1"
    }
    

Tip

Notice that even though you are accessing it at `http://127.0.0.1:8000/app` it shows the `root_path` of `/api/v1`, taken from the option `--root-path`.

And now open the URL with the port for Traefik, including the path prefix: <http://127.0.0.1:9999/api/v1/app>.

We get the same response:
    
    
    {
        "message": "Hello World",
        "root_path": "/api/v1"
    }
    

but this time at the URL with the prefix path provided by the proxy: `/api/v1`.

Of course, the idea here is that everyone would access the app through the proxy, so the version with the path prefix `/api/v1` is the "correct" one.

And the version without the path prefix (`http://127.0.0.1:8000/app`), provided by Uvicorn directly, would be exclusively for the _proxy_ (Traefik) to access it.

That demonstrates how the Proxy (Traefik) uses the path prefix and how the server (Uvicorn) uses the `root_path` from the option `--root-path`.

### Check the docs UI[¶](#check-the-docs-ui "Permanent link")

But here's the fun part. ‚ú®

The "official" way to access the app would be through the proxy with the path prefix that we defined. So, as we would expect, if you try the docs UI served by Uvicorn directly, without the path prefix in the URL, it won't work, because it expects to be accessed through the proxy.

You can check it at <http://127.0.0.1:8000/docs>:

![](/img/tutorial/behind-a-proxy/image01.png)

But if we access the docs UI at the "official" URL using the proxy with port `9999`, at `/api/v1/docs`, it works correctly! üéâ

You can check it at <http://127.0.0.1:9999/api/v1/docs>:

![](/img/tutorial/behind-a-proxy/image02.png)

Right as we wanted it. ‚úîÔ∏è

This is because FastAPI uses this `root_path` to create the default `server` in OpenAPI with the URL provided by `root_path`.

## Additional servers[¶](#additional-servers "Permanent link")

Warning

This is a more advanced use case. Feel free to skip it.

By default, **FastAPI** will create a `server` in the OpenAPI schema with the URL for the `root_path`.

But you can also provide other alternative `servers`, for example if you want _the same_ docs UI to interact with both a staging and a production environment.

If you pass a custom list of `servers` and there's a `root_path` (because your API lives behind a proxy), **FastAPI** will insert a "server" with this `root_path` at the beginning of the list.

For example:

Python 3.9+
    
    
    from fastapi import FastAPI, Request
    
    app = FastAPI(
        servers=[
            {"url": "https://stag.example.com", "description": "Staging environment"},
            {"url": "https://prod.example.com", "description": "Production environment"},
        ],
        root_path="/api/v1",
    )
    
    
    @app.get("/app")
    def read_main(request: Request):
        return {"message": "Hello World", "root_path": request.scope.get("root_path")}
    

Will generate an OpenAPI schema like:
    
    
    {
        "openapi": "3.1.0",
        // More stuff here
        "servers": [
            {
                "url": "/api/v1"
            },
            {
                "url": "https://stag.example.com",
                "description": "Staging environment"
            },
            {
                "url": "https://prod.example.com",
                "description": "Production environment"
            }
        ],
        "paths": {
                // More stuff here
        }
    }
    

Tip

Notice the auto-generated server with a `url` value of `/api/v1`, taken from the `root_path`.

In the docs UI at <http://127.0.0.1:9999/api/v1/docs> it would look like:

![](/img/tutorial/behind-a-proxy/image03.png)

Tip

The docs UI will interact with the server that you select.

Technical Details

The `servers` property in the OpenAPI specification is optional.

If you don't specify the `servers` parameter and `root_path` is equal to `/`, the `servers` property in the generated OpenAPI schema will be omitted entirely by default, which is the equivalent of a single server with a `url` value of `/`.

### Disable automatic server from `root_path`[¶](#disable-automatic-server-from-root-path "Permanent link")

If you don't want **FastAPI** to include an automatic server using the `root_path`, you can use the parameter `root_path_in_servers=False`:

Python 3.9+
    
    
    from fastapi import FastAPI, Request
    
    app = FastAPI(
        servers=[
            {"url": "https://stag.example.com", "description": "Staging environment"},
            {"url": "https://prod.example.com", "description": "Production environment"},
        ],
        root_path="/api/v1",
        root_path_in_servers=False,
    )
    
    
    @app.get("/app")
    def read_main(request: Request):
        return {"message": "Hello World", "root_path": request.scope.get("root_path")}
    

and then it won't include it in the OpenAPI schema.

## Mounting a sub-application[¶](#mounting-a-sub-application "Permanent link")

If you need to mount a sub-application (as described in [Sub Applications - Mounts](../sub-applications/)) while also using a proxy with `root_path`, you can do it normally, as you would expect.

FastAPI will internally use the `root_path` smartly, so it will just work. ‚ú®

---

###### Templates¶

# Templates[¶](#templates "Permanent link")

You can use any template engine you want with **FastAPI**.

A common choice is Jinja2, the same one used by Flask and other tools.

There are utilities to configure it easily that you can use directly in your **FastAPI** application (provided by Starlette).

## Install dependencies[¶](#install-dependencies "Permanent link")

Make sure you create a [virtual environment](../../virtual-environments/), activate it, and install `jinja2`:
    
    
    $ pip install jinja2
    
    ---> 100%
    

## Using `Jinja2Templates`[¶](#using-jinja2templates "Permanent link")

  * Import `Jinja2Templates`.
  * Create a `templates` object that you can reuse later.
  * Declare a `Request` parameter in the _path operation_ that will return a template.
  * Use the `templates` you created to render and return a `TemplateResponse`, pass the name of the template, the request object, and a "context" dictionary with key-value pairs to be used inside of the Jinja2 template.

Python 3.9+
    
    
    from fastapi import FastAPI, Request
    from fastapi.responses import HTMLResponse
    from fastapi.staticfiles import StaticFiles
    from fastapi.templating import Jinja2Templates
    
    app = FastAPI()
    
    app.mount("/static", StaticFiles(directory="static"), name="static")
    
    
    templates = Jinja2Templates(directory="templates")
    
    
    @app.get("/items/{id}", response_class=HTMLResponse)
    async def read_item(request: Request, id: str):
        return templates.TemplateResponse(
            request=request, name="item.html", context={"id": id}
        )
    

Note

Before FastAPI 0.108.0, Starlette 0.29.0, the `name` was the first parameter.

Also, before that, in previous versions, the `request` object was passed as part of the key-value pairs in the context for Jinja2.

Tip

By declaring `response_class=HTMLResponse` the docs UI will be able to know that the response will be HTML.

Technical Details

You could also use `from starlette.templating import Jinja2Templates`.

**FastAPI** provides the same `starlette.templating` as `fastapi.templating` just as a convenience for you, the developer. But most of the available responses come directly from Starlette. The same with `Request` and `StaticFiles`.

## Writing templates[¶](#writing-templates "Permanent link")

Then you can write a template at `templates/item.html` with, for example:
    
    
    <html>
    <head>
        <title>Item Details</title>
        <link href="{{ url_for('static', path='/styles.css') }}" rel="stylesheet">
    </head>
    <body>
        <h1><a href="{{ url_for('read_item', id=id) }}">Item ID: {{ id }}</a></h1>
    </body>
    </html>
    

### Template Context Values[¶](#template-context-values "Permanent link")

In the HTML that contains:
    
    
    Item ID: {{ id }}
    

...it will show the `id` taken from the "context" `dict` you passed:
    
    
    {"id": id}
    

For example, with an ID of `42`, this would render:
    
    
    Item ID: 42
    

### Template `url_for` Arguments[¶](#template-url-for-arguments "Permanent link")

You can also use `url_for()` inside of the template, it takes as arguments the same arguments that would be used by your _path operation function_.

So, the section with:
    
    
    <a href="{{ url_for('read_item', id=id) }}">
    

...will generate a link to the same URL that would be handled by the _path operation function_ `read_item(id=id)`.

For example, with an ID of `42`, this would render:
    
    
    <a href="/items/42">
    

## Templates and static files[¶](#templates-and-static-files "Permanent link")

You can also use `url_for()` inside of the template, and use it, for example, with the `StaticFiles` you mounted with the `name="static"`.
    
    
    <html>
    <head>
        <title>Item Details</title>
        <link href="{{ url_for('static', path='/styles.css') }}" rel="stylesheet">
    </head>
    <body>
        <h1><a href="{{ url_for('read_item', id=id) }}">Item ID: {{ id }}</a></h1>
    </body>
    </html>
    

In this example, it would link to a CSS file at `static/styles.css` with:
    
    
    h1 {
        color: green;
    }
    

And because you are using `StaticFiles`, that CSS file would be served automatically by your **FastAPI** application at the URL `/static/styles.css`.

## More details[¶](#more-details "Permanent link")

For more details, including how to test templates, check [Starlette's docs on templates](https://www.starlette.dev/templates/).

---

###### WebSockets¶

# WebSockets[¶](#websockets "Permanent link")

You can use [WebSockets](https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API) with **FastAPI**.

## Install `websockets`[¶](#install-websockets "Permanent link")

Make sure you create a [virtual environment](../../virtual-environments/), activate it, and install `websockets` (a Python library that makes it easy to use the "WebSocket" protocol):
    
    
    $ pip install websockets
    
    ---> 100%
    

## WebSockets client[¶](#websockets-client "Permanent link")

### In production[¶](#in-production "Permanent link")

In your production system, you probably have a frontend created with a modern framework like React, Vue.js or Angular.

And to communicate using WebSockets with your backend you would probably use your frontend's utilities.

Or you might have a native mobile application that communicates with your WebSocket backend directly, in native code.

Or you might have any other way to communicate with the WebSocket endpoint.

* * *

But for this example, we'll use a very simple HTML document with some JavaScript, all inside a long string.

This, of course, is not optimal and you wouldn't use it for production.

In production you would have one of the options above.

But it's the simplest way to focus on the server-side of WebSockets and have a working example:

Python 3.9+
    
    
    from fastapi import FastAPI, WebSocket
    from fastapi.responses import HTMLResponse
    
    app = FastAPI()
    
    html = """
    <!DOCTYPE html>
    <html>
        <head>
            <title>Chat</title>
        </head>
        <body>
            <h1>WebSocket Chat</h1>
            <form action="" onsubmit="sendMessage(event)">
                <input type="text" id="messageText" autocomplete="off"/>
                <button>Send</button>
            </form>
            <ul id='messages'>
            </ul>
            <script>
                var ws = new WebSocket("ws://localhost:8000/ws");
                ws.onmessage = function(event) {
                    var messages = document.getElementById('messages')
                    var message = document.createElement('li')
                    var content = document.createTextNode(event.data)
                    message.appendChild(content)
                    messages.appendChild(message)
                };
                function sendMessage(event) {
                    var input = document.getElementById("messageText")
                    ws.send(input.value)
                    input.value = ''
                    event.preventDefault()
                }
            </script>
        </body>
    </html>
    """
    
    
    @app.get("/")
    async def get():
        return HTMLResponse(html)
    
    
    @app.websocket("/ws")
    async def websocket_endpoint(websocket: WebSocket):
        await websocket.accept()
        while True:
            data = await websocket.receive_text()
            await websocket.send_text(f"Message text was: {data}")
    

## Create a `websocket`[¶](#create-a-websocket "Permanent link")

In your **FastAPI** application, create a `websocket`:

Python 3.9+
    
    
    from fastapi import FastAPI, WebSocket
    from fastapi.responses import HTMLResponse
    
    app = FastAPI()
    
    html = """
    <!DOCTYPE html>
    <html>
        <head>
            <title>Chat</title>
        </head>
        <body>
            <h1>WebSocket Chat</h1>
            <form action="" onsubmit="sendMessage(event)">
                <input type="text" id="messageText" autocomplete="off"/>
                <button>Send</button>
            </form>
            <ul id='messages'>
            </ul>
            <script>
                var ws = new WebSocket("ws://localhost:8000/ws");
                ws.onmessage = function(event) {
                    var messages = document.getElementById('messages')
                    var message = document.createElement('li')
                    var content = document.createTextNode(event.data)
                    message.appendChild(content)
                    messages.appendChild(message)
                };
                function sendMessage(event) {
                    var input = document.getElementById("messageText")
                    ws.send(input.value)
                    input.value = ''
                    event.preventDefault()
                }
            </script>
        </body>
    </html>
    """
    
    
    @app.get("/")
    async def get():
        return HTMLResponse(html)
    
    
    @app.websocket("/ws")
    async def websocket_endpoint(websocket: WebSocket):
        await websocket.accept()
        while True:
            data = await websocket.receive_text()
            await websocket.send_text(f"Message text was: {data}")
    

Technical Details

You could also use `from starlette.websockets import WebSocket`.

**FastAPI** provides the same `WebSocket` directly just as a convenience for you, the developer. But it comes directly from Starlette.

## Await for messages and send messages[¶](#await-for-messages-and-send-messages "Permanent link")

In your WebSocket route you can `await` for messages and send messages.

Python 3.9+
    
    
    from fastapi import FastAPI, WebSocket
    from fastapi.responses import HTMLResponse
    
    app = FastAPI()
    
    html = """
    <!DOCTYPE html>
    <html>
        <head>
            <title>Chat</title>
        </head>
        <body>
            <h1>WebSocket Chat</h1>
            <form action="" onsubmit="sendMessage(event)">
                <input type="text" id="messageText" autocomplete="off"/>
                <button>Send</button>
            </form>
            <ul id='messages'>
            </ul>
            <script>
                var ws = new WebSocket("ws://localhost:8000/ws");
                ws.onmessage = function(event) {
                    var messages = document.getElementById('messages')
                    var message = document.createElement('li')
                    var content = document.createTextNode(event.data)
                    message.appendChild(content)
                    messages.appendChild(message)
                };
                function sendMessage(event) {
                    var input = document.getElementById("messageText")
                    ws.send(input.value)
                    input.value = ''
                    event.preventDefault()
                }
            </script>
        </body>
    </html>
    """
    
    
    @app.get("/")
    async def get():
        return HTMLResponse(html)
    
    
    @app.websocket("/ws")
    async def websocket_endpoint(websocket: WebSocket):
        await websocket.accept()
        while True:
            data = await websocket.receive_text()
            await websocket.send_text(f"Message text was: {data}")
    

You can receive and send binary, text, and JSON data.

## Try it[¶](#try-it "Permanent link")

If your file is named `main.py`, run your application with:
    
    
    $ fastapi dev main.py
    
    <span style="color: green;">INFO</span>:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
    

Open your browser at <http://127.0.0.1:8000>.

You will see a simple page like:

![](/img/tutorial/websockets/image01.png)

You can type messages in the input box, and send them:

![](/img/tutorial/websockets/image02.png)

And your **FastAPI** application with WebSockets will respond back:

![](/img/tutorial/websockets/image03.png)

You can send (and receive) many messages:

![](/img/tutorial/websockets/image04.png)

And all of them will use the same WebSocket connection.

## Using `Depends` and others[¶](#using-depends-and-others "Permanent link")

In WebSocket endpoints you can import from `fastapi` and use:

  * `Depends`
  * `Security`
  * `Cookie`
  * `Header`
  * `Path`
  * `Query`

They work the same way as for other FastAPI endpoints/_path operations_ :

Python 3.10+
    
    
    from typing import Annotated
    
    from fastapi import (
        Cookie,
        Depends,
        FastAPI,
        Query,
        WebSocket,
        WebSocketException,
        status,
    )
    from fastapi.responses import HTMLResponse
    
    app = FastAPI()
    
    html = """
    <!DOCTYPE html>
    <html>
        <head>
            <title>Chat</title>
        </head>
        <body>
            <h1>WebSocket Chat</h1>
            <form action="" onsubmit="sendMessage(event)">
                <label>Item ID: <input type="text" id="itemId" autocomplete="off" value="foo"/></label>
                <label>Token: <input type="text" id="token" autocomplete="off" value="some-key-token"/></label>
                <button onclick="connect(event)">Connect</button>
                <hr>
                <label>Message: <input type="text" id="messageText" autocomplete="off"/></label>
                <button>Send</button>
            </form>
            <ul id='messages'>
            </ul>
            <script>
            var ws = null;
                function connect(event) {
                    var itemId = document.getElementById("itemId")
                    var token = document.getElementById("token")
                    ws = new WebSocket("ws://localhost:8000/items/" + itemId.value + "/ws?token=" + token.value);
                    ws.onmessage = function(event) {
                        var messages = document.getElementById('messages')
                        var message = document.createElement('li')
                        var content = document.createTextNode(event.data)
                        message.appendChild(content)
                        messages.appendChild(message)
                    };
                    event.preventDefault()
                }
                function sendMessage(event) {
                    var input = document.getElementById("messageText")
                    ws.send(input.value)
                    input.value = ''
                    event.preventDefault()
                }
            </script>
        </body>
    </html>
    """
    
    
    @app.get("/")
    async def get():
        return HTMLResponse(html)
    
    
    async def get_cookie_or_token(
        websocket: WebSocket,
        session: Annotated[str | None, Cookie()] = None,
        token: Annotated[str | None, Query()] = None,
    ):
        if session is None and token is None:
            raise WebSocketException(code=status.WS_1008_POLICY_VIOLATION)
        return session or token
    
    
    @app.websocket("/items/{item_id}/ws")
    async def websocket_endpoint(
        *,
        websocket: WebSocket,
        item_id: str,
        q: int | None = None,
        cookie_or_token: Annotated[str, Depends(get_cookie_or_token)],
    ):
        await websocket.accept()
        while True:
            data = await websocket.receive_text()
            await websocket.send_text(
                f"Session cookie or query token value is: {cookie_or_token}"
            )
            if q is not None:
                await websocket.send_text(f"Query parameter q is: {q}")
            await websocket.send_text(f"Message text was: {data}, for item ID: {item_id}")
    

ü§ì Other versions and variants

Python 3.9+Python 3.10+ - non-AnnotatedPython 3.9+ - non-Annotated
    
    
    from typing import Annotated, Union
    
    from fastapi import (
        Cookie,
        Depends,
        FastAPI,
        Query,
        WebSocket,
        WebSocketException,
        status,
    )
    from fastapi.responses import HTMLResponse
    
    app = FastAPI()
    
    html = """
    <!DOCTYPE html>
    <html>
        <head>
            <title>Chat</title>
        </head>
        <body>
            <h1>WebSocket Chat</h1>
            <form action="" onsubmit="sendMessage(event)">
                <label>Item ID: <input type="text" id="itemId" autocomplete="off" value="foo"/></label>
                <label>Token: <input type="text" id="token" autocomplete="off" value="some-key-token"/></label>
                <button onclick="connect(event)">Connect</button>
                <hr>
                <label>Message: <input type="text" id="messageText" autocomplete="off"/></label>
                <button>Send</button>
            </form>
            <ul id='messages'>
            </ul>
            <script>
            var ws = null;
                function connect(event) {
                    var itemId = document.getElementById("itemId")
                    var token = document.getElementById("token")
                    ws = new WebSocket("ws://localhost:8000/items/" + itemId.value + "/ws?token=" + token.value);
                    ws.onmessage = function(event) {
                        var messages = document.getElementById('messages')
                        var message = document.createElement('li')
                        var content = document.createTextNode(event.data)
                        message.appendChild(content)
                        messages.appendChild(message)
                    };
                    event.preventDefault()
                }
                function sendMessage(event) {
                    var input = document.getElementById("messageText")
                    ws.send(input.value)
                    input.value = ''
                    event.preventDefault()
                }
            </script>
        </body>
    </html>
    """
    
    
    @app.get("/")
    async def get():
        return HTMLResponse(html)
    
    
    async def get_cookie_or_token(
        websocket: WebSocket,
        session: Annotated[Union[str, None], Cookie()] = None,
        token: Annotated[Union[str, None], Query()] = None,
    ):
        if session is None and token is None:
            raise WebSocketException(code=status.WS_1008_POLICY_VIOLATION)
        return session or token
    
    
    @app.websocket("/items/{item_id}/ws")
    async def websocket_endpoint(
        *,
        websocket: WebSocket,
        item_id: str,
        q: Union[int, None] = None,
        cookie_or_token: Annotated[str, Depends(get_cookie_or_token)],
    ):
        await websocket.accept()
        while True:
            data = await websocket.receive_text()
            await websocket.send_text(
                f"Session cookie or query token value is: {cookie_or_token}"
            )
            if q is not None:
                await websocket.send_text(f"Query parameter q is: {q}")
            await websocket.send_text(f"Message text was: {data}, for item ID: {item_id}")
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import (
        Cookie,
        Depends,
        FastAPI,
        Query,
        WebSocket,
        WebSocketException,
        status,
    )
    from fastapi.responses import HTMLResponse
    
    app = FastAPI()
    
    html = """
    <!DOCTYPE html>
    <html>
        <head>
            <title>Chat</title>
        </head>
        <body>
            <h1>WebSocket Chat</h1>
            <form action="" onsubmit="sendMessage(event)">
                <label>Item ID: <input type="text" id="itemId" autocomplete="off" value="foo"/></label>
                <label>Token: <input type="text" id="token" autocomplete="off" value="some-key-token"/></label>
                <button onclick="connect(event)">Connect</button>
                <hr>
                <label>Message: <input type="text" id="messageText" autocomplete="off"/></label>
                <button>Send</button>
            </form>
            <ul id='messages'>
            </ul>
            <script>
            var ws = null;
                function connect(event) {
                    var itemId = document.getElementById("itemId")
                    var token = document.getElementById("token")
                    ws = new WebSocket("ws://localhost:8000/items/" + itemId.value + "/ws?token=" + token.value);
                    ws.onmessage = function(event) {
                        var messages = document.getElementById('messages')
                        var message = document.createElement('li')
                        var content = document.createTextNode(event.data)
                        message.appendChild(content)
                        messages.appendChild(message)
                    };
                    event.preventDefault()
                }
                function sendMessage(event) {
                    var input = document.getElementById("messageText")
                    ws.send(input.value)
                    input.value = ''
                    event.preventDefault()
                }
            </script>
        </body>
    </html>
    """
    
    
    @app.get("/")
    async def get():
        return HTMLResponse(html)
    
    
    async def get_cookie_or_token(
        websocket: WebSocket,
        session: str | None = Cookie(default=None),
        token: str | None = Query(default=None),
    ):
        if session is None and token is None:
            raise WebSocketException(code=status.WS_1008_POLICY_VIOLATION)
        return session or token
    
    
    @app.websocket("/items/{item_id}/ws")
    async def websocket_endpoint(
        websocket: WebSocket,
        item_id: str,
        q: int | None = None,
        cookie_or_token: str = Depends(get_cookie_or_token),
    ):
        await websocket.accept()
        while True:
            data = await websocket.receive_text()
            await websocket.send_text(
                f"Session cookie or query token value is: {cookie_or_token}"
            )
            if q is not None:
                await websocket.send_text(f"Query parameter q is: {q}")
            await websocket.send_text(f"Message text was: {data}, for item ID: {item_id}")
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from typing import Union
    
    from fastapi import (
        Cookie,
        Depends,
        FastAPI,
        Query,
        WebSocket,
        WebSocketException,
        status,
    )
    from fastapi.responses import HTMLResponse
    
    app = FastAPI()
    
    html = """
    <!DOCTYPE html>
    <html>
        <head>
            <title>Chat</title>
        </head>
        <body>
            <h1>WebSocket Chat</h1>
            <form action="" onsubmit="sendMessage(event)">
                <label>Item ID: <input type="text" id="itemId" autocomplete="off" value="foo"/></label>
                <label>Token: <input type="text" id="token" autocomplete="off" value="some-key-token"/></label>
                <button onclick="connect(event)">Connect</button>
                <hr>
                <label>Message: <input type="text" id="messageText" autocomplete="off"/></label>
                <button>Send</button>
            </form>
            <ul id='messages'>
            </ul>
            <script>
            var ws = null;
                function connect(event) {
                    var itemId = document.getElementById("itemId")
                    var token = document.getElementById("token")
                    ws = new WebSocket("ws://localhost:8000/items/" + itemId.value + "/ws?token=" + token.value);
                    ws.onmessage = function(event) {
                        var messages = document.getElementById('messages')
                        var message = document.createElement('li')
                        var content = document.createTextNode(event.data)
                        message.appendChild(content)
                        messages.appendChild(message)
                    };
                    event.preventDefault()
                }
                function sendMessage(event) {
                    var input = document.getElementById("messageText")
                    ws.send(input.value)
                    input.value = ''
                    event.preventDefault()
                }
            </script>
        </body>
    </html>
    """
    
    
    @app.get("/")
    async def get():
        return HTMLResponse(html)
    
    
    async def get_cookie_or_token(
        websocket: WebSocket,
        session: Union[str, None] = Cookie(default=None),
        token: Union[str, None] = Query(default=None),
    ):
        if session is None and token is None:
            raise WebSocketException(code=status.WS_1008_POLICY_VIOLATION)
        return session or token
    
    
    @app.websocket("/items/{item_id}/ws")
    async def websocket_endpoint(
        websocket: WebSocket,
        item_id: str,
        q: Union[int, None] = None,
        cookie_or_token: str = Depends(get_cookie_or_token),
    ):
        await websocket.accept()
        while True:
            data = await websocket.receive_text()
            await websocket.send_text(
                f"Session cookie or query token value is: {cookie_or_token}"
            )
            if q is not None:
                await websocket.send_text(f"Query parameter q is: {q}")
            await websocket.send_text(f"Message text was: {data}, for item ID: {item_id}")
    

Info

As this is a WebSocket it doesn't really make sense to raise an `HTTPException`, instead we raise a `WebSocketException`.

You can use a closing code from the [valid codes defined in the specification](https://tools.ietf.org/html/rfc6455#section-7.4.1).

### Try the WebSockets with dependencies[¶](#try-the-websockets-with-dependencies "Permanent link")

If your file is named `main.py`, run your application with:
    
    
    $ fastapi dev main.py
    
    <span style="color: green;">INFO</span>:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
    

Open your browser at <http://127.0.0.1:8000>.

There you can set:

  * The "Item ID", used in the path.
  * The "Token" used as a query parameter.

Tip

Notice that the query `token` will be handled by a dependency.

With that you can connect the WebSocket and then send and receive messages:

![](/img/tutorial/websockets/image05.png)

## Handling disconnections and multiple clients[¶](#handling-disconnections-and-multiple-clients "Permanent link")

When a WebSocket connection is closed, the `await websocket.receive_text()` will raise a `WebSocketDisconnect` exception, which you can then catch and handle like in this example.

Python 3.9+
    
    
    from fastapi import FastAPI, WebSocket, WebSocketDisconnect
    from fastapi.responses import HTMLResponse
    
    app = FastAPI()
    
    html = """
    <!DOCTYPE html>
    <html>
        <head>
            <title>Chat</title>
        </head>
        <body>
            <h1>WebSocket Chat</h1>
            <h2>Your ID: <span id="ws-id"></span></h2>
            <form action="" onsubmit="sendMessage(event)">
                <input type="text" id="messageText" autocomplete="off"/>
                <button>Send</button>
            </form>
            <ul id='messages'>
            </ul>
            <script>
                var client_id = Date.now()
                document.querySelector("#ws-id").textContent = client_id;
                var ws = new WebSocket(`ws://localhost:8000/ws/${client_id}`);
                ws.onmessage = function(event) {
                    var messages = document.getElementById('messages')
                    var message = document.createElement('li')
                    var content = document.createTextNode(event.data)
                    message.appendChild(content)
                    messages.appendChild(message)
                };
                function sendMessage(event) {
                    var input = document.getElementById("messageText")
                    ws.send(input.value)
                    input.value = ''
                    event.preventDefault()
                }
            </script>
        </body>
    </html>
    """
    
    
    class ConnectionManager:
        def __init__(self):
            self.active_connections: list[WebSocket] = []
    
        async def connect(self, websocket: WebSocket):
            await websocket.accept()
            self.active_connections.append(websocket)
    
        def disconnect(self, websocket: WebSocket):
            self.active_connections.remove(websocket)
    
        async def send_personal_message(self, message: str, websocket: WebSocket):
            await websocket.send_text(message)
    
        async def broadcast(self, message: str):
            for connection in self.active_connections:
                await connection.send_text(message)
    
    
    manager = ConnectionManager()
    
    
    @app.get("/")
    async def get():
        return HTMLResponse(html)
    
    
    @app.websocket("/ws/{client_id}")
    async def websocket_endpoint(websocket: WebSocket, client_id: int):
        await manager.connect(websocket)
        try:
            while True:
                data = await websocket.receive_text()
                await manager.send_personal_message(f"You wrote: {data}", websocket)
                await manager.broadcast(f"Client #{client_id} says: {data}")
        except WebSocketDisconnect:
            manager.disconnect(websocket)
            await manager.broadcast(f"Client #{client_id} left the chat")
    

To try it out:

  * Open the app with several browser tabs.
  * Write messages from them.
  * Then close one of the tabs.

That will raise the `WebSocketDisconnect` exception, and all the other clients will receive a message like:
    
    
    Client #1596980209979 left the chat
    

Tip

The app above is a minimal and simple example to demonstrate how to handle and broadcast messages to several WebSocket connections.

But keep in mind that, as everything is handled in memory, in a single list, it will only work while the process is running, and will only work with a single process.

If you need something easy to integrate with FastAPI but that is more robust, supported by Redis, PostgreSQL or others, check [encode/broadcaster](https://github.com/encode/broadcaster).

## More info[¶](#more-info "Permanent link")

To learn more about the options, check Starlette's documentation for:

  * [The `WebSocket` class](https://www.starlette.dev/websockets/).
  * [Class-based WebSocket handling](https://www.starlette.dev/endpoints/#websocketendpoint).

---

###### Lifespan Events¶

# Lifespan Events[¶](#lifespan-events "Permanent link")

You can define logic (code) that should be executed before the application **starts up**. This means that this code will be executed **once** , **before** the application **starts receiving requests**.

The same way, you can define logic (code) that should be executed when the application is **shutting down**. In this case, this code will be executed **once** , **after** having handled possibly **many requests**.

Because this code is executed before the application **starts** taking requests, and right after it **finishes** handling requests, it covers the whole application **lifespan** (the word "lifespan" will be important in a second üòâ).

This can be very useful for setting up **resources** that you need to use for the whole app, and that are **shared** among requests, and/or that you need to **clean up** afterwards. For example, a database connection pool, or loading a shared machine learning model.

## Use Case[¶](#use-case "Permanent link")

Let's start with an example **use case** and then see how to solve it with this.

Let's imagine that you have some **machine learning models** that you want to use to handle requests. ü§ñ

The same models are shared among requests, so, it's not one model per request, or one per user or something similar.

Let's imagine that loading the model can **take quite some time** , because it has to read a lot of **data from disk**. So you don't want to do it for every request.

You could load it at the top level of the module/file, but that would also mean that it would **load the model** even if you are just running a simple automated test, then that test would be **slow** because it would have to wait for the model to load before being able to run an independent part of the code.

That's what we'll solve, let's load the model before the requests are handled, but only right before the application starts receiving requests, not while the code is being loaded.

## Lifespan[¶](#lifespan "Permanent link")

You can define this _startup_ and _shutdown_ logic using the `lifespan` parameter of the `FastAPI` app, and a "context manager" (I'll show you what that is in a second).

Let's start with an example and then see it in detail.

We create an async function `lifespan()` with `yield` like this:

Python 3.9+
    
    
    from contextlib import asynccontextmanager
    
    from fastapi import FastAPI
    
    
    def fake_answer_to_everything_ml_model(x: float):
        return x * 42
    
    
    ml_models = {}
    
    
    @asynccontextmanager
    async def lifespan(app: FastAPI):
        # Load the ML model
        ml_models["answer_to_everything"] = fake_answer_to_everything_ml_model
        yield
        # Clean up the ML models and release the resources
        ml_models.clear()
    
    
    app = FastAPI(lifespan=lifespan)
    
    
    @app.get("/predict")
    async def predict(x: float):
        result = ml_models["answer_to_everything"](x)
        return {"result": result}
    

Here we are simulating the expensive _startup_ operation of loading the model by putting the (fake) model function in the dictionary with machine learning models before the `yield`. This code will be executed **before** the application **starts taking requests** , during the _startup_.

And then, right after the `yield`, we unload the model. This code will be executed **after** the application **finishes handling requests** , right before the _shutdown_. This could, for example, release resources like memory or a GPU.

Tip

The `shutdown` would happen when you are **stopping** the application.

Maybe you need to start a new version, or you just got tired of running it. ü§∑

### Lifespan function[¶](#lifespan-function "Permanent link")

The first thing to notice, is that we are defining an async function with `yield`. This is very similar to Dependencies with `yield`.

Python 3.9+
    
    
    from contextlib import asynccontextmanager
    
    from fastapi import FastAPI
    
    
    def fake_answer_to_everything_ml_model(x: float):
        return x * 42
    
    
    ml_models = {}
    
    
    @asynccontextmanager
    async def lifespan(app: FastAPI):
        # Load the ML model
        ml_models["answer_to_everything"] = fake_answer_to_everything_ml_model
        yield
        # Clean up the ML models and release the resources
        ml_models.clear()
    
    
    app = FastAPI(lifespan=lifespan)
    
    
    @app.get("/predict")
    async def predict(x: float):
        result = ml_models["answer_to_everything"](x)
        return {"result": result}
    

The first part of the function, before the `yield`, will be executed **before** the application starts.

And the part after the `yield` will be executed **after** the application has finished.

### Async Context Manager[¶](#async-context-manager "Permanent link")

If you check, the function is decorated with an `@asynccontextmanager`.

That converts the function into something called an "**async context manager** ".

Python 3.9+
    
    
    from contextlib import asynccontextmanager
    
    from fastapi import FastAPI
    
    
    def fake_answer_to_everything_ml_model(x: float):
        return x * 42
    
    
    ml_models = {}
    
    
    @asynccontextmanager
    async def lifespan(app: FastAPI):
        # Load the ML model
        ml_models["answer_to_everything"] = fake_answer_to_everything_ml_model
        yield
        # Clean up the ML models and release the resources
        ml_models.clear()
    
    
    app = FastAPI(lifespan=lifespan)
    
    
    @app.get("/predict")
    async def predict(x: float):
        result = ml_models["answer_to_everything"](x)
        return {"result": result}
    

A **context manager** in Python is something that you can use in a `with` statement, for example, `open()` can be used as a context manager:
    
    
    with open("file.txt") as file:
        file.read()
    

In recent versions of Python, there's also an **async context manager**. You would use it with `async with`:
    
    
    async with lifespan(app):
        await do_stuff()
    

When you create a context manager or an async context manager like above, what it does is that, before entering the `with` block, it will execute the code before the `yield`, and after exiting the `with` block, it will execute the code after the `yield`.

In our code example above, we don't use it directly, but we pass it to FastAPI for it to use it.

The `lifespan` parameter of the `FastAPI` app takes an **async context manager** , so we can pass our new `lifespan` async context manager to it.

Python 3.9+
    
    
    from contextlib import asynccontextmanager
    
    from fastapi import FastAPI
    
    
    def fake_answer_to_everything_ml_model(x: float):
        return x * 42
    
    
    ml_models = {}
    
    
    @asynccontextmanager
    async def lifespan(app: FastAPI):
        # Load the ML model
        ml_models["answer_to_everything"] = fake_answer_to_everything_ml_model
        yield
        # Clean up the ML models and release the resources
        ml_models.clear()
    
    
    app = FastAPI(lifespan=lifespan)
    
    
    @app.get("/predict")
    async def predict(x: float):
        result = ml_models["answer_to_everything"](x)
        return {"result": result}
    

## Alternative Events (deprecated)[¶](#alternative-events-deprecated "Permanent link")

Warning

The recommended way to handle the _startup_ and _shutdown_ is using the `lifespan` parameter of the `FastAPI` app as described above. If you provide a `lifespan` parameter, `startup` and `shutdown` event handlers will no longer be called. It's all `lifespan` or all events, not both.

You can probably skip this part.

There's an alternative way to define this logic to be executed during _startup_ and during _shutdown_.

You can define event handlers (functions) that need to be executed before the application starts up, or when the application is shutting down.

These functions can be declared with `async def` or normal `def`.

### `startup` event[¶](#startup-event "Permanent link")

To add a function that should be run before the application starts, declare it with the event `"startup"`:

Python 3.9+
    
    
    from fastapi import FastAPI
    
    app = FastAPI()
    
    items = {}
    
    
    @app.on_event("startup")
    async def startup_event():
        items["foo"] = {"name": "Fighters"}
        items["bar"] = {"name": "Tenders"}
    
    
    @app.get("/items/{item_id}")
    async def read_items(item_id: str):
        return items[item_id]
    

In this case, the `startup` event handler function will initialize the items "database" (just a `dict`) with some values.

You can add more than one event handler function.

And your application won't start receiving requests until all the `startup` event handlers have completed.

### `shutdown` event[¶](#shutdown-event "Permanent link")

To add a function that should be run when the application is shutting down, declare it with the event `"shutdown"`:

Python 3.9+
    
    
    from fastapi import FastAPI
    
    app = FastAPI()
    
    
    @app.on_event("shutdown")
    def shutdown_event():
        with open("log.txt", mode="a") as log:
            log.write("Application shutdown")
    
    
    @app.get("/items/")
    async def read_items():
        return [{"name": "Foo"}]
    

Here, the `shutdown` event handler function will write a text line `"Application shutdown"` to a file `log.txt`.

Info

In the `open()` function, the `mode="a"` means "append", so, the line will be added after whatever is on that file, without overwriting the previous contents.

Tip

Notice that in this case we are using a standard Python `open()` function that interacts with a file.

So, it involves I/O (input/output), that requires "waiting" for things to be written to disk.

But `open()` doesn't use `async` and `await`.

So, we declare the event handler function with standard `def` instead of `async def`.

### `startup` and `shutdown` together[¶](#startup-and-shutdown-together "Permanent link")

There's a high chance that the logic for your _startup_ and _shutdown_ is connected, you might want to start something and then finish it, acquire a resource and then release it, etc.

Doing that in separated functions that don't share logic or variables together is more difficult as you would need to store values in global variables or similar tricks.

Because of that, it's now recommended to instead use the `lifespan` as explained above.

## Technical Details[¶](#technical-details "Permanent link")

Just a technical detail for the curious nerds. ü§ì

Underneath, in the ASGI technical specification, this is part of the [Lifespan Protocol](https://asgi.readthedocs.io/en/latest/specs/lifespan.html), and it defines events called `startup` and `shutdown`.

Info

You can read more about the Starlette `lifespan` handlers in [Starlette's Lifespan' docs](https://www.starlette.dev/lifespan/).

Including how to handle lifespan state that can be used in other areas of your code.

## Sub Applications[¶](#sub-applications "Permanent link")

üö® Keep in mind that these lifespan events (startup and shutdown) will only be executed for the main application, not for [Sub Applications - Mounts](../sub-applications/).

---

###### Testing WebSockets¶

# Testing WebSockets[¶](#testing-websockets "Permanent link")

You can use the same `TestClient` to test WebSockets.

For this, you use the `TestClient` in a `with` statement, connecting to the WebSocket:

Python 3.9+
    
    
    from fastapi import FastAPI
    from fastapi.testclient import TestClient
    from fastapi.websockets import WebSocket
    
    app = FastAPI()
    
    
    @app.get("/")
    async def read_main():
        return {"msg": "Hello World"}
    
    
    @app.websocket("/ws")
    async def websocket(websocket: WebSocket):
        await websocket.accept()
        await websocket.send_json({"msg": "Hello WebSocket"})
        await websocket.close()
    
    
    def test_read_main():
        client = TestClient(app)
        response = client.get("/")
        assert response.status_code == 200
        assert response.json() == {"msg": "Hello World"}
    
    
    def test_websocket():
        client = TestClient(app)
        with client.websocket_connect("/ws") as websocket:
            data = websocket.receive_json()
            assert data == {"msg": "Hello WebSocket"}
    

Note

For more details, check Starlette's documentation for [testing WebSockets](https://www.starlette.dev/testclient/#testing-websocket-sessions).

---

###### Testing Events: lifespan and startup - shutdown¶

# Testing Events: lifespan and startup - shutdown[¶](#testing-events-lifespan-and-startup-shutdown "Permanent link")

When you need `lifespan` to run in your tests, you can use the `TestClient` with a `with` statement:

Python 3.9+
    
    
    from contextlib import asynccontextmanager
    
    from fastapi import FastAPI
    from fastapi.testclient import TestClient
    
    items = {}
    
    
    @asynccontextmanager
    async def lifespan(app: FastAPI):
        items["foo"] = {"name": "Fighters"}
        items["bar"] = {"name": "Tenders"}
        yield
        # clean up items
        items.clear()
    
    
    app = FastAPI(lifespan=lifespan)
    
    
    @app.get("/items/{item_id}")
    async def read_items(item_id: str):
        return items[item_id]
    
    
    def test_read_items():
        # Before the lifespan starts, "items" is still empty
        assert items == {}
    
        with TestClient(app) as client:
            # Inside the "with TestClient" block, the lifespan starts and items added
            assert items == {"foo": {"name": "Fighters"}, "bar": {"name": "Tenders"}}
    
            response = client.get("/items/foo")
            assert response.status_code == 200
            assert response.json() == {"name": "Fighters"}
    
            # After the requests is done, the items are still there
            assert items == {"foo": {"name": "Fighters"}, "bar": {"name": "Tenders"}}
    
        # The end of the "with TestClient" block simulates terminating the app, so
        # the lifespan ends and items are cleaned up
        assert items == {}
    

You can read more details about the ["Running lifespan in tests in the official Starlette documentation site."](https://www.starlette.dev/lifespan/#running-lifespan-in-tests)

For the deprecated `startup` and `shutdown` events, you can use the `TestClient` as follows:

Python 3.9+
    
    
    from fastapi import FastAPI
    from fastapi.testclient import TestClient
    
    app = FastAPI()
    
    items = {}
    
    
    @app.on_event("startup")
    async def startup_event():
        items["foo"] = {"name": "Fighters"}
        items["bar"] = {"name": "Tenders"}
    
    
    @app.get("/items/{item_id}")
    async def read_items(item_id: str):
        return items[item_id]
    
    
    def test_read_items():
        with TestClient(app) as client:
            response = client.get("/items/foo")
            assert response.status_code == 200
            assert response.json() == {"name": "Fighters"}

---

###### Testing Dependencies with Overrides¶

# Testing Dependencies with Overrides[¶](#testing-dependencies-with-overrides "Permanent link")

## Overriding dependencies during testing[¶](#overriding-dependencies-during-testing "Permanent link")

There are some scenarios where you might want to override a dependency during testing.

You don't want the original dependency to run (nor any of the sub-dependencies it might have).

Instead, you want to provide a different dependency that will be used only during tests (possibly only some specific tests), and will provide a value that can be used where the value of the original dependency was used.

### Use cases: external service[¶](#use-cases-external-service "Permanent link")

An example could be that you have an external authentication provider that you need to call.

You send it a token and it returns an authenticated user.

This provider might be charging you per request, and calling it might take some extra time than if you had a fixed mock user for tests.

You probably want to test the external provider once, but not necessarily call it for every test that runs.

In this case, you can override the dependency that calls that provider, and use a custom dependency that returns a mock user, only for your tests.

### Use the `app.dependency_overrides` attribute[¶](#use-the-app-dependency-overrides-attribute "Permanent link")

For these cases, your **FastAPI** application has an attribute `app.dependency_overrides`, it is a simple `dict`.

To override a dependency for testing, you put as a key the original dependency (a function), and as the value, your dependency override (another function).

And then **FastAPI** will call that override instead of the original dependency.

Python 3.10+
    
    
    from typing import Annotated
    
    from fastapi import Depends, FastAPI
    from fastapi.testclient import TestClient
    
    app = FastAPI()
    
    
    async def common_parameters(q: str | None = None, skip: int = 0, limit: int = 100):
        return {"q": q, "skip": skip, "limit": limit}
    
    
    @app.get("/items/")
    async def read_items(commons: Annotated[dict, Depends(common_parameters)]):
        return {"message": "Hello Items!", "params": commons}
    
    
    @app.get("/users/")
    async def read_users(commons: Annotated[dict, Depends(common_parameters)]):
        return {"message": "Hello Users!", "params": commons}
    
    
    client = TestClient(app)
    
    
    async def override_dependency(q: str | None = None):
        return {"q": q, "skip": 5, "limit": 10}
    
    
    app.dependency_overrides[common_parameters] = override_dependency
    
    
    def test_override_in_items():
        response = client.get("/items/")
        assert response.status_code == 200
        assert response.json() == {
            "message": "Hello Items!",
            "params": {"q": None, "skip": 5, "limit": 10},
        }
    
    
    def test_override_in_items_with_q():
        response = client.get("/items/?q=foo")
        assert response.status_code == 200
        assert response.json() == {
            "message": "Hello Items!",
            "params": {"q": "foo", "skip": 5, "limit": 10},
        }
    
    
    def test_override_in_items_with_params():
        response = client.get("/items/?q=foo&skip=100&limit=200")
        assert response.status_code == 200
        assert response.json() == {
            "message": "Hello Items!",
            "params": {"q": "foo", "skip": 5, "limit": 10},
        }
    

ü§ì Other versions and variants

Python 3.9+Python 3.10+ - non-AnnotatedPython 3.9+ - non-Annotated
    
    
    from typing import Annotated, Union
    
    from fastapi import Depends, FastAPI
    from fastapi.testclient import TestClient
    
    app = FastAPI()
    
    
    async def common_parameters(
        q: Union[str, None] = None, skip: int = 0, limit: int = 100
    ):
        return {"q": q, "skip": skip, "limit": limit}
    
    
    @app.get("/items/")
    async def read_items(commons: Annotated[dict, Depends(common_parameters)]):
        return {"message": "Hello Items!", "params": commons}
    
    
    @app.get("/users/")
    async def read_users(commons: Annotated[dict, Depends(common_parameters)]):
        return {"message": "Hello Users!", "params": commons}
    
    
    client = TestClient(app)
    
    
    async def override_dependency(q: Union[str, None] = None):
        return {"q": q, "skip": 5, "limit": 10}
    
    
    app.dependency_overrides[common_parameters] = override_dependency
    
    
    def test_override_in_items():
        response = client.get("/items/")
        assert response.status_code == 200
        assert response.json() == {
            "message": "Hello Items!",
            "params": {"q": None, "skip": 5, "limit": 10},
        }
    
    
    def test_override_in_items_with_q():
        response = client.get("/items/?q=foo")
        assert response.status_code == 200
        assert response.json() == {
            "message": "Hello Items!",
            "params": {"q": "foo", "skip": 5, "limit": 10},
        }
    
    
    def test_override_in_items_with_params():
        response = client.get("/items/?q=foo&skip=100&limit=200")
        assert response.status_code == 200
        assert response.json() == {
            "message": "Hello Items!",
            "params": {"q": "foo", "skip": 5, "limit": 10},
        }
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi import Depends, FastAPI
    from fastapi.testclient import TestClient
    
    app = FastAPI()
    
    
    async def common_parameters(q: str | None = None, skip: int = 0, limit: int = 100):
        return {"q": q, "skip": skip, "limit": limit}
    
    
    @app.get("/items/")
    async def read_items(commons: dict = Depends(common_parameters)):
        return {"message": "Hello Items!", "params": commons}
    
    
    @app.get("/users/")
    async def read_users(commons: dict = Depends(common_parameters)):
        return {"message": "Hello Users!", "params": commons}
    
    
    client = TestClient(app)
    
    
    async def override_dependency(q: str | None = None):
        return {"q": q, "skip": 5, "limit": 10}
    
    
    app.dependency_overrides[common_parameters] = override_dependency
    
    
    def test_override_in_items():
        response = client.get("/items/")
        assert response.status_code == 200
        assert response.json() == {
            "message": "Hello Items!",
            "params": {"q": None, "skip": 5, "limit": 10},
        }
    
    
    def test_override_in_items_with_q():
        response = client.get("/items/?q=foo")
        assert response.status_code == 200
        assert response.json() == {
            "message": "Hello Items!",
            "params": {"q": "foo", "skip": 5, "limit": 10},
        }
    
    
    def test_override_in_items_with_params():
        response = client.get("/items/?q=foo&skip=100&limit=200")
        assert response.status_code == 200
        assert response.json() == {
            "message": "Hello Items!",
            "params": {"q": "foo", "skip": 5, "limit": 10},
        }
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from typing import Union
    
    from fastapi import Depends, FastAPI
    from fastapi.testclient import TestClient
    
    app = FastAPI()
    
    
    async def common_parameters(
        q: Union[str, None] = None, skip: int = 0, limit: int = 100
    ):
        return {"q": q, "skip": skip, "limit": limit}
    
    
    @app.get("/items/")
    async def read_items(commons: dict = Depends(common_parameters)):
        return {"message": "Hello Items!", "params": commons}
    
    
    @app.get("/users/")
    async def read_users(commons: dict = Depends(common_parameters)):
        return {"message": "Hello Users!", "params": commons}
    
    
    client = TestClient(app)
    
    
    async def override_dependency(q: Union[str, None] = None):
        return {"q": q, "skip": 5, "limit": 10}
    
    
    app.dependency_overrides[common_parameters] = override_dependency
    
    
    def test_override_in_items():
        response = client.get("/items/")
        assert response.status_code == 200
        assert response.json() == {
            "message": "Hello Items!",
            "params": {"q": None, "skip": 5, "limit": 10},
        }
    
    
    def test_override_in_items_with_q():
        response = client.get("/items/?q=foo")
        assert response.status_code == 200
        assert response.json() == {
            "message": "Hello Items!",
            "params": {"q": "foo", "skip": 5, "limit": 10},
        }
    
    
    def test_override_in_items_with_params():
        response = client.get("/items/?q=foo&skip=100&limit=200")
        assert response.status_code == 200
        assert response.json() == {
            "message": "Hello Items!",
            "params": {"q": "foo", "skip": 5, "limit": 10},
        }
    

Tip

You can set a dependency override for a dependency used anywhere in your **FastAPI** application.

The original dependency could be used in a _path operation function_ , a _path operation decorator_ (when you don't use the return value), a `.include_router()` call, etc.

FastAPI will still be able to override it.

Then you can reset your overrides (remove them) by setting `app.dependency_overrides` to be an empty `dict`:
    
    
    app.dependency_overrides = {}
    

Tip

If you want to override a dependency only during some tests, you can set the override at the beginning of the test (inside the test function) and reset it at the end (at the end of the test function).

---

###### Async Tests¶

# Async Tests[¶](#async-tests "Permanent link")

You have already seen how to test your **FastAPI** applications using the provided `TestClient`. Up to now, you have only seen how to write synchronous tests, without using `async` functions.

Being able to use asynchronous functions in your tests could be useful, for example, when you're querying your database asynchronously. Imagine you want to test sending requests to your FastAPI application and then verify that your backend successfully wrote the correct data in the database, while using an async database library.

Let's look at how we can make that work.

## pytest.mark.anyio[¶](#pytest-mark-anyio "Permanent link")

If we want to call asynchronous functions in our tests, our test functions have to be asynchronous. AnyIO provides a neat plugin for this, that allows us to specify that some test functions are to be called asynchronously.

## HTTPX[¶](#httpx "Permanent link")

Even if your **FastAPI** application uses normal `def` functions instead of `async def`, it is still an `async` application underneath.

The `TestClient` does some magic inside to call the asynchronous FastAPI application in your normal `def` test functions, using standard pytest. But that magic doesn't work anymore when we're using it inside asynchronous functions. By running our tests asynchronously, we can no longer use the `TestClient` inside our test functions.

The `TestClient` is based on [HTTPX](https://www.python-httpx.org), and luckily, we can use it directly to test the API.

## Example[¶](#example "Permanent link")

For a simple example, let's consider a file structure similar to the one described in [Bigger Applications](../../tutorial/bigger-applications/) and [Testing](../../tutorial/testing/):
    
    
    .
    ‚îú‚îÄ‚îÄ app
    ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ __init__.py
    ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ main.py
    ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ test_main.py
    

The file `main.py` would have:

Python 3.9+
    
    
    from fastapi import FastAPI
    
    app = FastAPI()
    
    
    @app.get("/")
    async def root():
        return {"message": "Tomato"}
    

The file `test_main.py` would have the tests for `main.py`, it could look like this now:

Python 3.9+
    
    
    import pytest
    from httpx import ASGITransport, AsyncClient
    
    from .main import app
    
    
    @pytest.mark.anyio
    async def test_root():
        async with AsyncClient(
            transport=ASGITransport(app=app), base_url="http://test"
        ) as ac:
            response = await ac.get("/")
        assert response.status_code == 200
        assert response.json() == {"message": "Tomato"}
    

## Run it[¶](#run-it "Permanent link")

You can run your tests as usual via:
    
    
    $ pytest
    
    ---> 100%
    

## In Detail[¶](#in-detail "Permanent link")

The marker `@pytest.mark.anyio` tells pytest that this test function should be called asynchronously:

Python 3.9+
    
    
    import pytest
    from httpx import ASGITransport, AsyncClient
    
    from .main import app
    
    
    @pytest.mark.anyio
    async def test_root():
        async with AsyncClient(
            transport=ASGITransport(app=app), base_url="http://test"
        ) as ac:
            response = await ac.get("/")
        assert response.status_code == 200
        assert response.json() == {"message": "Tomato"}
    

Tip

Note that the test function is now `async def` instead of just `def` as before when using the `TestClient`.

Then we can create an `AsyncClient` with the app, and send async requests to it, using `await`.

Python 3.9+
    
    
    import pytest
    from httpx import ASGITransport, AsyncClient
    
    from .main import app
    
    
    @pytest.mark.anyio
    async def test_root():
        async with AsyncClient(
            transport=ASGITransport(app=app), base_url="http://test"
        ) as ac:
            response = await ac.get("/")
        assert response.status_code == 200
        assert response.json() == {"message": "Tomato"}
    

This is the equivalent to:
    
    
    response = client.get('/')
    

...that we used to make our requests with the `TestClient`.

Tip

Note that we're using async/await with the new `AsyncClient` \- the request is asynchronous.

Warning

If your application relies on lifespan events, the `AsyncClient` won't trigger these events. To ensure they are triggered, use `LifespanManager` from [florimondmanca/asgi-lifespan](https://github.com/florimondmanca/asgi-lifespan#usage).

## Other Asynchronous Function Calls[¶](#other-asynchronous-function-calls "Permanent link")

As the testing function is now asynchronous, you can now also call (and `await`) other `async` functions apart from sending requests to your FastAPI application in your tests, exactly as you would call them anywhere else in your code.

Tip

If you encounter a `RuntimeError: Task attached to a different loop` when integrating asynchronous function calls in your tests (e.g. when using [MongoDB's MotorClient](https://stackoverflow.com/questions/41584243/runtimeerror-task-attached-to-a-different-loop)), remember to instantiate objects that need an event loop only within async functions, e.g. an `@app.on_event("startup")` callback.

---

###### Settings and Environment Variables¶

# Settings and Environment Variables[¶](#settings-and-environment-variables "Permanent link")

In many cases your application could need some external settings or configurations, for example secret keys, database credentials, credentials for email services, etc.

Most of these settings are variable (can change), like database URLs. And many could be sensitive, like secrets.

For this reason it's common to provide them in environment variables that are read by the application.

Tip

To understand environment variables you can read [Environment Variables](../../environment-variables/).

## Types and validation[¶](#types-and-validation "Permanent link")

These environment variables can only handle text strings, as they are external to Python and have to be compatible with other programs and the rest of the system (and even with different operating systems, as Linux, Windows, macOS).

That means that any value read in Python from an environment variable will be a `str`, and any conversion to a different type or any validation has to be done in code.

## Pydantic `Settings`[¶](#pydantic-settings "Permanent link")

Fortunately, Pydantic provides a great utility to handle these settings coming from environment variables with [Pydantic: Settings management](https://docs.pydantic.dev/latest/concepts/pydantic_settings/).

### Install `pydantic-settings`[¶](#install-pydantic-settings "Permanent link")

First, make sure you create your [virtual environment](../../virtual-environments/), activate it, and then install the `pydantic-settings` package:
    
    
    $ pip install pydantic-settings
    ---> 100%
    

It also comes included when you install the `all` extras with:
    
    
    $ pip install "fastapi[all]"
    ---> 100%
    

### Create the `Settings` object[¶](#create-the-settings-object "Permanent link")

Import `BaseSettings` from Pydantic and create a sub-class, very much like with a Pydantic model.

The same way as with Pydantic models, you declare class attributes with type annotations, and possibly default values.

You can use all the same validation features and tools you use for Pydantic models, like different data types and additional validations with `Field()`.

Python 3.9+
    
    
    from fastapi import FastAPI
    from pydantic_settings import BaseSettings
    
    
    class Settings(BaseSettings):
        app_name: str = "Awesome API"
        admin_email: str
        items_per_user: int = 50
    
    
    settings = Settings()
    app = FastAPI()
    
    
    @app.get("/info")
    async def info():
        return {
            "app_name": settings.app_name,
            "admin_email": settings.admin_email,
            "items_per_user": settings.items_per_user,
        }
    

Tip

If you want something quick to copy and paste, don't use this example, use the last one below.

Then, when you create an instance of that `Settings` class (in this case, in the `settings` object), Pydantic will read the environment variables in a case-insensitive way, so, an upper-case variable `APP_NAME` will still be read for the attribute `app_name`.

Next it will convert and validate the data. So, when you use that `settings` object, you will have data of the types you declared (e.g. `items_per_user` will be an `int`).

### Use the `settings`[¶](#use-the-settings "Permanent link")

Then you can use the new `settings` object in your application:

Python 3.9+
    
    
    from fastapi import FastAPI
    from pydantic_settings import BaseSettings
    
    
    class Settings(BaseSettings):
        app_name: str = "Awesome API"
        admin_email: str
        items_per_user: int = 50
    
    
    settings = Settings()
    app = FastAPI()
    
    
    @app.get("/info")
    async def info():
        return {
            "app_name": settings.app_name,
            "admin_email": settings.admin_email,
            "items_per_user": settings.items_per_user,
        }
    

### Run the server[¶](#run-the-server "Permanent link")

Next, you would run the server passing the configurations as environment variables, for example you could set an `ADMIN_EMAIL` and `APP_NAME` with:
    
    
    $ ADMIN_EMAIL="deadpool@example.com" APP_NAME="ChimichangApp" fastapi run main.py
    
    <span style="color: green;">INFO</span>:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
    

Tip

To set multiple env vars for a single command just separate them with a space, and put them all before the command.

And then the `admin_email` setting would be set to `"deadpool@example.com"`.

The `app_name` would be `"ChimichangApp"`.

And the `items_per_user` would keep its default value of `50`.

## Settings in another module[¶](#settings-in-another-module "Permanent link")

You could put those settings in another module file as you saw in [Bigger Applications - Multiple Files](../../tutorial/bigger-applications/).

For example, you could have a file `config.py` with:

Python 3.9+
    
    
    from pydantic_settings import BaseSettings
    
    
    class Settings(BaseSettings):
        app_name: str = "Awesome API"
        admin_email: str
        items_per_user: int = 50
    
    
    settings = Settings()
    

And then use it in a file `main.py`:

Python 3.9+
    
    
    from fastapi import FastAPI
    
    from .config import settings
    
    app = FastAPI()
    
    
    @app.get("/info")
    async def info():
        return {
            "app_name": settings.app_name,
            "admin_email": settings.admin_email,
            "items_per_user": settings.items_per_user,
        }
    

Tip

You would also need a file `__init__.py` as you saw in [Bigger Applications - Multiple Files](../../tutorial/bigger-applications/).

## Settings in a dependency[¶](#settings-in-a-dependency "Permanent link")

In some occasions it might be useful to provide the settings from a dependency, instead of having a global object with `settings` that is used everywhere.

This could be especially useful during testing, as it's very easy to override a dependency with your own custom settings.

### The config file[¶](#the-config-file "Permanent link")

Coming from the previous example, your `config.py` file could look like:

Python 3.9+
    
    
    from pydantic_settings import BaseSettings
    
    
    class Settings(BaseSettings):
        app_name: str = "Awesome API"
        admin_email: str
        items_per_user: int = 50
    

ü§ì Other versions and variants

Python 3.9+ - non-Annotated

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from pydantic_settings import BaseSettings
    
    
    class Settings(BaseSettings):
        app_name: str = "Awesome API"
        admin_email: str
        items_per_user: int = 50
    

Notice that now we don't create a default instance `settings = Settings()`.

### The main app file[¶](#the-main-app-file "Permanent link")

Now we create a dependency that returns a new `config.Settings()`.

Python 3.9+
    
    
    from functools import lru_cache
    from typing import Annotated
    
    from fastapi import Depends, FastAPI
    
    from .config import Settings
    
    app = FastAPI()
    
    
    @lru_cache
    def get_settings():
        return Settings()
    
    
    @app.get("/info")
    async def info(settings: Annotated[Settings, Depends(get_settings)]):
        return {
            "app_name": settings.app_name,
            "admin_email": settings.admin_email,
            "items_per_user": settings.items_per_user,
        }
    

ü§ì Other versions and variants

Python 3.9+ - non-Annotated

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from functools import lru_cache
    
    from fastapi import Depends, FastAPI
    
    from .config import Settings
    
    app = FastAPI()
    
    
    @lru_cache
    def get_settings():
        return Settings()
    
    
    @app.get("/info")
    async def info(settings: Settings = Depends(get_settings)):
        return {
            "app_name": settings.app_name,
            "admin_email": settings.admin_email,
            "items_per_user": settings.items_per_user,
        }
    

Tip

We'll discuss the `@lru_cache` in a bit.

For now you can assume `get_settings()` is a normal function.

And then we can require it from the _path operation function_ as a dependency and use it anywhere we need it.

Python 3.9+
    
    
    from functools import lru_cache
    from typing import Annotated
    
    from fastapi import Depends, FastAPI
    
    from .config import Settings
    
    app = FastAPI()
    
    
    @lru_cache
    def get_settings():
        return Settings()
    
    
    @app.get("/info")
    async def info(settings: Annotated[Settings, Depends(get_settings)]):
        return {
            "app_name": settings.app_name,
            "admin_email": settings.admin_email,
            "items_per_user": settings.items_per_user,
        }
    

ü§ì Other versions and variants

Python 3.9+ - non-Annotated

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from functools import lru_cache
    
    from fastapi import Depends, FastAPI
    
    from .config import Settings
    
    app = FastAPI()
    
    
    @lru_cache
    def get_settings():
        return Settings()
    
    
    @app.get("/info")
    async def info(settings: Settings = Depends(get_settings)):
        return {
            "app_name": settings.app_name,
            "admin_email": settings.admin_email,
            "items_per_user": settings.items_per_user,
        }
    

### Settings and testing[¶](#settings-and-testing "Permanent link")

Then it would be very easy to provide a different settings object during testing by creating a dependency override for `get_settings`:

Python 3.9+
    
    
    from fastapi.testclient import TestClient
    
    from .config import Settings
    from .main import app, get_settings
    
    client = TestClient(app)
    
    
    def get_settings_override():
        return Settings(admin_email="testing_admin@example.com")
    
    
    app.dependency_overrides[get_settings] = get_settings_override
    
    
    def test_app():
        response = client.get("/info")
        data = response.json()
        assert data == {
            "app_name": "Awesome API",
            "admin_email": "testing_admin@example.com",
            "items_per_user": 50,
        }
    

ü§ì Other versions and variants

Python 3.9+ - non-Annotated

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from fastapi.testclient import TestClient
    
    from .config import Settings
    from .main import app, get_settings
    
    client = TestClient(app)
    
    
    def get_settings_override():
        return Settings(admin_email="testing_admin@example.com")
    
    
    app.dependency_overrides[get_settings] = get_settings_override
    
    
    def test_app():
        response = client.get("/info")
        data = response.json()
        assert data == {
            "app_name": "Awesome API",
            "admin_email": "testing_admin@example.com",
            "items_per_user": 50,
        }
    

In the dependency override we set a new value for the `admin_email` when creating the new `Settings` object, and then we return that new object.

Then we can test that it is used.

## Reading a `.env` file[¶](#reading-a-env-file "Permanent link")

If you have many settings that possibly change a lot, maybe in different environments, it might be useful to put them on a file and then read them from it as if they were environment variables.

This practice is common enough that it has a name, these environment variables are commonly placed in a file `.env`, and the file is called a "dotenv".

Tip

A file starting with a dot (`.`) is a hidden file in Unix-like systems, like Linux and macOS.

But a dotenv file doesn't really have to have that exact filename.

Pydantic has support for reading from these types of files using an external library. You can read more at [Pydantic Settings: Dotenv (.env) support](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#dotenv-env-support).

Tip

For this to work, you need to `pip install python-dotenv`.

### The `.env` file[¶](#the-env-file "Permanent link")

You could have a `.env` file with:
    
    
    ADMIN_EMAIL="deadpool@example.com"
    APP_NAME="ChimichangApp"
    

### Read settings from `.env`[¶](#read-settings-from-env "Permanent link")

And then update your `config.py` with:

Python 3.9+
    
    
    from pydantic_settings import BaseSettings, SettingsConfigDict
    
    
    class Settings(BaseSettings):
        app_name: str = "Awesome API"
        admin_email: str
        items_per_user: int = 50
    
        model_config = SettingsConfigDict(env_file=".env")
    

ü§ì Other versions and variants

Python 3.9+ - non-Annotated

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from pydantic_settings import BaseSettings, SettingsConfigDict
    
    
    class Settings(BaseSettings):
        app_name: str = "Awesome API"
        admin_email: str
        items_per_user: int = 50
    
        model_config = SettingsConfigDict(env_file=".env")
    

Tip

The `model_config` attribute is used just for Pydantic configuration. You can read more at [Pydantic: Concepts: Configuration](https://docs.pydantic.dev/latest/concepts/config/).

Here we define the config `env_file` inside of your Pydantic `Settings` class, and set the value to the filename with the dotenv file we want to use.

### Creating the `Settings` only once with `lru_cache`[¶](#creating-the-settings-only-once-with-lru-cache "Permanent link")

Reading a file from disk is normally a costly (slow) operation, so you probably want to do it only once and then reuse the same settings object, instead of reading it for each request.

But every time we do:
    
    
    Settings()
    

a new `Settings` object would be created, and at creation it would read the `.env` file again.

If the dependency function was just like:
    
    
    def get_settings():
        return Settings()
    

we would create that object for each request, and we would be reading the `.env` file for each request. ‚ö†Ô∏è

But as we are using the `@lru_cache` decorator on top, the `Settings` object will be created only once, the first time it's called. ‚úîÔ∏è

Python 3.9+
    
    
    from functools import lru_cache
    from typing import Annotated
    
    from fastapi import Depends, FastAPI
    
    from . import config
    
    app = FastAPI()
    
    
    @lru_cache
    def get_settings():
        return config.Settings()
    
    
    @app.get("/info")
    async def info(settings: Annotated[config.Settings, Depends(get_settings)]):
        return {
            "app_name": settings.app_name,
            "admin_email": settings.admin_email,
            "items_per_user": settings.items_per_user,
        }
    

ü§ì Other versions and variants

Python 3.9+ - non-Annotated

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from functools import lru_cache
    
    from fastapi import Depends, FastAPI
    
    from . import config
    
    app = FastAPI()
    
    
    @lru_cache
    def get_settings():
        return config.Settings()
    
    
    @app.get("/info")
    async def info(settings: config.Settings = Depends(get_settings)):
        return {
            "app_name": settings.app_name,
            "admin_email": settings.admin_email,
            "items_per_user": settings.items_per_user,
        }
    

Then for any subsequent call of `get_settings()` in the dependencies for the next requests, instead of executing the internal code of `get_settings()` and creating a new `Settings` object, it will return the same object that was returned on the first call, again and again.

#### `lru_cache` Technical Details[¶](#lru-cache-technical-details "Permanent link")

`@lru_cache` modifies the function it decorates to return the same value that was returned the first time, instead of computing it again, executing the code of the function every time.

So, the function below it will be executed once for each combination of arguments. And then the values returned by each of those combinations of arguments will be used again and again whenever the function is called with exactly the same combination of arguments.

For example, if you have a function:
    
    
    @lru_cache
    def say_hi(name: str, salutation: str = "Ms."):
        return f"Hello {salutation} {name}"
    

your program could execute like this:
    
    
    sequenceDiagram
    
    participant code as Code
    participant function as say_hi()
    participant execute as Execute function
    
        rect rgba(0, 255, 0, .1)
            code ->> function: say_hi(name="Camila")
            function ->> execute: execute function code
            execute ->> code: return the result
        end
    
        rect rgba(0, 255, 255, .1)
            code ->> function: say_hi(name="Camila")
            function ->> code: return stored result
        end
    
        rect rgba(0, 255, 0, .1)
            code ->> function: say_hi(name="Rick")
            function ->> execute: execute function code
            execute ->> code: return the result
        end
    
        rect rgba(0, 255, 0, .1)
            code ->> function: say_hi(name="Rick", salutation="Mr.")
            function ->> execute: execute function code
            execute ->> code: return the result
        end
    
        rect rgba(0, 255, 255, .1)
            code ->> function: say_hi(name="Rick")
            function ->> code: return stored result
        end
    
        rect rgba(0, 255, 255, .1)
            code ->> function: say_hi(name="Camila")
            function ->> code: return stored result
        end

In the case of our dependency `get_settings()`, the function doesn't even take any arguments, so it always returns the same value.

That way, it behaves almost as if it was just a global variable. But as it uses a dependency function, then we can override it easily for testing.

`@lru_cache` is part of `functools` which is part of Python's standard library, you can read more about it in the [Python docs for `@lru_cache`](https://docs.python.org/3/library/functools.html#functools.lru_cache).

## Recap[¶](#recap "Permanent link")

You can use Pydantic Settings to handle the settings or configurations for your application, with all the power of Pydantic models.

  * By using a dependency you can simplify testing.
  * You can use `.env` files with it.
  * Using `@lru_cache` lets you avoid reading the dotenv file again and again for each request, while allowing you to override it during testing.

---

###### OpenAPI Callbacks¶

# OpenAPI Callbacks[¶](#openapi-callbacks "Permanent link")

You could create an API with a _path operation_ that could trigger a request to an _external API_ created by someone else (probably the same developer that would be _using_ your API).

The process that happens when your API app calls the _external API_ is named a "callback". Because the software that the external developer wrote sends a request to your API and then your API _calls back_ , sending a request to an _external API_ (that was probably created by the same developer).

In this case, you could want to document how that external API _should_ look like. What _path operation_ it should have, what body it should expect, what response it should return, etc.

## An app with callbacks[¶](#an-app-with-callbacks "Permanent link")

Let's see all this with an example.

Imagine you develop an app that allows creating invoices.

These invoices will have an `id`, `title` (optional), `customer`, and `total`.

The user of your API (an external developer) will create an invoice in your API with a POST request.

Then your API will (let's imagine):

  * Send the invoice to some customer of the external developer.
  * Collect the money.
  * Send a notification back to the API user (the external developer).
    * This will be done by sending a POST request (from _your API_) to some _external API_ provided by that external developer (this is the "callback").

## The normal **FastAPI** app[¶](#the-normal-fastapi-app "Permanent link")

Let's first see how the normal API app would look like before adding the callback.

It will have a _path operation_ that will receive an `Invoice` body, and a query parameter `callback_url` that will contain the URL for the callback.

This part is pretty normal, most of the code is probably already familiar to you:

Python 3.10+
    
    
    from fastapi import APIRouter, FastAPI
    from pydantic import BaseModel, HttpUrl
    
    app = FastAPI()
    
    
    class Invoice(BaseModel):
        id: str
        title: str | None = None
        customer: str
        total: float
    
    
    class InvoiceEvent(BaseModel):
        description: str
        paid: bool
    
    
    class InvoiceEventReceived(BaseModel):
        ok: bool
    
    
    invoices_callback_router = APIRouter()
    
    
    @invoices_callback_router.post(
        "{$callback_url}/invoices/{$request.body.id}", response_model=InvoiceEventReceived
    )
    def invoice_notification(body: InvoiceEvent):
        pass
    
    
    @app.post("/invoices/", callbacks=invoices_callback_router.routes)
    def create_invoice(invoice: Invoice, callback_url: HttpUrl | None = None):
        """
        Create an invoice.
    
        This will (let's imagine) let the API user (some external developer) create an
        invoice.
    
        And this path operation will:
    
        * Send the invoice to the client.
        * Collect the money from the client.
        * Send a notification back to the API user (the external developer), as a callback.
            * At this point is that the API will somehow send a POST request to the
                external API with the notification of the invoice event
                (e.g. "payment successful").
        """
        # Send the invoice, collect the money, send the notification (the callback)
        return {"msg": "Invoice received"}
    

ü§ì Other versions and variants

Python 3.9+
    
    
    from typing import Union
    
    from fastapi import APIRouter, FastAPI
    from pydantic import BaseModel, HttpUrl
    
    app = FastAPI()
    
    
    class Invoice(BaseModel):
        id: str
        title: Union[str, None] = None
        customer: str
        total: float
    
    
    class InvoiceEvent(BaseModel):
        description: str
        paid: bool
    
    
    class InvoiceEventReceived(BaseModel):
        ok: bool
    
    
    invoices_callback_router = APIRouter()
    
    
    @invoices_callback_router.post(
        "{$callback_url}/invoices/{$request.body.id}", response_model=InvoiceEventReceived
    )
    def invoice_notification(body: InvoiceEvent):
        pass
    
    
    @app.post("/invoices/", callbacks=invoices_callback_router.routes)
    def create_invoice(invoice: Invoice, callback_url: Union[HttpUrl, None] = None):
        """
        Create an invoice.
    
        This will (let's imagine) let the API user (some external developer) create an
        invoice.
    
        And this path operation will:
    
        * Send the invoice to the client.
        * Collect the money from the client.
        * Send a notification back to the API user (the external developer), as a callback.
            * At this point is that the API will somehow send a POST request to the
                external API with the notification of the invoice event
                (e.g. "payment successful").
        """
        # Send the invoice, collect the money, send the notification (the callback)
        return {"msg": "Invoice received"}
    

Tip

The `callback_url` query parameter uses a Pydantic [Url](https://docs.pydantic.dev/latest/api/networks/) type.

The only new thing is the `callbacks=invoices_callback_router.routes` as an argument to the _path operation decorator_. We'll see what that is next.

## Documenting the callback[¶](#documenting-the-callback "Permanent link")

The actual callback code will depend heavily on your own API app.

And it will probably vary a lot from one app to the next.

It could be just one or two lines of code, like:
    
    
    callback_url = "https://example.com/api/v1/invoices/events/"
    httpx.post(callback_url, json={"description": "Invoice paid", "paid": True})
    

But possibly the most important part of the callback is making sure that your API user (the external developer) implements the _external API_ correctly, according to the data that _your API_ is going to send in the request body of the callback, etc.

So, what we will do next is add the code to document how that _external API_ should look like to receive the callback from _your API_.

That documentation will show up in the Swagger UI at `/docs` in your API, and it will let external developers know how to build the _external API_.

This example doesn't implement the callback itself (that could be just a line of code), only the documentation part.

Tip

The actual callback is just an HTTP request.

When implementing the callback yourself, you could use something like [HTTPX](https://www.python-httpx.org) or [Requests](https://requests.readthedocs.io/).

## Write the callback documentation code[¶](#write-the-callback-documentation-code "Permanent link")

This code won't be executed in your app, we only need it to _document_ how that _external API_ should look like.

But, you already know how to easily create automatic documentation for an API with **FastAPI**.

So we are going to use that same knowledge to document how the _external API_ should look like... by creating the _path operation(s)_ that the external API should implement (the ones your API will call).

Tip

When writing the code to document a callback, it might be useful to imagine that you are that _external developer_. And that you are currently implementing the _external API_ , not _your API_.

Temporarily adopting this point of view (of the _external developer_) can help you feel like it's more obvious where to put the parameters, the Pydantic model for the body, for the response, etc. for that _external API_.

### Create a callback `APIRouter`[¶](#create-a-callback-apirouter "Permanent link")

First create a new `APIRouter` that will contain one or more callbacks.

Python 3.10+
    
    
    from fastapi import APIRouter, FastAPI
    from pydantic import BaseModel, HttpUrl
    
    app = FastAPI()
    
    
    class Invoice(BaseModel):
        id: str
        title: str | None = None
        customer: str
        total: float
    
    
    class InvoiceEvent(BaseModel):
        description: str
        paid: bool
    
    
    class InvoiceEventReceived(BaseModel):
        ok: bool
    
    
    invoices_callback_router = APIRouter()
    
    
    @invoices_callback_router.post(
        "{$callback_url}/invoices/{$request.body.id}", response_model=InvoiceEventReceived
    )
    def invoice_notification(body: InvoiceEvent):
        pass
    
    
    @app.post("/invoices/", callbacks=invoices_callback_router.routes)
    def create_invoice(invoice: Invoice, callback_url: HttpUrl | None = None):
        """
        Create an invoice.
    
        This will (let's imagine) let the API user (some external developer) create an
        invoice.
    
        And this path operation will:
    
        * Send the invoice to the client.
        * Collect the money from the client.
        * Send a notification back to the API user (the external developer), as a callback.
            * At this point is that the API will somehow send a POST request to the
                external API with the notification of the invoice event
                (e.g. "payment successful").
        """
        # Send the invoice, collect the money, send the notification (the callback)
        return {"msg": "Invoice received"}
    

ü§ì Other versions and variants

Python 3.9+
    
    
    from typing import Union
    
    from fastapi import APIRouter, FastAPI
    from pydantic import BaseModel, HttpUrl
    
    app = FastAPI()
    
    
    class Invoice(BaseModel):
        id: str
        title: Union[str, None] = None
        customer: str
        total: float
    
    
    class InvoiceEvent(BaseModel):
        description: str
        paid: bool
    
    
    class InvoiceEventReceived(BaseModel):
        ok: bool
    
    
    invoices_callback_router = APIRouter()
    
    
    @invoices_callback_router.post(
        "{$callback_url}/invoices/{$request.body.id}", response_model=InvoiceEventReceived
    )
    def invoice_notification(body: InvoiceEvent):
        pass
    
    
    @app.post("/invoices/", callbacks=invoices_callback_router.routes)
    def create_invoice(invoice: Invoice, callback_url: Union[HttpUrl, None] = None):
        """
        Create an invoice.
    
        This will (let's imagine) let the API user (some external developer) create an
        invoice.
    
        And this path operation will:
    
        * Send the invoice to the client.
        * Collect the money from the client.
        * Send a notification back to the API user (the external developer), as a callback.
            * At this point is that the API will somehow send a POST request to the
                external API with the notification of the invoice event
                (e.g. "payment successful").
        """
        # Send the invoice, collect the money, send the notification (the callback)
        return {"msg": "Invoice received"}
    

### Create the callback _path operation_[¶](#create-the-callback-path-operation "Permanent link")

To create the callback _path operation_ use the same `APIRouter` you created above.

It should look just like a normal FastAPI _path operation_ :

  * It should probably have a declaration of the body it should receive, e.g. `body: InvoiceEvent`.
  * And it could also have a declaration of the response it should return, e.g. `response_model=InvoiceEventReceived`.

Python 3.10+
    
    
    from fastapi import APIRouter, FastAPI
    from pydantic import BaseModel, HttpUrl
    
    app = FastAPI()
    
    
    class Invoice(BaseModel):
        id: str
        title: str | None = None
        customer: str
        total: float
    
    
    class InvoiceEvent(BaseModel):
        description: str
        paid: bool
    
    
    class InvoiceEventReceived(BaseModel):
        ok: bool
    
    
    invoices_callback_router = APIRouter()
    
    
    @invoices_callback_router.post(
        "{$callback_url}/invoices/{$request.body.id}", response_model=InvoiceEventReceived
    )
    def invoice_notification(body: InvoiceEvent):
        pass
    
    
    @app.post("/invoices/", callbacks=invoices_callback_router.routes)
    def create_invoice(invoice: Invoice, callback_url: HttpUrl | None = None):
        """
        Create an invoice.
    
        This will (let's imagine) let the API user (some external developer) create an
        invoice.
    
        And this path operation will:
    
        * Send the invoice to the client.
        * Collect the money from the client.
        * Send a notification back to the API user (the external developer), as a callback.
            * At this point is that the API will somehow send a POST request to the
                external API with the notification of the invoice event
                (e.g. "payment successful").
        """
        # Send the invoice, collect the money, send the notification (the callback)
        return {"msg": "Invoice received"}
    

ü§ì Other versions and variants

Python 3.9+
    
    
    from typing import Union
    
    from fastapi import APIRouter, FastAPI
    from pydantic import BaseModel, HttpUrl
    
    app = FastAPI()
    
    
    class Invoice(BaseModel):
        id: str
        title: Union[str, None] = None
        customer: str
        total: float
    
    
    class InvoiceEvent(BaseModel):
        description: str
        paid: bool
    
    
    class InvoiceEventReceived(BaseModel):
        ok: bool
    
    
    invoices_callback_router = APIRouter()
    
    
    @invoices_callback_router.post(
        "{$callback_url}/invoices/{$request.body.id}", response_model=InvoiceEventReceived
    )
    def invoice_notification(body: InvoiceEvent):
        pass
    
    
    @app.post("/invoices/", callbacks=invoices_callback_router.routes)
    def create_invoice(invoice: Invoice, callback_url: Union[HttpUrl, None] = None):
        """
        Create an invoice.
    
        This will (let's imagine) let the API user (some external developer) create an
        invoice.
    
        And this path operation will:
    
        * Send the invoice to the client.
        * Collect the money from the client.
        * Send a notification back to the API user (the external developer), as a callback.
            * At this point is that the API will somehow send a POST request to the
                external API with the notification of the invoice event
                (e.g. "payment successful").
        """
        # Send the invoice, collect the money, send the notification (the callback)
        return {"msg": "Invoice received"}
    

There are 2 main differences from a normal _path operation_ :

  * It doesn't need to have any actual code, because your app will never call this code. It's only used to document the _external API_. So, the function could just have `pass`.
  * The _path_ can contain an [OpenAPI 3 expression](https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.1.0.md#key-expression) (see more below) where it can use variables with parameters and parts of the original request sent to _your API_.

### The callback path expression[¶](#the-callback-path-expression "Permanent link")

The callback _path_ can have an [OpenAPI 3 expression](https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.1.0.md#key-expression) that can contain parts of the original request sent to _your API_.

In this case, it's the `str`:
    
    
    "{$callback_url}/invoices/{$request.body.id}"
    

So, if your API user (the external developer) sends a request to _your API_ to:
    
    
    https://yourapi.com/invoices/?callback_url=https://www.external.org/events
    

with a JSON body of:
    
    
    {
        "id": "2expen51ve",
        "customer": "Mr. Richie Rich",
        "total": "9999"
    }
    

then _your API_ will process the invoice, and at some point later, send a callback request to the `callback_url` (the _external API_):
    
    
    https://www.external.org/events/invoices/2expen51ve
    

with a JSON body containing something like:
    
    
    {
        "description": "Payment celebration",
        "paid": true
    }
    

and it would expect a response from that _external API_ with a JSON body like:
    
    
    {
        "ok": true
    }
    

Tip

Notice how the callback URL used contains the URL received as a query parameter in `callback_url` (`https://www.external.org/events`) and also the invoice `id` from inside of the JSON body (`2expen51ve`).

### Add the callback router[¶](#add-the-callback-router "Permanent link")

At this point you have the _callback path operation(s)_ needed (the one(s) that the _external developer_ should implement in the _external API_) in the callback router you created above.

Now use the parameter `callbacks` in _your API's path operation decorator_ to pass the attribute `.routes` (that's actually just a `list` of routes/_path operations_) from that callback router:

Python 3.10+
    
    
    from fastapi import APIRouter, FastAPI
    from pydantic import BaseModel, HttpUrl
    
    app = FastAPI()
    
    
    class Invoice(BaseModel):
        id: str
        title: str | None = None
        customer: str
        total: float
    
    
    class InvoiceEvent(BaseModel):
        description: str
        paid: bool
    
    
    class InvoiceEventReceived(BaseModel):
        ok: bool
    
    
    invoices_callback_router = APIRouter()
    
    
    @invoices_callback_router.post(
        "{$callback_url}/invoices/{$request.body.id}", response_model=InvoiceEventReceived
    )
    def invoice_notification(body: InvoiceEvent):
        pass
    
    
    @app.post("/invoices/", callbacks=invoices_callback_router.routes)
    def create_invoice(invoice: Invoice, callback_url: HttpUrl | None = None):
        """
        Create an invoice.
    
        This will (let's imagine) let the API user (some external developer) create an
        invoice.
    
        And this path operation will:
    
        * Send the invoice to the client.
        * Collect the money from the client.
        * Send a notification back to the API user (the external developer), as a callback.
            * At this point is that the API will somehow send a POST request to the
                external API with the notification of the invoice event
                (e.g. "payment successful").
        """
        # Send the invoice, collect the money, send the notification (the callback)
        return {"msg": "Invoice received"}
    

ü§ì Other versions and variants

Python 3.9+
    
    
    from typing import Union
    
    from fastapi import APIRouter, FastAPI
    from pydantic import BaseModel, HttpUrl
    
    app = FastAPI()
    
    
    class Invoice(BaseModel):
        id: str
        title: Union[str, None] = None
        customer: str
        total: float
    
    
    class InvoiceEvent(BaseModel):
        description: str
        paid: bool
    
    
    class InvoiceEventReceived(BaseModel):
        ok: bool
    
    
    invoices_callback_router = APIRouter()
    
    
    @invoices_callback_router.post(
        "{$callback_url}/invoices/{$request.body.id}", response_model=InvoiceEventReceived
    )
    def invoice_notification(body: InvoiceEvent):
        pass
    
    
    @app.post("/invoices/", callbacks=invoices_callback_router.routes)
    def create_invoice(invoice: Invoice, callback_url: Union[HttpUrl, None] = None):
        """
        Create an invoice.
    
        This will (let's imagine) let the API user (some external developer) create an
        invoice.
    
        And this path operation will:
    
        * Send the invoice to the client.
        * Collect the money from the client.
        * Send a notification back to the API user (the external developer), as a callback.
            * At this point is that the API will somehow send a POST request to the
                external API with the notification of the invoice event
                (e.g. "payment successful").
        """
        # Send the invoice, collect the money, send the notification (the callback)
        return {"msg": "Invoice received"}
    

Tip

Notice that you are not passing the router itself (`invoices_callback_router`) to `callback=`, but the attribute `.routes`, as in `invoices_callback_router.routes`.

### Check the docs[¶](#check-the-docs "Permanent link")

Now you can start your app and go to <http://127.0.0.1:8000/docs>.

You will see your docs including a "Callbacks" section for your _path operation_ that shows how the _external API_ should look like:

![](/img/tutorial/openapi-callbacks/image01.png)

---

###### OpenAPI Webhooks¶

# OpenAPI Webhooks[¶](#openapi-webhooks "Permanent link")

There are cases where you want to tell your API **users** that your app could call _their_ app (sending a request) with some data, normally to **notify** of some type of **event**.

This means that instead of the normal process of your users sending requests to your API, it's **your API** (or your app) that could **send requests to their system** (to their API, their app).

This is normally called a **webhook**.

## Webhooks steps[¶](#webhooks-steps "Permanent link")

The process normally is that **you define** in your code what is the message that you will send, the **body of the request**.

You also define in some way at which **moments** your app will send those requests or events.

And **your users** define in some way (for example in a web dashboard somewhere) the **URL** where your app should send those requests.

All the **logic** about how to register the URLs for webhooks and the code to actually send those requests is up to you. You write it however you want to in **your own code**.

## Documenting webhooks with **FastAPI** and OpenAPI[¶](#documenting-webhooks-with-fastapi-and-openapi "Permanent link")

With **FastAPI** , using OpenAPI, you can define the names of these webhooks, the types of HTTP operations that your app can send (e.g. `POST`, `PUT`, etc.) and the request **bodies** that your app would send.

This can make it a lot easier for your users to **implement their APIs** to receive your **webhook** requests, they might even be able to autogenerate some of their own API code.

Info

Webhooks are available in OpenAPI 3.1.0 and above, supported by FastAPI `0.99.0` and above.

## An app with webhooks[¶](#an-app-with-webhooks "Permanent link")

When you create a **FastAPI** application, there is a `webhooks` attribute that you can use to define _webhooks_ , the same way you would define _path operations_ , for example with `@app.webhooks.post()`.

Python 3.9+
    
    
    from datetime import datetime
    
    from fastapi import FastAPI
    from pydantic import BaseModel
    
    app = FastAPI()
    
    
    class Subscription(BaseModel):
        username: str
        monthly_fee: float
        start_date: datetime
    
    
    @app.webhooks.post("new-subscription")
    def new_subscription(body: Subscription):
        """
        When a new user subscribes to your service we'll send you a POST request with this
        data to the URL that you register for the event `new-subscription` in the dashboard.
        """
    
    
    @app.get("/users/")
    def read_users():
        return ["Rick", "Morty"]
    

The webhooks that you define will end up in the **OpenAPI** schema and the automatic **docs UI**.

Info

The `app.webhooks` object is actually just an `APIRouter`, the same type you would use when structuring your app with multiple files.

Notice that with webhooks you are actually not declaring a _path_ (like `/items/`), the text you pass there is just an **identifier** of the webhook (the name of the event), for example in `@app.webhooks.post("new-subscription")`, the webhook name is `new-subscription`.

This is because it is expected that **your users** would define the actual **URL path** where they want to receive the webhook request in some other way (e.g. a web dashboard).

### Check the docs[¶](#check-the-docs "Permanent link")

Now you can start your app and go to <http://127.0.0.1:8000/docs>.

You will see your docs have the normal _path operations_ and now also some **webhooks** :

![](/img/tutorial/openapi-webhooks/image01.png)

---

###### Including WSGI - Flask, Django, others¶

# Including WSGI - Flask, Django, others[¶](#including-wsgi-flask-django-others "Permanent link")

You can mount WSGI applications as you saw with [Sub Applications - Mounts](../sub-applications/), [Behind a Proxy](../behind-a-proxy/).

For that, you can use the `WSGIMiddleware` and use it to wrap your WSGI application, for example, Flask, Django, etc.

## Using `WSGIMiddleware`[¶](#using-wsgimiddleware "Permanent link")

Info

This requires installing `a2wsgi` for example with `pip install a2wsgi`.

You need to import `WSGIMiddleware` from `a2wsgi`.

Then wrap the WSGI (e.g. Flask) app with the middleware.

And then mount that under a path.

Python 3.9+
    
    
    from a2wsgi import WSGIMiddleware
    from fastapi import FastAPI
    from flask import Flask, request
    from markupsafe import escape
    
    flask_app = Flask(__name__)
    
    
    @flask_app.route("/")
    def flask_main():
        name = request.args.get("name", "World")
        return f"Hello, {escape(name)} from Flask!"
    
    
    app = FastAPI()
    
    
    @app.get("/v2")
    def read_main():
        return {"message": "Hello World"}
    
    
    app.mount("/v1", WSGIMiddleware(flask_app))
    

Note

Previously, it was recommended to use `WSGIMiddleware` from `fastapi.middleware.wsgi`, but it is now deprecated.

It‚Äôs advised to use the `a2wsgi` package instead. The usage remains the same.

Just ensure that you have the `a2wsgi` package installed and import `WSGIMiddleware` correctly from `a2wsgi`.

## Check it[¶](#check-it "Permanent link")

Now, every request under the path `/v1/` will be handled by the Flask application.

And the rest will be handled by **FastAPI**.

If you run it and go to <http://localhost:8000/v1/> you will see the response from Flask:
    
    
    Hello, World from Flask!
    

And if you go to <http://localhost:8000/v2> you will see the response from FastAPI:
    
    
    {
        "message": "Hello World"
    }

---

###### Generating SDKs¶

# Generating SDKs[¶](#generating-sdks "Permanent link")

Because **FastAPI** is based on the **OpenAPI** specification, its APIs can be described in a standard format that many tools understand.

This makes it easy to generate up-to-date **documentation** , client libraries (**SDKs**) in multiple languages, and **testing** or **automation workflows** that stay in sync with your code.

In this guide, you'll learn how to generate a **TypeScript SDK** for your FastAPI backend.

## Open Source SDK Generators[¶](#open-source-sdk-generators "Permanent link")

A versatile option is the [OpenAPI Generator](https://openapi-generator.tech/), which supports **many programming languages** and can generate SDKs from your OpenAPI specification.

For **TypeScript clients** , [Hey API](https://heyapi.dev/) is a purpose-built solution, providing an optimized experience for the TypeScript ecosystem.

You can discover more SDK generators on [OpenAPI.Tools](https://openapi.tools/#sdk).

Tip

FastAPI automatically generates **OpenAPI 3.1** specifications, so any tool you use must support this version.

## SDK Generators from FastAPI Sponsors[¶](#sdk-generators-from-fastapi-sponsors "Permanent link")

This section highlights **venture-backed** and **company-supported** solutions from companies that sponsor FastAPI. These products provide **additional features** and **integrations** on top of high-quality generated SDKs.

By ‚ú® [**sponsoring FastAPI**](../../help-fastapi/#sponsor-the-author) ‚ú®, these companies help ensure the framework and its **ecosystem** remain healthy and **sustainable**.

Their sponsorship also demonstrates a strong commitment to the FastAPI **community** (you), showing that they care not only about offering a **great service** but also about supporting a **robust and thriving framework** , FastAPI. üôá

For example, you might want to try:

  * [Speakeasy](https://speakeasy.com/editor?utm_source=fastapi+repo&utm_medium=github+sponsorship)
  * [Stainless](https://www.stainless.com/?utm_source=fastapi&utm_medium=referral)
  * [liblab](https://developers.liblab.com/tutorials/sdk-for-fastapi?utm_source=fastapi)

Some of these solutions may also be open source or offer free tiers, so you can try them without a financial commitment. Other commercial SDK generators are available and can be found online. ü§ì

## Create a TypeScript SDK[¶](#create-a-typescript-sdk "Permanent link")

Let's start with a simple FastAPI application:

Python 3.9+
    
    
    from fastapi import FastAPI
    from pydantic import BaseModel
    
    app = FastAPI()
    
    
    class Item(BaseModel):
        name: str
        price: float
    
    
    class ResponseMessage(BaseModel):
        message: str
    
    
    @app.post("/items/", response_model=ResponseMessage)
    async def create_item(item: Item):
        return {"message": "item received"}
    
    
    @app.get("/items/", response_model=list[Item])
    async def get_items():
        return [
            {"name": "Plumbus", "price": 3},
            {"name": "Portal Gun", "price": 9001},
        ]
    

Notice that the _path operations_ define the models they use for request payload and response payload, using the models `Item` and `ResponseMessage`.

### API Docs[¶](#api-docs "Permanent link")

If you go to `/docs`, you will see that it has the **schemas** for the data to be sent in requests and received in responses:

![](/img/tutorial/generate-clients/image01.png)

You can see those schemas because they were declared with the models in the app.

That information is available in the app's **OpenAPI schema** , and then shown in the API docs.

That same information from the models that is included in OpenAPI is what can be used to **generate the client code**.

### Hey API[¶](#hey-api "Permanent link")

Once we have a FastAPI app with the models, we can use Hey API to generate a TypeScript client. The fastest way to do that is via npx.
    
    
    npx @hey-api/openapi-ts -i http://localhost:8000/openapi.json -o src/client
    

This will generate a TypeScript SDK in `./src/client`.

You can learn how to [install `@hey-api/openapi-ts`](https://heyapi.dev/openapi-ts/get-started) and read about the [generated output](https://heyapi.dev/openapi-ts/output) on their website.

### Using the SDK[¶](#using-the-sdk "Permanent link")

Now you can import and use the client code. It could look like this, notice that you get autocompletion for the methods:

![](/img/tutorial/generate-clients/image02.png)

You will also get autocompletion for the payload to send:

![](/img/tutorial/generate-clients/image03.png)

Tip

Notice the autocompletion for `name` and `price`, that was defined in the FastAPI application, in the `Item` model.

You will have inline errors for the data that you send:

![](/img/tutorial/generate-clients/image04.png)

The response object will also have autocompletion:

![](/img/tutorial/generate-clients/image05.png)

## FastAPI App with Tags[¶](#fastapi-app-with-tags "Permanent link")

In many cases, your FastAPI app will be bigger, and you will probably use tags to separate different groups of _path operations_.

For example, you could have a section for **items** and another section for **users** , and they could be separated by tags:

Python 3.9+
    
    
    from fastapi import FastAPI
    from pydantic import BaseModel
    
    app = FastAPI()
    
    
    class Item(BaseModel):
        name: str
        price: float
    
    
    class ResponseMessage(BaseModel):
        message: str
    
    
    class User(BaseModel):
        username: str
        email: str
    
    
    @app.post("/items/", response_model=ResponseMessage, tags=["items"])
    async def create_item(item: Item):
        return {"message": "Item received"}
    
    
    @app.get("/items/", response_model=list[Item], tags=["items"])
    async def get_items():
        return [
            {"name": "Plumbus", "price": 3},
            {"name": "Portal Gun", "price": 9001},
        ]
    
    
    @app.post("/users/", response_model=ResponseMessage, tags=["users"])
    async def create_user(user: User):
        return {"message": "User received"}
    

### Generate a TypeScript Client with Tags[¶](#generate-a-typescript-client-with-tags "Permanent link")

If you generate a client for a FastAPI app using tags, it will normally also separate the client code based on the tags.

This way, you will be able to have things ordered and grouped correctly for the client code:

![](/img/tutorial/generate-clients/image06.png)

In this case, you have:

  * `ItemsService`
  * `UsersService`

### Client Method Names[¶](#client-method-names "Permanent link")

Right now, the generated method names like `createItemItemsPost` don't look very clean:
    
    
    ItemsService.createItemItemsPost({name: "Plumbus", price: 5})
    

...that's because the client generator uses the OpenAPI internal **operation ID** for each _path operation_.

OpenAPI requires that each operation ID is unique across all the _path operations_ , so FastAPI uses the **function name** , the **path** , and the **HTTP method/operation** to generate that operation ID, because that way it can make sure that the operation IDs are unique.

But I'll show you how to improve that next. ü§ì

## Custom Operation IDs and Better Method Names[¶](#custom-operation-ids-and-better-method-names "Permanent link")

You can **modify** the way these operation IDs are **generated** to make them simpler and have **simpler method names** in the clients.

In this case, you will have to ensure that each operation ID is **unique** in some other way.

For example, you could make sure that each _path operation_ has a tag, and then generate the operation ID based on the **tag** and the _path operation_ **name** (the function name).

### Custom Generate Unique ID Function[¶](#custom-generate-unique-id-function "Permanent link")

FastAPI uses a **unique ID** for each _path operation_ , which is used for the **operation ID** and also for the names of any needed custom models, for requests or responses.

You can customize that function. It takes an `APIRoute` and outputs a string.

For example, here it is using the first tag (you will probably have only one tag) and the _path operation_ name (the function name).

You can then pass that custom function to **FastAPI** as the `generate_unique_id_function` parameter:

Python 3.9+
    
    
    from fastapi import FastAPI
    from fastapi.routing import APIRoute
    from pydantic import BaseModel
    
    
    def custom_generate_unique_id(route: APIRoute):
        return f"{route.tags[0]}-{route.name}"
    
    
    app = FastAPI(generate_unique_id_function=custom_generate_unique_id)
    
    
    class Item(BaseModel):
        name: str
        price: float
    
    
    class ResponseMessage(BaseModel):
        message: str
    
    
    class User(BaseModel):
        username: str
        email: str
    
    
    @app.post("/items/", response_model=ResponseMessage, tags=["items"])
    async def create_item(item: Item):
        return {"message": "Item received"}
    
    
    @app.get("/items/", response_model=list[Item], tags=["items"])
    async def get_items():
        return [
            {"name": "Plumbus", "price": 3},
            {"name": "Portal Gun", "price": 9001},
        ]
    
    
    @app.post("/users/", response_model=ResponseMessage, tags=["users"])
    async def create_user(user: User):
        return {"message": "User received"}
    

### Generate a TypeScript Client with Custom Operation IDs[¶](#generate-a-typescript-client-with-custom-operation-ids "Permanent link")

Now, if you generate the client again, you will see that it has the improved method names:

![](/img/tutorial/generate-clients/image07.png)

As you see, the method names now have the tag and then the function name, now they don't include information from the URL path and the HTTP operation.

### Preprocess the OpenAPI Specification for the Client Generator[¶](#preprocess-the-openapi-specification-for-the-client-generator "Permanent link")

The generated code still has some **duplicated information**.

We already know that this method is related to the **items** because that word is in the `ItemsService` (taken from the tag), but we still have the tag name prefixed in the method name too. üòï

We will probably still want to keep it for OpenAPI in general, as that will ensure that the operation IDs are **unique**.

But for the generated client, we could **modify** the OpenAPI operation IDs right before generating the clients, just to make those method names nicer and **cleaner**.

We could download the OpenAPI JSON to a file `openapi.json` and then we could **remove that prefixed tag** with a script like this:

Python 3.9+Node.js
    
    
    import json
    from pathlib import Path
    
    file_path = Path("./openapi.json")
    openapi_content = json.loads(file_path.read_text())
    
    for path_data in openapi_content["paths"].values():
        for operation in path_data.values():
            tag = operation["tags"][0]
            operation_id = operation["operationId"]
            to_remove = f"{tag}-"
            new_operation_id = operation_id[len(to_remove) :]
            operation["operationId"] = new_operation_id
    
    file_path.write_text(json.dumps(openapi_content))
    
    
    
    import * as fs from 'fs'
    
    async function modifyOpenAPIFile(filePath) {
      try {
        const data = await fs.promises.readFile(filePath)
        const openapiContent = JSON.parse(data)
    
        const paths = openapiContent.paths
        for (const pathKey of Object.keys(paths)) {
          const pathData = paths[pathKey]
          for (const method of Object.keys(pathData)) {
            const operation = pathData[method]
            if (operation.tags && operation.tags.length > 0) {
              const tag = operation.tags[0]
              const operationId = operation.operationId
              const toRemove = `${tag}-`
              if (operationId.startsWith(toRemove)) {
                const newOperationId = operationId.substring(toRemove.length)
                operation.operationId = newOperationId
              }
            }
          }
        }
    
        await fs.promises.writeFile(
          filePath,
          JSON.stringify(openapiContent, null, 2),
        )
        console.log('File successfully modified')
      } catch (err) {
        console.error('Error:', err)
      }
    }
    
    const filePath = './openapi.json'
    modifyOpenAPIFile(filePath)
    

With that, the operation IDs would be renamed from things like `items-get_items` to just `get_items`, that way the client generator can generate simpler method names.

### Generate a TypeScript Client with the Preprocessed OpenAPI[¶](#generate-a-typescript-client-with-the-preprocessed-openapi "Permanent link")

Since the end result is now in an `openapi.json` file, you need to update your input location:
    
    
    npx @hey-api/openapi-ts -i ./openapi.json -o src/client
    

After generating the new client, you would now have **clean method names** , with all the **autocompletion** , **inline errors** , etc:

![](/img/tutorial/generate-clients/image08.png)

## Benefits[¶](#benefits "Permanent link")

When using the automatically generated clients, you would get **autocompletion** for:

  * Methods.
  * Request payloads in the body, query parameters, etc.
  * Response payloads.

You would also have **inline errors** for everything.

And whenever you update the backend code, and **regenerate** the frontend, it would have any new _path operations_ available as methods, the old ones removed, and any other change would be reflected on the generated code. ü§ì

This also means that if something changed, it will be **reflected** on the client code automatically. And if you **build** the client, it will error out if you have any **mismatch** in the data used.

So, you would **detect many errors** very early in the development cycle instead of having to wait for the errors to show up to your final users in production and then trying to debug where the problem is. ‚ú®
  *[**SDKs**]: Software Development Kits

---

###### FastAPI CLI¶

# FastAPI CLI[¶](#fastapi-cli "Permanent link")

**FastAPI CLI** is a command line program that you can use to serve your FastAPI app, manage your FastAPI project, and more.

When you install FastAPI (e.g. with `pip install "fastapi[standard]"`), it includes a package called `fastapi-cli`, this package provides the `fastapi` command in the terminal.

To run your FastAPI app for development, you can use the `fastapi dev` command:
    
    
    $ <font color="#4E9A06">fastapi</font> dev <u style="text-decoration-style:solid">main.py</u>
    
      <span style="background-color:#009485"><font color="#D3D7CF"> FastAPI </font></span>  Starting development server üöÄ
    
                 Searching for package file structure from directories with
                 <font color="#3465A4">__init__.py</font> files
                 Importing from <font color="#75507B">/home/user/code/</font><font color="#AD7FA8">awesomeapp</font>
    
       <span style="background-color:#007166"><font color="#D3D7CF"> module </font></span>  üêç main.py
    
         <span style="background-color:#007166"><font color="#D3D7CF"> code </font></span>  Importing the FastAPI app object from the module with the
                 following code:
    
                 <u style="text-decoration-style:solid">from </u><u style="text-decoration-style:solid"><b>main</b></u><u style="text-decoration-style:solid"> import </u><u style="text-decoration-style:solid"><b>app</b></u>
    
          <span style="background-color:#007166"><font color="#D3D7CF"> app </font></span>  Using import string: <font color="#3465A4">main:app</font>
    
       <span style="background-color:#007166"><font color="#D3D7CF"> server </font></span>  Server started at <font color="#729FCF"><u style="text-decoration-style:solid">http://127.0.0.1:8000</u></font>
       <span style="background-color:#007166"><font color="#D3D7CF"> server </font></span>  Documentation at <font color="#729FCF"><u style="text-decoration-style:solid">http://127.0.0.1:8000/docs</u></font>
    
          <span style="background-color:#007166"><font color="#D3D7CF"> tip </font></span>  Running in development mode, for production use:
                 <b>fastapi run</b>
    
                 Logs:
    
         <span style="background-color:#007166"><font color="#D3D7CF"> INFO </font></span>  Will watch for changes in these directories:
                 <b>[</b><font color="#4E9A06">&apos;/home/user/code/awesomeapp&apos;</font><b>]</b>
         <span style="background-color:#007166"><font color="#D3D7CF"> INFO </font></span>  Uvicorn running on <font color="#729FCF"><u style="text-decoration-style:solid">http://127.0.0.1:8000</u></font> <b>(</b>Press CTRL+C to
                 quit<b>)</b>
         <span style="background-color:#007166"><font color="#D3D7CF"> INFO </font></span>  Started reloader process <b>[</b><font color="#34E2E2"><b>383138</b></font><b>]</b> using WatchFiles
         <span style="background-color:#007166"><font color="#D3D7CF"> INFO </font></span>  Started server process <b>[</b><font color="#34E2E2"><b>383153</b></font><b>]</b>
         <span style="background-color:#007166"><font color="#D3D7CF"> INFO </font></span>  Waiting for application startup.
         <span style="background-color:#007166"><font color="#D3D7CF"> INFO </font></span>  Application startup complete.
    

The command line program called `fastapi` is **FastAPI CLI**.

FastAPI CLI takes the path to your Python program (e.g. `main.py`) and automatically detects the `FastAPI` instance (commonly named `app`), determines the correct import process, and then serves it.

For production you would use `fastapi run` instead. üöÄ

Internally, **FastAPI CLI** uses [Uvicorn](https://www.uvicorn.dev), a high-performance, production-ready, ASGI server. üòé

## `fastapi dev`[¶](#fastapi-dev "Permanent link")

Running `fastapi dev` initiates development mode.

By default, **auto-reload** is enabled, automatically reloading the server when you make changes to your code. This is resource-intensive and could be less stable than when it's disabled. You should only use it for development. It also listens on the IP address `127.0.0.1`, which is the IP for your machine to communicate with itself alone (`localhost`).

## `fastapi run`[¶](#fastapi-run "Permanent link")

Executing `fastapi run` starts FastAPI in production mode by default.

By default, **auto-reload** is disabled. It also listens on the IP address `0.0.0.0`, which means all the available IP addresses, this way it will be publicly accessible to anyone that can communicate with the machine. This is how you would normally run it in production, for example, in a container.

In most cases you would (and should) have a "termination proxy" handling HTTPS for you on top, this will depend on how you deploy your application, your provider might do this for you, or you might need to set it up yourself.

Tip

You can learn more about it in the [deployment documentation](../deployment/).

---

###### Deployment¶

# Deployment[¶](#deployment "Permanent link")

Deploying a **FastAPI** application is relatively easy.

## What Does Deployment Mean[¶](#what-does-deployment-mean "Permanent link")

To **deploy** an application means to perform the necessary steps to make it **available to the users**.

For a **web API** , it normally involves putting it in a **remote machine** , with a **server program** that provides good performance, stability, etc, so that your **users** can **access** the application efficiently and without interruptions or problems.

This is in contrast to the **development** stages, where you are constantly changing the code, breaking it and fixing it, stopping and restarting the development server, etc.

## Deployment Strategies[¶](#deployment-strategies "Permanent link")

There are several ways to do it depending on your specific use case and the tools that you use.

You could **deploy a server** yourself using a combination of tools, you could use a **cloud service** that does part of the work for you, or other possible options.

For example, we, the team behind FastAPI, built [**FastAPI Cloud**](https://fastapicloud.com), to make deploying FastAPI apps to the cloud as streamlined as possible, with the same developer experience of working with FastAPI.

I will show you some of the main concepts you should probably keep in mind when deploying a **FastAPI** application (although most of it applies to any other type of web application).

You will see more details to keep in mind and some of the techniques to do it in the next sections. ‚ú®

---

###### About FastAPI versions¶

# About FastAPI versions[¶](#about-fastapi-versions "Permanent link")

**FastAPI** is already being used in production in many applications and systems. And the test coverage is kept at 100%. But its development is still moving quickly.

New features are added frequently, bugs are fixed regularly, and the code is still continuously improving.

That's why the current versions are still `0.x.x`, this reflects that each version could potentially have breaking changes. This follows the [Semantic Versioning](https://semver.org/) conventions.

You can create production applications with **FastAPI** right now (and you have probably been doing it for some time), you just have to make sure that you use a version that works correctly with the rest of your code.

## Pin your `fastapi` version[¶](#pin-your-fastapi-version "Permanent link")

The first thing you should do is to "pin" the version of **FastAPI** you are using to the specific latest version that you know works correctly for your application.

For example, let's say you are using version `0.112.0` in your app.

If you use a `requirements.txt` file you could specify the version with:
    
    
    fastapi[standard]==0.112.0
    

that would mean that you would use exactly the version `0.112.0`.

Or you could also pin it with:
    
    
    fastapi[standard]>=0.112.0,<0.113.0
    

that would mean that you would use the versions `0.112.0` or above, but less than `0.113.0`, for example, a version `0.112.2` would still be accepted.

If you use any other tool to manage your installations, like `uv`, Poetry, Pipenv, or others, they all have a way that you can use to define specific versions for your packages.

## Available versions[¶](#available-versions "Permanent link")

You can see the available versions (e.g. to check what is the current latest) in the [Release Notes](../../release-notes/).

## About versions[¶](#about-versions "Permanent link")

Following the Semantic Versioning conventions, any version below `1.0.0` could potentially add breaking changes.

FastAPI also follows the convention that any "PATCH" version change is for bug fixes and non-breaking changes.

Tip

The "PATCH" is the last number, for example, in `0.2.3`, the PATCH version is `3`.

So, you should be able to pin to a version like:
    
    
    fastapi>=0.45.0,<0.46.0
    

Breaking changes and new features are added in "MINOR" versions.

Tip

The "MINOR" is the number in the middle, for example, in `0.2.3`, the MINOR version is `2`.

## Upgrading the FastAPI versions[¶](#upgrading-the-fastapi-versions "Permanent link")

You should add tests for your app.

With **FastAPI** it's very easy (thanks to Starlette), check the docs: [Testing](../../tutorial/testing/)

After you have tests, then you can upgrade the **FastAPI** version to a more recent one, and make sure that all your code is working correctly by running your tests.

If everything is working, or after you make the necessary changes, and all your tests are passing, then you can pin your `fastapi` to that new recent version.

## About Starlette[¶](#about-starlette "Permanent link")

You shouldn't pin the version of `starlette`.

Different versions of **FastAPI** will use a specific newer version of Starlette.

So, you can just let **FastAPI** use the correct Starlette version.

## About Pydantic[¶](#about-pydantic "Permanent link")

Pydantic includes the tests for **FastAPI** with its own tests, so new versions of Pydantic (above `1.0.0`) are always compatible with FastAPI.

You can pin Pydantic to any version above `1.0.0` that works for you.

For example:
    
    
    pydantic>=2.7.0,<3.0.0

---

###### FastAPI Cloud¶

# FastAPI Cloud[¶](#fastapi-cloud "Permanent link")

You can deploy your FastAPI app to [FastAPI Cloud](https://fastapicloud.com) with **one command** , go and join the waiting list if you haven't. üöÄ

## Login[¶](#login "Permanent link")

Make sure you already have a **FastAPI Cloud** account (we invited you from the waiting list üòâ).

Then log in:
    
    
    $ fastapi login
    
    You are logged in to FastAPI Cloud üöÄ
    

## Deploy[¶](#deploy "Permanent link")

Now deploy your app, with **one command** :
    
    
    $ fastapi deploy
    
    Deploying to FastAPI Cloud...
    
    ‚úÖ Deployment successful!
    
    üêî Ready the chicken! Your app is ready at https://myapp.fastapicloud.dev
    

That's it! Now you can access your app at that URL. ‚ú®

## About FastAPI Cloud[¶](#about-fastapi-cloud "Permanent link")

**[FastAPI Cloud](https://fastapicloud.com)** is built by the same author and team behind **FastAPI**.

It streamlines the process of **building** , **deploying** , and **accessing** an API with minimal effort.

It brings the same **developer experience** of building apps with FastAPI to **deploying** them to the cloud. üéâ

It will also take care of most of the things you would need when deploying an app, like:

  * HTTPS
  * Replication, with autoscaling based on requests
  * etc.

FastAPI Cloud is the primary sponsor and funding provider for the _FastAPI and friends_ open source projects. ‚ú®

## Deploy to other cloud providers[¶](#deploy-to-other-cloud-providers "Permanent link")

FastAPI is open source and based on standards. You can deploy FastAPI apps to any cloud provider you choose.

Follow your cloud provider's guides to deploy FastAPI apps with them. ü§ì

## Deploy your own server[¶](#deploy-your-own-server "Permanent link")

I will also teach you later in this **Deployment** guide all the details, so you can understand what is going on, what needs to happen, or how to deploy FastAPI apps on your own, also with your own servers. ü§ì

---

###### About HTTPS¶

# About HTTPS[¶](#about-https "Permanent link")

It is easy to assume that HTTPS is something that is just "enabled" or not.

But it is way more complex than that.

Tip

If you are in a hurry or don't care, continue with the next sections for step by step instructions to set everything up with different techniques.

To **learn the basics of HTTPS** , from a consumer perspective, check <https://howhttps.works/>.

Now, from a **developer's perspective** , here are several things to keep in mind while thinking about HTTPS:

  * For HTTPS, **the server** needs to **have "certificates"** generated by a **third party**.
    * Those certificates are actually **acquired** from the third party, not "generated".
  * Certificates have a **lifetime**.
    * They **expire**.
    * And then they need to be **renewed** , **acquired again** from the third party.
  * The encryption of the connection happens at the **TCP level**.
    * That's one layer **below HTTP**.
    * So, the **certificate and encryption** handling is done **before HTTP**.
  * **TCP doesn't know about "domains"**. Only about IP addresses.
    * The information about the **specific domain** requested goes in the **HTTP data**.
  * The **HTTPS certificates** "certify" a **certain domain** , but the protocol and encryption happen at the TCP level, **before knowing** which domain is being dealt with.
  * **By default** , that would mean that you can only have **one HTTPS certificate per IP address**.
    * No matter how big your server is or how small each application you have on it might be.
    * There is a **solution** to this, however.
  * There's an **extension** to the **TLS** protocol (the one handling the encryption at the TCP level, before HTTP) called **[SNI](https://en.wikipedia.org/wiki/Server_Name_Indication)**.
    * This SNI extension allows one single server (with a **single IP address**) to have **several HTTPS certificates** and serve **multiple HTTPS domains/applications**.
    * For this to work, a **single** component (program) running on the server, listening on the **public IP address** , must have **all the HTTPS certificates** in the server.
  * **After** obtaining a secure connection, the communication protocol is **still HTTP**.
    * The contents are **encrypted** , even though they are being sent with the **HTTP protocol**.

It is a common practice to have **one program/HTTP server** running on the server (the machine, host, etc.) and **managing all the HTTPS parts** : receiving the **encrypted HTTPS requests** , sending the **decrypted HTTP requests** to the actual HTTP application running in the same server (the **FastAPI** application, in this case), take the **HTTP response** from the application, **encrypt it** using the appropriate **HTTPS certificate** and sending it back to the client using **HTTPS**. This server is often called a **[TLS Termination Proxy](https://en.wikipedia.org/wiki/TLS_termination_proxy)**.

Some of the options you could use as a TLS Termination Proxy are:

  * Traefik (that can also handle certificate renewals)
  * Caddy (that can also handle certificate renewals)
  * Nginx
  * HAProxy

## Let's Encrypt[¶](#lets-encrypt "Permanent link")

Before Let's Encrypt, these **HTTPS certificates** were sold by trusted third parties.

The process to acquire one of these certificates used to be cumbersome, require quite some paperwork and the certificates were quite expensive.

But then **[Let's Encrypt](https://letsencrypt.org/)** was created.

It is a project from the Linux Foundation. It provides **HTTPS certificates for free** , in an automated way. These certificates use all the standard cryptographic security, and are short-lived (about 3 months), so the **security is actually better** because of their reduced lifespan.

The domains are securely verified and the certificates are generated automatically. This also allows automating the renewal of these certificates.

The idea is to automate the acquisition and renewal of these certificates so that you can have **secure HTTPS, for free, forever**.

## HTTPS for Developers[¶](#https-for-developers "Permanent link")

Here's an example of how an HTTPS API could look like, step by step, paying attention mainly to the ideas important for developers.

### Domain Name[¶](#domain-name "Permanent link")

It would probably all start by you **acquiring** some **domain name**. Then, you would configure it in a DNS server (possibly your same cloud provider).

You would probably get a cloud server (a virtual machine) or something similar, and it would have a fixed **public IP address**.

In the DNS server(s) you would configure a record (an "`A record`") to point **your domain** to the public **IP address of your server**.

You would probably do this just once, the first time, when setting everything up.

Tip

This Domain Name part is way before HTTPS, but as everything depends on the domain and the IP address, it's worth mentioning it here.

### DNS[¶](#dns "Permanent link")

Now let's focus on all the actual HTTPS parts.

First, the browser would check with the **DNS servers** what is the **IP for the domain** , in this case, `someapp.example.com`.

The DNS servers would tell the browser to use some specific **IP address**. That would be the public IP address used by your server, that you configured in the DNS servers.

![](/img/deployment/https/https01.drawio.svg)

### TLS Handshake Start[¶](#tls-handshake-start "Permanent link")

The browser would then communicate with that IP address on **port 443** (the HTTPS port).

The first part of the communication is just to establish the connection between the client and the server and to decide the cryptographic keys they will use, etc.

![](/img/deployment/https/https02.drawio.svg)

This interaction between the client and the server to establish the TLS connection is called the **TLS handshake**.

### TLS with SNI Extension[¶](#tls-with-sni-extension "Permanent link")

**Only one process** in the server can be listening on a specific **port** in a specific **IP address**. There could be other processes listening on other ports in the same IP address, but only one for each combination of IP address and port.

TLS (HTTPS) uses the specific port `443` by default. So that's the port we would need.

As only one process can be listening on this port, the process that would do it would be the **TLS Termination Proxy**.

The TLS Termination Proxy would have access to one or more **TLS certificates** (HTTPS certificates).

Using the **SNI extension** discussed above, the TLS Termination Proxy would check which of the TLS (HTTPS) certificates available it should use for this connection, using the one that matches the domain expected by the client.

In this case, it would use the certificate for `someapp.example.com`.

![](/img/deployment/https/https03.drawio.svg)

The client already **trusts** the entity that generated that TLS certificate (in this case Let's Encrypt, but we'll see about that later), so it can **verify** that the certificate is valid.

Then, using the certificate, the client and the TLS Termination Proxy **decide how to encrypt** the rest of the **TCP communication**. This completes the **TLS Handshake** part.

After this, the client and the server have an **encrypted TCP connection** , this is what TLS provides. And then they can use that connection to start the actual **HTTP communication**.

And that's what **HTTPS** is, it's just plain **HTTP** inside a **secure TLS connection** instead of a pure (unencrypted) TCP connection.

Tip

Notice that the encryption of the communication happens at the **TCP level** , not at the HTTP level.

### HTTPS Request[¶](#https-request "Permanent link")

Now that the client and server (specifically the browser and the TLS Termination Proxy) have an **encrypted TCP connection** , they can start the **HTTP communication**.

So, the client sends an **HTTPS request**. This is just an HTTP request through an encrypted TLS connection.

![](/img/deployment/https/https04.drawio.svg)

### Decrypt the Request[¶](#decrypt-the-request "Permanent link")

The TLS Termination Proxy would use the encryption agreed to **decrypt the request** , and would transmit the **plain (decrypted) HTTP request** to the process running the application (for example a process with Uvicorn running the FastAPI application).

![](/img/deployment/https/https05.drawio.svg)

### HTTP Response[¶](#http-response "Permanent link")

The application would process the request and send a **plain (unencrypted) HTTP response** to the TLS Termination Proxy.

![](/img/deployment/https/https06.drawio.svg)

### HTTPS Response[¶](#https-response "Permanent link")

The TLS Termination Proxy would then **encrypt the response** using the cryptography agreed before (that started with the certificate for `someapp.example.com`), and send it back to the browser.

Next, the browser would verify that the response is valid and encrypted with the right cryptographic key, etc. It would then **decrypt the response** and process it.

![](/img/deployment/https/https07.drawio.svg)

The client (browser) will know that the response comes from the correct server because it is using the cryptography they agreed using the **HTTPS certificate** before.

### Multiple Applications[¶](#multiple-applications "Permanent link")

In the same server (or servers), there could be **multiple applications** , for example, other API programs or a database.

Only one process can be handling the specific IP and port (the TLS Termination Proxy in our example) but the other applications/processes can be running on the server(s) too, as long as they don't try to use the same **combination of public IP and port**.

![](/img/deployment/https/https08.drawio.svg)

That way, the TLS Termination Proxy could handle HTTPS and certificates for **multiple domains** , for multiple applications, and then transmit the requests to the right application in each case.

### Certificate Renewal[¶](#certificate-renewal "Permanent link")

At some point in the future, each certificate would **expire** (about 3 months after acquiring it).

And then, there would be another program (in some cases it's another program, in some cases it could be the same TLS Termination Proxy) that would talk to Let's Encrypt, and renew the certificate(s).

![](/img/deployment/https/https.drawio.svg)

The **TLS certificates** are **associated with a domain name** , not with an IP address.

So, to renew the certificates, the renewal program needs to **prove** to the authority (Let's Encrypt) that it indeed **"owns" and controls that domain**.

To do that, and to accommodate different application needs, there are several ways it can do it. Some popular ways are:

  * **Modify some DNS records**.
    * For this, the renewal program needs to support the APIs of the DNS provider, so, depending on the DNS provider you are using, this might or might not be an option.
  * **Run as a server** (at least during the certificate acquisition process) on the public IP address associated with the domain.
    * As we said above, only one process can be listening on a specific IP and port.
    * This is one of the reasons why it's very useful when the same TLS Termination Proxy also takes care of the certificate renewal process.
    * Otherwise, you might have to stop the TLS Termination Proxy momentarily, start the renewal program to acquire the certificates, then configure them with the TLS Termination Proxy, and then restart the TLS Termination Proxy. This is not ideal, as your app(s) will not be available during the time that the TLS Termination Proxy is off.

All this renewal process, while still serving the app, is one of the main reasons why you would want to have a **separate system to handle HTTPS** with a TLS Termination Proxy instead of just using the TLS certificates with the application server directly (e.g. Uvicorn).

## Proxy Forwarded Headers[¶](#proxy-forwarded-headers "Permanent link")

When using a proxy to handle HTTPS, your **application server** (for example Uvicorn via FastAPI CLI) doesn't known anything about the HTTPS process, it communicates with plain HTTP with the **TLS Termination Proxy**.

This **proxy** would normally set some HTTP headers on the fly before transmitting the request to the **application server** , to let the application server know that the request is being **forwarded** by the proxy.

Technical Details

The proxy headers are:

  * [X-Forwarded-For](https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/X-Forwarded-For)
  * [X-Forwarded-Proto](https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/X-Forwarded-Proto)
  * [X-Forwarded-Host](https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/X-Forwarded-Host)

Nevertheless, as the **application server** doesn't know it is behind a trusted **proxy** , by default, it wouldn't trust those headers.

But you can configure the **application server** to trust the _forwarded_ headers sent by the **proxy**. If you are using FastAPI CLI, you can use the _CLI Option_ `--forwarded-allow-ips` to tell it from which IPs it should trust those _forwarded_ headers.

For example, if the **application server** is only receiving communication from the trusted **proxy** , you can set it to `--forwarded-allow-ips="*"` to make it trust all incoming IPs, as it will only receive requests from whatever is the IP used by the **proxy**.

This way the application would be able to know what is its own public URL, if it is using HTTPS, the domain, etc.

This would be useful for example to properly handle redirects.

Tip

You can learn more about this in the documentation for [Behind a Proxy - Enable Proxy Forwarded Headers](../../advanced/behind-a-proxy/#enable-proxy-forwarded-headers)

## Recap[¶](#recap "Permanent link")

Having **HTTPS** is very important, and quite **critical** in most cases. Most of the effort you as a developer have to put around HTTPS is just about **understanding these concepts** and how they work.

But once you know the basic information of **HTTPS for developers** you can easily combine and configure different tools to help you manage everything in a simple way.

In some of the next chapters, I'll show you several concrete examples of how to set up **HTTPS** for **FastAPI** applications. üîí
  *[SNI]: Server Name Indication
  *[fixed]: That doesn't change

---

###### Run a Server Manually¶

# Run a Server Manually[¶](#run-a-server-manually "Permanent link")

## Use the `fastapi run` Command[¶](#use-the-fastapi-run-command "Permanent link")

In short, use `fastapi run` to serve your FastAPI application:
    
    
    $ <font color="#4E9A06">fastapi</font> run <u style="text-decoration-style:solid">main.py</u>
    
      <span style="background-color:#009485"><font color="#D3D7CF"> FastAPI </font></span>  Starting production server üöÄ
    
                 Searching for package file structure from directories
                 with <font color="#3465A4">__init__.py</font> files
                 Importing from <font color="#75507B">/home/user/code/</font><font color="#AD7FA8">awesomeapp</font>
    
       <span style="background-color:#007166"><font color="#D3D7CF"> module </font></span>  üêç main.py
    
         <span style="background-color:#007166"><font color="#D3D7CF"> code </font></span>  Importing the FastAPI app object from the module with
                 the following code:
    
                 <u style="text-decoration-style:solid">from </u><u style="text-decoration-style:solid"><b>main</b></u><u style="text-decoration-style:solid"> import </u><u style="text-decoration-style:solid"><b>app</b></u>
    
          <span style="background-color:#007166"><font color="#D3D7CF"> app </font></span>  Using import string: <font color="#3465A4">main:app</font>
    
       <span style="background-color:#007166"><font color="#D3D7CF"> server </font></span>  Server started at <font color="#729FCF"><u style="text-decoration-style:solid">http://0.0.0.0:8000</u></font>
       <span style="background-color:#007166"><font color="#D3D7CF"> server </font></span>  Documentation at <font color="#729FCF"><u style="text-decoration-style:solid">http://0.0.0.0:8000/docs</u></font>
    
                 Logs:
    
         <span style="background-color:#007166"><font color="#D3D7CF"> INFO </font></span>  Started server process <b>[</b><font color="#34E2E2"><b>2306215</b></font><b>]</b>
         <span style="background-color:#007166"><font color="#D3D7CF"> INFO </font></span>  Waiting for application startup.
         <span style="background-color:#007166"><font color="#D3D7CF"> INFO </font></span>  Application startup complete.
         <span style="background-color:#007166"><font color="#D3D7CF"> INFO </font></span>  Uvicorn running on <font color="#729FCF"><u style="text-decoration-style:solid">http://0.0.0.0:8000</u></font> <b>(</b>Press CTRL+C
                 to quit<b>)</b>
    

That would work for most of the cases. üòé

You could use that command for example to start your **FastAPI** app in a container, in a server, etc.

## ASGI Servers[¶](#asgi-servers "Permanent link")

Let's go a little deeper into the details.

FastAPI uses a standard for building Python web frameworks and servers called ASGI. FastAPI is an ASGI web framework.

The main thing you need to run a **FastAPI** application (or any other ASGI application) in a remote server machine is an ASGI server program like **Uvicorn** , this is the one that comes by default in the `fastapi` command.

There are several alternatives, including:

  * [Uvicorn](https://www.uvicorn.dev/): a high performance ASGI server.
  * [Hypercorn](https://hypercorn.readthedocs.io/): an ASGI server compatible with HTTP/2 and Trio among other features.
  * [Daphne](https://github.com/django/daphne): the ASGI server built for Django Channels.
  * [Granian](https://github.com/emmett-framework/granian): A Rust HTTP server for Python applications.
  * [NGINX Unit](https://unit.nginx.org/howto/fastapi/): NGINX Unit is a lightweight and versatile web application runtime.

## Server Machine and Server Program[¶](#server-machine-and-server-program "Permanent link")

There's a small detail about names to keep in mind. üí°

The word "**server** " is commonly used to refer to both the remote/cloud computer (the physical or virtual machine) and also the program that is running on that machine (e.g. Uvicorn).

Just keep in mind that when you read "server" in general, it could refer to one of those two things.

When referring to the remote machine, it's common to call it **server** , but also **machine** , **VM** (virtual machine), **node**. Those all refer to some type of remote machine, normally running Linux, where you run programs.

## Install the Server Program[¶](#install-the-server-program "Permanent link")

When you install FastAPI, it comes with a production server, Uvicorn, and you can start it with the `fastapi run` command.

But you can also install an ASGI server manually.

Make sure you create a [virtual environment](../../virtual-environments/), activate it, and then you can install the server application.

For example, to install Uvicorn:
    
    
    $ pip install "uvicorn[standard]"
    
    ---> 100%
    

A similar process would apply to any other ASGI server program.

Tip

By adding the `standard`, Uvicorn will install and use some recommended extra dependencies.

That including `uvloop`, the high-performance drop-in replacement for `asyncio`, that provides the big concurrency performance boost.

When you install FastAPI with something like `pip install "fastapi[standard]"` you already get `uvicorn[standard]` as well.

## Run the Server Program[¶](#run-the-server-program "Permanent link")

If you installed an ASGI server manually, you would normally need to pass an import string in a special format for it to import your FastAPI application:
    
    
    $ uvicorn main:app --host 0.0.0.0 --port 80
    
    <span style="color: green;">INFO</span>:     Uvicorn running on http://0.0.0.0:80 (Press CTRL+C to quit)
    

Note

The command `uvicorn main:app` refers to:

  * `main`: the file `main.py` (the Python "module").
  * `app`: the object created inside of `main.py` with the line `app = FastAPI()`.

It is equivalent to:
    
    
    from main import app
    

Each alternative ASGI server program would have a similar command, you can read more in their respective documentation.

Warning

Uvicorn and other servers support a `--reload` option that is useful during development.

The `--reload` option consumes much more resources, is more unstable, etc.

It helps a lot during **development** , but you **shouldn't** use it in **production**.

## Deployment Concepts[¶](#deployment-concepts "Permanent link")

These examples run the server program (e.g Uvicorn), starting **a single process** , listening on all the IPs (`0.0.0.0`) on a predefined port (e.g. `80`).

This is the basic idea. But you will probably want to take care of some additional things, like:

  * Security - HTTPS
  * Running on startup
  * Restarts
  * Replication (the number of processes running)
  * Memory
  * Previous steps before starting

I'll tell you more about each of these concepts, how to think about them, and some concrete examples with strategies to handle them in the next chapters. üöÄ
  *[ASGI]: Asynchronous Server Gateway Interface

---

###### Deployments Concepts¶

# Deployments Concepts[¶](#deployments-concepts "Permanent link")

When deploying a **FastAPI** application, or actually, any type of web API, there are several concepts that you probably care about, and using them you can find the **most appropriate** way to **deploy your application**.

Some of the important concepts are:

  * Security - HTTPS
  * Running on startup
  * Restarts
  * Replication (the number of processes running)
  * Memory
  * Previous steps before starting

We'll see how they would affect **deployments**.

In the end, the ultimate objective is to be able to **serve your API clients** in a way that is **secure** , to **avoid disruptions** , and to use the **compute resources** (for example remote servers/virtual machines) as efficiently as possible. üöÄ

I'll tell you a bit more about these **concepts** here, and that would hopefully give you the **intuition** you would need to decide how to deploy your API in very different environments, possibly even in **future** ones that don't exist yet.

By considering these concepts, you will be able to **evaluate and design** the best way to deploy **your own APIs**.

In the next chapters, I'll give you more **concrete recipes** to deploy FastAPI applications.

But for now, let's check these important **conceptual ideas**. These concepts also apply to any other type of web API. üí°

## Security - HTTPS[¶](#security-https "Permanent link")

In the [previous chapter about HTTPS](../https/) we learned about how HTTPS provides encryption for your API.

We also saw that HTTPS is normally provided by a component **external** to your application server, a **TLS Termination Proxy**.

And there has to be something in charge of **renewing the HTTPS certificates** , it could be the same component or it could be something different.

### Example Tools for HTTPS[¶](#example-tools-for-https "Permanent link")

Some of the tools you could use as a TLS Termination Proxy are:

  * Traefik
    * Automatically handles certificates renewals ‚ú®
  * Caddy
    * Automatically handles certificates renewals ‚ú®
  * Nginx
    * With an external component like Certbot for certificate renewals
  * HAProxy
    * With an external component like Certbot for certificate renewals
  * Kubernetes with an Ingress Controller like Nginx
    * With an external component like cert-manager for certificate renewals
  * Handled internally by a cloud provider as part of their services (read below üëá)

Another option is that you could use a **cloud service** that does more of the work including setting up HTTPS. It could have some restrictions or charge you more, etc. But in that case, you wouldn't have to set up a TLS Termination Proxy yourself.

I'll show you some concrete examples in the next chapters.

* * *

Then the next concepts to consider are all about the program running your actual API (e.g. Uvicorn).

## Program and Process[¶](#program-and-process "Permanent link")

We will talk a lot about the running "**process** ", so it's useful to have clarity about what it means, and what's the difference with the word "**program** ".

### What is a Program[¶](#what-is-a-program "Permanent link")

The word **program** is commonly used to describe many things:

  * The **code** that you write, the **Python files**.
  * The **file** that can be **executed** by the operating system, for example: `python`, `python.exe` or `uvicorn`.
  * A particular program while it is **running** on the operating system, using the CPU, and storing things in memory. This is also called a **process**.

### What is a Process[¶](#what-is-a-process "Permanent link")

The word **process** is normally used in a more specific way, only referring to the thing that is running in the operating system (like in the last point above):

  * A particular program while it is **running** on the operating system.
    * This doesn't refer to the file, nor to the code, it refers **specifically** to the thing that is being **executed** and managed by the operating system.
  * Any program, any code, **can only do things** when it is being **executed**. So, when there's a **process running**.
  * The process can be **terminated** (or "killed") by you, or by the operating system. At that point, it stops running/being executed, and it can **no longer do things**.
  * Each application that you have running on your computer has some process behind it, each running program, each window, etc. And there are normally many processes running **at the same time** while a computer is on.
  * There can be **multiple processes** of the **same program** running at the same time.

If you check out the "task manager" or "system monitor" (or similar tools) in your operating system, you will be able to see many of those processes running.

And, for example, you will probably see that there are multiple processes running the same browser program (Firefox, Chrome, Edge, etc). They normally run one process per tab, plus some other extra processes.

![](/img/deployment/concepts/image01.png)

* * *

Now that we know the difference between the terms **process** and **program** , let's continue talking about deployments.

## Running on Startup[¶](#running-on-startup "Permanent link")

In most cases, when you create a web API, you want it to be **always running** , uninterrupted, so that your clients can always access it. This is of course, unless you have a specific reason why you want it to run only in certain situations, but most of the time you want it constantly running and **available**.

### In a Remote Server[¶](#in-a-remote-server "Permanent link")

When you set up a remote server (a cloud server, a virtual machine, etc.) the simplest thing you can do is use `fastapi run` (which uses Uvicorn) or something similar, manually, the same way you do when developing locally.

And it will work and will be useful **during development**.

But if your connection to the server is lost, the **running process** will probably die.

And if the server is restarted (for example after updates, or migrations from the cloud provider) you probably **won't notice it**. And because of that, you won't even know that you have to restart the process manually. So, your API will just stay dead. üò±

### Run Automatically on Startup[¶](#run-automatically-on-startup "Permanent link")

In general, you will probably want the server program (e.g. Uvicorn) to be started automatically on server startup, and without needing any **human intervention** , to have a process always running with your API (e.g. Uvicorn running your FastAPI app).

### Separate Program[¶](#separate-program "Permanent link")

To achieve this, you will normally have a **separate program** that would make sure your application is run on startup. And in many cases, it would also make sure other components or applications are also run, for example, a database.

### Example Tools to Run at Startup[¶](#example-tools-to-run-at-startup "Permanent link")

Some examples of the tools that can do this job are:

  * Docker
  * Kubernetes
  * Docker Compose
  * Docker in Swarm Mode
  * Systemd
  * Supervisor
  * Handled internally by a cloud provider as part of their services
  * Others...

I'll give you more concrete examples in the next chapters.

## Restarts[¶](#restarts "Permanent link")

Similar to making sure your application is run on startup, you probably also want to make sure it is **restarted** after failures.

### We Make Mistakes[¶](#we-make-mistakes "Permanent link")

We, as humans, make **mistakes** , all the time. Software almost _always_ has **bugs** hidden in different places. üêõ

And we as developers keep improving the code as we find those bugs and as we implement new features (possibly adding new bugs too üòÖ).

### Small Errors Automatically Handled[¶](#small-errors-automatically-handled "Permanent link")

When building web APIs with FastAPI, if there's an error in our code, FastAPI will normally contain it to the single request that triggered the error. üõ°

The client will get a **500 Internal Server Error** for that request, but the application will continue working for the next requests instead of just crashing completely.

### Bigger Errors - Crashes[¶](#bigger-errors-crashes "Permanent link")

Nevertheless, there might be cases where we write some code that **crashes the entire application** making Uvicorn and Python crash. üí•

And still, you would probably not want the application to stay dead because there was an error in one place, you probably want it to **continue running** at least for the _path operations_ that are not broken.

### Restart After Crash[¶](#restart-after-crash "Permanent link")

But in those cases with really bad errors that crash the running **process** , you would want an external component that is in charge of **restarting** the process, at least a couple of times...

Tip

...Although if the whole application is just **crashing immediately** it probably doesn't make sense to keep restarting it forever. But in those cases, you will probably notice it during development, or at least right after deployment.

So let's focus on the main cases, where it could crash entirely in some particular cases **in the future** , and it still makes sense to restart it.

You would probably want to have the thing in charge of restarting your application as an **external component** , because by that point, the same application with Uvicorn and Python already crashed, so there's nothing in the same code of the same app that could do anything about it.

### Example Tools to Restart Automatically[¶](#example-tools-to-restart-automatically "Permanent link")

In most cases, the same tool that is used to **run the program on startup** is also used to handle automatic **restarts**.

For example, this could be handled by:

  * Docker
  * Kubernetes
  * Docker Compose
  * Docker in Swarm Mode
  * Systemd
  * Supervisor
  * Handled internally by a cloud provider as part of their services
  * Others...

## Replication - Processes and Memory[¶](#replication-processes-and-memory "Permanent link")

With a FastAPI application, using a server program like the `fastapi` command that runs Uvicorn, running it once in **one process** can serve multiple clients concurrently.

But in many cases, you will want to run several worker processes at the same time.

### Multiple Processes - Workers[¶](#multiple-processes-workers "Permanent link")

If you have more clients than what a single process can handle (for example if the virtual machine is not too big) and you have **multiple cores** in the server's CPU, then you could have **multiple processes** running with the same application at the same time, and distribute all the requests among them.

When you run **multiple processes** of the same API program, they are commonly called **workers**.

### Worker Processes and Ports[¶](#worker-processes-and-ports "Permanent link")

Remember from the docs [About HTTPS](../https/) that only one process can be listening on one combination of port and IP address in a server?

This is still true.

So, to be able to have **multiple processes** at the same time, there has to be a **single process listening on a port** that then transmits the communication to each worker process in some way.

### Memory per Process[¶](#memory-per-process "Permanent link")

Now, when the program loads things in memory, for example, a machine learning model in a variable, or the contents of a large file in a variable, all that **consumes a bit of the memory (RAM)** of the server.

And multiple processes normally **don't share any memory**. This means that each running process has its own things, variables, and memory. And if you are consuming a large amount of memory in your code, **each process** will consume an equivalent amount of memory.

### Server Memory[¶](#server-memory "Permanent link")

For example, if your code loads a Machine Learning model with **1 GB in size** , when you run one process with your API, it will consume at least 1 GB of RAM. And if you start **4 processes** (4 workers), each will consume 1 GB of RAM. So in total, your API will consume **4 GB of RAM**.

And if your remote server or virtual machine only has 3 GB of RAM, trying to load more than 4 GB of RAM will cause problems. üö®

### Multiple Processes - An Example[¶](#multiple-processes-an-example "Permanent link")

In this example, there's a **Manager Process** that starts and controls two **Worker Processes**.

This Manager Process would probably be the one listening on the **port** in the IP. And it would transmit all the communication to the worker processes.

Those worker processes would be the ones running your application, they would perform the main computations to receive a **request** and return a **response** , and they would load anything you put in variables in RAM.

![](/img/deployment/concepts/process-ram.drawio.svg)

And of course, the same machine would probably have **other processes** running as well, apart from your application.

An interesting detail is that the percentage of the **CPU used** by each process can **vary** a lot over time, but the **memory (RAM)** normally stays more or less **stable**.

If you have an API that does a comparable amount of computations every time and you have a lot of clients, then the **CPU utilization** will probably _also be stable_ (instead of constantly going up and down quickly).

### Examples of Replication Tools and Strategies[¶](#examples-of-replication-tools-and-strategies "Permanent link")

There can be several approaches to achieve this, and I'll tell you more about specific strategies in the next chapters, for example when talking about Docker and containers.

The main constraint to consider is that there has to be a **single** component handling the **port** in the **public IP**. And then it has to have a way to **transmit** the communication to the replicated **processes/workers**.

Here are some possible combinations and strategies:

  * **Uvicorn** with `--workers`
    * One Uvicorn **process manager** would listen on the **IP** and **port** , and it would start **multiple Uvicorn worker processes**.
  * **Kubernetes** and other distributed **container systems**
    * Something in the **Kubernetes** layer would listen on the **IP** and **port**. The replication would be by having **multiple containers** , each with **one Uvicorn process** running.
  * **Cloud services** that handle this for you
    * The cloud service will probably **handle replication for you**. It would possibly let you define **a process to run** , or a **container image** to use, in any case, it would most probably be **a single Uvicorn process** , and the cloud service would be in charge of replicating it.

Tip

Don't worry if some of these items about **containers** , Docker, or Kubernetes don't make a lot of sense yet.

I'll tell you more about container images, Docker, Kubernetes, etc. in a future chapter: [FastAPI in Containers - Docker](../docker/).

## Previous Steps Before Starting[¶](#previous-steps-before-starting "Permanent link")

There are many cases where you want to perform some steps **before starting** your application.

For example, you might want to run **database migrations**.

But in most cases, you will want to perform these steps only **once**.

So, you will want to have a **single process** to perform those **previous steps** , before starting the application.

And you will have to make sure that it's a single process running those previous steps _even_ if afterwards, you start **multiple processes** (multiple workers) for the application itself. If those steps were run by **multiple processes** , they would **duplicate** the work by running it in **parallel** , and if the steps were something delicate like a database migration, they could cause conflicts with each other.

Of course, there are some cases where there's no problem in running the previous steps multiple times, in that case, it's a lot easier to handle.

Tip

Also, keep in mind that depending on your setup, in some cases you **might not even need any previous steps** before starting your application.

In that case, you wouldn't have to worry about any of this. ü§∑

### Examples of Previous Steps Strategies[¶](#examples-of-previous-steps-strategies "Permanent link")

This will **depend heavily** on the way you **deploy your system** , and it would probably be connected to the way you start programs, handling restarts, etc.

Here are some possible ideas:

  * An "Init Container" in Kubernetes that runs before your app container
  * A bash script that runs the previous steps and then starts your application
    * You would still need a way to start/restart _that_ bash script, detect errors, etc.

Tip

I'll give you more concrete examples for doing this with containers in a future chapter: [FastAPI in Containers - Docker](../docker/).

## Resource Utilization[¶](#resource-utilization "Permanent link")

Your server(s) is (are) a **resource** , you can consume or **utilize** , with your programs, the computation time on the CPUs, and the RAM memory available.

How much of the system resources do you want to be consuming/utilizing? It might be easy to think "not much", but in reality, you will probably want to consume **as much as possible without crashing**.

If you are paying for 3 servers but you are using only a little bit of their RAM and CPU, you are probably **wasting money** üí∏, and probably **wasting server electric power** üåé, etc.

In that case, it could be better to have only 2 servers and use a higher percentage of their resources (CPU, memory, disk, network bandwidth, etc).

On the other hand, if you have 2 servers and you are using **100% of their CPU and RAM** , at some point one process will ask for more memory, and the server will have to use the disk as "memory" (which can be thousands of times slower), or even **crash**. Or one process might need to do some computation and would have to wait until the CPU is free again.

In this case, it would be better to get **one extra server** and run some processes on it so that they all have **enough RAM and CPU time**.

There's also the chance that for some reason you have a **spike** of usage of your API. Maybe it went viral, or maybe some other services or bots start using it. And you might want to have extra resources to be safe in those cases.

You could put an **arbitrary number** to target, for example, something **between 50% to 90%** of resource utilization. The point is that those are probably the main things you will want to measure and use to tweak your deployments.

You can use simple tools like `htop` to see the CPU and RAM used in your server or the amount used by each process. Or you can use more complex monitoring tools, which may be distributed across servers, etc.

## Recap[¶](#recap "Permanent link")

You have been reading here some of the main concepts that you would probably need to keep in mind when deciding how to deploy your application:

  * Security - HTTPS
  * Running on startup
  * Restarts
  * Replication (the number of processes running)
  * Memory
  * Previous steps before starting

Understanding these ideas and how to apply them should give you the intuition necessary to take any decisions when configuring and tweaking your deployments. ü§ì

In the next sections, I'll give you more concrete examples of possible strategies you can follow. üöÄ

---

###### Deploy FastAPI on Cloud Providers¶

# Deploy FastAPI on Cloud Providers[¶](#deploy-fastapi-on-cloud-providers "Permanent link")

You can use virtually **any cloud provider** to deploy your FastAPI application.

In most of the cases, the main cloud providers have guides to deploy FastAPI with them.

## FastAPI Cloud[¶](#fastapi-cloud "Permanent link")

**[FastAPI Cloud](https://fastapicloud.com)** is built by the same author and team behind **FastAPI**.

It streamlines the process of **building** , **deploying** , and **accessing** an API with minimal effort.

It brings the same **developer experience** of building apps with FastAPI to **deploying** them to the cloud. üéâ

FastAPI Cloud is the primary sponsor and funding provider for the _FastAPI and friends_ open source projects. ‚ú®

## Cloud Providers - Sponsors[¶](#cloud-providers-sponsors "Permanent link")

Some other cloud providers ‚ú® [**sponsor FastAPI**](../../help-fastapi/#sponsor-the-author) ‚ú® too. üôá

You might also want to consider them to follow their guides and try their services:

  * [Render](https://docs.render.com/deploy-fastapi?utm_source=deploydoc&utm_medium=referral&utm_campaign=fastapi)
  * [Railway](https://docs.railway.com/guides/fastapi?utm_medium=integration&utm_source=docs&utm_campaign=fastapi)

---

###### Server Workers - Uvicorn with Workers¶

# Server Workers - Uvicorn with Workers[¶](#server-workers-uvicorn-with-workers "Permanent link")

Let's check back those deployment concepts from before:

  * Security - HTTPS
  * Running on startup
  * Restarts
  * **Replication (the number of processes running)**
  * Memory
  * Previous steps before starting

Up to this point, with all the tutorials in the docs, you have probably been running a **server program** , for example, using the `fastapi` command, that runs Uvicorn, running a **single process**.

When deploying applications you will probably want to have some **replication of processes** to take advantage of **multiple cores** and to be able to handle more requests.

As you saw in the previous chapter about [Deployment Concepts](../concepts/), there are multiple strategies you can use.

Here I'll show you how to use **Uvicorn** with **worker processes** using the `fastapi` command or the `uvicorn` command directly.

Info

If you are using containers, for example with Docker or Kubernetes, I'll tell you more about that in the next chapter: [FastAPI in Containers - Docker](../docker/).

In particular, when running on **Kubernetes** you will probably **not** want to use workers and instead run **a single Uvicorn process per container** , but I'll tell you about it later in that chapter.

## Multiple Workers[¶](#multiple-workers "Permanent link")

You can start multiple workers with the `--workers` command line option:

`fastapi``uvicorn`

If you use the `fastapi` command:
    
    
    $ <font color="#4E9A06">fastapi</font> run --workers 4 <u style="text-decoration-style:solid">main.py</u>
    
      <span style="background-color:#009485"><font color="#D3D7CF"> FastAPI </font></span>  Starting production server üöÄ
    
                 Searching for package file structure from directories with
                 <font color="#3465A4">__init__.py</font> files
                 Importing from <font color="#75507B">/home/user/code/</font><font color="#AD7FA8">awesomeapp</font>
    
       <span style="background-color:#007166"><font color="#D3D7CF"> module </font></span>  üêç main.py
    
         <span style="background-color:#007166"><font color="#D3D7CF"> code </font></span>  Importing the FastAPI app object from the module with the
                 following code:
    
                 <u style="text-decoration-style:solid">from </u><u style="text-decoration-style:solid"><b>main</b></u><u style="text-decoration-style:solid"> import </u><u style="text-decoration-style:solid"><b>app</b></u>
    
          <span style="background-color:#007166"><font color="#D3D7CF"> app </font></span>  Using import string: <font color="#3465A4">main:app</font>
    
       <span style="background-color:#007166"><font color="#D3D7CF"> server </font></span>  Server started at <font color="#729FCF"><u style="text-decoration-style:solid">http://0.0.0.0:8000</u></font>
       <span style="background-color:#007166"><font color="#D3D7CF"> server </font></span>  Documentation at <font color="#729FCF"><u style="text-decoration-style:solid">http://0.0.0.0:8000/docs</u></font>
    
                 Logs:
    
         <span style="background-color:#007166"><font color="#D3D7CF"> INFO </font></span>  Uvicorn running on <font color="#729FCF"><u style="text-decoration-style:solid">http://0.0.0.0:8000</u></font> <b>(</b>Press CTRL+C to
                 quit<b>)</b>
         <span style="background-color:#007166"><font color="#D3D7CF"> INFO </font></span>  Started parent process <b>[</b><font color="#34E2E2"><b>27365</b></font><b>]</b>
         <span style="background-color:#007166"><font color="#D3D7CF"> INFO </font></span>  Started server process <b>[</b><font color="#34E2E2"><b>27368</b></font><b>]</b>
         <span style="background-color:#007166"><font color="#D3D7CF"> INFO </font></span>  Started server process <b>[</b><font color="#34E2E2"><b>27369</b></font><b>]</b>
         <span style="background-color:#007166"><font color="#D3D7CF"> INFO </font></span>  Started server process <b>[</b><font color="#34E2E2"><b>27370</b></font><b>]</b>
         <span style="background-color:#007166"><font color="#D3D7CF"> INFO </font></span>  Started server process <b>[</b><font color="#34E2E2"><b>27367</b></font><b>]</b>
         <span style="background-color:#007166"><font color="#D3D7CF"> INFO </font></span>  Waiting for application startup.
         <span style="background-color:#007166"><font color="#D3D7CF"> INFO </font></span>  Waiting for application startup.
         <span style="background-color:#007166"><font color="#D3D7CF"> INFO </font></span>  Waiting for application startup.
         <span style="background-color:#007166"><font color="#D3D7CF"> INFO </font></span>  Waiting for application startup.
         <span style="background-color:#007166"><font color="#D3D7CF"> INFO </font></span>  Application startup complete.
         <span style="background-color:#007166"><font color="#D3D7CF"> INFO </font></span>  Application startup complete.
         <span style="background-color:#007166"><font color="#D3D7CF"> INFO </font></span>  Application startup complete.
         <span style="background-color:#007166"><font color="#D3D7CF"> INFO </font></span>  Application startup complete.
    

If you prefer to use the `uvicorn` command directly:
    
    
    $ uvicorn main:app --host 0.0.0.0 --port 8080 --workers 4
    <font color="#A6E22E">INFO</font>:     Uvicorn running on <b>http://0.0.0.0:8080</b> (Press CTRL+C to quit)
    <font color="#A6E22E">INFO</font>:     Started parent process [<font color="#A1EFE4"><b>27365</b></font>]
    <font color="#A6E22E">INFO</font>:     Started server process [<font color="#A1EFE4">27368</font>]
    <font color="#A6E22E">INFO</font>:     Waiting for application startup.
    <font color="#A6E22E">INFO</font>:     Application startup complete.
    <font color="#A6E22E">INFO</font>:     Started server process [<font color="#A1EFE4">27369</font>]
    <font color="#A6E22E">INFO</font>:     Waiting for application startup.
    <font color="#A6E22E">INFO</font>:     Application startup complete.
    <font color="#A6E22E">INFO</font>:     Started server process [<font color="#A1EFE4">27370</font>]
    <font color="#A6E22E">INFO</font>:     Waiting for application startup.
    <font color="#A6E22E">INFO</font>:     Application startup complete.
    <font color="#A6E22E">INFO</font>:     Started server process [<font color="#A1EFE4">27367</font>]
    <font color="#A6E22E">INFO</font>:     Waiting for application startup.
    <font color="#A6E22E">INFO</font>:     Application startup complete.
    

The only new option here is `--workers` telling Uvicorn to start 4 worker processes.

You can also see that it shows the **PID** of each process, `27365` for the parent process (this is the **process manager**) and one for each worker process: `27368`, `27369`, `27370`, and `27367`.

## Deployment Concepts[¶](#deployment-concepts "Permanent link")

Here you saw how to use multiple **workers** to **parallelize** the execution of the application, take advantage of **multiple cores** in the CPU, and be able to serve **more requests**.

From the list of deployment concepts from above, using workers would mainly help with the **replication** part, and a little bit with the **restarts** , but you still need to take care of the others:

  * **Security - HTTPS**
  * **Running on startup**
  * **_Restarts_**
  * Replication (the number of processes running)
  * **Memory**
  * **Previous steps before starting**

## Containers and Docker[¶](#containers-and-docker "Permanent link")

In the next chapter about [FastAPI in Containers - Docker](../docker/) I'll explain some strategies you could use to handle the other **deployment concepts**.

I'll show you how to **build your own image from scratch** to run a single Uvicorn process. It is a simple process and is probably what you would want to do when using a distributed container management system like **Kubernetes**.

## Recap[¶](#recap "Permanent link")

You can use multiple worker processes with the `--workers` CLI option with the `fastapi` or `uvicorn` commands to take advantage of **multi-core CPUs** , to run **multiple processes in parallel**.

You could use these tools and ideas if you are setting up **your own deployment system** while taking care of the other deployment concepts yourself.

Check out the next chapter to learn about **FastAPI** with containers (e.g. Docker and Kubernetes). You will see that those tools have simple ways to solve the other **deployment concepts** as well. ‚ú®

---

###### FastAPI in Containers - Docker¶

# FastAPI in Containers - Docker[¶](#fastapi-in-containers-docker "Permanent link")

When deploying FastAPI applications a common approach is to build a **Linux container image**. It's normally done using [**Docker**](https://www.docker.com/). You can then deploy that container image in one of a few possible ways.

Using Linux containers has several advantages including **security** , **replicability** , **simplicity** , and others.

Tip

In a hurry and already know this stuff? Jump to the [`Dockerfile` below üëá](#build-a-docker-image-for-fastapi).

Dockerfile Preview üëÄ
    
    
    FROM python:3.9
    
    WORKDIR /code
    
    COPY ./requirements.txt /code/requirements.txt
    
    RUN pip install --no-cache-dir --upgrade -r /code/requirements.txt
    
    COPY ./app /code/app
    
    CMD ["fastapi", "run", "app/main.py", "--port", "80"]
    
    # If running behind a proxy like Nginx or Traefik add --proxy-headers
    # CMD ["fastapi", "run", "app/main.py", "--port", "80", "--proxy-headers"]
    

## What is a Container[¶](#what-is-a-container "Permanent link")

Containers (mainly Linux containers) are a very **lightweight** way to package applications including all their dependencies and necessary files while keeping them isolated from other containers (other applications or components) in the same system.

Linux containers run using the same Linux kernel of the host (machine, virtual machine, cloud server, etc). This just means that they are very lightweight (compared to full virtual machines emulating an entire operating system).

This way, containers consume **little resources** , an amount comparable to running the processes directly (a virtual machine would consume much more).

Containers also have their own **isolated** running processes (commonly just one process), file system, and network, simplifying deployment, security, development, etc.

## What is a Container Image[¶](#what-is-a-container-image "Permanent link")

A **container** is run from a **container image**.

A container image is a **static** version of all the files, environment variables, and the default command/program that should be present in a container. **Static** here means that the container **image** is not running, it's not being executed, it's only the packaged files and metadata.

In contrast to a "**container image** " that is the stored static contents, a "**container** " normally refers to the running instance, the thing that is being **executed**.

When the **container** is started and running (started from a **container image**) it could create or change files, environment variables, etc. Those changes will exist only in that container, but would not persist in the underlying container image (would not be saved to disk).

A container image is comparable to the **program** file and contents, e.g. `python` and some file `main.py`.

And the **container** itself (in contrast to the **container image**) is the actual running instance of the image, comparable to a **process**. In fact, a container is running only when it has a **process running** (and normally it's only a single process). The container stops when there's no process running in it.

## Container Images[¶](#container-images "Permanent link")

Docker has been one of the main tools to create and manage **container images** and **containers**.

And there's a public [Docker Hub](https://hub.docker.com/) with pre-made **official container images** for many tools, environments, databases, and applications.

For example, there's an official [Python Image](https://hub.docker.com/_/python).

And there are many other images for different things like databases, for example for:

  * [PostgreSQL](https://hub.docker.com/_/postgres)
  * [MySQL](https://hub.docker.com/_/mysql)
  * [MongoDB](https://hub.docker.com/_/mongo)
  * [Redis](https://hub.docker.com/_/redis), etc.

By using a pre-made container image it's very easy to **combine** and use different tools. For example, to try out a new database. In most cases, you can use the **official images** , and just configure them with environment variables.

That way, in many cases you can learn about containers and Docker and reuse that knowledge with many different tools and components.

So, you would run **multiple containers** with different things, like a database, a Python application, a web server with a React frontend application, and connect them together via their internal network.

All the container management systems (like Docker or Kubernetes) have these networking features integrated into them.

## Containers and Processes[¶](#containers-and-processes "Permanent link")

A **container image** normally includes in its metadata the default program or command that should be run when the **container** is started and the parameters to be passed to that program. Very similar to what would be if it was in the command line.

When a **container** is started, it will run that command/program (although you can override it and make it run a different command/program).

A container is running as long as the **main process** (command or program) is running.

A container normally has a **single process** , but it's also possible to start subprocesses from the main process, and that way you will have **multiple processes** in the same container.

But it's not possible to have a running container without **at least one running process**. If the main process stops, the container stops.

## Build a Docker Image for FastAPI[¶](#build-a-docker-image-for-fastapi "Permanent link")

Okay, let's build something now! üöÄ

I'll show you how to build a **Docker image** for FastAPI **from scratch** , based on the **official Python** image.

This is what you would want to do in **most cases** , for example:

  * Using **Kubernetes** or similar tools
  * When running on a **Raspberry Pi**
  * Using a cloud service that would run a container image for you, etc.

### Package Requirements[¶](#package-requirements "Permanent link")

You would normally have the **package requirements** for your application in some file.

It would depend mainly on the tool you use to **install** those requirements.

The most common way to do it is to have a file `requirements.txt` with the package names and their versions, one per line.

You would of course use the same ideas you read in [About FastAPI versions](../versions/) to set the ranges of versions.

For example, your `requirements.txt` could look like:
    
    
    fastapi[standard]>=0.113.0,<0.114.0
    pydantic>=2.7.0,<3.0.0
    

And you would normally install those package dependencies with `pip`, for example:
    
    
    $ pip install -r requirements.txt
    ---> 100%
    Successfully installed fastapi pydantic
    

Info

There are other formats and tools to define and install package dependencies.

### Create the **FastAPI** Code[¶](#create-the-fastapi-code "Permanent link")

  * Create an `app` directory and enter it.
  * Create an empty file `__init__.py`.
  * Create a `main.py` file with:

    
    
    from fastapi import FastAPI
    
    app = FastAPI()
    
    
    @app.get("/")
    def read_root():
        return {"Hello": "World"}
    
    
    @app.get("/items/{item_id}")
    def read_item(item_id: int, q: str | None = None):
        return {"item_id": item_id, "q": q}
    

### Dockerfile[¶](#dockerfile "Permanent link")

Now in the same project directory create a file `Dockerfile` with:
    
    
    # (1)!
    FROM python:3.9
    
    # (2)!
    WORKDIR /code
    
    # (3)!
    COPY ./requirements.txt /code/requirements.txt
    
    # (4)!
    RUN pip install --no-cache-dir --upgrade -r /code/requirements.txt
    
    # (5)!
    COPY ./app /code/app
    
    # (6)!
    CMD ["fastapi", "run", "app/main.py", "--port", "80"]
    

  1. Start from the official Python base image.

  2. Set the current working directory to `/code`.

This is where we'll put the `requirements.txt` file and the `app` directory.

  3. Copy the file with the requirements to the `/code` directory.

Copy **only** the file with the requirements first, not the rest of the code.

As this file **doesn't change often** , Docker will detect it and use the **cache** for this step, enabling the cache for the next step too.

  4. Install the package dependencies in the requirements file.

The `--no-cache-dir` option tells `pip` to not save the downloaded packages locally, as that is only if `pip` was going to be run again to install the same packages, but that's not the case when working with containers.

Note

The `--no-cache-dir` is only related to `pip`, it has nothing to do with Docker or containers.

The `--upgrade` option tells `pip` to upgrade the packages if they are already installed.

Because the previous step copying the file could be detected by the **Docker cache** , this step will also **use the Docker cache** when available.

Using the cache in this step will **save** you a lot of **time** when building the image again and again during development, instead of **downloading and installing** all the dependencies **every time**.

  5. Copy the `./app` directory inside the `/code` directory.

As this has all the code which is what **changes most frequently** the Docker **cache** won't be used for this or any **following steps** easily.

So, it's important to put this **near the end** of the `Dockerfile`, to optimize the container image build times.

  6. Set the **command** to use `fastapi run`, which uses Uvicorn underneath.

`CMD` takes a list of strings, each of these strings is what you would type in the command line separated by spaces.

This command will be run from the **current working directory** , the same `/code` directory you set above with `WORKDIR /code`.

Tip

Review what each line does by clicking each number bubble in the code. üëÜ

Warning

Make sure to **always** use the **exec form** of the `CMD` instruction, as explained below.

#### Use `CMD` \- Exec Form[¶](#use-cmd-exec-form "Permanent link")

The [`CMD`](https://docs.docker.com/reference/dockerfile/#cmd) Docker instruction can be written using two forms:

‚úÖ **Exec** form:
    
    
    # ‚úÖ Do this
    CMD ["fastapi", "run", "app/main.py", "--port", "80"]
    

‚õîÔ∏è **Shell** form:
    
    
    # ‚õîÔ∏è Don't do this
    CMD fastapi run app/main.py --port 80
    

Make sure to always use the **exec** form to ensure that FastAPI can shutdown gracefully and [lifespan events](../../advanced/events/) are triggered.

You can read more about it in the [Docker docs for shell and exec form](https://docs.docker.com/reference/dockerfile/#shell-and-exec-form).

This can be quite noticeable when using `docker compose`. See this Docker Compose FAQ section for more technical details: [Why do my services take 10 seconds to recreate or stop?](https://docs.docker.com/compose/faq/#why-do-my-services-take-10-seconds-to-recreate-or-stop).

#### Directory Structure[¶](#directory-structure "Permanent link")

You should now have a directory structure like:
    
    
    .
    ‚îú‚îÄ‚îÄ app
    ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ __init__.py
    ‚îÇ   ‚îî‚îÄ‚îÄ main.py
    ‚îú‚îÄ‚îÄ Dockerfile
    ‚îî‚îÄ‚îÄ requirements.txt
    

#### Behind a TLS Termination Proxy[¶](#behind-a-tls-termination-proxy "Permanent link")

If you are running your container behind a TLS Termination Proxy (load balancer) like Nginx or Traefik, add the option `--proxy-headers`, this will tell Uvicorn (through the FastAPI CLI) to trust the headers sent by that proxy telling it that the application is running behind HTTPS, etc.
    
    
    CMD ["fastapi", "run", "app/main.py", "--proxy-headers", "--port", "80"]
    

#### Docker Cache[¶](#docker-cache "Permanent link")

There's an important trick in this `Dockerfile`, we first copy the **file with the dependencies alone** , not the rest of the code. Let me tell you why is that.
    
    
    COPY ./requirements.txt /code/requirements.txt
    

Docker and other tools **build** these container images **incrementally** , adding **one layer on top of the other** , starting from the top of the `Dockerfile` and adding any files created by each of the instructions of the `Dockerfile`.

Docker and similar tools also use an **internal cache** when building the image, if a file hasn't changed since the last time building the container image, then it will **reuse the same layer** created the last time, instead of copying the file again and creating a new layer from scratch.

Just avoiding the copy of files doesn't necessarily improve things too much, but because it used the cache for that step, it can **use the cache for the next step**. For example, it could use the cache for the instruction that installs dependencies with:
    
    
    RUN pip install --no-cache-dir --upgrade -r /code/requirements.txt
    

The file with the package requirements **won't change frequently**. So, by copying only that file, Docker will be able to **use the cache** for that step.

And then, Docker will be able to **use the cache for the next step** that downloads and install those dependencies. And here's where we **save a lot of time**. ‚ú® ...and avoid boredom waiting. üò™üòÜ

Downloading and installing the package dependencies **could take minutes** , but using the **cache** would **take seconds** at most.

And as you would be building the container image again and again during development to check that your code changes are working, there's a lot of accumulated time this would save.

Then, near the end of the `Dockerfile`, we copy all the code. As this is what **changes most frequently** , we put it near the end, because almost always, anything after this step will not be able to use the cache.
    
    
    COPY ./app /code/app
    

### Build the Docker Image[¶](#build-the-docker-image "Permanent link")

Now that all the files are in place, let's build the container image.

  * Go to the project directory (in where your `Dockerfile` is, containing your `app` directory).
  * Build your FastAPI image:

    
    
    $ docker build -t myimage .
    
    ---> 100%
    

Tip

Notice the `.` at the end, it's equivalent to `./`, it tells Docker the directory to use to build the container image.

In this case, it's the same current directory (`.`).

### Start the Docker Container[¶](#start-the-docker-container "Permanent link")

  * Run a container based on your image:

    
    
    $ docker run -d --name mycontainer -p 80:80 myimage
    

## Check it[¶](#check-it "Permanent link")

You should be able to check it in your Docker container's URL, for example: <http://192.168.99.100/items/5?q=somequery> or <http://127.0.0.1/items/5?q=somequery> (or equivalent, using your Docker host).

You will see something like:
    
    
    {"item_id": 5, "q": "somequery"}
    

## Interactive API docs[¶](#interactive-api-docs "Permanent link")

Now you can go to <http://192.168.99.100/docs> or <http://127.0.0.1/docs> (or equivalent, using your Docker host).

You will see the automatic interactive API documentation (provided by [Swagger UI](https://github.com/swagger-api/swagger-ui)):

![Swagger UI](https://fastapi.tiangolo.com/img/index/index-01-swagger-ui-simple.png)

## Alternative API docs[¶](#alternative-api-docs "Permanent link")

And you can also go to <http://192.168.99.100/redoc> or <http://127.0.0.1/redoc> (or equivalent, using your Docker host).

You will see the alternative automatic documentation (provided by [ReDoc](https://github.com/Rebilly/ReDoc)):

![ReDoc](https://fastapi.tiangolo.com/img/index/index-02-redoc-simple.png)

## Build a Docker Image with a Single-File FastAPI[¶](#build-a-docker-image-with-a-single-file-fastapi "Permanent link")

If your FastAPI is a single file, for example, `main.py` without an `./app` directory, your file structure could look like this:
    
    
    .
    ‚îú‚îÄ‚îÄ Dockerfile
    ‚îú‚îÄ‚îÄ main.py
    ‚îî‚îÄ‚îÄ requirements.txt
    

Then you would just have to change the corresponding paths to copy the file inside the `Dockerfile`:
    
    
    FROM python:3.9
    
    WORKDIR /code
    
    COPY ./requirements.txt /code/requirements.txt
    
    RUN pip install --no-cache-dir --upgrade -r /code/requirements.txt
    
    # (1)!
    COPY ./main.py /code/
    
    # (2)!
    CMD ["fastapi", "run", "main.py", "--port", "80"]
    

  1. Copy the `main.py` file to the `/code` directory directly (without any `./app` directory).

  2. Use `fastapi run` to serve your application in the single file `main.py`.

When you pass the file to `fastapi run` it will detect automatically that it is a single file and not part of a package and will know how to import it and serve your FastAPI app. üòé

## Deployment Concepts[¶](#deployment-concepts "Permanent link")

Let's talk again about some of the same [Deployment Concepts](../concepts/) in terms of containers.

Containers are mainly a tool to simplify the process of **building and deploying** an application, but they don't enforce a particular approach to handle these **deployment concepts** , and there are several possible strategies.

The **good news** is that with each different strategy there's a way to cover all of the deployment concepts. üéâ

Let's review these **deployment concepts** in terms of containers:

  * HTTPS
  * Running on startup
  * Restarts
  * Replication (the number of processes running)
  * Memory
  * Previous steps before starting

## HTTPS[¶](#https "Permanent link")

If we focus just on the **container image** for a FastAPI application (and later the running **container**), HTTPS normally would be handled **externally** by another tool.

It could be another container, for example with [Traefik](https://traefik.io/), handling **HTTPS** and **automatic** acquisition of **certificates**.

Tip

Traefik has integrations with Docker, Kubernetes, and others, so it's very easy to set up and configure HTTPS for your containers with it.

Alternatively, HTTPS could be handled by a cloud provider as one of their services (while still running the application in a container).

## Running on Startup and Restarts[¶](#running-on-startup-and-restarts "Permanent link")

There is normally another tool in charge of **starting and running** your container.

It could be **Docker** directly, **Docker Compose** , **Kubernetes** , a **cloud service** , etc.

In most (or all) cases, there's a simple option to enable running the container on startup and enabling restarts on failures. For example, in Docker, it's the command line option `--restart`.

Without using containers, making applications run on startup and with restarts can be cumbersome and difficult. But when **working with containers** in most cases that functionality is included by default. ‚ú®

## Replication - Number of Processes[¶](#replication-number-of-processes "Permanent link")

If you have a cluster of machines with **Kubernetes** , Docker Swarm Mode, Nomad, or another similar complex system to manage distributed containers on multiple machines, then you will probably want to **handle replication** at the **cluster level** instead of using a **process manager** (like Uvicorn with workers) in each container.

One of those distributed container management systems like Kubernetes normally has some integrated way of handling **replication of containers** while still supporting **load balancing** for the incoming requests. All at the **cluster level**.

In those cases, you would probably want to build a **Docker image from scratch** as [explained above](#dockerfile), installing your dependencies, and running **a single Uvicorn process** instead of using multiple Uvicorn workers.

### Load Balancer[¶](#load-balancer "Permanent link")

When using containers, you would normally have some component **listening on the main port**. It could possibly be another container that is also a **TLS Termination Proxy** to handle **HTTPS** or some similar tool.

As this component would take the **load** of requests and distribute that among the workers in a (hopefully) **balanced** way, it is also commonly called a **Load Balancer**.

Tip

The same **TLS Termination Proxy** component used for HTTPS would probably also be a **Load Balancer**.

And when working with containers, the same system you use to start and manage them would already have internal tools to transmit the **network communication** (e.g. HTTP requests) from that **load balancer** (that could also be a **TLS Termination Proxy**) to the container(s) with your app.

### One Load Balancer - Multiple Worker Containers[¶](#one-load-balancer-multiple-worker-containers "Permanent link")

When working with **Kubernetes** or similar distributed container management systems, using their internal networking mechanisms would allow the single **load balancer** that is listening on the main **port** to transmit communication (requests) to possibly **multiple containers** running your app.

Each of these containers running your app would normally have **just one process** (e.g. a Uvicorn process running your FastAPI application). They would all be **identical containers** , running the same thing, but each with its own process, memory, etc. That way you would take advantage of **parallelization** in **different cores** of the CPU, or even in **different machines**.

And the distributed container system with the **load balancer** would **distribute the requests** to each one of the containers with your app **in turns**. So, each request could be handled by one of the multiple **replicated containers** running your app.

And normally this **load balancer** would be able to handle requests that go to _other_ apps in your cluster (e.g. to a different domain, or under a different URL path prefix), and would transmit that communication to the right containers for _that other_ application running in your cluster.

### One Process per Container[¶](#one-process-per-container "Permanent link")

In this type of scenario, you probably would want to have **a single (Uvicorn) process per container** , as you would already be handling replication at the cluster level.

So, in this case, you **would not** want to have a multiple workers in the container, for example with the `--workers` command line option. You would want to have just a **single Uvicorn process** per container (but probably multiple containers).

Having another process manager inside the container (as would be with multiple workers) would only add **unnecessary complexity** that you are most probably already taking care of with your cluster system.

### Containers with Multiple Processes and Special Cases[¶](#containers-with-multiple-processes-and-special-cases "Permanent link")

Of course, there are **special cases** where you could want to have **a container** with several **Uvicorn worker processes** inside.

In those cases, you can use the `--workers` command line option to set the number of workers that you want to run:
    
    
    FROM python:3.9
    
    WORKDIR /code
    
    COPY ./requirements.txt /code/requirements.txt
    
    RUN pip install --no-cache-dir --upgrade -r /code/requirements.txt
    
    COPY ./app /code/app
    
    # (1)!
    CMD ["fastapi", "run", "app/main.py", "--port", "80", "--workers", "4"]
    

  1. Here we use the `--workers` command line option to set the number of workers to 4.

Here are some examples of when that could make sense:

#### A Simple App[¶](#a-simple-app "Permanent link")

You could want a process manager in the container if your application is **simple enough** that can run it on a **single server** , not a cluster.

#### Docker Compose[¶](#docker-compose "Permanent link")

You could be deploying to a **single server** (not a cluster) with **Docker Compose** , so you wouldn't have an easy way to manage replication of containers (with Docker Compose) while preserving the shared network and **load balancing**.

Then you could want to have **a single container** with a **process manager** starting **several worker processes** inside.

* * *

The main point is, **none** of these are **rules written in stone** that you have to blindly follow. You can use these ideas to **evaluate your own use case** and decide what is the best approach for your system, checking out how to manage the concepts of:

  * Security - HTTPS
  * Running on startup
  * Restarts
  * Replication (the number of processes running)
  * Memory
  * Previous steps before starting

## Memory[¶](#memory "Permanent link")

If you run **a single process per container** you will have a more or less well-defined, stable, and limited amount of memory consumed by each of those containers (more than one if they are replicated).

And then you can set those same memory limits and requirements in your configurations for your container management system (for example in **Kubernetes**). That way it will be able to **replicate the containers** in the **available machines** taking into account the amount of memory needed by them, and the amount available in the machines in the cluster.

If your application is **simple** , this will probably **not be a problem** , and you might not need to specify hard memory limits. But if you are **using a lot of memory** (for example with **machine learning** models), you should check how much memory you are consuming and adjust the **number of containers** that runs in **each machine** (and maybe add more machines to your cluster).

If you run **multiple processes per container** you will have to make sure that the number of processes started doesn't **consume more memory** than what is available.

## Previous Steps Before Starting and Containers[¶](#previous-steps-before-starting-and-containers "Permanent link")

If you are using containers (e.g. Docker, Kubernetes), then there are two main approaches you can use.

### Multiple Containers[¶](#multiple-containers "Permanent link")

If you have **multiple containers** , probably each one running a **single process** (for example, in a **Kubernetes** cluster), then you would probably want to have a **separate container** doing the work of the **previous steps** in a single container, running a single process, **before** running the replicated worker containers.

Info

If you are using Kubernetes, this would probably be an [Init Container](https://kubernetes.io/docs/concepts/workloads/pods/init-containers/).

If in your use case there's no problem in running those previous steps **multiple times in parallel** (for example if you are not running database migrations, but just checking if the database is ready yet), then you could also just put them in each container right before starting the main process.

### Single Container[¶](#single-container "Permanent link")

If you have a simple setup, with a **single container** that then starts multiple **worker processes** (or also just one process), then you could run those previous steps in the same container, right before starting the process with the app.

### Base Docker Image[¶](#base-docker-image "Permanent link")

There used to be an official FastAPI Docker image: [tiangolo/uvicorn-gunicorn-fastapi](https://github.com/tiangolo/uvicorn-gunicorn-fastapi-docker). But it is now deprecated. ‚õîÔ∏è

You should probably **not** use this base Docker image (or any other similar one).

If you are using **Kubernetes** (or others) and you are already setting **replication** at the cluster level, with multiple **containers**. In those cases, you are better off **building an image from scratch** as described above: [Build a Docker Image for FastAPI](#build-a-docker-image-for-fastapi).

And if you need to have multiple workers, you can simply use the `--workers` command line option.

Technical Details

The Docker image was created when Uvicorn didn't support managing and restarting dead workers, so it was needed to use Gunicorn with Uvicorn, which added quite some complexity, just to have Gunicorn manage and restart the Uvicorn worker processes.

But now that Uvicorn (and the `fastapi` command) support using `--workers`, there's no reason to use a base Docker image instead of building your own (it's pretty much the same amount of code üòÖ).

## Deploy the Container Image[¶](#deploy-the-container-image "Permanent link")

After having a Container (Docker) Image there are several ways to deploy it.

For example:

  * With **Docker Compose** in a single server
  * With a **Kubernetes** cluster
  * With a Docker Swarm Mode cluster
  * With another tool like Nomad
  * With a cloud service that takes your container image and deploys it

## Docker Image with `uv`[¶](#docker-image-with-uv "Permanent link")

If you are using [uv](https://github.com/astral-sh/uv) to install and manage your project, you can follow their [uv Docker guide](https://docs.astral.sh/uv/guides/integration/docker/).

## Recap[¶](#recap "Permanent link")

Using container systems (e.g. with **Docker** and **Kubernetes**) it becomes fairly straightforward to handle all the **deployment concepts** :

  * HTTPS
  * Running on startup
  * Restarts
  * Replication (the number of processes running)
  * Memory
  * Previous steps before starting

In most cases, you probably won't want to use any base image, and instead **build a container image from scratch** based on the official Python Docker image.

Taking care of the **order** of instructions in the `Dockerfile` and the **Docker cache** you can **minimize build times** , to maximize your productivity (and avoid boredom). üòé
  *[cluster]: A group of machines that are configured to be connected and work together in some way.

---

###### How To - Recipes¶

# How To - Recipes[¶](#how-to-recipes "Permanent link")

Here you will see different recipes or "how to" guides for **several topics**.

Most of these ideas would be more or less **independent** , and in most cases you should only need to study them if they apply directly to **your project**.

If something seems interesting and useful to your project, go ahead and check it, but otherwise, you might probably just skip them.

Tip

If you want to **learn FastAPI** in a structured way (recommended), go and read the [Tutorial - User Guide](../tutorial/) chapter by chapter instead.

---

###### General - How To - Recipes¶

# General - How To - Recipes[¶](#general-how-to-recipes "Permanent link")

Here are several pointers to other places in the docs, for general or frequent questions.

## Filter Data - Security[¶](#filter-data-security "Permanent link")

To ensure that you don't return more data than you should, read the docs for [Tutorial - Response Model - Return Type](../../tutorial/response-model/).

## Documentation Tags - OpenAPI[¶](#documentation-tags-openapi "Permanent link")

To add tags to your _path operations_ , and group them in the docs UI, read the docs for [Tutorial - Path Operation Configurations - Tags](../../tutorial/path-operation-configuration/#tags).

## Documentation Summary and Description - OpenAPI[¶](#documentation-summary-and-description-openapi "Permanent link")

To add a summary and description to your _path operations_ , and show them in the docs UI, read the docs for [Tutorial - Path Operation Configurations - Summary and Description](../../tutorial/path-operation-configuration/#summary-and-description).

## Documentation Response description - OpenAPI[¶](#documentation-response-description-openapi "Permanent link")

To define the description of the response, shown in the docs UI, read the docs for [Tutorial - Path Operation Configurations - Response description](../../tutorial/path-operation-configuration/#response-description).

## Documentation Deprecate a _Path Operation_ \- OpenAPI[¶](#documentation-deprecate-a-path-operation-openapi "Permanent link")

To deprecate a _path operation_ , and show it in the docs UI, read the docs for [Tutorial - Path Operation Configurations - Deprecation](../../tutorial/path-operation-configuration/#deprecate-a-path-operation).

## Convert any Data to JSON-compatible[¶](#convert-any-data-to-json-compatible "Permanent link")

To convert any data to JSON-compatible, read the docs for [Tutorial - JSON Compatible Encoder](../../tutorial/encoder/).

## OpenAPI Metadata - Docs[¶](#openapi-metadata-docs "Permanent link")

To add metadata to your OpenAPI schema, including a license, version, contact, etc, read the docs for [Tutorial - Metadata and Docs URLs](../../tutorial/metadata/).

## OpenAPI Custom URL[¶](#openapi-custom-url "Permanent link")

To customize the OpenAPI URL (or remove it), read the docs for [Tutorial - Metadata and Docs URLs](../../tutorial/metadata/#openapi-url).

## OpenAPI Docs URLs[¶](#openapi-docs-urls "Permanent link")

To update the URLs used for the automatically generated docs user interfaces, read the docs for [Tutorial - Metadata and Docs URLs](../../tutorial/metadata/#docs-urls).

---

###### Migrate from Pydantic v1 to Pydantic v2¶

# Migrate from Pydantic v1 to Pydantic v2[¶](#migrate-from-pydantic-v1-to-pydantic-v2 "Permanent link")

If you have an old FastAPI app, you might be using Pydantic version 1.

FastAPI version 0.100.0 had support for either Pydantic v1 or v2. It would use whichever you had installed.

FastAPI version 0.119.0 introduced partial support for Pydantic v1 from inside of Pydantic v2 (as `pydantic.v1`), to facilitate the migration to v2.

FastAPI 0.126.0 dropped support for Pydantic v1, while still supporting `pydantic.v1` for a little while.

Warning

The Pydantic team stopped support for Pydantic v1 for the latest versions of Python, starting with **Python 3.14**.

This includes `pydantic.v1`, which is no longer supported in Python 3.14 and above.

If you want to use the latest features of Python, you will need to make sure you use Pydantic v2.

If you have an old FastAPI app with Pydantic v1, here I'll show you how to migrate it to Pydantic v2, and the **features in FastAPI 0.119.0** to help you with a gradual migration.

## Official Guide[¶](#official-guide "Permanent link")

Pydantic has an official [Migration Guide](https://docs.pydantic.dev/latest/migration/) from v1 to v2.

It also includes what has changed, how validations are now more correct and strict, possible caveats, etc.

You can read it to understand better what has changed.

## Tests[¶](#tests "Permanent link")

Make sure you have [tests](../../tutorial/testing/) for your app and you run them on continuous integration (CI).

This way, you can do the upgrade and make sure everything is still working as expected.

## `bump-pydantic`[¶](#bump-pydantic "Permanent link")

In many cases, when you use regular Pydantic models without customizations, you will be able to automate most of the process of migrating from Pydantic v1 to Pydantic v2.

You can use [`bump-pydantic`](https://github.com/pydantic/bump-pydantic) from the same Pydantic team.

This tool will help you to automatically change most of the code that needs to be changed.

After this, you can run the tests and check if everything works. If it does, you are done. üòé

## Pydantic v1 in v2[¶](#pydantic-v1-in-v2 "Permanent link")

Pydantic v2 includes everything from Pydantic v1 as a submodule `pydantic.v1`. But this is no longer supported in versions above Python 3.13.

This means that you can install the latest version of Pydantic v2 and import and use the old Pydantic v1 components from this submodule, as if you had the old Pydantic v1 installed.

Python 3.10+
    
    
    from pydantic.v1 import BaseModel
    
    
    class Item(BaseModel):
        name: str
        description: str | None = None
        size: float
    

ü§ì Other versions and variants

Python 3.9+
    
    
    from typing import Union
    
    from pydantic.v1 import BaseModel
    
    
    class Item(BaseModel):
        name: str
        description: Union[str, None] = None
        size: float
    

### FastAPI support for Pydantic v1 in v2[¶](#fastapi-support-for-pydantic-v1-in-v2 "Permanent link")

Since FastAPI 0.119.0, there's also partial support for Pydantic v1 from inside of Pydantic v2, to facilitate the migration to v2.

So, you could upgrade Pydantic to the latest version 2, and change the imports to use the `pydantic.v1` submodule, and in many cases it would just work.

Python 3.10+
    
    
    from fastapi import FastAPI
    from pydantic.v1 import BaseModel
    
    
    class Item(BaseModel):
        name: str
        description: str | None = None
        size: float
    
    
    app = FastAPI()
    
    
    @app.post("/items/")
    async def create_item(item: Item) -> Item:
        return item
    

ü§ì Other versions and variants

Python 3.9+
    
    
    from typing import Union
    
    from fastapi import FastAPI
    from pydantic.v1 import BaseModel
    
    
    class Item(BaseModel):
        name: str
        description: Union[str, None] = None
        size: float
    
    
    app = FastAPI()
    
    
    @app.post("/items/")
    async def create_item(item: Item) -> Item:
        return item
    

Warning

Have in mind that as the Pydantic team no longer supports Pydantic v1 in recent versions of Python, starting from Python 3.14, using `pydantic.v1` is also not supported in Python 3.14 and above.

### Pydantic v1 and v2 on the same app[¶](#pydantic-v1-and-v2-on-the-same-app "Permanent link")

It's **not supported** by Pydantic to have a model of Pydantic v2 with its own fields defined as Pydantic v1 models or vice versa.
    
    
    graph TB
        subgraph "‚ùå Not Supported"
            direction TB
            subgraph V2["Pydantic v2 Model"]
                V1Field["Pydantic v1 Model"]
            end
            subgraph V1["Pydantic v1 Model"]
                V2Field["Pydantic v2 Model"]
            end
        end
    
        style V2 fill:#f9fff3
        style V1 fill:#fff6f0
        style V1Field fill:#fff6f0
        style V2Field fill:#f9fff3

...but, you can have separated models using Pydantic v1 and v2 in the same app.
    
    
    graph TB
        subgraph "‚úÖ Supported"
            direction TB
            subgraph V2["Pydantic v2 Model"]
                V2Field["Pydantic v2 Model"]
            end
            subgraph V1["Pydantic v1 Model"]
                V1Field["Pydantic v1 Model"]
            end
        end
    
        style V2 fill:#f9fff3
        style V1 fill:#fff6f0
        style V1Field fill:#fff6f0
        style V2Field fill:#f9fff3

In some cases, it's even possible to have both Pydantic v1 and v2 models in the same **path operation** in your FastAPI app:

Python 3.10+
    
    
    from fastapi import FastAPI
    from pydantic import BaseModel as BaseModelV2
    from pydantic.v1 import BaseModel
    
    
    class Item(BaseModel):
        name: str
        description: str | None = None
        size: float
    
    
    class ItemV2(BaseModelV2):
        name: str
        description: str | None = None
        size: float
    
    
    app = FastAPI()
    
    
    @app.post("/items/", response_model=ItemV2)
    async def create_item(item: Item):
        return item
    

ü§ì Other versions and variants

Python 3.9+
    
    
    from typing import Union
    
    from fastapi import FastAPI
    from pydantic import BaseModel as BaseModelV2
    from pydantic.v1 import BaseModel
    
    
    class Item(BaseModel):
        name: str
        description: Union[str, None] = None
        size: float
    
    
    class ItemV2(BaseModelV2):
        name: str
        description: Union[str, None] = None
        size: float
    
    
    app = FastAPI()
    
    
    @app.post("/items/", response_model=ItemV2)
    async def create_item(item: Item):
        return item
    

In this example above, the input model is a Pydantic v1 model, and the output model (defined in `response_model=ItemV2`) is a Pydantic v2 model.

### Pydantic v1 parameters[¶](#pydantic-v1-parameters "Permanent link")

If you need to use some of the FastAPI-specific tools for parameters like `Body`, `Query`, `Form`, etc. with Pydantic v1 models, you can import them from `fastapi.temp_pydantic_v1_params` while you finish the migration to Pydantic v2:

Python 3.10+
    
    
    from typing import Annotated
    
    from fastapi import FastAPI
    from fastapi.temp_pydantic_v1_params import Body
    from pydantic.v1 import BaseModel
    
    
    class Item(BaseModel):
        name: str
        description: str | None = None
        size: float
    
    
    app = FastAPI()
    
    
    @app.post("/items/")
    async def create_item(item: Annotated[Item, Body(embed=True)]) -> Item:
        return item
    

ü§ì Other versions and variants

Python 3.9+
    
    
    from typing import Annotated, Union
    
    from fastapi import FastAPI
    from fastapi.temp_pydantic_v1_params import Body
    from pydantic.v1 import BaseModel
    
    
    class Item(BaseModel):
        name: str
        description: Union[str, None] = None
        size: float
    
    
    app = FastAPI()
    
    
    @app.post("/items/")
    async def create_item(item: Annotated[Item, Body(embed=True)]) -> Item:
        return item
    

### Migrate in steps[¶](#migrate-in-steps "Permanent link")

Tip

First try with `bump-pydantic`, if your tests pass and that works, then you're done in one command. ‚ú®

If `bump-pydantic` doesn't work for your use case, you can use the support for both Pydantic v1 and v2 models in the same app to do the migration to Pydantic v2 gradually.

You could fist upgrade Pydantic to use the latest version 2, and change the imports to use `pydantic.v1` for all your models.

Then, you can start migrating your models from Pydantic v1 to v2 in groups, in gradual steps. üö∂

---

###### GraphQL¶

# GraphQL[¶](#graphql "Permanent link")

As **FastAPI** is based on the **ASGI** standard, it's very easy to integrate any **GraphQL** library also compatible with ASGI.

You can combine normal FastAPI _path operations_ with GraphQL on the same application.

Tip

**GraphQL** solves some very specific use cases.

It has **advantages** and **disadvantages** when compared to common **web APIs**.

Make sure you evaluate if the **benefits** for your use case compensate the **drawbacks**. ü§ì

## GraphQL Libraries[¶](#graphql-libraries "Permanent link")

Here are some of the **GraphQL** libraries that have **ASGI** support. You could use them with **FastAPI** :

  * [Strawberry](https://strawberry.rocks/) üçì
    * With [docs for FastAPI](https://strawberry.rocks/docs/integrations/fastapi)
  * [Ariadne](https://ariadnegraphql.org/)
    * With [docs for FastAPI](https://ariadnegraphql.org/docs/fastapi-integration)
  * [Tartiflette](https://tartiflette.io/)
    * With [Tartiflette ASGI](https://tartiflette.github.io/tartiflette-asgi/) to provide ASGI integration
  * [Graphene](https://graphene-python.org/)
    * With [starlette-graphene3](https://github.com/ciscorn/starlette-graphene3)

## GraphQL with Strawberry[¶](#graphql-with-strawberry "Permanent link")

If you need or want to work with **GraphQL** , [**Strawberry**](https://strawberry.rocks/) is the **recommended** library as it has the design closest to **FastAPI's** design, it's all based on **type annotations**.

Depending on your use case, you might prefer to use a different library, but if you asked me, I would probably suggest you try **Strawberry**.

Here's a small preview of how you could integrate Strawberry with FastAPI:

Python 3.9+
    
    
    import strawberry
    from fastapi import FastAPI
    from strawberry.fastapi import GraphQLRouter
    
    
    @strawberry.type
    class User:
        name: str
        age: int
    
    
    @strawberry.type
    class Query:
        @strawberry.field
        def user(self) -> User:
            return User(name="Patrick", age=100)
    
    
    schema = strawberry.Schema(query=Query)
    
    
    graphql_app = GraphQLRouter(schema)
    
    app = FastAPI()
    app.include_router(graphql_app, prefix="/graphql")
    

You can learn more about Strawberry in the [Strawberry documentation](https://strawberry.rocks/).

And also the docs about [Strawberry with FastAPI](https://strawberry.rocks/docs/integrations/fastapi).

## Older `GraphQLApp` from Starlette[¶](#older-graphqlapp-from-starlette "Permanent link")

Previous versions of Starlette included a `GraphQLApp` class to integrate with [Graphene](https://graphene-python.org/).

It was deprecated from Starlette, but if you have code that used it, you can easily **migrate** to [starlette-graphene3](https://github.com/ciscorn/starlette-graphene3), that covers the same use case and has an **almost identical interface**.

Tip

If you need GraphQL, I still would recommend you check out [Strawberry](https://strawberry.rocks/), as it's based on type annotations instead of custom classes and types.

## Learn More[¶](#learn-more "Permanent link")

You can learn more about **GraphQL** in the [official GraphQL documentation](https://graphql.org/).

You can also read more about each those libraries described above in their links.

---

###### Custom Request and APIRoute class¶

# Custom Request and APIRoute class[¶](#custom-request-and-apiroute-class "Permanent link")

In some cases, you may want to override the logic used by the `Request` and `APIRoute` classes.

In particular, this may be a good alternative to logic in a middleware.

For example, if you want to read or manipulate the request body before it is processed by your application.

Danger

This is an "advanced" feature.

If you are just starting with **FastAPI** you might want to skip this section.

## Use cases[¶](#use-cases "Permanent link")

Some use cases include:

  * Converting non-JSON request bodies to JSON (e.g. [`msgpack`](https://msgpack.org/index.html)).
  * Decompressing gzip-compressed request bodies.
  * Automatically logging all request bodies.

## Handling custom request body encodings[¶](#handling-custom-request-body-encodings "Permanent link")

Let's see how to make use of a custom `Request` subclass to decompress gzip requests.

And an `APIRoute` subclass to use that custom request class.

### Create a custom `GzipRequest` class[¶](#create-a-custom-gziprequest-class "Permanent link")

Tip

This is a toy example to demonstrate how it works, if you need Gzip support, you can use the provided [`GzipMiddleware`](../../advanced/middleware/#gzipmiddleware).

First, we create a `GzipRequest` class, which will overwrite the `Request.body()` method to decompress the body in the presence of an appropriate header.

If there's no `gzip` in the header, it will not try to decompress the body.

That way, the same route class can handle gzip compressed or uncompressed requests.

Python 3.10+
    
    
    import gzip
    from collections.abc import Callable
    from typing import Annotated
    
    from fastapi import Body, FastAPI, Request, Response
    from fastapi.routing import APIRoute
    
    
    class GzipRequest(Request):
        async def body(self) -> bytes:
            if not hasattr(self, "_body"):
                body = await super().body()
                if "gzip" in self.headers.getlist("Content-Encoding"):
                    body = gzip.decompress(body)
                self._body = body
            return self._body
    
    
    class GzipRoute(APIRoute):
        def get_route_handler(self) -> Callable:
            original_route_handler = super().get_route_handler()
    
            async def custom_route_handler(request: Request) -> Response:
                request = GzipRequest(request.scope, request.receive)
                return await original_route_handler(request)
    
            return custom_route_handler
    
    
    app = FastAPI()
    app.router.route_class = GzipRoute
    
    
    @app.post("/sum")
    async def sum_numbers(numbers: Annotated[list[int], Body()]):
        return {"sum": sum(numbers)}
    

ü§ì Other versions and variants

Python 3.9+Python 3.10+ - non-AnnotatedPython 3.9+ - non-Annotated
    
    
    import gzip
    from typing import Annotated, Callable
    
    from fastapi import Body, FastAPI, Request, Response
    from fastapi.routing import APIRoute
    
    
    class GzipRequest(Request):
        async def body(self) -> bytes:
            if not hasattr(self, "_body"):
                body = await super().body()
                if "gzip" in self.headers.getlist("Content-Encoding"):
                    body = gzip.decompress(body)
                self._body = body
            return self._body
    
    
    class GzipRoute(APIRoute):
        def get_route_handler(self) -> Callable:
            original_route_handler = super().get_route_handler()
    
            async def custom_route_handler(request: Request) -> Response:
                request = GzipRequest(request.scope, request.receive)
                return await original_route_handler(request)
    
            return custom_route_handler
    
    
    app = FastAPI()
    app.router.route_class = GzipRoute
    
    
    @app.post("/sum")
    async def sum_numbers(numbers: Annotated[list[int], Body()]):
        return {"sum": sum(numbers)}
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    import gzip
    from collections.abc import Callable
    
    from fastapi import Body, FastAPI, Request, Response
    from fastapi.routing import APIRoute
    
    
    class GzipRequest(Request):
        async def body(self) -> bytes:
            if not hasattr(self, "_body"):
                body = await super().body()
                if "gzip" in self.headers.getlist("Content-Encoding"):
                    body = gzip.decompress(body)
                self._body = body
            return self._body
    
    
    class GzipRoute(APIRoute):
        def get_route_handler(self) -> Callable:
            original_route_handler = super().get_route_handler()
    
            async def custom_route_handler(request: Request) -> Response:
                request = GzipRequest(request.scope, request.receive)
                return await original_route_handler(request)
    
            return custom_route_handler
    
    
    app = FastAPI()
    app.router.route_class = GzipRoute
    
    
    @app.post("/sum")
    async def sum_numbers(numbers: list[int] = Body()):
        return {"sum": sum(numbers)}
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    import gzip
    from typing import Callable
    
    from fastapi import Body, FastAPI, Request, Response
    from fastapi.routing import APIRoute
    
    
    class GzipRequest(Request):
        async def body(self) -> bytes:
            if not hasattr(self, "_body"):
                body = await super().body()
                if "gzip" in self.headers.getlist("Content-Encoding"):
                    body = gzip.decompress(body)
                self._body = body
            return self._body
    
    
    class GzipRoute(APIRoute):
        def get_route_handler(self) -> Callable:
            original_route_handler = super().get_route_handler()
    
            async def custom_route_handler(request: Request) -> Response:
                request = GzipRequest(request.scope, request.receive)
                return await original_route_handler(request)
    
            return custom_route_handler
    
    
    app = FastAPI()
    app.router.route_class = GzipRoute
    
    
    @app.post("/sum")
    async def sum_numbers(numbers: list[int] = Body()):
        return {"sum": sum(numbers)}
    

### Create a custom `GzipRoute` class[¶](#create-a-custom-gziproute-class "Permanent link")

Next, we create a custom subclass of `fastapi.routing.APIRoute` that will make use of the `GzipRequest`.

This time, it will overwrite the method `APIRoute.get_route_handler()`.

This method returns a function. And that function is what will receive a request and return a response.

Here we use it to create a `GzipRequest` from the original request.

Python 3.10+
    
    
    import gzip
    from collections.abc import Callable
    from typing import Annotated
    
    from fastapi import Body, FastAPI, Request, Response
    from fastapi.routing import APIRoute
    
    
    class GzipRequest(Request):
        async def body(self) -> bytes:
            if not hasattr(self, "_body"):
                body = await super().body()
                if "gzip" in self.headers.getlist("Content-Encoding"):
                    body = gzip.decompress(body)
                self._body = body
            return self._body
    
    
    class GzipRoute(APIRoute):
        def get_route_handler(self) -> Callable:
            original_route_handler = super().get_route_handler()
    
            async def custom_route_handler(request: Request) -> Response:
                request = GzipRequest(request.scope, request.receive)
                return await original_route_handler(request)
    
            return custom_route_handler
    
    
    app = FastAPI()
    app.router.route_class = GzipRoute
    
    
    @app.post("/sum")
    async def sum_numbers(numbers: Annotated[list[int], Body()]):
        return {"sum": sum(numbers)}
    

ü§ì Other versions and variants

Python 3.9+Python 3.10+ - non-AnnotatedPython 3.9+ - non-Annotated
    
    
    import gzip
    from typing import Annotated, Callable
    
    from fastapi import Body, FastAPI, Request, Response
    from fastapi.routing import APIRoute
    
    
    class GzipRequest(Request):
        async def body(self) -> bytes:
            if not hasattr(self, "_body"):
                body = await super().body()
                if "gzip" in self.headers.getlist("Content-Encoding"):
                    body = gzip.decompress(body)
                self._body = body
            return self._body
    
    
    class GzipRoute(APIRoute):
        def get_route_handler(self) -> Callable:
            original_route_handler = super().get_route_handler()
    
            async def custom_route_handler(request: Request) -> Response:
                request = GzipRequest(request.scope, request.receive)
                return await original_route_handler(request)
    
            return custom_route_handler
    
    
    app = FastAPI()
    app.router.route_class = GzipRoute
    
    
    @app.post("/sum")
    async def sum_numbers(numbers: Annotated[list[int], Body()]):
        return {"sum": sum(numbers)}
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    import gzip
    from collections.abc import Callable
    
    from fastapi import Body, FastAPI, Request, Response
    from fastapi.routing import APIRoute
    
    
    class GzipRequest(Request):
        async def body(self) -> bytes:
            if not hasattr(self, "_body"):
                body = await super().body()
                if "gzip" in self.headers.getlist("Content-Encoding"):
                    body = gzip.decompress(body)
                self._body = body
            return self._body
    
    
    class GzipRoute(APIRoute):
        def get_route_handler(self) -> Callable:
            original_route_handler = super().get_route_handler()
    
            async def custom_route_handler(request: Request) -> Response:
                request = GzipRequest(request.scope, request.receive)
                return await original_route_handler(request)
    
            return custom_route_handler
    
    
    app = FastAPI()
    app.router.route_class = GzipRoute
    
    
    @app.post("/sum")
    async def sum_numbers(numbers: list[int] = Body()):
        return {"sum": sum(numbers)}
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    import gzip
    from typing import Callable
    
    from fastapi import Body, FastAPI, Request, Response
    from fastapi.routing import APIRoute
    
    
    class GzipRequest(Request):
        async def body(self) -> bytes:
            if not hasattr(self, "_body"):
                body = await super().body()
                if "gzip" in self.headers.getlist("Content-Encoding"):
                    body = gzip.decompress(body)
                self._body = body
            return self._body
    
    
    class GzipRoute(APIRoute):
        def get_route_handler(self) -> Callable:
            original_route_handler = super().get_route_handler()
    
            async def custom_route_handler(request: Request) -> Response:
                request = GzipRequest(request.scope, request.receive)
                return await original_route_handler(request)
    
            return custom_route_handler
    
    
    app = FastAPI()
    app.router.route_class = GzipRoute
    
    
    @app.post("/sum")
    async def sum_numbers(numbers: list[int] = Body()):
        return {"sum": sum(numbers)}
    

Technical Details

A `Request` has a `request.scope` attribute, that's just a Python `dict` containing the metadata related to the request.

A `Request` also has a `request.receive`, that's a function to "receive" the body of the request.

The `scope` `dict` and `receive` function are both part of the ASGI specification.

And those two things, `scope` and `receive`, are what is needed to create a new `Request` instance.

To learn more about the `Request` check [Starlette's docs about Requests](https://www.starlette.dev/requests/).

The only thing the function returned by `GzipRequest.get_route_handler` does differently is convert the `Request` to a `GzipRequest`.

Doing this, our `GzipRequest` will take care of decompressing the data (if necessary) before passing it to our _path operations_.

After that, all of the processing logic is the same.

But because of our changes in `GzipRequest.body`, the request body will be automatically decompressed when it is loaded by **FastAPI** when needed.

## Accessing the request body in an exception handler[¶](#accessing-the-request-body-in-an-exception-handler "Permanent link")

Tip

To solve this same problem, it's probably a lot easier to use the `body` in a custom handler for `RequestValidationError` ([Handling Errors](../../tutorial/handling-errors/#use-the-requestvalidationerror-body)).

But this example is still valid and it shows how to interact with the internal components.

We can also use this same approach to access the request body in an exception handler.

All we need to do is handle the request inside a `try`/`except` block:

Python 3.10+
    
    
    from collections.abc import Callable
    from typing import Annotated
    
    from fastapi import Body, FastAPI, HTTPException, Request, Response
    from fastapi.exceptions import RequestValidationError
    from fastapi.routing import APIRoute
    
    
    class ValidationErrorLoggingRoute(APIRoute):
        def get_route_handler(self) -> Callable:
            original_route_handler = super().get_route_handler()
    
            async def custom_route_handler(request: Request) -> Response:
                try:
                    return await original_route_handler(request)
                except RequestValidationError as exc:
                    body = await request.body()
                    detail = {"errors": exc.errors(), "body": body.decode()}
                    raise HTTPException(status_code=422, detail=detail)
    
            return custom_route_handler
    
    
    app = FastAPI()
    app.router.route_class = ValidationErrorLoggingRoute
    
    
    @app.post("/")
    async def sum_numbers(numbers: Annotated[list[int], Body()]):
        return sum(numbers)
    

ü§ì Other versions and variants

Python 3.9+Python 3.10+ - non-AnnotatedPython 3.9+ - non-Annotated
    
    
    from typing import Annotated, Callable
    
    from fastapi import Body, FastAPI, HTTPException, Request, Response
    from fastapi.exceptions import RequestValidationError
    from fastapi.routing import APIRoute
    
    
    class ValidationErrorLoggingRoute(APIRoute):
        def get_route_handler(self) -> Callable:
            original_route_handler = super().get_route_handler()
    
            async def custom_route_handler(request: Request) -> Response:
                try:
                    return await original_route_handler(request)
                except RequestValidationError as exc:
                    body = await request.body()
                    detail = {"errors": exc.errors(), "body": body.decode()}
                    raise HTTPException(status_code=422, detail=detail)
    
            return custom_route_handler
    
    
    app = FastAPI()
    app.router.route_class = ValidationErrorLoggingRoute
    
    
    @app.post("/")
    async def sum_numbers(numbers: Annotated[list[int], Body()]):
        return sum(numbers)
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from collections.abc import Callable
    
    from fastapi import Body, FastAPI, HTTPException, Request, Response
    from fastapi.exceptions import RequestValidationError
    from fastapi.routing import APIRoute
    
    
    class ValidationErrorLoggingRoute(APIRoute):
        def get_route_handler(self) -> Callable:
            original_route_handler = super().get_route_handler()
    
            async def custom_route_handler(request: Request) -> Response:
                try:
                    return await original_route_handler(request)
                except RequestValidationError as exc:
                    body = await request.body()
                    detail = {"errors": exc.errors(), "body": body.decode()}
                    raise HTTPException(status_code=422, detail=detail)
    
            return custom_route_handler
    
    
    app = FastAPI()
    app.router.route_class = ValidationErrorLoggingRoute
    
    
    @app.post("/")
    async def sum_numbers(numbers: list[int] = Body()):
        return sum(numbers)
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from typing import Callable
    
    from fastapi import Body, FastAPI, HTTPException, Request, Response
    from fastapi.exceptions import RequestValidationError
    from fastapi.routing import APIRoute
    
    
    class ValidationErrorLoggingRoute(APIRoute):
        def get_route_handler(self) -> Callable:
            original_route_handler = super().get_route_handler()
    
            async def custom_route_handler(request: Request) -> Response:
                try:
                    return await original_route_handler(request)
                except RequestValidationError as exc:
                    body = await request.body()
                    detail = {"errors": exc.errors(), "body": body.decode()}
                    raise HTTPException(status_code=422, detail=detail)
    
            return custom_route_handler
    
    
    app = FastAPI()
    app.router.route_class = ValidationErrorLoggingRoute
    
    
    @app.post("/")
    async def sum_numbers(numbers: list[int] = Body()):
        return sum(numbers)
    

If an exception occurs, the`Request` instance will still be in scope, so we can read and make use of the request body when handling the error:

Python 3.10+
    
    
    from collections.abc import Callable
    from typing import Annotated
    
    from fastapi import Body, FastAPI, HTTPException, Request, Response
    from fastapi.exceptions import RequestValidationError
    from fastapi.routing import APIRoute
    
    
    class ValidationErrorLoggingRoute(APIRoute):
        def get_route_handler(self) -> Callable:
            original_route_handler = super().get_route_handler()
    
            async def custom_route_handler(request: Request) -> Response:
                try:
                    return await original_route_handler(request)
                except RequestValidationError as exc:
                    body = await request.body()
                    detail = {"errors": exc.errors(), "body": body.decode()}
                    raise HTTPException(status_code=422, detail=detail)
    
            return custom_route_handler
    
    
    app = FastAPI()
    app.router.route_class = ValidationErrorLoggingRoute
    
    
    @app.post("/")
    async def sum_numbers(numbers: Annotated[list[int], Body()]):
        return sum(numbers)
    

ü§ì Other versions and variants

Python 3.9+Python 3.10+ - non-AnnotatedPython 3.9+ - non-Annotated
    
    
    from typing import Annotated, Callable
    
    from fastapi import Body, FastAPI, HTTPException, Request, Response
    from fastapi.exceptions import RequestValidationError
    from fastapi.routing import APIRoute
    
    
    class ValidationErrorLoggingRoute(APIRoute):
        def get_route_handler(self) -> Callable:
            original_route_handler = super().get_route_handler()
    
            async def custom_route_handler(request: Request) -> Response:
                try:
                    return await original_route_handler(request)
                except RequestValidationError as exc:
                    body = await request.body()
                    detail = {"errors": exc.errors(), "body": body.decode()}
                    raise HTTPException(status_code=422, detail=detail)
    
            return custom_route_handler
    
    
    app = FastAPI()
    app.router.route_class = ValidationErrorLoggingRoute
    
    
    @app.post("/")
    async def sum_numbers(numbers: Annotated[list[int], Body()]):
        return sum(numbers)
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from collections.abc import Callable
    
    from fastapi import Body, FastAPI, HTTPException, Request, Response
    from fastapi.exceptions import RequestValidationError
    from fastapi.routing import APIRoute
    
    
    class ValidationErrorLoggingRoute(APIRoute):
        def get_route_handler(self) -> Callable:
            original_route_handler = super().get_route_handler()
    
            async def custom_route_handler(request: Request) -> Response:
                try:
                    return await original_route_handler(request)
                except RequestValidationError as exc:
                    body = await request.body()
                    detail = {"errors": exc.errors(), "body": body.decode()}
                    raise HTTPException(status_code=422, detail=detail)
    
            return custom_route_handler
    
    
    app = FastAPI()
    app.router.route_class = ValidationErrorLoggingRoute
    
    
    @app.post("/")
    async def sum_numbers(numbers: list[int] = Body()):
        return sum(numbers)
    

Tip

Prefer to use the `Annotated` version if possible.
    
    
    from typing import Callable
    
    from fastapi import Body, FastAPI, HTTPException, Request, Response
    from fastapi.exceptions import RequestValidationError
    from fastapi.routing import APIRoute
    
    
    class ValidationErrorLoggingRoute(APIRoute):
        def get_route_handler(self) -> Callable:
            original_route_handler = super().get_route_handler()
    
            async def custom_route_handler(request: Request) -> Response:
                try:
                    return await original_route_handler(request)
                except RequestValidationError as exc:
                    body = await request.body()
                    detail = {"errors": exc.errors(), "body": body.decode()}
                    raise HTTPException(status_code=422, detail=detail)
    
            return custom_route_handler
    
    
    app = FastAPI()
    app.router.route_class = ValidationErrorLoggingRoute
    
    
    @app.post("/")
    async def sum_numbers(numbers: list[int] = Body()):
        return sum(numbers)
    

## Custom `APIRoute` class in a router[¶](#custom-apiroute-class-in-a-router "Permanent link")

You can also set the `route_class` parameter of an `APIRouter`:

Python 3.10+
    
    
    import time
    from collections.abc import Callable
    
    from fastapi import APIRouter, FastAPI, Request, Response
    from fastapi.routing import APIRoute
    
    
    class TimedRoute(APIRoute):
        def get_route_handler(self) -> Callable:
            original_route_handler = super().get_route_handler()
    
            async def custom_route_handler(request: Request) -> Response:
                before = time.time()
                response: Response = await original_route_handler(request)
                duration = time.time() - before
                response.headers["X-Response-Time"] = str(duration)
                print(f"route duration: {duration}")
                print(f"route response: {response}")
                print(f"route response headers: {response.headers}")
                return response
    
            return custom_route_handler
    
    
    app = FastAPI()
    router = APIRouter(route_class=TimedRoute)
    
    
    @app.get("/")
    async def not_timed():
        return {"message": "Not timed"}
    
    
    @router.get("/timed")
    async def timed():
        return {"message": "It's the time of my life"}
    
    
    app.include_router(router)
    

ü§ì Other versions and variants

Python 3.9+
    
    
    import time
    from typing import Callable
    
    from fastapi import APIRouter, FastAPI, Request, Response
    from fastapi.routing import APIRoute
    
    
    class TimedRoute(APIRoute):
        def get_route_handler(self) -> Callable:
            original_route_handler = super().get_route_handler()
    
            async def custom_route_handler(request: Request) -> Response:
                before = time.time()
                response: Response = await original_route_handler(request)
                duration = time.time() - before
                response.headers["X-Response-Time"] = str(duration)
                print(f"route duration: {duration}")
                print(f"route response: {response}")
                print(f"route response headers: {response.headers}")
                return response
    
            return custom_route_handler
    
    
    app = FastAPI()
    router = APIRouter(route_class=TimedRoute)
    
    
    @app.get("/")
    async def not_timed():
        return {"message": "Not timed"}
    
    
    @router.get("/timed")
    async def timed():
        return {"message": "It's the time of my life"}
    
    
    app.include_router(router)
    

In this example, the _path operations_ under the `router` will use the custom `TimedRoute` class, and will have an extra `X-Response-Time` header in the response with the time it took to generate the response:

Python 3.10+
    
    
    import time
    from collections.abc import Callable
    
    from fastapi import APIRouter, FastAPI, Request, Response
    from fastapi.routing import APIRoute
    
    
    class TimedRoute(APIRoute):
        def get_route_handler(self) -> Callable:
            original_route_handler = super().get_route_handler()
    
            async def custom_route_handler(request: Request) -> Response:
                before = time.time()
                response: Response = await original_route_handler(request)
                duration = time.time() - before
                response.headers["X-Response-Time"] = str(duration)
                print(f"route duration: {duration}")
                print(f"route response: {response}")
                print(f"route response headers: {response.headers}")
                return response
    
            return custom_route_handler
    
    
    app = FastAPI()
    router = APIRouter(route_class=TimedRoute)
    
    
    @app.get("/")
    async def not_timed():
        return {"message": "Not timed"}
    
    
    @router.get("/timed")
    async def timed():
        return {"message": "It's the time of my life"}
    
    
    app.include_router(router)
    

ü§ì Other versions and variants

Python 3.9+
    
    
    import time
    from typing import Callable
    
    from fastapi import APIRouter, FastAPI, Request, Response
    from fastapi.routing import APIRoute
    
    
    class TimedRoute(APIRoute):
        def get_route_handler(self) -> Callable:
            original_route_handler = super().get_route_handler()
    
            async def custom_route_handler(request: Request) -> Response:
                before = time.time()
                response: Response = await original_route_handler(request)
                duration = time.time() - before
                response.headers["X-Response-Time"] = str(duration)
                print(f"route duration: {duration}")
                print(f"route response: {response}")
                print(f"route response headers: {response.headers}")
                return response
    
            return custom_route_handler
    
    
    app = FastAPI()
    router = APIRouter(route_class=TimedRoute)
    
    
    @app.get("/")
    async def not_timed():
        return {"message": "Not timed"}
    
    
    @router.get("/timed")
    async def timed():
        return {"message": "It's the time of my life"}
    
    
    app.include_router(router)

---

###### Conditional OpenAPI¶

# Conditional OpenAPI[¶](#conditional-openapi "Permanent link")

If you needed to, you could use settings and environment variables to configure OpenAPI conditionally depending on the environment, and even disable it entirely.

## About security, APIs, and docs[¶](#about-security-apis-and-docs "Permanent link")

Hiding your documentation user interfaces in production _shouldn't_ be the way to protect your API.

That doesn't add any extra security to your API, the _path operations_ will still be available where they are.

If there's a security flaw in your code, it will still exist.

Hiding the documentation just makes it more difficult to understand how to interact with your API, and could make it more difficult for you to debug it in production. It could be considered simply a form of [Security through obscurity](https://en.wikipedia.org/wiki/Security_through_obscurity).

If you want to secure your API, there are several better things you can do, for example:

  * Make sure you have well defined Pydantic models for your request bodies and responses.
  * Configure any required permissions and roles using dependencies.
  * Never store plaintext passwords, only password hashes.
  * Implement and use well-known cryptographic tools, like pwdlib and JWT tokens, etc.
  * Add more granular permission controls with OAuth2 scopes where needed.
  * ...etc.

Nevertheless, you might have a very specific use case where you really need to disable the API docs for some environment (e.g. for production) or depending on configurations from environment variables.

## Conditional OpenAPI from settings and env vars[¶](#conditional-openapi-from-settings-and-env-vars "Permanent link")

You can easily use the same Pydantic settings to configure your generated OpenAPI and the docs UIs.

For example:

Python 3.9+
    
    
    from fastapi import FastAPI
    from pydantic_settings import BaseSettings
    
    
    class Settings(BaseSettings):
        openapi_url: str = "/openapi.json"
    
    
    settings = Settings()
    
    app = FastAPI(openapi_url=settings.openapi_url)
    
    
    @app.get("/")
    def root():
        return {"message": "Hello World"}
    

Here we declare the setting `openapi_url` with the same default of `"/openapi.json"`.

And then we use it when creating the `FastAPI` app.

Then you could disable OpenAPI (including the UI docs) by setting the environment variable `OPENAPI_URL` to the empty string, like:
    
    
    $ OPENAPI_URL= uvicorn main:app
    
    <span style="color: green;">INFO</span>:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
    

Then if you go to the URLs at `/openapi.json`, `/docs`, or `/redoc` you will just get a `404 Not Found` error like:
    
    
    {
        "detail": "Not Found"
    }

---

###### Extending OpenAPI¶

# Extending OpenAPI[¶](#extending-openapi "Permanent link")

There are some cases where you might need to modify the generated OpenAPI schema.

In this section you will see how.

## The normal process[¶](#the-normal-process "Permanent link")

The normal (default) process, is as follows.

A `FastAPI` application (instance) has an `.openapi()` method that is expected to return the OpenAPI schema.

As part of the application object creation, a _path operation_ for `/openapi.json` (or for whatever you set your `openapi_url`) is registered.

It just returns a JSON response with the result of the application's `.openapi()` method.

By default, what the method `.openapi()` does is check the property `.openapi_schema` to see if it has contents and return them.

If it doesn't, it generates them using the utility function at `fastapi.openapi.utils.get_openapi`.

And that function `get_openapi()` receives as parameters:

  * `title`: The OpenAPI title, shown in the docs.
  * `version`: The version of your API, e.g. `2.5.0`.
  * `openapi_version`: The version of the OpenAPI specification used. By default, the latest: `3.1.0`.
  * `summary`: A short summary of the API.
  * `description`: The description of your API, this can include markdown and will be shown in the docs.
  * `routes`: A list of routes, these are each of the registered _path operations_. They are taken from `app.routes`.

Info

The parameter `summary` is available in OpenAPI 3.1.0 and above, supported by FastAPI 0.99.0 and above.

## Overriding the defaults[¶](#overriding-the-defaults "Permanent link")

Using the information above, you can use the same utility function to generate the OpenAPI schema and override each part that you need.

For example, let's add [ReDoc's OpenAPI extension to include a custom logo](https://github.com/Rebilly/ReDoc/blob/master/docs/redoc-vendor-extensions.md#x-logo).

### Normal **FastAPI**[¶](#normal-fastapi "Permanent link")

First, write all your **FastAPI** application as normally:

Python 3.9+
    
    
    from fastapi import FastAPI
    from fastapi.openapi.utils import get_openapi
    
    app = FastAPI()
    
    
    @app.get("/items/")
    async def read_items():
        return [{"name": "Foo"}]
    
    
    def custom_openapi():
        if app.openapi_schema:
            return app.openapi_schema
        openapi_schema = get_openapi(
            title="Custom title",
            version="2.5.0",
            summary="This is a very custom OpenAPI schema",
            description="Here's a longer description of the custom **OpenAPI** schema",
            routes=app.routes,
        )
        openapi_schema["info"]["x-logo"] = {
            "url": "https://fastapi.tiangolo.com/img/logo-margin/logo-teal.png"
        }
        app.openapi_schema = openapi_schema
        return app.openapi_schema
    
    
    app.openapi = custom_openapi
    

### Generate the OpenAPI schema[¶](#generate-the-openapi-schema "Permanent link")

Then, use the same utility function to generate the OpenAPI schema, inside a `custom_openapi()` function:

Python 3.9+
    
    
    from fastapi import FastAPI
    from fastapi.openapi.utils import get_openapi
    
    app = FastAPI()
    
    
    @app.get("/items/")
    async def read_items():
        return [{"name": "Foo"}]
    
    
    def custom_openapi():
        if app.openapi_schema:
            return app.openapi_schema
        openapi_schema = get_openapi(
            title="Custom title",
            version="2.5.0",
            summary="This is a very custom OpenAPI schema",
            description="Here's a longer description of the custom **OpenAPI** schema",
            routes=app.routes,
        )
        openapi_schema["info"]["x-logo"] = {
            "url": "https://fastapi.tiangolo.com/img/logo-margin/logo-teal.png"
        }
        app.openapi_schema = openapi_schema
        return app.openapi_schema
    
    
    app.openapi = custom_openapi
    

### Modify the OpenAPI schema[¶](#modify-the-openapi-schema "Permanent link")

Now you can add the ReDoc extension, adding a custom `x-logo` to the `info` "object" in the OpenAPI schema:

Python 3.9+
    
    
    from fastapi import FastAPI
    from fastapi.openapi.utils import get_openapi
    
    app = FastAPI()
    
    
    @app.get("/items/")
    async def read_items():
        return [{"name": "Foo"}]
    
    
    def custom_openapi():
        if app.openapi_schema:
            return app.openapi_schema
        openapi_schema = get_openapi(
            title="Custom title",
            version="2.5.0",
            summary="This is a very custom OpenAPI schema",
            description="Here's a longer description of the custom **OpenAPI** schema",
            routes=app.routes,
        )
        openapi_schema["info"]["x-logo"] = {
            "url": "https://fastapi.tiangolo.com/img/logo-margin/logo-teal.png"
        }
        app.openapi_schema = openapi_schema
        return app.openapi_schema
    
    
    app.openapi = custom_openapi
    

### Cache the OpenAPI schema[¶](#cache-the-openapi-schema "Permanent link")

You can use the property `.openapi_schema` as a "cache", to store your generated schema.

That way, your application won't have to generate the schema every time a user opens your API docs.

It will be generated only once, and then the same cached schema will be used for the next requests.

Python 3.9+
    
    
    from fastapi import FastAPI
    from fastapi.openapi.utils import get_openapi
    
    app = FastAPI()
    
    
    @app.get("/items/")
    async def read_items():
        return [{"name": "Foo"}]
    
    
    def custom_openapi():
        if app.openapi_schema:
            return app.openapi_schema
        openapi_schema = get_openapi(
            title="Custom title",
            version="2.5.0",
            summary="This is a very custom OpenAPI schema",
            description="Here's a longer description of the custom **OpenAPI** schema",
            routes=app.routes,
        )
        openapi_schema["info"]["x-logo"] = {
            "url": "https://fastapi.tiangolo.com/img/logo-margin/logo-teal.png"
        }
        app.openapi_schema = openapi_schema
        return app.openapi_schema
    
    
    app.openapi = custom_openapi
    

### Override the method[¶](#override-the-method "Permanent link")

Now you can replace the `.openapi()` method with your new function.

Python 3.9+
    
    
    from fastapi import FastAPI
    from fastapi.openapi.utils import get_openapi
    
    app = FastAPI()
    
    
    @app.get("/items/")
    async def read_items():
        return [{"name": "Foo"}]
    
    
    def custom_openapi():
        if app.openapi_schema:
            return app.openapi_schema
        openapi_schema = get_openapi(
            title="Custom title",
            version="2.5.0",
            summary="This is a very custom OpenAPI schema",
            description="Here's a longer description of the custom **OpenAPI** schema",
            routes=app.routes,
        )
        openapi_schema["info"]["x-logo"] = {
            "url": "https://fastapi.tiangolo.com/img/logo-margin/logo-teal.png"
        }
        app.openapi_schema = openapi_schema
        return app.openapi_schema
    
    
    app.openapi = custom_openapi
    

### Check it[¶](#check-it "Permanent link")

Once you go to <http://127.0.0.1:8000/redoc> you will see that you are using your custom logo (in this example, **FastAPI** 's logo):

![](/img/tutorial/extending-openapi/image01.png)

---

###### Separate OpenAPI Schemas for Input and Output or Not¶

# Separate OpenAPI Schemas for Input and Output or Not[¶](#separate-openapi-schemas-for-input-and-output-or-not "Permanent link")

Since **Pydantic v2** was released, the generated OpenAPI is a bit more exact and **correct** than before. üòé

In fact, in some cases, it will even have **two JSON Schemas** in OpenAPI for the same Pydantic model, for input and output, depending on if they have **default values**.

Let's see how that works and how to change it if you need to do that.

## Pydantic Models for Input and Output[¶](#pydantic-models-for-input-and-output "Permanent link")

Let's say you have a Pydantic model with default values, like this one:

Python 3.10+
    
    
    from fastapi import FastAPI
    from pydantic import BaseModel
    
    
    class Item(BaseModel):
        name: str
        description: str | None = None
    
    # Code below omitted üëá
    

üëÄ Full file preview

Python 3.10+
    
    
    from fastapi import FastAPI
    from pydantic import BaseModel
    
    
    class Item(BaseModel):
        name: str
        description: str | None = None
    
    
    app = FastAPI()
    
    
    @app.post("/items/")
    def create_item(item: Item):
        return item
    
    
    @app.get("/items/")
    def read_items() -> list[Item]:
        return [
            Item(
                name="Portal Gun",
                description="Device to travel through the multi-rick-verse",
            ),
            Item(name="Plumbus"),
        ]
    

ü§ì Other versions and variants

Python 3.9+
    
    
    from typing import Optional
    
    from fastapi import FastAPI
    from pydantic import BaseModel
    
    
    class Item(BaseModel):
        name: str
        description: Optional[str] = None
    
    
    app = FastAPI()
    
    
    @app.post("/items/")
    def create_item(item: Item):
        return item
    
    
    @app.get("/items/")
    def read_items() -> list[Item]:
        return [
            Item(
                name="Portal Gun",
                description="Device to travel through the multi-rick-verse",
            ),
            Item(name="Plumbus"),
        ]
    

### Model for Input[¶](#model-for-input "Permanent link")

If you use this model as an input like here:

Python 3.10+
    
    
    from fastapi import FastAPI
    from pydantic import BaseModel
    
    
    class Item(BaseModel):
        name: str
        description: str | None = None
    
    
    app = FastAPI()
    
    
    @app.post("/items/")
    def create_item(item: Item):
        return item
    
    # Code below omitted üëá
    

üëÄ Full file preview

Python 3.10+
    
    
    from fastapi import FastAPI
    from pydantic import BaseModel
    
    
    class Item(BaseModel):
        name: str
        description: str | None = None
    
    
    app = FastAPI()
    
    
    @app.post("/items/")
    def create_item(item: Item):
        return item
    
    
    @app.get("/items/")
    def read_items() -> list[Item]:
        return [
            Item(
                name="Portal Gun",
                description="Device to travel through the multi-rick-verse",
            ),
            Item(name="Plumbus"),
        ]
    

ü§ì Other versions and variants

Python 3.9+
    
    
    from typing import Optional
    
    from fastapi import FastAPI
    from pydantic import BaseModel
    
    
    class Item(BaseModel):
        name: str
        description: Optional[str] = None
    
    
    app = FastAPI()
    
    
    @app.post("/items/")
    def create_item(item: Item):
        return item
    
    
    @app.get("/items/")
    def read_items() -> list[Item]:
        return [
            Item(
                name="Portal Gun",
                description="Device to travel through the multi-rick-verse",
            ),
            Item(name="Plumbus"),
        ]
    

...then the `description` field will **not be required**. Because it has a default value of `None`.

### Input Model in Docs[¶](#input-model-in-docs "Permanent link")

You can confirm that in the docs, the `description` field doesn't have a **red asterisk** , it's not marked as required:

![](/img/tutorial/separate-openapi-schemas/image01.png)

### Model for Output[¶](#model-for-output "Permanent link")

But if you use the same model as an output, like here:

Python 3.10+
    
    
    from fastapi import FastAPI
    from pydantic import BaseModel
    
    
    class Item(BaseModel):
        name: str
        description: str | None = None
    
    
    app = FastAPI()
    
    
    @app.post("/items/")
    def create_item(item: Item):
        return item
    
    
    @app.get("/items/")
    def read_items() -> list[Item]:
        return [
            Item(
                name="Portal Gun",
                description="Device to travel through the multi-rick-verse",
            ),
            Item(name="Plumbus"),
        ]
    

ü§ì Other versions and variants

Python 3.9+
    
    
    from typing import Optional
    
    from fastapi import FastAPI
    from pydantic import BaseModel
    
    
    class Item(BaseModel):
        name: str
        description: Optional[str] = None
    
    
    app = FastAPI()
    
    
    @app.post("/items/")
    def create_item(item: Item):
        return item
    
    
    @app.get("/items/")
    def read_items() -> list[Item]:
        return [
            Item(
                name="Portal Gun",
                description="Device to travel through the multi-rick-verse",
            ),
            Item(name="Plumbus"),
        ]
    

...then because `description` has a default value, if you **don't return anything** for that field, it will still have that **default value**.

### Model for Output Response Data[¶](#model-for-output-response-data "Permanent link")

If you interact with the docs and check the response, even though the code didn't add anything in one of the `description` fields, the JSON response contains the default value (`null`):

![](/img/tutorial/separate-openapi-schemas/image02.png)

This means that it will **always have a value** , it's just that sometimes the value could be `None` (or `null` in JSON).

That means that, clients using your API don't have to check if the value exists or not, they can **assume the field will always be there** , but just that in some cases it will have the default value of `None`.

The way to describe this in OpenAPI, is to mark that field as **required** , because it will always be there.

Because of that, the JSON Schema for a model can be different depending on if it's used for **input or output** :

  * for **input** the `description` will **not be required**
  * for **output** it will be **required** (and possibly `None`, or in JSON terms, `null`)

### Model for Output in Docs[¶](#model-for-output-in-docs "Permanent link")

You can check the output model in the docs too, **both** `name` and `description` are marked as **required** with a **red asterisk** :

![](/img/tutorial/separate-openapi-schemas/image03.png)

### Model for Input and Output in Docs[¶](#model-for-input-and-output-in-docs "Permanent link")

And if you check all the available Schemas (JSON Schemas) in OpenAPI, you will see that there are two, one `Item-Input` and one `Item-Output`.

For `Item-Input`, `description` is **not required** , it doesn't have a red asterisk.

But for `Item-Output`, `description` is **required** , it has a red asterisk.

![](/img/tutorial/separate-openapi-schemas/image04.png)

With this feature from **Pydantic v2** , your API documentation is more **precise** , and if you have autogenerated clients and SDKs, they will be more precise too, with a better **developer experience** and consistency. üéâ

## Do not Separate Schemas[¶](#do-not-separate-schemas "Permanent link")

Now, there are some cases where you might want to have the **same schema for input and output**.

Probably the main use case for this is if you already have some autogenerated client code/SDKs and you don't want to update all the autogenerated client code/SDKs yet, you probably will want to do it at some point, but maybe not right now.

In that case, you can disable this feature in **FastAPI** , with the parameter `separate_input_output_schemas=False`.

Info

Support for `separate_input_output_schemas` was added in FastAPI `0.102.0`. ü§ì

Python 3.10+
    
    
    from fastapi import FastAPI
    from pydantic import BaseModel
    
    
    class Item(BaseModel):
        name: str
        description: str | None = None
    
    
    app = FastAPI(separate_input_output_schemas=False)
    
    
    @app.post("/items/")
    def create_item(item: Item):
        return item
    
    
    @app.get("/items/")
    def read_items() -> list[Item]:
        return [
            Item(
                name="Portal Gun",
                description="Device to travel through the multi-rick-verse",
            ),
            Item(name="Plumbus"),
        ]
    

ü§ì Other versions and variants

Python 3.9+
    
    
    from typing import Optional
    
    from fastapi import FastAPI
    from pydantic import BaseModel
    
    
    class Item(BaseModel):
        name: str
        description: Optional[str] = None
    
    
    app = FastAPI(separate_input_output_schemas=False)
    
    
    @app.post("/items/")
    def create_item(item: Item):
        return item
    
    
    @app.get("/items/")
    def read_items() -> list[Item]:
        return [
            Item(
                name="Portal Gun",
                description="Device to travel through the multi-rick-verse",
            ),
            Item(name="Plumbus"),
        ]
    

### Same Schema for Input and Output Models in Docs[¶](#same-schema-for-input-and-output-models-in-docs "Permanent link")

And now there will be one single schema for input and output for the model, only `Item`, and it will have `description` as **not required** :

![](/img/tutorial/separate-openapi-schemas/image05.png)

---

###### Custom Docs UI Static Assets (Self-Hosting)¶

# Custom Docs UI Static Assets (Self-Hosting)[¶](#custom-docs-ui-static-assets-self-hosting "Permanent link")

The API docs use **Swagger UI** and **ReDoc** , and each of those need some JavaScript and CSS files.

By default, those files are served from a CDN.

But it's possible to customize it, you can set a specific CDN, or serve the files yourself.

## Custom CDN for JavaScript and CSS[¶](#custom-cdn-for-javascript-and-css "Permanent link")

Let's say that you want to use a different CDN, for example you want to use `https://unpkg.com/`.

This could be useful if for example you live in a country that restricts some URLs.

### Disable the automatic docs[¶](#disable-the-automatic-docs "Permanent link")

The first step is to disable the automatic docs, as by default, those use the default CDN.

To disable them, set their URLs to `None` when creating your `FastAPI` app:

Python 3.9+
    
    
    from fastapi import FastAPI
    from fastapi.openapi.docs import (
        get_redoc_html,
        get_swagger_ui_html,
        get_swagger_ui_oauth2_redirect_html,
    )
    
    app = FastAPI(docs_url=None, redoc_url=None)
    
    
    @app.get("/docs", include_in_schema=False)
    async def custom_swagger_ui_html():
        return get_swagger_ui_html(
            openapi_url=app.openapi_url,
            title=app.title + " - Swagger UI",
            oauth2_redirect_url=app.swagger_ui_oauth2_redirect_url,
            swagger_js_url="https://unpkg.com/swagger-ui-dist@5/swagger-ui-bundle.js",
            swagger_css_url="https://unpkg.com/swagger-ui-dist@5/swagger-ui.css",
        )
    
    
    @app.get(app.swagger_ui_oauth2_redirect_url, include_in_schema=False)
    async def swagger_ui_redirect():
        return get_swagger_ui_oauth2_redirect_html()
    
    
    @app.get("/redoc", include_in_schema=False)
    async def redoc_html():
        return get_redoc_html(
            openapi_url=app.openapi_url,
            title=app.title + " - ReDoc",
            redoc_js_url="https://unpkg.com/redoc@2/bundles/redoc.standalone.js",
        )
    
    
    @app.get("/users/{username}")
    async def read_user(username: str):
        return {"message": f"Hello {username}"}
    

### Include the custom docs[¶](#include-the-custom-docs "Permanent link")

Now you can create the _path operations_ for the custom docs.

You can reuse FastAPI's internal functions to create the HTML pages for the docs, and pass them the needed arguments:

  * `openapi_url`: the URL where the HTML page for the docs can get the OpenAPI schema for your API. You can use here the attribute `app.openapi_url`.
  * `title`: the title of your API.
  * `oauth2_redirect_url`: you can use `app.swagger_ui_oauth2_redirect_url` here to use the default.
  * `swagger_js_url`: the URL where the HTML for your Swagger UI docs can get the **JavaScript** file. This is the custom CDN URL.
  * `swagger_css_url`: the URL where the HTML for your Swagger UI docs can get the **CSS** file. This is the custom CDN URL.

And similarly for ReDoc...

Python 3.9+
    
    
    from fastapi import FastAPI
    from fastapi.openapi.docs import (
        get_redoc_html,
        get_swagger_ui_html,
        get_swagger_ui_oauth2_redirect_html,
    )
    
    app = FastAPI(docs_url=None, redoc_url=None)
    
    
    @app.get("/docs", include_in_schema=False)
    async def custom_swagger_ui_html():
        return get_swagger_ui_html(
            openapi_url=app.openapi_url,
            title=app.title + " - Swagger UI",
            oauth2_redirect_url=app.swagger_ui_oauth2_redirect_url,
            swagger_js_url="https://unpkg.com/swagger-ui-dist@5/swagger-ui-bundle.js",
            swagger_css_url="https://unpkg.com/swagger-ui-dist@5/swagger-ui.css",
        )
    
    
    @app.get(app.swagger_ui_oauth2_redirect_url, include_in_schema=False)
    async def swagger_ui_redirect():
        return get_swagger_ui_oauth2_redirect_html()
    
    
    @app.get("/redoc", include_in_schema=False)
    async def redoc_html():
        return get_redoc_html(
            openapi_url=app.openapi_url,
            title=app.title + " - ReDoc",
            redoc_js_url="https://unpkg.com/redoc@2/bundles/redoc.standalone.js",
        )
    
    
    @app.get("/users/{username}")
    async def read_user(username: str):
        return {"message": f"Hello {username}"}
    

Tip

The _path operation_ for `swagger_ui_redirect` is a helper for when you use OAuth2.

If you integrate your API with an OAuth2 provider, you will be able to authenticate and come back to the API docs with the acquired credentials. And interact with it using the real OAuth2 authentication.

Swagger UI will handle it behind the scenes for you, but it needs this "redirect" helper.

### Create a _path operation_ to test it[¶](#create-a-path-operation-to-test-it "Permanent link")

Now, to be able to test that everything works, create a _path operation_ :

Python 3.9+
    
    
    from fastapi import FastAPI
    from fastapi.openapi.docs import (
        get_redoc_html,
        get_swagger_ui_html,
        get_swagger_ui_oauth2_redirect_html,
    )
    
    app = FastAPI(docs_url=None, redoc_url=None)
    
    
    @app.get("/docs", include_in_schema=False)
    async def custom_swagger_ui_html():
        return get_swagger_ui_html(
            openapi_url=app.openapi_url,
            title=app.title + " - Swagger UI",
            oauth2_redirect_url=app.swagger_ui_oauth2_redirect_url,
            swagger_js_url="https://unpkg.com/swagger-ui-dist@5/swagger-ui-bundle.js",
            swagger_css_url="https://unpkg.com/swagger-ui-dist@5/swagger-ui.css",
        )
    
    
    @app.get(app.swagger_ui_oauth2_redirect_url, include_in_schema=False)
    async def swagger_ui_redirect():
        return get_swagger_ui_oauth2_redirect_html()
    
    
    @app.get("/redoc", include_in_schema=False)
    async def redoc_html():
        return get_redoc_html(
            openapi_url=app.openapi_url,
            title=app.title + " - ReDoc",
            redoc_js_url="https://unpkg.com/redoc@2/bundles/redoc.standalone.js",
        )
    
    
    @app.get("/users/{username}")
    async def read_user(username: str):
        return {"message": f"Hello {username}"}
    

### Test it[¶](#test-it "Permanent link")

Now, you should be able to go to your docs at <http://127.0.0.1:8000/docs>, and reload the page, it will load those assets from the new CDN.

## Self-hosting JavaScript and CSS for docs[¶](#self-hosting-javascript-and-css-for-docs "Permanent link")

Self-hosting the JavaScript and CSS could be useful if, for example, you need your app to keep working even while offline, without open Internet access, or in a local network.

Here you'll see how to serve those files yourself, in the same FastAPI app, and configure the docs to use them.

### Project file structure[¶](#project-file-structure "Permanent link")

Let's say your project file structure looks like this:
    
    
    .
    ‚îú‚îÄ‚îÄ app
    ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
    ‚îÇ   ‚îú‚îÄ‚îÄ main.py
    

Now create a directory to store those static files.

Your new file structure could look like this:
    
    
    .
    ‚îú‚îÄ‚îÄ app
    ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ __init__.py
    ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ main.py
    ‚îî‚îÄ‚îÄ static/
    

### Download the files[¶](#download-the-files "Permanent link")

Download the static files needed for the docs and put them on that `static/` directory.

You can probably right-click each link and select an option similar to "Save link as...".

**Swagger UI** uses the files:

  * [`swagger-ui-bundle.js`](https://cdn.jsdelivr.net/npm/swagger-ui-dist@5/swagger-ui-bundle.js)
  * [`swagger-ui.css`](https://cdn.jsdelivr.net/npm/swagger-ui-dist@5/swagger-ui.css)

And **ReDoc** uses the file:

  * [`redoc.standalone.js`](https://cdn.jsdelivr.net/npm/redoc@2/bundles/redoc.standalone.js)

After that, your file structure could look like:
    
    
    .
    ‚îú‚îÄ‚îÄ app
    ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ __init__.py
    ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ main.py
    ‚îî‚îÄ‚îÄ static
        ‚îú‚îÄ‚îÄ redoc.standalone.js
        ‚îú‚îÄ‚îÄ swagger-ui-bundle.js
        ‚îî‚îÄ‚îÄ swagger-ui.css
    

### Serve the static files[¶](#serve-the-static-files "Permanent link")

  * Import `StaticFiles`.
  * "Mount" a `StaticFiles()` instance in a specific path.

Python 3.9+
    
    
    from fastapi import FastAPI
    from fastapi.openapi.docs import (
        get_redoc_html,
        get_swagger_ui_html,
        get_swagger_ui_oauth2_redirect_html,
    )
    from fastapi.staticfiles import StaticFiles
    
    app = FastAPI(docs_url=None, redoc_url=None)
    
    app.mount("/static", StaticFiles(directory="static"), name="static")
    
    
    @app.get("/docs", include_in_schema=False)
    async def custom_swagger_ui_html():
        return get_swagger_ui_html(
            openapi_url=app.openapi_url,
            title=app.title + " - Swagger UI",
            oauth2_redirect_url=app.swagger_ui_oauth2_redirect_url,
            swagger_js_url="/static/swagger-ui-bundle.js",
            swagger_css_url="/static/swagger-ui.css",
        )
    
    
    @app.get(app.swagger_ui_oauth2_redirect_url, include_in_schema=False)
    async def swagger_ui_redirect():
        return get_swagger_ui_oauth2_redirect_html()
    
    
    @app.get("/redoc", include_in_schema=False)
    async def redoc_html():
        return get_redoc_html(
            openapi_url=app.openapi_url,
            title=app.title + " - ReDoc",
            redoc_js_url="/static/redoc.standalone.js",
        )
    
    
    @app.get("/users/{username}")
    async def read_user(username: str):
        return {"message": f"Hello {username}"}
    

### Test the static files[¶](#test-the-static-files "Permanent link")

Start your application and go to <http://127.0.0.1:8000/static/redoc.standalone.js>.

You should see a very long JavaScript file for **ReDoc**.

It could start with something like:
    
    
    /*! For license information please see redoc.standalone.js.LICENSE.txt */
    !function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t(require("null")):
    ...
    

That confirms that you are being able to serve static files from your app, and that you placed the static files for the docs in the correct place.

Now we can configure the app to use those static files for the docs.

### Disable the automatic docs for static files[¶](#disable-the-automatic-docs-for-static-files "Permanent link")

The same as when using a custom CDN, the first step is to disable the automatic docs, as those use the CDN by default.

To disable them, set their URLs to `None` when creating your `FastAPI` app:

Python 3.9+
    
    
    from fastapi import FastAPI
    from fastapi.openapi.docs import (
        get_redoc_html,
        get_swagger_ui_html,
        get_swagger_ui_oauth2_redirect_html,
    )
    from fastapi.staticfiles import StaticFiles
    
    app = FastAPI(docs_url=None, redoc_url=None)
    
    app.mount("/static", StaticFiles(directory="static"), name="static")
    
    
    @app.get("/docs", include_in_schema=False)
    async def custom_swagger_ui_html():
        return get_swagger_ui_html(
            openapi_url=app.openapi_url,
            title=app.title + " - Swagger UI",
            oauth2_redirect_url=app.swagger_ui_oauth2_redirect_url,
            swagger_js_url="/static/swagger-ui-bundle.js",
            swagger_css_url="/static/swagger-ui.css",
        )
    
    
    @app.get(app.swagger_ui_oauth2_redirect_url, include_in_schema=False)
    async def swagger_ui_redirect():
        return get_swagger_ui_oauth2_redirect_html()
    
    
    @app.get("/redoc", include_in_schema=False)
    async def redoc_html():
        return get_redoc_html(
            openapi_url=app.openapi_url,
            title=app.title + " - ReDoc",
            redoc_js_url="/static/redoc.standalone.js",
        )
    
    
    @app.get("/users/{username}")
    async def read_user(username: str):
        return {"message": f"Hello {username}"}
    

### Include the custom docs for static files[¶](#include-the-custom-docs-for-static-files "Permanent link")

And the same way as with a custom CDN, now you can create the _path operations_ for the custom docs.

Again, you can reuse FastAPI's internal functions to create the HTML pages for the docs, and pass them the needed arguments:

  * `openapi_url`: the URL where the HTML page for the docs can get the OpenAPI schema for your API. You can use here the attribute `app.openapi_url`.
  * `title`: the title of your API.
  * `oauth2_redirect_url`: you can use `app.swagger_ui_oauth2_redirect_url` here to use the default.
  * `swagger_js_url`: the URL where the HTML for your Swagger UI docs can get the **JavaScript** file. **This is the one that your own app is now serving**.
  * `swagger_css_url`: the URL where the HTML for your Swagger UI docs can get the **CSS** file. **This is the one that your own app is now serving**.

And similarly for ReDoc...

Python 3.9+
    
    
    from fastapi import FastAPI
    from fastapi.openapi.docs import (
        get_redoc_html,
        get_swagger_ui_html,
        get_swagger_ui_oauth2_redirect_html,
    )
    from fastapi.staticfiles import StaticFiles
    
    app = FastAPI(docs_url=None, redoc_url=None)
    
    app.mount("/static", StaticFiles(directory="static"), name="static")
    
    
    @app.get("/docs", include_in_schema=False)
    async def custom_swagger_ui_html():
        return get_swagger_ui_html(
            openapi_url=app.openapi_url,
            title=app.title + " - Swagger UI",
            oauth2_redirect_url=app.swagger_ui_oauth2_redirect_url,
            swagger_js_url="/static/swagger-ui-bundle.js",
            swagger_css_url="/static/swagger-ui.css",
        )
    
    
    @app.get(app.swagger_ui_oauth2_redirect_url, include_in_schema=False)
    async def swagger_ui_redirect():
        return get_swagger_ui_oauth2_redirect_html()
    
    
    @app.get("/redoc", include_in_schema=False)
    async def redoc_html():
        return get_redoc_html(
            openapi_url=app.openapi_url,
            title=app.title + " - ReDoc",
            redoc_js_url="/static/redoc.standalone.js",
        )
    
    
    @app.get("/users/{username}")
    async def read_user(username: str):
        return {"message": f"Hello {username}"}
    

Tip

The _path operation_ for `swagger_ui_redirect` is a helper for when you use OAuth2.

If you integrate your API with an OAuth2 provider, you will be able to authenticate and come back to the API docs with the acquired credentials. And interact with it using the real OAuth2 authentication.

Swagger UI will handle it behind the scenes for you, but it needs this "redirect" helper.

### Create a _path operation_ to test static files[¶](#create-a-path-operation-to-test-static-files "Permanent link")

Now, to be able to test that everything works, create a _path operation_ :

Python 3.9+
    
    
    from fastapi import FastAPI
    from fastapi.openapi.docs import (
        get_redoc_html,
        get_swagger_ui_html,
        get_swagger_ui_oauth2_redirect_html,
    )
    from fastapi.staticfiles import StaticFiles
    
    app = FastAPI(docs_url=None, redoc_url=None)
    
    app.mount("/static", StaticFiles(directory="static"), name="static")
    
    
    @app.get("/docs", include_in_schema=False)
    async def custom_swagger_ui_html():
        return get_swagger_ui_html(
            openapi_url=app.openapi_url,
            title=app.title + " - Swagger UI",
            oauth2_redirect_url=app.swagger_ui_oauth2_redirect_url,
            swagger_js_url="/static/swagger-ui-bundle.js",
            swagger_css_url="/static/swagger-ui.css",
        )
    
    
    @app.get(app.swagger_ui_oauth2_redirect_url, include_in_schema=False)
    async def swagger_ui_redirect():
        return get_swagger_ui_oauth2_redirect_html()
    
    
    @app.get("/redoc", include_in_schema=False)
    async def redoc_html():
        return get_redoc_html(
            openapi_url=app.openapi_url,
            title=app.title + " - ReDoc",
            redoc_js_url="/static/redoc.standalone.js",
        )
    
    
    @app.get("/users/{username}")
    async def read_user(username: str):
        return {"message": f"Hello {username}"}
    

### Test Static Files UI[¶](#test-static-files-ui "Permanent link")

Now, you should be able to disconnect your WiFi, go to your docs at <http://127.0.0.1:8000/docs>, and reload the page.

And even without Internet, you would be able to see the docs for your API and interact with it.
  *[CDN]: Content Delivery Network

---

###### Configure Swagger UI¶

# Configure Swagger UI[¶](#configure-swagger-ui "Permanent link")

You can configure some extra [Swagger UI parameters](https://swagger.io/docs/open-source-tools/swagger-ui/usage/configuration/).

To configure them, pass the `swagger_ui_parameters` argument when creating the `FastAPI()` app object or to the `get_swagger_ui_html()` function.

`swagger_ui_parameters` receives a dictionary with the configurations passed to Swagger UI directly.

FastAPI converts the configurations to **JSON** to make them compatible with JavaScript, as that's what Swagger UI needs.

## Disable Syntax Highlighting[¶](#disable-syntax-highlighting "Permanent link")

For example, you could disable syntax highlighting in Swagger UI.

Without changing the settings, syntax highlighting is enabled by default:

![](/img/tutorial/extending-openapi/image02.png)

But you can disable it by setting `syntaxHighlight` to `False`:

Python 3.9+
    
    
    from fastapi import FastAPI
    
    app = FastAPI(swagger_ui_parameters={"syntaxHighlight": False})
    
    
    @app.get("/users/{username}")
    async def read_user(username: str):
        return {"message": f"Hello {username}"}
    

...and then Swagger UI won't show the syntax highlighting anymore:

![](/img/tutorial/extending-openapi/image03.png)

## Change the Theme[¶](#change-the-theme "Permanent link")

The same way you could set the syntax highlighting theme with the key `"syntaxHighlight.theme"` (notice that it has a dot in the middle):

Python 3.9+
    
    
    from fastapi import FastAPI
    
    app = FastAPI(swagger_ui_parameters={"syntaxHighlight": {"theme": "obsidian"}})
    
    
    @app.get("/users/{username}")
    async def read_user(username: str):
        return {"message": f"Hello {username}"}
    

That configuration would change the syntax highlighting color theme:

![](/img/tutorial/extending-openapi/image04.png)

## Change Default Swagger UI Parameters[¶](#change-default-swagger-ui-parameters "Permanent link")

FastAPI includes some default configuration parameters appropriate for most of the use cases.

It includes these default configurations:

Python 3.8+
    
    
    # Code above omitted üëÜ
    
        dict[str, Any],
        Doc(
            """
            Default configurations for Swagger UI.
    
            You can use it as a template to add any other configurations needed.
            """
        ),
    ] = {
        "dom_id": "#swagger-ui",
        "layout": "BaseLayout",
        "deepLinking": True,
        "showExtensions": True,
        "showCommonExtensions": True,
    }
    
    
    # Code below omitted üëá
    

üëÄ Full file preview

Python 3.8+
    
    
    import json
    from typing import Annotated, Any, Optional
    
    from annotated_doc import Doc
    from fastapi.encoders import jsonable_encoder
    from starlette.responses import HTMLResponse
    
    swagger_ui_default_parameters: Annotated[
        dict[str, Any],
        Doc(
            """
            Default configurations for Swagger UI.
    
            You can use it as a template to add any other configurations needed.
            """
        ),
    ] = {
        "dom_id": "#swagger-ui",
        "layout": "BaseLayout",
        "deepLinking": True,
        "showExtensions": True,
        "showCommonExtensions": True,
    }
    
    
    def get_swagger_ui_html(
        *,
        openapi_url: Annotated[
            str,
            Doc(
                """
                The OpenAPI URL that Swagger UI should load and use.
    
                This is normally done automatically by FastAPI using the default URL
                `/openapi.json`.
    
                Read more about it in the
                [FastAPI docs for Conditional OpenAPI](https://fastapi.tiangolo.com/how-to/conditional-openapi/#conditional-openapi-from-settings-and-env-vars)
                """
            ),
        ],
        title: Annotated[
            str,
            Doc(
                """
                The HTML `<title>` content, normally shown in the browser tab.
    
                Read more about it in the
                [FastAPI docs for Custom Docs UI Static Assets](https://fastapi.tiangolo.com/how-to/custom-docs-ui-assets/)
                """
            ),
        ],
        swagger_js_url: Annotated[
            str,
            Doc(
                """
                The URL to use to load the Swagger UI JavaScript.
    
                It is normally set to a CDN URL.
    
                Read more about it in the
                [FastAPI docs for Custom Docs UI Static Assets](https://fastapi.tiangolo.com/how-to/custom-docs-ui-assets/)
                """
            ),
        ] = "https://cdn.jsdelivr.net/npm/swagger-ui-dist@5/swagger-ui-bundle.js",
        swagger_css_url: Annotated[
            str,
            Doc(
                """
                The URL to use to load the Swagger UI CSS.
    
                It is normally set to a CDN URL.
    
                Read more about it in the
                [FastAPI docs for Custom Docs UI Static Assets](https://fastapi.tiangolo.com/how-to/custom-docs-ui-assets/)
                """
            ),
        ] = "https://cdn.jsdelivr.net/npm/swagger-ui-dist@5/swagger-ui.css",
        swagger_favicon_url: Annotated[
            str,
            Doc(
                """
                The URL of the favicon to use. It is normally shown in the browser tab.
                """
            ),
        ] = "https://fastapi.tiangolo.com/img/favicon.png",
        oauth2_redirect_url: Annotated[
            Optional[str],
            Doc(
                """
                The OAuth2 redirect URL, it is normally automatically handled by FastAPI.
    
                Read more about it in the
                [FastAPI docs for Custom Docs UI Static Assets](https://fastapi.tiangolo.com/how-to/custom-docs-ui-assets/)
                """
            ),
        ] = None,
        init_oauth: Annotated[
            Optional[dict[str, Any]],
            Doc(
                """
                A dictionary with Swagger UI OAuth2 initialization configurations.
    
                Read more about the available configuration options in the
                [Swagger UI docs](https://swagger.io/docs/open-source-tools/swagger-ui/usage/oauth2/).
                """
            ),
        ] = None,
        swagger_ui_parameters: Annotated[
            Optional[dict[str, Any]],
            Doc(
                """
                Configuration parameters for Swagger UI.
    
                It defaults to [swagger_ui_default_parameters][fastapi.openapi.docs.swagger_ui_default_parameters].
    
                Read more about it in the
                [FastAPI docs about how to Configure Swagger UI](https://fastapi.tiangolo.com/how-to/configure-swagger-ui/).
                """
            ),
        ] = None,
    ) -> HTMLResponse:
        """
        Generate and return the HTML  that loads Swagger UI for the interactive
        API docs (normally served at `/docs`).
    
        You would only call this function yourself if you needed to override some parts,
        for example the URLs to use to load Swagger UI's JavaScript and CSS.
    
        Read more about it in the
        [FastAPI docs for Configure Swagger UI](https://fastapi.tiangolo.com/how-to/configure-swagger-ui/)
        and the [FastAPI docs for Custom Docs UI Static Assets (Self-Hosting)](https://fastapi.tiangolo.com/how-to/custom-docs-ui-assets/).
        """
        current_swagger_ui_parameters = swagger_ui_default_parameters.copy()
        if swagger_ui_parameters:
            current_swagger_ui_parameters.update(swagger_ui_parameters)
    
        html = f"""
        <!DOCTYPE html>
        <html>
        <head>
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link type="text/css" rel="stylesheet" href="{swagger_css_url}">
        <link rel="shortcut icon" href="{swagger_favicon_url}">
        <title>{title}</title>
        </head>
        <body>
        <div id="swagger-ui">
        </div>
        <script src="{swagger_js_url}"></script>
        <!-- `SwaggerUIBundle` is now available on the page -->
        <script>
        const ui = SwaggerUIBundle({{
            url: '{openapi_url}',
        """
    
        for key, value in current_swagger_ui_parameters.items():
            html += f"{json.dumps(key)}: {json.dumps(jsonable_encoder(value))},\n"
    
        if oauth2_redirect_url:
            html += f"oauth2RedirectUrl: window.location.origin + '{oauth2_redirect_url}',"
    
        html += """
        presets: [
            SwaggerUIBundle.presets.apis,
            SwaggerUIBundle.SwaggerUIStandalonePreset
            ],
        })"""
    
        if init_oauth:
            html += f"""
            ui.initOAuth({json.dumps(jsonable_encoder(init_oauth))})
            """
    
        html += """
        </script>
        </body>
        </html>
        """
        return HTMLResponse(html)
    
    
    def get_redoc_html(
        *,
        openapi_url: Annotated[
            str,
            Doc(
                """
                The OpenAPI URL that ReDoc should load and use.
    
                This is normally done automatically by FastAPI using the default URL
                `/openapi.json`.
    
                Read more about it in the
                [FastAPI docs for Conditional OpenAPI](https://fastapi.tiangolo.com/how-to/conditional-openapi/#conditional-openapi-from-settings-and-env-vars)
                """
            ),
        ],
        title: Annotated[
            str,
            Doc(
                """
                The HTML `<title>` content, normally shown in the browser tab.
    
                Read more about it in the
                [FastAPI docs for Custom Docs UI Static Assets](https://fastapi.tiangolo.com/how-to/custom-docs-ui-assets/)
                """
            ),
        ],
        redoc_js_url: Annotated[
            str,
            Doc(
                """
                The URL to use to load the ReDoc JavaScript.
    
                It is normally set to a CDN URL.
    
                Read more about it in the
                [FastAPI docs for Custom Docs UI Static Assets](https://fastapi.tiangolo.com/how-to/custom-docs-ui-assets/)
                """
            ),
        ] = "https://cdn.jsdelivr.net/npm/redoc@2/bundles/redoc.standalone.js",
        redoc_favicon_url: Annotated[
            str,
            Doc(
                """
                The URL of the favicon to use. It is normally shown in the browser tab.
                """
            ),
        ] = "https://fastapi.tiangolo.com/img/favicon.png",
        with_google_fonts: Annotated[
            bool,
            Doc(
                """
                Load and use Google Fonts.
                """
            ),
        ] = True,
    ) -> HTMLResponse:
        """
        Generate and return the HTML response that loads ReDoc for the alternative
        API docs (normally served at `/redoc`).
    
        You would only call this function yourself if you needed to override some parts,
        for example the URLs to use to load ReDoc's JavaScript and CSS.
    
        Read more about it in the
        [FastAPI docs for Custom Docs UI Static Assets (Self-Hosting)](https://fastapi.tiangolo.com/how-to/custom-docs-ui-assets/).
        """
        html = f"""
        <!DOCTYPE html>
        <html>
        <head>
        <title>{title}</title>
        <!-- needed for adaptive design -->
        <meta charset="utf-8"/>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        """
        if with_google_fonts:
            html += """
        <link href="https://fonts.googleapis.com/css?family=Montserrat:300,400,700|Roboto:300,400,700" rel="stylesheet">
        """
        html += f"""
        <link rel="shortcut icon" href="{redoc_favicon_url}">
        <!--
        ReDoc doesn't change outer page styles
        -->
        <style>
          body {{
            margin: 0;
            padding: 0;
          }}
        </style>
        </head>
        <body>
        <noscript>
            ReDoc requires Javascript to function. Please enable it to browse the documentation.
        </noscript>
        <redoc spec-url="{openapi_url}"></redoc>
        <script src="{redoc_js_url}"> </script>
        </body>
        </html>
        """
        return HTMLResponse(html)
    
    
    def get_swagger_ui_oauth2_redirect_html() -> HTMLResponse:
        """
        Generate the HTML response with the OAuth2 redirection for Swagger UI.
    
        You normally don't need to use or change this.
        """
        # copied from https://github.com/swagger-api/swagger-ui/blob/v4.14.0/dist/oauth2-redirect.html
        html = """
        <!doctype html>
        <html lang="en-US">
        <head>
            <title>Swagger UI: OAuth2 Redirect</title>
        </head>
        <body>
        <script>
            'use strict';
            function run () {
                var oauth2 = window.opener.swaggerUIRedirectOauth2;
                var sentState = oauth2.state;
                var redirectUrl = oauth2.redirectUrl;
                var isValid, qp, arr;
    
                if (/code|token|error/.test(window.location.hash)) {
                    qp = window.location.hash.substring(1).replace('?', '&');
                } else {
                    qp = location.search.substring(1);
                }
    
                arr = qp.split("&");
                arr.forEach(function (v,i,_arr) { _arr[i] = '"' + v.replace('=', '":"') + '"';});
                qp = qp ? JSON.parse('{' + arr.join() + '}',
                        function (key, value) {
                            return key === "" ? value : decodeURIComponent(value);
                        }
                ) : {};
    
                isValid = qp.state === sentState;
    
                if ((
                  oauth2.auth.schema.get("flow") === "accessCode" ||
                  oauth2.auth.schema.get("flow") === "authorizationCode" ||
                  oauth2.auth.schema.get("flow") === "authorization_code"
                ) && !oauth2.auth.code) {
                    if (!isValid) {
                        oauth2.errCb({
                            authId: oauth2.auth.name,
                            source: "auth",
                            level: "warning",
                            message: "Authorization may be unsafe, passed state was changed in server. The passed state wasn't returned from auth server."
                        });
                    }
    
                    if (qp.code) {
                        delete oauth2.state;
                        oauth2.auth.code = qp.code;
                        oauth2.callback({auth: oauth2.auth, redirectUrl: redirectUrl});
                    } else {
                        let oauthErrorMsg;
                        if (qp.error) {
                            oauthErrorMsg = "["+qp.error+"]: " +
                                (qp.error_description ? qp.error_description+ ". " : "no accessCode received from the server. ") +
                                (qp.error_uri ? "More info: "+qp.error_uri : "");
                        }
    
                        oauth2.errCb({
                            authId: oauth2.auth.name,
                            source: "auth",
                            level: "error",
                            message: oauthErrorMsg || "[Authorization failed]: no accessCode received from the server."
                        });
                    }
                } else {
                    oauth2.callback({auth: oauth2.auth, token: qp, isValid: isValid, redirectUrl: redirectUrl});
                }
                window.close();
            }
    
            if (document.readyState !== 'loading') {
                run();
            } else {
                document.addEventListener('DOMContentLoaded', function () {
                    run();
                });
            }
        </script>
        </body>
        </html>
            """
        return HTMLResponse(content=html)
    

You can override any of them by setting a different value in the argument `swagger_ui_parameters`.

For example, to disable `deepLinking` you could pass these settings to `swagger_ui_parameters`:

Python 3.9+
    
    
    from fastapi import FastAPI
    
    app = FastAPI(swagger_ui_parameters={"deepLinking": False})
    
    
    @app.get("/users/{username}")
    async def read_user(username: str):
        return {"message": f"Hello {username}"}
    

## Other Swagger UI Parameters[¶](#other-swagger-ui-parameters "Permanent link")

To see all the other possible configurations you can use, read the official [docs for Swagger UI parameters](https://swagger.io/docs/open-source-tools/swagger-ui/usage/configuration/).

## JavaScript-only settings[¶](#javascript-only-settings "Permanent link")

Swagger UI also allows other configurations to be **JavaScript-only** objects (for example, JavaScript functions).

FastAPI also includes these JavaScript-only `presets` settings:
    
    
    presets: [
        SwaggerUIBundle.presets.apis,
        SwaggerUIBundle.SwaggerUIStandalonePreset
    ]
    

These are **JavaScript** objects, not strings, so you can't pass them from Python code directly.

If you need to use JavaScript-only configurations like those, you can use one of the methods above. Override all the Swagger UI _path operation_ and manually write any JavaScript you need.

---

###### Testing a Database¶

# Testing a Database[¶](#testing-a-database "Permanent link")

You can study about databases, SQL, and SQLModel in the [SQLModel docs](https://sqlmodel.tiangolo.com/). ü§ì

There's a mini [tutorial on using SQLModel with FastAPI](https://sqlmodel.tiangolo.com/tutorial/fastapi/). ‚ú®

That tutorial includes a section about [testing SQL databases](https://sqlmodel.tiangolo.com/tutorial/fastapi/tests/). üòé

---

###### Use Old 403 Authentication Error Status Codes¶

# Use Old 403 Authentication Error Status Codes[¶](#use-old-403-authentication-error-status-codes "Permanent link")

Before FastAPI version `0.122.0`, when the integrated security utilities returned an error to the client after a failed authentication, they used the HTTP status code `403 Forbidden`.

Starting with FastAPI version `0.122.0`, they use the more appropriate HTTP status code `401 Unauthorized`, and return a sensible `WWW-Authenticate` header in the response, following the HTTP specifications, [RFC 7235](https://datatracker.ietf.org/doc/html/rfc7235#section-3.1), [RFC 9110](https://datatracker.ietf.org/doc/html/rfc9110#name-401-unauthorized).

But if for some reason your clients depend on the old behavior, you can revert to it by overriding the method `make_not_authenticated_error` in your security classes.

For example, you can create a subclass of `HTTPBearer` that returns a `403 Forbidden` error instead of the default `401 Unauthorized` error:

Python 3.9+
    
    
    from typing import Annotated
    
    from fastapi import Depends, FastAPI, HTTPException, status
    from fastapi.security import HTTPAuthorizationCredentials, HTTPBearer
    
    app = FastAPI()
    
    
    class HTTPBearer403(HTTPBearer):
        def make_not_authenticated_error(self) -> HTTPException:
            return HTTPException(
                status_code=status.HTTP_403_FORBIDDEN, detail="Not authenticated"
            )
    
    
    CredentialsDep = Annotated[HTTPAuthorizationCredentials, Depends(HTTPBearer403())]
    
    
    @app.get("/me")
    def read_me(credentials: CredentialsDep):
        return {"message": "You are authenticated", "token": credentials.credentials}
    

Tip

Notice that the function returns the exception instance, it doesn't raise it. The raising is done in the rest of the internal code.

---

#### Reference¶

# Reference[¶](#reference "Permanent link")

Here's the reference or code API, the classes, functions, parameters, attributes, and all the FastAPI parts you can use in your applications.

If you want to **learn FastAPI** you are much better off reading the [FastAPI Tutorial](https://fastapi.tiangolo.com/tutorial/).

---

###### FastAPIclass¶

# `FastAPI` class[¶](#fastapi-class "Permanent link")

Here's the reference information for the `FastAPI` class, with all its parameters, attributes and methods.

You can import the `FastAPI` class directly from `fastapi`:
    
    
    from fastapi import FastAPI
    

##  `` fastapi.FastAPI [¶](#fastapi.FastAPI "Permanent link")
    
    
    FastAPI(
        *,
        debug=False,
        routes=None,
        title="FastAPI",
        summary=None,
        description="",
        version="0.1.0",
        openapi_url="/openapi.json",
        openapi_tags=None,
        servers=None,
        dependencies=None,
        default_response_class=Default([JSONResponse](../responses/#fastapi.responses.JSONResponse "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">fastapi.responses.JSONResponse</span> \(<code>starlette.responses.JSONResponse</code>\)")),
        redirect_slashes=True,
        docs_url="/docs",
        redoc_url="/redoc",
        swagger_ui_oauth2_redirect_url="/docs/oauth2-redirect",
        swagger_ui_init_oauth=None,
        middleware=None,
        exception_handlers=None,
        on_startup=None,
        on_shutdown=None,
        lifespan=None,
        terms_of_service=None,
        contact=None,
        license_info=None,
        openapi_prefix="",
        root_path="",
        root_path_in_servers=True,
        responses=None,
        callbacks=None,
        webhooks=None,
        deprecated=None,
        include_in_schema=True,
        swagger_ui_parameters=None,
        generate_unique_id_function=Default(generate_unique_id),
        separate_input_output_schemas=True,
        openapi_external_docs=None,
        **extra
    )
    

Bases: `Starlette`

`FastAPI` app class, the main entrypoint to use FastAPI.

Read more in the [FastAPI docs for First Steps](https://fastapi.tiangolo.com/tutorial/first-steps/).

#### Example[¶](#fastapi.FastAPI--example "Permanent link")
    
    
    from fastapi import FastAPI
    
    app = FastAPI()
    

PARAMETER | DESCRIPTION  
---|---  
`debug` |  Boolean indicating if debug tracebacks should be returned on server errors. Read more in the [Starlette docs for Applications](https://www.starlette.dev/applications/#instantiating-the-application). **TYPE:** `bool` **DEFAULT:** `False`  
`routes` |  **Note** : you probably shouldn't use this parameter, it is inherited from Starlette and supported for compatibility.

* * *

A list of routes to serve incoming HTTP and WebSocket requests. **TYPE:** `Optional[list[BaseRoute]]` **DEFAULT:** `None`  
`title` |  The title of the API. It will be added to the generated OpenAPI (e.g. visible at `/docs`). Read more in the [FastAPI docs for Metadata and Docs URLs](https://fastapi.tiangolo.com/tutorial/metadata/#metadata-for-api). **Example**
    
    
    from fastapi import FastAPI
    
    app = FastAPI(title="ChimichangApp")
    

**TYPE:** `str` **DEFAULT:** `'FastAPI'`  
`summary` |  A short summary of the API. It will be added to the generated OpenAPI (e.g. visible at `/docs`). Read more in the [FastAPI docs for Metadata and Docs URLs](https://fastapi.tiangolo.com/tutorial/metadata/#metadata-for-api). **Example**
    
    
    from fastapi import FastAPI
    
    app = FastAPI(summary="Deadpond's favorite app. Nuff said.")
    

**TYPE:** `Optional[str]` **DEFAULT:** `None`  
`description` |  A description of the API. Supports Markdown (using [CommonMark syntax](https://commonmark.org/)). It will be added to the generated OpenAPI (e.g. visible at `/docs`). Read more in the [FastAPI docs for Metadata and Docs URLs](https://fastapi.tiangolo.com/tutorial/metadata/#metadata-for-api). **Example**
    
    
    from fastapi import FastAPI
    
    app = FastAPI(
        description="""
                    ChimichangApp API helps you do awesome stuff. üöÄ
    
                    ## Items
    
                    You can **read items**.
    
                    ## Users
    
                    You will be able to:
    
                    * **Create users** (_not implemented_).
                    * **Read users** (_not implemented_).
    
                    """
    )
    

**TYPE:** `str` **DEFAULT:** `''`  
`version` |  The version of the API. **Note** This is the version of your application, not the version of the OpenAPI specification nor the version of FastAPI being used. It will be added to the generated OpenAPI (e.g. visible at `/docs`). Read more in the [FastAPI docs for Metadata and Docs URLs](https://fastapi.tiangolo.com/tutorial/metadata/#metadata-for-api). **Example**
    
    
    from fastapi import FastAPI
    
    app = FastAPI(version="0.0.1")
    

**TYPE:** `str` **DEFAULT:** `'0.1.0'`  
`openapi_url` |  The URL where the OpenAPI schema will be served from. If you set it to `None`, no OpenAPI schema will be served publicly, and the default automatic endpoints `/docs` and `/redoc` will also be disabled. Read more in the [FastAPI docs for Metadata and Docs URLs](https://fastapi.tiangolo.com/tutorial/metadata/#openapi-url). **Example**
    
    
    from fastapi import FastAPI
    
    app = FastAPI(openapi_url="/api/v1/openapi.json")
    

**TYPE:** `Optional[str]` **DEFAULT:** `'/openapi.json'`  
`openapi_tags` |  A list of tags used by OpenAPI, these are the same `tags` you can set in the _path operations_ , like:

  * `@app.get("/users/", tags=["users"])`
  * `@app.get("/items/", tags=["items"])`

The order of the tags can be used to specify the order shown in tools like Swagger UI, used in the automatic path `/docs`. It's not required to specify all the tags used. The tags that are not declared MAY be organized randomly or based on the tools' logic. Each tag name in the list MUST be unique. The value of each item is a `dict` containing:

  * `name`: The name of the tag.
  * `description`: A short description of the tag. [CommonMark syntax](https://commonmark.org/) MAY be used for rich text representation.
  * `externalDocs`: Additional external documentation for this tag. If provided, it would contain a `dict` with:
    * `description`: A short description of the target documentation. [CommonMark syntax](https://commonmark.org/) MAY be used for rich text representation.
    * `url`: The URL for the target documentation. Value MUST be in the form of a URL.

Read more in the [FastAPI docs for Metadata and Docs URLs](https://fastapi.tiangolo.com/tutorial/metadata/#metadata-for-tags). **Example**
    
    
    from fastapi import FastAPI
    
    tags_metadata = [
        {
            "name": "users",
            "description": "Operations with users. The **login** logic is also here.",
        },
        {
            "name": "items",
            "description": "Manage items. So _fancy_ they have their own docs.",
            "externalDocs": {
                "description": "Items external docs",
                "url": "https://fastapi.tiangolo.com/",
            },
        },
    ]
    
    app = FastAPI(openapi_tags=tags_metadata)
    

**TYPE:** `Optional[list[dict[str, Any]]]` **DEFAULT:** `None`  
`servers` |  A `list` of `dict`s with connectivity information to a target server. You would use it, for example, if your application is served from different domains and you want to use the same Swagger UI in the browser to interact with each of them (instead of having multiple browser tabs open). Or if you want to leave fixed the possible URLs. If the servers `list` is not provided, or is an empty `list`, the `servers` property in the generated OpenAPI will be:

  * a `dict` with a `url` value of the application's mounting point (`root_path`) if it's different from `/`.
  * otherwise, the `servers` property will be omitted from the OpenAPI schema.

Each item in the `list` is a `dict` containing:

  * `url`: A URL to the target host. This URL supports Server Variables and MAY be relative, to indicate that the host location is relative to the location where the OpenAPI document is being served. Variable substitutions will be made when a variable is named in `{`brackets`}`.
  * `description`: An optional string describing the host designated by the URL. [CommonMark syntax](https://commonmark.org/) MAY be used for rich text representation.
  * `variables`: A `dict` between a variable name and its value. The value is used for substitution in the server's URL template.

Read more in the [FastAPI docs for Behind a Proxy](https://fastapi.tiangolo.com/advanced/behind-a-proxy/#additional-servers). **Example**
    
    
    from fastapi import FastAPI
    
    app = FastAPI(
        servers=[
            {"url": "https://stag.example.com", "description": "Staging environment"},
            {"url": "https://prod.example.com", "description": "Production environment"},
        ]
    )
    

**TYPE:** `Optional[list[dict[str, Union[str, Any]]]]` **DEFAULT:** `None`  
`dependencies` |  A list of global dependencies, they will be applied to each _path operation_ , including in sub-routers. Read more about it in the [FastAPI docs for Global Dependencies](https://fastapi.tiangolo.com/tutorial/dependencies/global-dependencies/). **Example**
    
    
    from fastapi import Depends, FastAPI
    
    from .dependencies import func_dep_1, func_dep_2
    
    app = FastAPI(dependencies=[Depends(func_dep_1), Depends(func_dep_2)])
    

**TYPE:** `Optional[Sequence[Depends]]` **DEFAULT:** `None`  
`default_response_class` |  The default response class to be used. Read more in the [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#default-response-class). **Example**
    
    
    from fastapi import FastAPI
    from fastapi.responses import ORJSONResponse
    
    app = FastAPI(default_response_class=ORJSONResponse)
    

**TYPE:** `type[[Response](../response/#fastapi.Response "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">fastapi.Response</span> \(<code>starlette.responses.Response</code>\)")]` **DEFAULT:** `Default([JSONResponse](../responses/#fastapi.responses.JSONResponse "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">fastapi.responses.JSONResponse</span> \(<code>starlette.responses.JSONResponse</code>\)"))`  
`redirect_slashes` |  Whether to detect and redirect slashes in URLs when the client doesn't use the same format. **Example**
    
    
    from fastapi import FastAPI
    
    app = FastAPI(redirect_slashes=True)  # the default
    
    @app.get("/items/")
    async def read_items():
        return [{"item_id": "Foo"}]
    

With this app, if a client goes to `/items` (without a trailing slash), they will be automatically redirected with an HTTP status code of 307 to `/items/`. **TYPE:** `bool` **DEFAULT:** `True`  
`docs_url` |  The path to the automatic interactive API documentation. It is handled in the browser by Swagger UI. The default URL is `/docs`. You can disable it by setting it to `None`. If `openapi_url` is set to `None`, this will be automatically disabled. Read more in the [FastAPI docs for Metadata and Docs URLs](https://fastapi.tiangolo.com/tutorial/metadata/#docs-urls). **Example**
    
    
    from fastapi import FastAPI
    
    app = FastAPI(docs_url="/documentation", redoc_url=None)
    

**TYPE:** `Optional[str]` **DEFAULT:** `'/docs'`  
`redoc_url` |  The path to the alternative automatic interactive API documentation provided by ReDoc. The default URL is `/redoc`. You can disable it by setting it to `None`. If `openapi_url` is set to `None`, this will be automatically disabled. Read more in the [FastAPI docs for Metadata and Docs URLs](https://fastapi.tiangolo.com/tutorial/metadata/#docs-urls). **Example**
    
    
    from fastapi import FastAPI
    
    app = FastAPI(docs_url="/documentation", redoc_url="redocumentation")
    

**TYPE:** `Optional[str]` **DEFAULT:** `'/redoc'`  
`swagger_ui_oauth2_redirect_url` |  The OAuth2 redirect endpoint for the Swagger UI. By default it is `/docs/oauth2-redirect`. This is only used if you use OAuth2 (with the "Authorize" button) with Swagger UI. **TYPE:** `Optional[str]` **DEFAULT:** `'/docs/oauth2-redirect'`  
`swagger_ui_init_oauth` |  OAuth2 configuration for the Swagger UI, by default shown at `/docs`. Read more about the available configuration options in the [Swagger UI docs](https://swagger.io/docs/open-source-tools/swagger-ui/usage/oauth2/). **TYPE:** `Optional[dict[str, Any]]` **DEFAULT:** `None`  
`middleware` |  List of middleware to be added when creating the application. In FastAPI you would normally do this with `app.add_middleware()` instead. Read more in the [FastAPI docs for Middleware](https://fastapi.tiangolo.com/tutorial/middleware/). **TYPE:** `Optional[Sequence[Middleware]]` **DEFAULT:** `None`  
`exception_handlers` |  A dictionary with handlers for exceptions. In FastAPI, you would normally use the decorator `@app.exception_handler()`. Read more in the [FastAPI docs for Handling Errors](https://fastapi.tiangolo.com/tutorial/handling-errors/). **TYPE:** `Optional[dict[Union[int, type[Exception]], Callable[[[Request](../request/#fastapi.Request "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">fastapi.Request</span> \(<code>starlette.requests.Request</code>\)"), Any], Coroutine[Any, Any, [Response](../response/#fastapi.Response "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">fastapi.Response</span> \(<code>starlette.responses.Response</code>\)")]]]]` **DEFAULT:** `None`  
`on_startup` |  A list of startup event handler functions. You should instead use the `lifespan` handlers. Read more in the [FastAPI docs for `lifespan`](https://fastapi.tiangolo.com/advanced/events/). **TYPE:** `Optional[Sequence[Callable[[], Any]]]` **DEFAULT:** `None`  
`on_shutdown` |  A list of shutdown event handler functions. You should instead use the `lifespan` handlers. Read more in the [FastAPI docs for `lifespan`](https://fastapi.tiangolo.com/advanced/events/). **TYPE:** `Optional[Sequence[Callable[[], Any]]]` **DEFAULT:** `None`  
`lifespan` |  A `Lifespan` context manager handler. This replaces `startup` and `shutdown` functions with a single context manager. Read more in the [FastAPI docs for `lifespan`](https://fastapi.tiangolo.com/advanced/events/). **TYPE:** `Optional[Lifespan[AppType]]` **DEFAULT:** `None`  
`terms_of_service` |  A URL to the Terms of Service for your API. It will be added to the generated OpenAPI (e.g. visible at `/docs`). Read more at the [FastAPI docs for Metadata and Docs URLs](https://fastapi.tiangolo.com/tutorial/metadata/#metadata-for-api). **Example**
    
    
    app = FastAPI(terms_of_service="http://example.com/terms/")
    

**TYPE:** `Optional[str]` **DEFAULT:** `None`  
`contact` |  A dictionary with the contact information for the exposed API. It can contain several fields.

  * `name`: (`str`) The name of the contact person/organization.
  * `url`: (`str`) A URL pointing to the contact information. MUST be in the format of a URL.
  * `email`: (`str`) The email address of the contact person/organization. MUST be in the format of an email address.

It will be added to the generated OpenAPI (e.g. visible at `/docs`). Read more at the [FastAPI docs for Metadata and Docs URLs](https://fastapi.tiangolo.com/tutorial/metadata/#metadata-for-api). **Example**
    
    
    app = FastAPI(
        contact={
            "name": "Deadpoolio the Amazing",
            "url": "http://x-force.example.com/contact/",
            "email": "dp@x-force.example.com",
        }
    )
    

**TYPE:** `Optional[dict[str, Union[str, Any]]]` **DEFAULT:** `None`  
`license_info` |  A dictionary with the license information for the exposed API. It can contain several fields.

  * `name`: (`str`) **REQUIRED** (if a `license_info` is set). The license name used for the API.
  * `identifier`: (`str`) An [SPDX](https://spdx.dev/) license expression for the API. The `identifier` field is mutually exclusive of the `url` field. Available since OpenAPI 3.1.0, FastAPI 0.99.0.
  * `url`: (`str`) A URL to the license used for the API. This MUST be the format of a URL.

It will be added to the generated OpenAPI (e.g. visible at `/docs`). Read more at the [FastAPI docs for Metadata and Docs URLs](https://fastapi.tiangolo.com/tutorial/metadata/#metadata-for-api). **Example**
    
    
    app = FastAPI(
        license_info={
            "name": "Apache 2.0",
            "url": "https://www.apache.org/licenses/LICENSE-2.0.html",
        }
    )
    

**TYPE:** `Optional[dict[str, Union[str, Any]]]` **DEFAULT:** `None`  
`openapi_prefix` |  A URL prefix for the OpenAPI URL. **TYPE:** `str` **DEFAULT:** `''`  
`root_path` |  A path prefix handled by a proxy that is not seen by the application but is seen by external clients, which affects things like Swagger UI. Read more about it at the [FastAPI docs for Behind a Proxy](https://fastapi.tiangolo.com/advanced/behind-a-proxy/). **Example**
    
    
    from fastapi import FastAPI
    
    app = FastAPI(root_path="/api/v1")
    

**TYPE:** `str` **DEFAULT:** `''`  
`root_path_in_servers` |  To disable automatically generating the URLs in the `servers` field in the autogenerated OpenAPI using the `root_path`. Read more about it in the [FastAPI docs for Behind a Proxy](https://fastapi.tiangolo.com/advanced/behind-a-proxy/#disable-automatic-server-from-root-path). **Example**
    
    
    from fastapi import FastAPI
    
    app = FastAPI(root_path_in_servers=False)
    

**TYPE:** `bool` **DEFAULT:** `True`  
`responses` |  Additional responses to be shown in OpenAPI. It will be added to the generated OpenAPI (e.g. visible at `/docs`). Read more about it in the [FastAPI docs for Additional Responses in OpenAPI](https://fastapi.tiangolo.com/advanced/additional-responses/). And in the [FastAPI docs for Bigger Applications](https://fastapi.tiangolo.com/tutorial/bigger-applications/#include-an-apirouter-with-a-custom-prefix-tags-responses-and-dependencies). **TYPE:** `Optional[dict[Union[int, str], dict[str, Any]]]` **DEFAULT:** `None`  
`callbacks` |  OpenAPI callbacks that should apply to all _path operations_. It will be added to the generated OpenAPI (e.g. visible at `/docs`). Read more about it in the [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/). **TYPE:** `Optional[list[BaseRoute]]` **DEFAULT:** `None`  
`webhooks` |  Add OpenAPI webhooks. This is similar to `callbacks` but it doesn't depend on specific _path operations_. It will be added to the generated OpenAPI (e.g. visible at `/docs`). **Note** : This is available since OpenAPI 3.1.0, FastAPI 0.99.0. Read more about it in the [FastAPI docs for OpenAPI Webhooks](https://fastapi.tiangolo.com/advanced/openapi-webhooks/). **TYPE:** `Optional[[APIRouter](../apirouter/#fastapi.APIRouter "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">fastapi.APIRouter</span> \(<code>fastapi.routing.APIRouter</code>\)")]` **DEFAULT:** `None`  
`deprecated` |  Mark all _path operations_ as deprecated. You probably don't need it, but it's available. It will be added to the generated OpenAPI (e.g. visible at `/docs`). Read more about it in the [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#deprecate-a-path-operation). **TYPE:** `Optional[bool]` **DEFAULT:** `None`  
`include_in_schema` |  To include (or not) all the _path operations_ in the generated OpenAPI. You probably don't need it, but it's available. This affects the generated OpenAPI (e.g. visible at `/docs`). Read more about it in the [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-parameters-from-openapi). **TYPE:** `bool` **DEFAULT:** `True`  
`swagger_ui_parameters` |  Parameters to configure Swagger UI, the autogenerated interactive API documentation (by default at `/docs`). Read more about it in the [FastAPI docs about how to Configure Swagger UI](https://fastapi.tiangolo.com/how-to/configure-swagger-ui/). **TYPE:** `Optional[dict[str, Any]]` **DEFAULT:** `None`  
`generate_unique_id_function` |  Customize the function used to generate unique IDs for the _path operations_ shown in the generated OpenAPI. This is particularly useful when automatically generating clients or SDKs for your API. Read more about it in the [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function). **TYPE:** `Callable[[APIRoute], str]` **DEFAULT:** `Default(generate_unique_id)`  
`separate_input_output_schemas` |  Whether to generate separate OpenAPI schemas for request body and response body when the results would be more precise. This is particularly useful when automatically generating clients. For example, if you have a model like:
    
    
    from pydantic import BaseModel
    
    class Item(BaseModel):
        name: str
        tags: list[str] = []
    

When `Item` is used for input, a request body, `tags` is not required, the client doesn't have to provide it. But when using `Item` for output, for a response body, `tags` is always available because it has a default value, even if it's just an empty list. So, the client should be able to always expect it. In this case, there would be two different schemas, one for input and another one for output. Read more about it in the [FastAPI docs about how to separate schemas for input and output](https://fastapi.tiangolo.com/how-to/separate-openapi-schemas) **TYPE:** `bool` **DEFAULT:** `True`  
`openapi_external_docs` |  This field allows you to provide additional external documentation links. If provided, it must be a dictionary containing:

  * `description`: A brief description of the external documentation.
  * `url`: The URL pointing to the external documentation. The value **MUST** be a valid URL format.

**Example** :
    
    
    from fastapi import FastAPI
    
    external_docs = {
        "description": "Detailed API Reference",
        "url": "https://example.com/api-docs",
    }
    
    app = FastAPI(openapi_external_docs=external_docs)
    

**TYPE:** `Optional[dict[str, Any]]` **DEFAULT:** `None`  
`**extra` |  Extra keyword arguments to be stored in the app, not used by FastAPI anywhere. **TYPE:** `Any` **DEFAULT:** `{}`  
Source code in `fastapi/applications.py`
    
    
     64
     65
     66
     67
     68
     69
     70
     71
     72
     73
     74
     75
     76
     77
     78
     79
     80
     81
     82
     83
     84
     85
     86
     87
     88
     89
     90
     91
     92
     93
     94
     95
     96
     97
     98
     99
    100
    101
    102
    103
    104
    105
    106
    107
    108
    109
    110
    111
    112
    113
    114
    115
    116
    117
    118
    119
    120
    121
    122
    123
    124
    125
    126
    127
    128
    129
    130
    131
    132
    133
    134
    135
    136
    137
    138
    139
    140
    141
    142
    143
    144
    145
    146
    147
    148
    149
    150
    151
    152
    153
    154
    155
    156
    157
    158
    159
    160
    161
    162
    163
    164
    165
    166
    167
    168
    169
    170
    171
    172
    173
    174
    175
    176
    177
    178
    179
    180
    181
    182
    183
    184
    185
    186
    187
    188
    189
    190
    191
    192
    193
    194
    195
    196
    197
    198
    199
    200
    201
    202
    203
    204
    205
    206
    207
    208
    209
    210
    211
    212
    213
    214
    215
    216
    217
    218
    219
    220
    221
    222
    223
    224
    225
    226
    227
    228
    229
    230
    231
    232
    233
    234
    235
    236
    237
    238
    239
    240
    241
    242
    243
    244
    245
    246
    247
    248
    249
    250
    251
    252
    253
    254
    255
    256
    257
    258
    259
    260
    261
    262
    263
    264
    265
    266
    267
    268
    269
    270
    271
    272
    273
    274
    275
    276
    277
    278
    279
    280
    281
    282
    283
    284
    285
    286
    287
    288
    289
    290
    291
    292
    293
    294
    295
    296
    297
    298
    299
    300
    301
    302
    303
    304
    305
    306
    307
    308
    309
    310
    311
    312
    313
    314
    315
    316
    317
    318
    319
    320
    321
    322
    323
    324
    325
    326
    327
    328
    329
    330
    331
    332
    333
    334
    335
    336
    337
    338
    339
    340
    341
    342
    343
    344
    345
    346
    347
    348
    349
    350
    351
    352
    353
    354
    355
    356
    357
    358
    359
    360
    361
    362
    363
    364
    365
    366
    367
    368
    369
    370
    371
    372
    373
    374
    375
    376
    377
    378
    379
    380
    381
    382
    383
    384
    385
    386
    387
    388
    389
    390
    391
    392
    393
    394
    395
    396
    397
    398
    399
    400
    401
    402
    403
    404
    405
    406
    407
    408
    409
    410
    411
    412
    413
    414
    415
    416
    417
    418
    419
    420
    421
    422
    423
    424
    425
    426
    427
    428
    429
    430
    431
    432
    433
    434
    435
    436
    437
    438
    439
    440
    441
    442
    443
    444
    445
    446
    447
    448
    449
    450
    451
    452
    453
    454
    455
    456
    457
    458
    459
    460
    461
    462
    463
    464
    465
    466
    467
    468
    469
    470
    471
    472
    473
    474
    475
    476
    477
    478
    479
    480
    481
    482
    483
    484
    485
    486
    487
    488
    489
    490
    491
    492
    493
    494
    495
    496
    497
    498
    499
    500
    501
    502
    503
    504
    505
    506
    507
    508
    509
    510
    511
    512
    513
    514
    515
    516
    517
    518
    519
    520
    521
    522
    523
    524
    525
    526
    527
    528
    529
    530
    531
    532
    533
    534
    535
    536
    537
    538
    539
    540
    541
    542
    543
    544
    545
    546
    547
    548
    549
    550
    551
    552
    553
    554
    555
    556
    557
    558
    559
    560
    561
    562
    563
    564
    565
    566
    567
    568
    569
    570
    571
    572
    573
    574
    575
    576
    577
    578
    579
    580
    581
    582
    583
    584
    585
    586
    587
    588
    589
    590
    591
    592
    593
    594
    595
    596
    597
    598
    599
    600
    601
    602
    603
    604
    605
    606
    607
    608
    609
    610
    611
    612
    613
    614
    615
    616
    617
    618
    619
    620
    621
    622
    623
    624
    625
    626
    627
    628
    629
    630
    631
    632
    633
    634
    635
    636
    637
    638
    639
    640
    641
    642
    643
    644
    645
    646
    647
    648
    649
    650
    651
    652
    653
    654
    655
    656
    657
    658
    659
    660
    661
    662
    663
    664
    665
    666
    667
    668
    669
    670
    671
    672
    673
    674
    675
    676
    677
    678
    679
    680
    681
    682
    683
    684
    685
    686
    687
    688
    689
    690
    691
    692
    693
    694
    695
    696
    697
    698
    699
    700
    701
    702
    703
    704
    705
    706
    707
    708
    709
    710
    711
    712
    713
    714
    715
    716
    717
    718
    719
    720
    721
    722
    723
    724
    725
    726
    727
    728
    729
    730
    731
    732
    733
    734
    735
    736
    737
    738
    739
    740
    741
    742
    743
    744
    745
    746
    747
    748
    749
    750
    751
    752
    753
    754
    755
    756
    757
    758
    759
    760
    761
    762
    763
    764
    765
    766
    767
    768
    769
    770
    771
    772
    773
    774
    775
    776
    777
    778
    779
    780
    781
    782
    783
    784
    785
    786
    787
    788
    789
    790
    791
    792
    793
    794
    795
    796
    797
    798
    799
    800
    801
    802
    803
    804
    805
    806
    807
    808
    809
    810
    811
    812
    813
    814
    815
    816
    817
    818
    819
    820
    821
    822
    823
    824
    825
    826
    827
    828
    829
    830
    831
    832
    833
    834
    835
    836
    837
    838
    839
    840
    841
    842
    843
    844
    845
    846
    847
    848
    849
    850
    851
    852
    853
    854
    855
    856
    857
    858
    859
    860
    861
    862
    863
    864
    865
    866
    867
    868
    869
    870
    871
    872
    873
    874
    875
    876
    877
    878
    879
    880
    881
    882
    883
    884
    885
    886
    887
    888
    889
    890
    891
    892
    893
    894
    895
    896
    897
    898
    899
    900
    901
    902
    903
    904
    905
    906
    907
    908
    909
    910
    911
    912
    913
    914
    915
    916
    917
    918
    919
    920
    921
    922
    923
    924
    925
    926
    927
    928
    929
    930
    931
    932
    933
    934
    935
    936
    937
    938
    939
    940
    941
    942
    943
    944
    945
    946
    947
    948
    949
    950
    951
    952
    953
    954
    955
    956
    957
    958
    959
    960
    961
    962
    963
    964
    965
    966
    967
    968
    969
    970
    971
    972
    973
    974
    975
    976
    977
    978
    979
    980
    981
    982
    983
    984
    985
    986
    987
    988
    989
    990
    991
    992
    993
    994
    995
    996
    997
    998
    999

| 
    
    
    def __init__(
        self: AppType,
        *,
        debug: Annotated[
            bool,
            Doc(
                """
                Boolean indicating if debug tracebacks should be returned on server
                errors.
    
                Read more in the
                [Starlette docs for Applications](https://www.starlette.dev/applications/#instantiating-the-application).
                """
            ),
        ] = False,
        routes: Annotated[
            Optional[list[BaseRoute]],
            Doc(
                """
                **Note**: you probably shouldn't use this parameter, it is inherited
                from Starlette and supported for compatibility.
    
                ---
    
                A list of routes to serve incoming HTTP and WebSocket requests.
                """
            ),
            deprecated(
                """
                You normally wouldn't use this parameter with FastAPI, it is inherited
                from Starlette and supported for compatibility.
    
                In FastAPI, you normally would use the *path operation methods*,
                like `app.get()`, `app.post()`, etc.
                """
            ),
        ] = None,
        title: Annotated[
            str,
            Doc(
                """
                The title of the API.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
    
                Read more in the
                [FastAPI docs for Metadata and Docs URLs](https://fastapi.tiangolo.com/tutorial/metadata/#metadata-for-api).
    
                **Example**
    
                ```python
                from fastapi import FastAPI
    
                app = FastAPI(title="ChimichangApp")
                ```
                """
            ),
        ] = "FastAPI",
        summary: Annotated[
            Optional[str],
            Doc(
                """
                A short summary of the API.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
    
                Read more in the
                [FastAPI docs for Metadata and Docs URLs](https://fastapi.tiangolo.com/tutorial/metadata/#metadata-for-api).
    
                **Example**
    
                ```python
                from fastapi import FastAPI
    
                app = FastAPI(summary="Deadpond's favorite app. Nuff said.")
                ```
                """
            ),
        ] = None,
        description: Annotated[
            str,
            Doc(
                '''
                A description of the API. Supports Markdown (using
                [CommonMark syntax](https://commonmark.org/)).
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
    
                Read more in the
                [FastAPI docs for Metadata and Docs URLs](https://fastapi.tiangolo.com/tutorial/metadata/#metadata-for-api).
    
                **Example**
    
                ```python
                from fastapi import FastAPI
    
                app = FastAPI(
                    description="""
                                ChimichangApp API helps you do awesome stuff. üöÄ
    
                                ## Items
    
                                You can **read items**.
    
                                ## Users
    
                                You will be able to:
    
                                * **Create users** (_not implemented_).
                                * **Read users** (_not implemented_).
    
                                """
                )
                ```
                '''
            ),
        ] = "",
        version: Annotated[
            str,
            Doc(
                """
                The version of the API.
    
                **Note** This is the version of your application, not the version of
                the OpenAPI specification nor the version of FastAPI being used.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
    
                Read more in the
                [FastAPI docs for Metadata and Docs URLs](https://fastapi.tiangolo.com/tutorial/metadata/#metadata-for-api).
    
                **Example**
    
                ```python
                from fastapi import FastAPI
    
                app = FastAPI(version="0.0.1")
                ```
                """
            ),
        ] = "0.1.0",
        openapi_url: Annotated[
            Optional[str],
            Doc(
                """
                The URL where the OpenAPI schema will be served from.
    
                If you set it to `None`, no OpenAPI schema will be served publicly, and
                the default automatic endpoints `/docs` and `/redoc` will also be
                disabled.
    
                Read more in the
                [FastAPI docs for Metadata and Docs URLs](https://fastapi.tiangolo.com/tutorial/metadata/#openapi-url).
    
                **Example**
    
                ```python
                from fastapi import FastAPI
    
                app = FastAPI(openapi_url="/api/v1/openapi.json")
                ```
                """
            ),
        ] = "/openapi.json",
        openapi_tags: Annotated[
            Optional[list[dict[str, Any]]],
            Doc(
                """
                A list of tags used by OpenAPI, these are the same `tags` you can set
                in the *path operations*, like:
    
                * `@app.get("/users/", tags=["users"])`
                * `@app.get("/items/", tags=["items"])`
    
                The order of the tags can be used to specify the order shown in
                tools like Swagger UI, used in the automatic path `/docs`.
    
                It's not required to specify all the tags used.
    
                The tags that are not declared MAY be organized randomly or based
                on the tools' logic. Each tag name in the list MUST be unique.
    
                The value of each item is a `dict` containing:
    
                * `name`: The name of the tag.
                * `description`: A short description of the tag.
                    [CommonMark syntax](https://commonmark.org/) MAY be used for rich
                    text representation.
                * `externalDocs`: Additional external documentation for this tag. If
                    provided, it would contain a `dict` with:
                    * `description`: A short description of the target documentation.
                        [CommonMark syntax](https://commonmark.org/) MAY be used for
                        rich text representation.
                    * `url`: The URL for the target documentation. Value MUST be in
                        the form of a URL.
    
                Read more in the
                [FastAPI docs for Metadata and Docs URLs](https://fastapi.tiangolo.com/tutorial/metadata/#metadata-for-tags).
    
                **Example**
    
                ```python
                from fastapi import FastAPI
    
                tags_metadata = [
                    {
                        "name": "users",
                        "description": "Operations with users. The **login** logic is also here.",
                    },
                    {
                        "name": "items",
                        "description": "Manage items. So _fancy_ they have their own docs.",
                        "externalDocs": {
                            "description": "Items external docs",
                            "url": "https://fastapi.tiangolo.com/",
                        },
                    },
                ]
    
                app = FastAPI(openapi_tags=tags_metadata)
                ```
                """
            ),
        ] = None,
        servers: Annotated[
            Optional[list[dict[str, Union[str, Any]]]],
            Doc(
                """
                A `list` of `dict`s with connectivity information to a target server.
    
                You would use it, for example, if your application is served from
                different domains and you want to use the same Swagger UI in the
                browser to interact with each of them (instead of having multiple
                browser tabs open). Or if you want to leave fixed the possible URLs.
    
                If the servers `list` is not provided, or is an empty `list`, the
                `servers` property in the generated OpenAPI will be:
    
                * a `dict` with a `url` value of the application's mounting point
                (`root_path`) if it's different from `/`.
                * otherwise, the `servers` property will be omitted from the OpenAPI
                schema.
    
                Each item in the `list` is a `dict` containing:
    
                * `url`: A URL to the target host. This URL supports Server Variables
                and MAY be relative, to indicate that the host location is relative
                to the location where the OpenAPI document is being served. Variable
                substitutions will be made when a variable is named in `{`brackets`}`.
                * `description`: An optional string describing the host designated by
                the URL. [CommonMark syntax](https://commonmark.org/) MAY be used for
                rich text representation.
                * `variables`: A `dict` between a variable name and its value. The value
                    is used for substitution in the server's URL template.
    
                Read more in the
                [FastAPI docs for Behind a Proxy](https://fastapi.tiangolo.com/advanced/behind-a-proxy/#additional-servers).
    
                **Example**
    
                ```python
                from fastapi import FastAPI
    
                app = FastAPI(
                    servers=[
                        {"url": "https://stag.example.com", "description": "Staging environment"},
                        {"url": "https://prod.example.com", "description": "Production environment"},
                    ]
                )
                ```
                """
            ),
        ] = None,
        dependencies: Annotated[
            Optional[Sequence[Depends]],
            Doc(
                """
                A list of global dependencies, they will be applied to each
                *path operation*, including in sub-routers.
    
                Read more about it in the
                [FastAPI docs for Global Dependencies](https://fastapi.tiangolo.com/tutorial/dependencies/global-dependencies/).
    
                **Example**
    
                ```python
                from fastapi import Depends, FastAPI
    
                from .dependencies import func_dep_1, func_dep_2
    
                app = FastAPI(dependencies=[Depends(func_dep_1), Depends(func_dep_2)])
                ```
                """
            ),
        ] = None,
        default_response_class: Annotated[
            type[Response],
            Doc(
                """
                The default response class to be used.
    
                Read more in the
                [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#default-response-class).
    
                **Example**
    
                ```python
                from fastapi import FastAPI
                from fastapi.responses import ORJSONResponse
    
                app = FastAPI(default_response_class=ORJSONResponse)
                ```
                """
            ),
        ] = Default(JSONResponse),
        redirect_slashes: Annotated[
            bool,
            Doc(
                """
                Whether to detect and redirect slashes in URLs when the client doesn't
                use the same format.
    
                **Example**
    
                ```python
                from fastapi import FastAPI
    
                app = FastAPI(redirect_slashes=True)  # the default
    
                @app.get("/items/")
                async def read_items():
                    return [{"item_id": "Foo"}]
                ```
    
                With this app, if a client goes to `/items` (without a trailing slash),
                they will be automatically redirected with an HTTP status code of 307
                to `/items/`.
                """
            ),
        ] = True,
        docs_url: Annotated[
            Optional[str],
            Doc(
                """
                The path to the automatic interactive API documentation.
                It is handled in the browser by Swagger UI.
    
                The default URL is `/docs`. You can disable it by setting it to `None`.
    
                If `openapi_url` is set to `None`, this will be automatically disabled.
    
                Read more in the
                [FastAPI docs for Metadata and Docs URLs](https://fastapi.tiangolo.com/tutorial/metadata/#docs-urls).
    
                **Example**
    
                ```python
                from fastapi import FastAPI
    
                app = FastAPI(docs_url="/documentation", redoc_url=None)
                ```
                """
            ),
        ] = "/docs",
        redoc_url: Annotated[
            Optional[str],
            Doc(
                """
                The path to the alternative automatic interactive API documentation
                provided by ReDoc.
    
                The default URL is `/redoc`. You can disable it by setting it to `None`.
    
                If `openapi_url` is set to `None`, this will be automatically disabled.
    
                Read more in the
                [FastAPI docs for Metadata and Docs URLs](https://fastapi.tiangolo.com/tutorial/metadata/#docs-urls).
    
                **Example**
    
                ```python
                from fastapi import FastAPI
    
                app = FastAPI(docs_url="/documentation", redoc_url="redocumentation")
                ```
                """
            ),
        ] = "/redoc",
        swagger_ui_oauth2_redirect_url: Annotated[
            Optional[str],
            Doc(
                """
                The OAuth2 redirect endpoint for the Swagger UI.
    
                By default it is `/docs/oauth2-redirect`.
    
                This is only used if you use OAuth2 (with the "Authorize" button)
                with Swagger UI.
                """
            ),
        ] = "/docs/oauth2-redirect",
        swagger_ui_init_oauth: Annotated[
            Optional[dict[str, Any]],
            Doc(
                """
                OAuth2 configuration for the Swagger UI, by default shown at `/docs`.
    
                Read more about the available configuration options in the
                [Swagger UI docs](https://swagger.io/docs/open-source-tools/swagger-ui/usage/oauth2/).
                """
            ),
        ] = None,
        middleware: Annotated[
            Optional[Sequence[Middleware]],
            Doc(
                """
                List of middleware to be added when creating the application.
    
                In FastAPI you would normally do this with `app.add_middleware()`
                instead.
    
                Read more in the
                [FastAPI docs for Middleware](https://fastapi.tiangolo.com/tutorial/middleware/).
                """
            ),
        ] = None,
        exception_handlers: Annotated[
            Optional[
                dict[
                    Union[int, type[Exception]],
                    Callable[[Request, Any], Coroutine[Any, Any, Response]],
                ]
            ],
            Doc(
                """
                A dictionary with handlers for exceptions.
    
                In FastAPI, you would normally use the decorator
                `@app.exception_handler()`.
    
                Read more in the
                [FastAPI docs for Handling Errors](https://fastapi.tiangolo.com/tutorial/handling-errors/).
                """
            ),
        ] = None,
        on_startup: Annotated[
            Optional[Sequence[Callable[[], Any]]],
            Doc(
                """
                A list of startup event handler functions.
    
                You should instead use the `lifespan` handlers.
    
                Read more in the [FastAPI docs for `lifespan`](https://fastapi.tiangolo.com/advanced/events/).
                """
            ),
        ] = None,
        on_shutdown: Annotated[
            Optional[Sequence[Callable[[], Any]]],
            Doc(
                """
                A list of shutdown event handler functions.
    
                You should instead use the `lifespan` handlers.
    
                Read more in the
                [FastAPI docs for `lifespan`](https://fastapi.tiangolo.com/advanced/events/).
                """
            ),
        ] = None,
        lifespan: Annotated[
            Optional[Lifespan[AppType]],
            Doc(
                """
                A `Lifespan` context manager handler. This replaces `startup` and
                `shutdown` functions with a single context manager.
    
                Read more in the
                [FastAPI docs for `lifespan`](https://fastapi.tiangolo.com/advanced/events/).
                """
            ),
        ] = None,
        terms_of_service: Annotated[
            Optional[str],
            Doc(
                """
                A URL to the Terms of Service for your API.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
    
                Read more at the
                [FastAPI docs for Metadata and Docs URLs](https://fastapi.tiangolo.com/tutorial/metadata/#metadata-for-api).
    
                **Example**
    
                ```python
                app = FastAPI(terms_of_service="http://example.com/terms/")
                ```
                """
            ),
        ] = None,
        contact: Annotated[
            Optional[dict[str, Union[str, Any]]],
            Doc(
                """
                A dictionary with the contact information for the exposed API.
    
                It can contain several fields.
    
                * `name`: (`str`) The name of the contact person/organization.
                * `url`: (`str`) A URL pointing to the contact information. MUST be in
                    the format of a URL.
                * `email`: (`str`) The email address of the contact person/organization.
                    MUST be in the format of an email address.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
    
                Read more at the
                [FastAPI docs for Metadata and Docs URLs](https://fastapi.tiangolo.com/tutorial/metadata/#metadata-for-api).
    
                **Example**
    
                ```python
                app = FastAPI(
                    contact={
                        "name": "Deadpoolio the Amazing",
                        "url": "http://x-force.example.com/contact/",
                        "email": "dp@x-force.example.com",
                    }
                )
                ```
                """
            ),
        ] = None,
        license_info: Annotated[
            Optional[dict[str, Union[str, Any]]],
            Doc(
                """
                A dictionary with the license information for the exposed API.
    
                It can contain several fields.
    
                * `name`: (`str`) **REQUIRED** (if a `license_info` is set). The
                    license name used for the API.
                * `identifier`: (`str`) An [SPDX](https://spdx.dev/) license expression
                    for the API. The `identifier` field is mutually exclusive of the `url`
                    field. Available since OpenAPI 3.1.0, FastAPI 0.99.0.
                * `url`: (`str`) A URL to the license used for the API. This MUST be
                    the format of a URL.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
    
                Read more at the
                [FastAPI docs for Metadata and Docs URLs](https://fastapi.tiangolo.com/tutorial/metadata/#metadata-for-api).
    
                **Example**
    
                ```python
                app = FastAPI(
                    license_info={
                        "name": "Apache 2.0",
                        "url": "https://www.apache.org/licenses/LICENSE-2.0.html",
                    }
                )
                ```
                """
            ),
        ] = None,
        openapi_prefix: Annotated[
            str,
            Doc(
                """
                A URL prefix for the OpenAPI URL.
                """
            ),
            deprecated(
                """
                "openapi_prefix" has been deprecated in favor of "root_path", which
                follows more closely the ASGI standard, is simpler, and more
                automatic.
                """
            ),
        ] = "",
        root_path: Annotated[
            str,
            Doc(
                """
                A path prefix handled by a proxy that is not seen by the application
                but is seen by external clients, which affects things like Swagger UI.
    
                Read more about it at the
                [FastAPI docs for Behind a Proxy](https://fastapi.tiangolo.com/advanced/behind-a-proxy/).
    
                **Example**
    
                ```python
                from fastapi import FastAPI
    
                app = FastAPI(root_path="/api/v1")
                ```
                """
            ),
        ] = "",
        root_path_in_servers: Annotated[
            bool,
            Doc(
                """
                To disable automatically generating the URLs in the `servers` field
                in the autogenerated OpenAPI using the `root_path`.
    
                Read more about it in the
                [FastAPI docs for Behind a Proxy](https://fastapi.tiangolo.com/advanced/behind-a-proxy/#disable-automatic-server-from-root-path).
    
                **Example**
    
                ```python
                from fastapi import FastAPI
    
                app = FastAPI(root_path_in_servers=False)
                ```
                """
            ),
        ] = True,
        responses: Annotated[
            Optional[dict[Union[int, str], dict[str, Any]]],
            Doc(
                """
                Additional responses to be shown in OpenAPI.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
    
                Read more about it in the
                [FastAPI docs for Additional Responses in OpenAPI](https://fastapi.tiangolo.com/advanced/additional-responses/).
    
                And in the
                [FastAPI docs for Bigger Applications](https://fastapi.tiangolo.com/tutorial/bigger-applications/#include-an-apirouter-with-a-custom-prefix-tags-responses-and-dependencies).
                """
            ),
        ] = None,
        callbacks: Annotated[
            Optional[list[BaseRoute]],
            Doc(
                """
                OpenAPI callbacks that should apply to all *path operations*.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
    
                Read more about it in the
                [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).
                """
            ),
        ] = None,
        webhooks: Annotated[
            Optional[routing.APIRouter],
            Doc(
                """
                Add OpenAPI webhooks. This is similar to `callbacks` but it doesn't
                depend on specific *path operations*.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
    
                **Note**: This is available since OpenAPI 3.1.0, FastAPI 0.99.0.
    
                Read more about it in the
                [FastAPI docs for OpenAPI Webhooks](https://fastapi.tiangolo.com/advanced/openapi-webhooks/).
                """
            ),
        ] = None,
        deprecated: Annotated[
            Optional[bool],
            Doc(
                """
                Mark all *path operations* as deprecated. You probably don't need it,
                but it's available.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
    
                Read more about it in the
                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#deprecate-a-path-operation).
                """
            ),
        ] = None,
        include_in_schema: Annotated[
            bool,
            Doc(
                """
                To include (or not) all the *path operations* in the generated OpenAPI.
                You probably don't need it, but it's available.
    
                This affects the generated OpenAPI (e.g. visible at `/docs`).
    
                Read more about it in the
                [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-parameters-from-openapi).
                """
            ),
        ] = True,
        swagger_ui_parameters: Annotated[
            Optional[dict[str, Any]],
            Doc(
                """
                Parameters to configure Swagger UI, the autogenerated interactive API
                documentation (by default at `/docs`).
    
                Read more about it in the
                [FastAPI docs about how to Configure Swagger UI](https://fastapi.tiangolo.com/how-to/configure-swagger-ui/).
                """
            ),
        ] = None,
        generate_unique_id_function: Annotated[
            Callable[[routing.APIRoute], str],
            Doc(
                """
                Customize the function used to generate unique IDs for the *path
                operations* shown in the generated OpenAPI.
    
                This is particularly useful when automatically generating clients or
                SDKs for your API.
    
                Read more about it in the
                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
                """
            ),
        ] = Default(generate_unique_id),
        separate_input_output_schemas: Annotated[
            bool,
            Doc(
                """
                Whether to generate separate OpenAPI schemas for request body and
                response body when the results would be more precise.
    
                This is particularly useful when automatically generating clients.
    
                For example, if you have a model like:
    
                ```python
                from pydantic import BaseModel
    
                class Item(BaseModel):
                    name: str
                    tags: list[str] = []
                ```
    
                When `Item` is used for input, a request body, `tags` is not required,
                the client doesn't have to provide it.
    
                But when using `Item` for output, for a response body, `tags` is always
                available because it has a default value, even if it's just an empty
                list. So, the client should be able to always expect it.
    
                In this case, there would be two different schemas, one for input and
                another one for output.
    
                Read more about it in the
                [FastAPI docs about how to separate schemas for input and output](https://fastapi.tiangolo.com/how-to/separate-openapi-schemas)
                """
            ),
        ] = True,
        openapi_external_docs: Annotated[
            Optional[dict[str, Any]],
            Doc(
                """
                This field allows you to provide additional external documentation links.
                If provided, it must be a dictionary containing:
    
                * `description`: A brief description of the external documentation.
                * `url`: The URL pointing to the external documentation. The value **MUST**
                be a valid URL format.
    
                **Example**:
    
                ```python
                from fastapi import FastAPI
    
                external_docs = {
                    "description": "Detailed API Reference",
                    "url": "https://example.com/api-docs",
                }
    
                app = FastAPI(openapi_external_docs=external_docs)
                ```
                """
            ),
        ] = None,
        **extra: Annotated[
            Any,
            Doc(
                """
                Extra keyword arguments to be stored in the app, not used by FastAPI
                anywhere.
                """
            ),
        ],
    ) -> None:
        self.debug = debug
        self.title = title
        self.summary = summary
        self.description = description
        self.version = version
        self.terms_of_service = terms_of_service
        self.contact = contact
        self.license_info = license_info
        self.openapi_url = openapi_url
        self.openapi_tags = openapi_tags
        self.root_path_in_servers = root_path_in_servers
        self.docs_url = docs_url
        self.redoc_url = redoc_url
        self.swagger_ui_oauth2_redirect_url = swagger_ui_oauth2_redirect_url
        self.swagger_ui_init_oauth = swagger_ui_init_oauth
        self.swagger_ui_parameters = swagger_ui_parameters
        self.servers = servers or []
        self.separate_input_output_schemas = separate_input_output_schemas
        self.openapi_external_docs = openapi_external_docs
        self.extra = extra
        self.openapi_version: Annotated[
            str,
            Doc(
                """
                The version string of OpenAPI.
    
                FastAPI will generate OpenAPI version 3.1.0, and will output that as
                the OpenAPI version. But some tools, even though they might be
                compatible with OpenAPI 3.1.0, might not recognize it as a valid.
    
                So you could override this value to trick those tools into using
                the generated OpenAPI. Have in mind that this is a hack. But if you
                avoid using features added in OpenAPI 3.1.0, it might work for your
                use case.
    
                This is not passed as a parameter to the `FastAPI` class to avoid
                giving the false idea that FastAPI would generate a different OpenAPI
                schema. It is only available as an attribute.
    
                **Example**
    
                ```python
                from fastapi import FastAPI
    
                app = FastAPI()
    
                app.openapi_version = "3.0.2"
                ```
                """
            ),
        ] = "3.1.0"
        self.openapi_schema: Optional[dict[str, Any]] = None
        if self.openapi_url:
            assert self.title, "A title must be provided for OpenAPI, e.g.: 'My API'"
            assert self.version, "A version must be provided for OpenAPI, e.g.: '2.1.0'"
        # TODO: remove when discarding the openapi_prefix parameter
        if openapi_prefix:
            logger.warning(
                '"openapi_prefix" has been deprecated in favor of "root_path", which '
                "follows more closely the ASGI standard, is simpler, and more "
                "automatic. Check the docs at "
                "https://fastapi.tiangolo.com/advanced/sub-applications/"
            )
        self.webhooks: Annotated[
            routing.APIRouter,
            Doc(
                """
                The `app.webhooks` attribute is an `APIRouter` with the *path
                operations* that will be used just for documentation of webhooks.
    
                Read more about it in the
                [FastAPI docs for OpenAPI Webhooks](https://fastapi.tiangolo.com/advanced/openapi-webhooks/).
                """
            ),
        ] = webhooks or routing.APIRouter()
        self.root_path = root_path or openapi_prefix
        self.state: Annotated[
            State,
            Doc(
                """
                A state object for the application. This is the same object for the
                entire application, it doesn't change from request to request.
    
                You normally wouldn't use this in FastAPI, for most of the cases you
                would instead use FastAPI dependencies.
    
                This is simply inherited from Starlette.
    
                Read more about it in the
                [Starlette docs for Applications](https://www.starlette.dev/applications/#storing-state-on-the-app-instance).
                """
            ),
        ] = State()
        self.dependency_overrides: Annotated[
            dict[Callable[..., Any], Callable[..., Any]],
            Doc(
                """
                A dictionary with overrides for the dependencies.
    
                Each key is the original dependency callable, and the value is the
                actual dependency that should be called.
    
                This is for testing, to replace expensive dependencies with testing
                versions.
    
                Read more about it in the
                [FastAPI docs for Testing Dependencies with Overrides](https://fastapi.tiangolo.com/advanced/testing-dependencies/).
                """
            ),
        ] = {}
        self.router: routing.APIRouter = routing.APIRouter(
            routes=routes,
            redirect_slashes=redirect_slashes,
            dependency_overrides_provider=self,
            on_startup=on_startup,
            on_shutdown=on_shutdown,
            lifespan=lifespan,
            default_response_class=default_response_class,
            dependencies=dependencies,
            callbacks=callbacks,
            deprecated=deprecated,
            include_in_schema=include_in_schema,
            responses=responses,
            generate_unique_id_function=generate_unique_id_function,
        )
        self.exception_handlers: dict[
            Any, Callable[[Request, Any], Union[Response, Awaitable[Response]]]
        ] = {} if exception_handlers is None else dict(exception_handlers)
        self.exception_handlers.setdefault(HTTPException, http_exception_handler)
        self.exception_handlers.setdefault(
            RequestValidationError, request_validation_exception_handler
        )
        self.exception_handlers.setdefault(
            WebSocketRequestValidationError,
            # Starlette still has incorrect type specification for the handlers
            websocket_request_validation_exception_handler,  # type: ignore
        )
    
        self.user_middleware: list[Middleware] = (
            [] if middleware is None else list(middleware)
        )
        self.middleware_stack: Union[ASGIApp, None] = None
        self.setup()
      
  
---|---  
  
###  `` openapi_version `instance-attribute` [¶](#fastapi.FastAPI.openapi_version "Permanent link")
    
    
    openapi_version = '3.1.0'
    

The version string of OpenAPI.

FastAPI will generate OpenAPI version 3.1.0, and will output that as the OpenAPI version. But some tools, even though they might be compatible with OpenAPI 3.1.0, might not recognize it as a valid.

So you could override this value to trick those tools into using the generated OpenAPI. Have in mind that this is a hack. But if you avoid using features added in OpenAPI 3.1.0, it might work for your use case.

This is not passed as a parameter to the `FastAPI` class to avoid giving the false idea that FastAPI would generate a different OpenAPI schema. It is only available as an attribute.

**Example**
    
    
    from fastapi import FastAPI
    
    app = FastAPI()
    
    app.openapi_version = "3.0.2"
    

###  `` webhooks `instance-attribute` [¶](#fastapi.FastAPI.webhooks "Permanent link")
    
    
    webhooks = webhooks or [APIRouter](../apirouter/#fastapi.APIRouter "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">fastapi.APIRouter</span> \(<code>fastapi.routing.APIRouter</code>\)")()
    

The `app.webhooks` attribute is an `APIRouter` with the _path operations_ that will be used just for documentation of webhooks.

Read more about it in the [FastAPI docs for OpenAPI Webhooks](https://fastapi.tiangolo.com/advanced/openapi-webhooks/).

###  `` state `instance-attribute` [¶](#fastapi.FastAPI.state "Permanent link")
    
    
    state = State()
    

A state object for the application. This is the same object for the entire application, it doesn't change from request to request.

You normally wouldn't use this in FastAPI, for most of the cases you would instead use FastAPI dependencies.

This is simply inherited from Starlette.

Read more about it in the [Starlette docs for Applications](https://www.starlette.dev/applications/#storing-state-on-the-app-instance).

###  `` dependency_overrides `instance-attribute` [¶](#fastapi.FastAPI.dependency_overrides "Permanent link")
    
    
    dependency_overrides = {}
    

A dictionary with overrides for the dependencies.

Each key is the original dependency callable, and the value is the actual dependency that should be called.

This is for testing, to replace expensive dependencies with testing versions.

Read more about it in the [FastAPI docs for Testing Dependencies with Overrides](https://fastapi.tiangolo.com/advanced/testing-dependencies/).

###  `` openapi [¶](#fastapi.FastAPI.openapi "Permanent link")
    
    
    openapi()
    

Generate the OpenAPI schema of the application. This is called by FastAPI internally.

The first time it is called it stores the result in the attribute `app.openapi_schema`, and next times it is called, it just returns that same result. To avoid the cost of generating the schema every time.

If you need to modify the generated OpenAPI schema, you could modify it.

Read more in the [FastAPI docs for OpenAPI](https://fastapi.tiangolo.com/how-to/extending-openapi/).

Source code in `fastapi/applications.py`
    
    
    1049
    1050
    1051
    1052
    1053
    1054
    1055
    1056
    1057
    1058
    1059
    1060
    1061
    1062
    1063
    1064
    1065
    1066
    1067
    1068
    1069
    1070
    1071
    1072
    1073
    1074
    1075
    1076
    1077
    1078
    1079
    1080

| 
    
    
    def openapi(self) -> dict[str, Any]:
        """
        Generate the OpenAPI schema of the application. This is called by FastAPI
        internally.
    
        The first time it is called it stores the result in the attribute
        `app.openapi_schema`, and next times it is called, it just returns that same
        result. To avoid the cost of generating the schema every time.
    
        If you need to modify the generated OpenAPI schema, you could modify it.
    
        Read more in the
        [FastAPI docs for OpenAPI](https://fastapi.tiangolo.com/how-to/extending-openapi/).
        """
        if not self.openapi_schema:
            self.openapi_schema = get_openapi(
                title=self.title,
                version=self.version,
                openapi_version=self.openapi_version,
                summary=self.summary,
                description=self.description,
                terms_of_service=self.terms_of_service,
                contact=self.contact,
                license_info=self.license_info,
                routes=self.routes,
                webhooks=self.webhooks.routes,
                tags=self.openapi_tags,
                servers=self.servers,
                separate_input_output_schemas=self.separate_input_output_schemas,
                external_docs=self.openapi_external_docs,
            )
        return self.openapi_schema
      
  
---|---  
  
###  `` websocket [¶](#fastapi.FastAPI.websocket "Permanent link")
    
    
    websocket(path, name=None, *, dependencies=None)
    

Decorate a WebSocket function.

Read more about it in the [FastAPI docs for WebSockets](https://fastapi.tiangolo.com/advanced/websockets/).

**Example**
    
    
    from fastapi import FastAPI, WebSocket
    
    app = FastAPI()
    
    @app.websocket("/ws")
    async def websocket_endpoint(websocket: WebSocket):
        await websocket.accept()
        while True:
            data = await websocket.receive_text()
            await websocket.send_text(f"Message text was: {data}")
    

PARAMETER | DESCRIPTION  
---|---  
`path` |  WebSocket path. **TYPE:** `str`  
`name` |  A name for the WebSocket. Only used internally. **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`dependencies` |  A list of dependencies (using `Depends()`) to be used for this WebSocket. Read more about it in the [FastAPI docs for WebSockets](https://fastapi.tiangolo.com/advanced/websockets/). **TYPE:** `Optional[Sequence[Depends]]` **DEFAULT:** `None`  
Source code in `fastapi/applications.py`
    
    
    1274
    1275
    1276
    1277
    1278
    1279
    1280
    1281
    1282
    1283
    1284
    1285
    1286
    1287
    1288
    1289
    1290
    1291
    1292
    1293
    1294
    1295
    1296
    1297
    1298
    1299
    1300
    1301
    1302
    1303
    1304
    1305
    1306
    1307
    1308
    1309
    1310
    1311
    1312
    1313
    1314
    1315
    1316
    1317
    1318
    1319
    1320
    1321
    1322
    1323
    1324
    1325
    1326
    1327
    1328
    1329
    1330
    1331
    1332
    1333
    1334
    1335
    1336
    1337

| 
    
    
    def websocket(
        self,
        path: Annotated[
            str,
            Doc(
                """
                WebSocket path.
                """
            ),
        ],
        name: Annotated[
            Optional[str],
            Doc(
                """
                A name for the WebSocket. Only used internally.
                """
            ),
        ] = None,
        *,
        dependencies: Annotated[
            Optional[Sequence[Depends]],
            Doc(
                """
                A list of dependencies (using `Depends()`) to be used for this
                WebSocket.
    
                Read more about it in the
                [FastAPI docs for WebSockets](https://fastapi.tiangolo.com/advanced/websockets/).
                """
            ),
        ] = None,
    ) -> Callable[[DecoratedCallable], DecoratedCallable]:
        """
        Decorate a WebSocket function.
    
        Read more about it in the
        [FastAPI docs for WebSockets](https://fastapi.tiangolo.com/advanced/websockets/).
    
        **Example**
    
        ```python
        from fastapi import FastAPI, WebSocket
    
        app = FastAPI()
    
        @app.websocket("/ws")
        async def websocket_endpoint(websocket: WebSocket):
            await websocket.accept()
            while True:
                data = await websocket.receive_text()
                await websocket.send_text(f"Message text was: {data}")
        ```
        """
    
        def decorator(func: DecoratedCallable) -> DecoratedCallable:
            self.add_api_websocket_route(
                path,
                func,
                name=name,
                dependencies=dependencies,
            )
            return func
    
        return decorator
      
  
---|---  
  
###  `` include_router [¶](#fastapi.FastAPI.include_router "Permanent link")
    
    
    include_router(
        router,
        *,
        prefix="",
        tags=None,
        dependencies=None,
        responses=None,
        deprecated=None,
        include_in_schema=True,
        default_response_class=Default([JSONResponse](../responses/#fastapi.responses.JSONResponse "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">fastapi.responses.JSONResponse</span> \(<code>starlette.responses.JSONResponse</code>\)")),
        callbacks=None,
        generate_unique_id_function=Default(generate_unique_id)
    )
    

Include an `APIRouter` in the same app.

Read more about it in the [FastAPI docs for Bigger Applications](https://fastapi.tiangolo.com/tutorial/bigger-applications/).

##### Example[¶](#fastapi.FastAPI.include_router--example "Permanent link")
    
    
    from fastapi import FastAPI
    
    from .users import users_router
    
    app = FastAPI()
    
    app.include_router(users_router)
    

PARAMETER | DESCRIPTION  
---|---  
`router` |  The `APIRouter` to include. **TYPE:** `[APIRouter](../apirouter/#fastapi.APIRouter "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">fastapi.APIRouter</span> \(<code>fastapi.routing.APIRouter</code>\)")`  
`prefix` |  An optional path prefix for the router. **TYPE:** `str` **DEFAULT:** `''`  
`tags` |  A list of tags to be applied to all the _path operations_ in this router. It will be added to the generated OpenAPI (e.g. visible at `/docs`). Read more about it in the [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/). **TYPE:** `Optional[list[Union[str, Enum]]]` **DEFAULT:** `None`  
`dependencies` |  A list of dependencies (using `Depends()`) to be applied to all the _path operations_ in this router. Read more about it in the [FastAPI docs for Bigger Applications - Multiple Files](https://fastapi.tiangolo.com/tutorial/bigger-applications/#include-an-apirouter-with-a-custom-prefix-tags-responses-and-dependencies). **Example**
    
    
    from fastapi import Depends, FastAPI
    
    from .dependencies import get_token_header
    from .internal import admin
    
    app = FastAPI()
    
    app.include_router(
        admin.router,
        dependencies=[Depends(get_token_header)],
    )
    

**TYPE:** `Optional[Sequence[Depends]]` **DEFAULT:** `None`  
`responses` |  Additional responses to be shown in OpenAPI. It will be added to the generated OpenAPI (e.g. visible at `/docs`). Read more about it in the [FastAPI docs for Additional Responses in OpenAPI](https://fastapi.tiangolo.com/advanced/additional-responses/). And in the [FastAPI docs for Bigger Applications](https://fastapi.tiangolo.com/tutorial/bigger-applications/#include-an-apirouter-with-a-custom-prefix-tags-responses-and-dependencies). **TYPE:** `Optional[dict[Union[int, str], dict[str, Any]]]` **DEFAULT:** `None`  
`deprecated` |  Mark all the _path operations_ in this router as deprecated. It will be added to the generated OpenAPI (e.g. visible at `/docs`). **Example**
    
    
    from fastapi import FastAPI
    
    from .internal import old_api
    
    app = FastAPI()
    
    app.include_router(
        old_api.router,
        deprecated=True,
    )
    

**TYPE:** `Optional[bool]` **DEFAULT:** `None`  
`include_in_schema` |  Include (or not) all the _path operations_ in this router in the generated OpenAPI schema. This affects the generated OpenAPI (e.g. visible at `/docs`). **Example**
    
    
    from fastapi import FastAPI
    
    from .internal import old_api
    
    app = FastAPI()
    
    app.include_router(
        old_api.router,
        include_in_schema=False,
    )
    

**TYPE:** `bool` **DEFAULT:** `True`  
`default_response_class` |  Default response class to be used for the _path operations_ in this router. Read more in the [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#default-response-class). **Example**
    
    
    from fastapi import FastAPI
    from fastapi.responses import ORJSONResponse
    
    from .internal import old_api
    
    app = FastAPI()
    
    app.include_router(
        old_api.router,
        default_response_class=ORJSONResponse,
    )
    

**TYPE:** `type[[Response](../response/#fastapi.Response "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">fastapi.Response</span> \(<code>starlette.responses.Response</code>\)")]` **DEFAULT:** `Default([JSONResponse](../responses/#fastapi.responses.JSONResponse "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">fastapi.responses.JSONResponse</span> \(<code>starlette.responses.JSONResponse</code>\)"))`  
`callbacks` |  List of _path operations_ that will be used as OpenAPI callbacks. This is only for OpenAPI documentation, the callbacks won't be used directly. It will be added to the generated OpenAPI (e.g. visible at `/docs`). Read more about it in the [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/). **TYPE:** `Optional[list[BaseRoute]]` **DEFAULT:** `None`  
`generate_unique_id_function` |  Customize the function used to generate unique IDs for the _path operations_ shown in the generated OpenAPI. This is particularly useful when automatically generating clients or SDKs for your API. Read more about it in the [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function). **TYPE:** `Callable[[APIRoute], str]` **DEFAULT:** `Default(generate_unique_id)`  
Source code in `fastapi/applications.py`
    
    
    1339
    1340
    1341
    1342
    1343
    1344
    1345
    1346
    1347
    1348
    1349
    1350
    1351
    1352
    1353
    1354
    1355
    1356
    1357
    1358
    1359
    1360
    1361
    1362
    1363
    1364
    1365
    1366
    1367
    1368
    1369
    1370
    1371
    1372
    1373
    1374
    1375
    1376
    1377
    1378
    1379
    1380
    1381
    1382
    1383
    1384
    1385
    1386
    1387
    1388
    1389
    1390
    1391
    1392
    1393
    1394
    1395
    1396
    1397
    1398
    1399
    1400
    1401
    1402
    1403
    1404
    1405
    1406
    1407
    1408
    1409
    1410
    1411
    1412
    1413
    1414
    1415
    1416
    1417
    1418
    1419
    1420
    1421
    1422
    1423
    1424
    1425
    1426
    1427
    1428
    1429
    1430
    1431
    1432
    1433
    1434
    1435
    1436
    1437
    1438
    1439
    1440
    1441
    1442
    1443
    1444
    1445
    1446
    1447
    1448
    1449
    1450
    1451
    1452
    1453
    1454
    1455
    1456
    1457
    1458
    1459
    1460
    1461
    1462
    1463
    1464
    1465
    1466
    1467
    1468
    1469
    1470
    1471
    1472
    1473
    1474
    1475
    1476
    1477
    1478
    1479
    1480
    1481
    1482
    1483
    1484
    1485
    1486
    1487
    1488
    1489
    1490
    1491
    1492
    1493
    1494
    1495
    1496
    1497
    1498
    1499
    1500
    1501
    1502
    1503
    1504
    1505
    1506
    1507
    1508
    1509
    1510
    1511
    1512
    1513
    1514
    1515
    1516
    1517
    1518
    1519
    1520
    1521
    1522
    1523
    1524
    1525
    1526
    1527
    1528
    1529
    1530
    1531
    1532
    1533
    1534
    1535
    1536
    1537
    1538
    1539
    1540
    1541
    1542

| 
    
    
    def include_router(
        self,
        router: Annotated[routing.APIRouter, Doc("The `APIRouter` to include.")],
        *,
        prefix: Annotated[str, Doc("An optional path prefix for the router.")] = "",
        tags: Annotated[
            Optional[list[Union[str, Enum]]],
            Doc(
                """
                A list of tags to be applied to all the *path operations* in this
                router.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
    
                Read more about it in the
                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
                """
            ),
        ] = None,
        dependencies: Annotated[
            Optional[Sequence[Depends]],
            Doc(
                """
                A list of dependencies (using `Depends()`) to be applied to all the
                *path operations* in this router.
    
                Read more about it in the
                [FastAPI docs for Bigger Applications - Multiple Files](https://fastapi.tiangolo.com/tutorial/bigger-applications/#include-an-apirouter-with-a-custom-prefix-tags-responses-and-dependencies).
    
                **Example**
    
                ```python
                from fastapi import Depends, FastAPI
    
                from .dependencies import get_token_header
                from .internal import admin
    
                app = FastAPI()
    
                app.include_router(
                    admin.router,
                    dependencies=[Depends(get_token_header)],
                )
                ```
                """
            ),
        ] = None,
        responses: Annotated[
            Optional[dict[Union[int, str], dict[str, Any]]],
            Doc(
                """
                Additional responses to be shown in OpenAPI.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
    
                Read more about it in the
                [FastAPI docs for Additional Responses in OpenAPI](https://fastapi.tiangolo.com/advanced/additional-responses/).
    
                And in the
                [FastAPI docs for Bigger Applications](https://fastapi.tiangolo.com/tutorial/bigger-applications/#include-an-apirouter-with-a-custom-prefix-tags-responses-and-dependencies).
                """
            ),
        ] = None,
        deprecated: Annotated[
            Optional[bool],
            Doc(
                """
                Mark all the *path operations* in this router as deprecated.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
    
                **Example**
    
                ```python
                from fastapi import FastAPI
    
                from .internal import old_api
    
                app = FastAPI()
    
                app.include_router(
                    old_api.router,
                    deprecated=True,
                )
                ```
                """
            ),
        ] = None,
        include_in_schema: Annotated[
            bool,
            Doc(
                """
                Include (or not) all the *path operations* in this router in the
                generated OpenAPI schema.
    
                This affects the generated OpenAPI (e.g. visible at `/docs`).
    
                **Example**
    
                ```python
                from fastapi import FastAPI
    
                from .internal import old_api
    
                app = FastAPI()
    
                app.include_router(
                    old_api.router,
                    include_in_schema=False,
                )
                ```
                """
            ),
        ] = True,
        default_response_class: Annotated[
            type[Response],
            Doc(
                """
                Default response class to be used for the *path operations* in this
                router.
    
                Read more in the
                [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#default-response-class).
    
                **Example**
    
                ```python
                from fastapi import FastAPI
                from fastapi.responses import ORJSONResponse
    
                from .internal import old_api
    
                app = FastAPI()
    
                app.include_router(
                    old_api.router,
                    default_response_class=ORJSONResponse,
                )
                ```
                """
            ),
        ] = Default(JSONResponse),
        callbacks: Annotated[
            Optional[list[BaseRoute]],
            Doc(
                """
                List of *path operations* that will be used as OpenAPI callbacks.
    
                This is only for OpenAPI documentation, the callbacks won't be used
                directly.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
    
                Read more about it in the
                [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).
                """
            ),
        ] = None,
        generate_unique_id_function: Annotated[
            Callable[[routing.APIRoute], str],
            Doc(
                """
                Customize the function used to generate unique IDs for the *path
                operations* shown in the generated OpenAPI.
    
                This is particularly useful when automatically generating clients or
                SDKs for your API.
    
                Read more about it in the
                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
                """
            ),
        ] = Default(generate_unique_id),
    ) -> None:
        """
        Include an `APIRouter` in the same app.
    
        Read more about it in the
        [FastAPI docs for Bigger Applications](https://fastapi.tiangolo.com/tutorial/bigger-applications/).
    
        ## Example
    
        ```python
        from fastapi import FastAPI
    
        from .users import users_router
    
        app = FastAPI()
    
        app.include_router(users_router)
        ```
        """
        self.router.include_router(
            router,
            prefix=prefix,
            tags=tags,
            dependencies=dependencies,
            responses=responses,
            deprecated=deprecated,
            include_in_schema=include_in_schema,
            default_response_class=default_response_class,
            callbacks=callbacks,
            generate_unique_id_function=generate_unique_id_function,
        )
      
  
---|---  
  
###  `` get [¶](#fastapi.FastAPI.get "Permanent link")
    
    
    get(
        path,
        *,
        response_model=Default(None),
        status_code=None,
        tags=None,
        dependencies=None,
        summary=None,
        description=None,
        response_description="Successful Response",
        responses=None,
        deprecated=None,
        operation_id=None,
        response_model_include=None,
        response_model_exclude=None,
        response_model_by_alias=True,
        response_model_exclude_unset=False,
        response_model_exclude_defaults=False,
        response_model_exclude_none=False,
        include_in_schema=True,
        response_class=Default([JSONResponse](../responses/#fastapi.responses.JSONResponse "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">fastapi.responses.JSONResponse</span> \(<code>starlette.responses.JSONResponse</code>\)")),
        name=None,
        callbacks=None,
        openapi_extra=None,
        generate_unique_id_function=Default(generate_unique_id)
    )
    

Add a _path operation_ using an HTTP GET operation.

##### Example[¶](#fastapi.FastAPI.get--example "Permanent link")
    
    
    from fastapi import FastAPI
    
    app = FastAPI()
    
    @app.get("/items/")
    def read_items():
        return [{"name": "Empanada"}, {"name": "Arepa"}]
    

PARAMETER | DESCRIPTION  
---|---  
`path` |  The URL path to be used for this _path operation_. For example, in `http://example.com/items`, the path is `/items`. **TYPE:** `str`  
`response_model` |  The type to use for the response. It could be any valid Pydantic _field_ type. So, it doesn't have to be a Pydantic model, it could be other things, like a `list`, `dict`, etc. It will be used for:

  * Documentation: the generated OpenAPI (and the UI at `/docs`) will show it as the response (JSON Schema).
  * Serialization: you could return an arbitrary object and the `response_model` would be used to serialize that object into the corresponding JSON.
  * Filtering: the JSON sent to the client will only contain the data (fields) defined in the `response_model`. If you returned an object that contains an attribute `password` but the `response_model` does not include that field, the JSON sent to the client would not have that `password`.
  * Validation: whatever you return will be serialized with the `response_model`, converting any data as necessary to generate the corresponding JSON. But if the data in the object returned is not valid, that would mean a violation of the contract with the client, so it's an error from the API developer. So, FastAPI will raise an error and return a 500 error code (Internal Server Error).

Read more about it in the [FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/). **TYPE:** `Any` **DEFAULT:** `Default(None)`  
`status_code` |  The default status code to be used for the response. You could override the status code by returning a response directly. Read more about it in the [FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/). **TYPE:** `Optional[int]` **DEFAULT:** `None`  
`tags` |  A list of tags to be applied to the _path operation_. It will be added to the generated OpenAPI (e.g. visible at `/docs`). Read more about it in the [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags). **TYPE:** `Optional[list[Union[str, Enum]]]` **DEFAULT:** `None`  
`dependencies` |  A list of dependencies (using `Depends()`) to be applied to the _path operation_. Read more about it in the [FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/). **TYPE:** `Optional[Sequence[Depends]]` **DEFAULT:** `None`  
`summary` |  A summary for the _path operation_. It will be added to the generated OpenAPI (e.g. visible at `/docs`). Read more about it in the [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/). **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`description` |  A description for the _path operation_. If not provided, it will be extracted automatically from the docstring of the _path operation function_. It can contain Markdown. It will be added to the generated OpenAPI (e.g. visible at `/docs`). Read more about it in the [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/). **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`response_description` |  The description for the default response. It will be added to the generated OpenAPI (e.g. visible at `/docs`). **TYPE:** `str` **DEFAULT:** `'Successful Response'`  
`responses` |  Additional responses that could be returned by this _path operation_. It will be added to the generated OpenAPI (e.g. visible at `/docs`). **TYPE:** `Optional[dict[Union[int, str], dict[str, Any]]]` **DEFAULT:** `None`  
`deprecated` |  Mark this _path operation_ as deprecated. It will be added to the generated OpenAPI (e.g. visible at `/docs`). **TYPE:** `Optional[bool]` **DEFAULT:** `None`  
`operation_id` |  Custom operation ID to be used by this _path operation_. By default, it is generated automatically. If you provide a custom operation ID, you need to make sure it is unique for the whole API. You can customize the operation ID generation with the parameter `generate_unique_id_function` in the `FastAPI` class. Read more about it in the [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function). **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`response_model_include` |  Configuration passed to Pydantic to include only certain fields in the response data. Read more about it in the [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude). **TYPE:** `Optional[IncEx]` **DEFAULT:** `None`  
`response_model_exclude` |  Configuration passed to Pydantic to exclude certain fields in the response data. Read more about it in the [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude). **TYPE:** `Optional[IncEx]` **DEFAULT:** `None`  
`response_model_by_alias` |  Configuration passed to Pydantic to define if the response model should be serialized by alias when an alias is used. Read more about it in the [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude). **TYPE:** `bool` **DEFAULT:** `True`  
`response_model_exclude_unset` |  Configuration passed to Pydantic to define if the response data should have all the fields, including the ones that were not set and have their default values. This is different from `response_model_exclude_defaults` in that if the fields are set, they will be included in the response, even if the value is the same as the default. When `True`, default values are omitted from the response. Read more about it in the [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter). **TYPE:** `bool` **DEFAULT:** `False`  
`response_model_exclude_defaults` |  Configuration passed to Pydantic to define if the response data should have all the fields, including the ones that have the same value as the default. This is different from `response_model_exclude_unset` in that if the fields are set but contain the same default values, they will be excluded from the response. When `True`, default values are omitted from the response. Read more about it in the [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter). **TYPE:** `bool` **DEFAULT:** `False`  
`response_model_exclude_none` |  Configuration passed to Pydantic to define if the response data should exclude fields set to `None`. This is much simpler (less smart) than `response_model_exclude_unset` and `response_model_exclude_defaults`. You probably want to use one of those two instead of this one, as those allow returning `None` values when it makes sense. Read more about it in the [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none). **TYPE:** `bool` **DEFAULT:** `False`  
`include_in_schema` |  Include this _path operation_ in the generated OpenAPI schema. This affects the generated OpenAPI (e.g. visible at `/docs`). Read more about it in the [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-parameters-from-openapi). **TYPE:** `bool` **DEFAULT:** `True`  
`response_class` |  Response class to be used for this _path operation_. This will not be used if you return a response directly. Read more about it in the [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse). **TYPE:** `type[[Response](../response/#fastapi.Response "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">fastapi.Response</span> \(<code>starlette.responses.Response</code>\)")]` **DEFAULT:** `Default([JSONResponse](../responses/#fastapi.responses.JSONResponse "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">fastapi.responses.JSONResponse</span> \(<code>starlette.responses.JSONResponse</code>\)"))`  
`name` |  Name for this _path operation_. Only used internally. **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`callbacks` |  List of _path operations_ that will be used as OpenAPI callbacks. This is only for OpenAPI documentation, the callbacks won't be used directly. It will be added to the generated OpenAPI (e.g. visible at `/docs`). Read more about it in the [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/). **TYPE:** `Optional[list[BaseRoute]]` **DEFAULT:** `None`  
`openapi_extra` |  Extra metadata to be included in the OpenAPI schema for this _path operation_. Read more about it in the [FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema). **TYPE:** `Optional[dict[str, Any]]` **DEFAULT:** `None`  
`generate_unique_id_function` |  Customize the function used to generate unique IDs for the _path operations_ shown in the generated OpenAPI. This is particularly useful when automatically generating clients or SDKs for your API. Read more about it in the [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function). **TYPE:** `Callable[[APIRoute], str]` **DEFAULT:** `Default(generate_unique_id)`  
Source code in `fastapi/applications.py`
    
    
    1544
    1545
    1546
    1547
    1548
    1549
    1550
    1551
    1552
    1553
    1554
    1555
    1556
    1557
    1558
    1559
    1560
    1561
    1562
    1563
    1564
    1565
    1566
    1567
    1568
    1569
    1570
    1571
    1572
    1573
    1574
    1575
    1576
    1577
    1578
    1579
    1580
    1581
    1582
    1583
    1584
    1585
    1586
    1587
    1588
    1589
    1590
    1591
    1592
    1593
    1594
    1595
    1596
    1597
    1598
    1599
    1600
    1601
    1602
    1603
    1604
    1605
    1606
    1607
    1608
    1609
    1610
    1611
    1612
    1613
    1614
    1615
    1616
    1617
    1618
    1619
    1620
    1621
    1622
    1623
    1624
    1625
    1626
    1627
    1628
    1629
    1630
    1631
    1632
    1633
    1634
    1635
    1636
    1637
    1638
    1639
    1640
    1641
    1642
    1643
    1644
    1645
    1646
    1647
    1648
    1649
    1650
    1651
    1652
    1653
    1654
    1655
    1656
    1657
    1658
    1659
    1660
    1661
    1662
    1663
    1664
    1665
    1666
    1667
    1668
    1669
    1670
    1671
    1672
    1673
    1674
    1675
    1676
    1677
    1678
    1679
    1680
    1681
    1682
    1683
    1684
    1685
    1686
    1687
    1688
    1689
    1690
    1691
    1692
    1693
    1694
    1695
    1696
    1697
    1698
    1699
    1700
    1701
    1702
    1703
    1704
    1705
    1706
    1707
    1708
    1709
    1710
    1711
    1712
    1713
    1714
    1715
    1716
    1717
    1718
    1719
    1720
    1721
    1722
    1723
    1724
    1725
    1726
    1727
    1728
    1729
    1730
    1731
    1732
    1733
    1734
    1735
    1736
    1737
    1738
    1739
    1740
    1741
    1742
    1743
    1744
    1745
    1746
    1747
    1748
    1749
    1750
    1751
    1752
    1753
    1754
    1755
    1756
    1757
    1758
    1759
    1760
    1761
    1762
    1763
    1764
    1765
    1766
    1767
    1768
    1769
    1770
    1771
    1772
    1773
    1774
    1775
    1776
    1777
    1778
    1779
    1780
    1781
    1782
    1783
    1784
    1785
    1786
    1787
    1788
    1789
    1790
    1791
    1792
    1793
    1794
    1795
    1796
    1797
    1798
    1799
    1800
    1801
    1802
    1803
    1804
    1805
    1806
    1807
    1808
    1809
    1810
    1811
    1812
    1813
    1814
    1815
    1816
    1817
    1818
    1819
    1820
    1821
    1822
    1823
    1824
    1825
    1826
    1827
    1828
    1829
    1830
    1831
    1832
    1833
    1834
    1835
    1836
    1837
    1838
    1839
    1840
    1841
    1842
    1843
    1844
    1845
    1846
    1847
    1848
    1849
    1850
    1851
    1852
    1853
    1854
    1855
    1856
    1857
    1858
    1859
    1860
    1861
    1862
    1863
    1864
    1865
    1866
    1867
    1868
    1869
    1870
    1871
    1872
    1873
    1874
    1875
    1876
    1877
    1878
    1879
    1880
    1881
    1882
    1883
    1884
    1885
    1886
    1887
    1888
    1889
    1890
    1891
    1892
    1893
    1894
    1895
    1896
    1897
    1898
    1899
    1900
    1901
    1902
    1903
    1904
    1905
    1906
    1907
    1908
    1909
    1910
    1911
    1912
    1913
    1914
    1915

| 
    
    
    def get(
        self,
        path: Annotated[
            str,
            Doc(
                """
                The URL path to be used for this *path operation*.
    
                For example, in `http://example.com/items`, the path is `/items`.
                """
            ),
        ],
        *,
        response_model: Annotated[
            Any,
            Doc(
                """
                The type to use for the response.
    
                It could be any valid Pydantic *field* type. So, it doesn't have to
                be a Pydantic model, it could be other things, like a `list`, `dict`,
                etc.
    
                It will be used for:
    
                * Documentation: the generated OpenAPI (and the UI at `/docs`) will
                    show it as the response (JSON Schema).
                * Serialization: you could return an arbitrary object and the
                    `response_model` would be used to serialize that object into the
                    corresponding JSON.
                * Filtering: the JSON sent to the client will only contain the data
                    (fields) defined in the `response_model`. If you returned an object
                    that contains an attribute `password` but the `response_model` does
                    not include that field, the JSON sent to the client would not have
                    that `password`.
                * Validation: whatever you return will be serialized with the
                    `response_model`, converting any data as necessary to generate the
                    corresponding JSON. But if the data in the object returned is not
                    valid, that would mean a violation of the contract with the client,
                    so it's an error from the API developer. So, FastAPI will raise an
                    error and return a 500 error code (Internal Server Error).
    
                Read more about it in the
                [FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).
                """
            ),
        ] = Default(None),
        status_code: Annotated[
            Optional[int],
            Doc(
                """
                The default status code to be used for the response.
    
                You could override the status code by returning a response directly.
    
                Read more about it in the
                [FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).
                """
            ),
        ] = None,
        tags: Annotated[
            Optional[list[Union[str, Enum]]],
            Doc(
                """
                A list of tags to be applied to the *path operation*.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
    
                Read more about it in the
                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).
                """
            ),
        ] = None,
        dependencies: Annotated[
            Optional[Sequence[Depends]],
            Doc(
                """
                A list of dependencies (using `Depends()`) to be applied to the
                *path operation*.
    
                Read more about it in the
                [FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).
                """
            ),
        ] = None,
        summary: Annotated[
            Optional[str],
            Doc(
                """
                A summary for the *path operation*.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
    
                Read more about it in the
                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
                """
            ),
        ] = None,
        description: Annotated[
            Optional[str],
            Doc(
                """
                A description for the *path operation*.
    
                If not provided, it will be extracted automatically from the docstring
                of the *path operation function*.
    
                It can contain Markdown.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
    
                Read more about it in the
                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
                """
            ),
        ] = None,
        response_description: Annotated[
            str,
            Doc(
                """
                The description for the default response.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
                """
            ),
        ] = "Successful Response",
        responses: Annotated[
            Optional[dict[Union[int, str], dict[str, Any]]],
            Doc(
                """
                Additional responses that could be returned by this *path operation*.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
                """
            ),
        ] = None,
        deprecated: Annotated[
            Optional[bool],
            Doc(
                """
                Mark this *path operation* as deprecated.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
                """
            ),
        ] = None,
        operation_id: Annotated[
            Optional[str],
            Doc(
                """
                Custom operation ID to be used by this *path operation*.
    
                By default, it is generated automatically.
    
                If you provide a custom operation ID, you need to make sure it is
                unique for the whole API.
    
                You can customize the
                operation ID generation with the parameter
                `generate_unique_id_function` in the `FastAPI` class.
    
                Read more about it in the
                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
                """
            ),
        ] = None,
        response_model_include: Annotated[
            Optional[IncEx],
            Doc(
                """
                Configuration passed to Pydantic to include only certain fields in the
                response data.
    
                Read more about it in the
                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
                """
            ),
        ] = None,
        response_model_exclude: Annotated[
            Optional[IncEx],
            Doc(
                """
                Configuration passed to Pydantic to exclude certain fields in the
                response data.
    
                Read more about it in the
                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
                """
            ),
        ] = None,
        response_model_by_alias: Annotated[
            bool,
            Doc(
                """
                Configuration passed to Pydantic to define if the response model
                should be serialized by alias when an alias is used.
    
                Read more about it in the
                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
                """
            ),
        ] = True,
        response_model_exclude_unset: Annotated[
            bool,
            Doc(
                """
                Configuration passed to Pydantic to define if the response data
                should have all the fields, including the ones that were not set and
                have their default values. This is different from
                `response_model_exclude_defaults` in that if the fields are set,
                they will be included in the response, even if the value is the same
                as the default.
    
                When `True`, default values are omitted from the response.
    
                Read more about it in the
                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).
                """
            ),
        ] = False,
        response_model_exclude_defaults: Annotated[
            bool,
            Doc(
                """
                Configuration passed to Pydantic to define if the response data
                should have all the fields, including the ones that have the same value
                as the default. This is different from `response_model_exclude_unset`
                in that if the fields are set but contain the same default values,
                they will be excluded from the response.
    
                When `True`, default values are omitted from the response.
    
                Read more about it in the
                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).
                """
            ),
        ] = False,
        response_model_exclude_none: Annotated[
            bool,
            Doc(
                """
                Configuration passed to Pydantic to define if the response data should
                exclude fields set to `None`.
    
                This is much simpler (less smart) than `response_model_exclude_unset`
                and `response_model_exclude_defaults`. You probably want to use one of
                those two instead of this one, as those allow returning `None` values
                when it makes sense.
    
                Read more about it in the
                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).
                """
            ),
        ] = False,
        include_in_schema: Annotated[
            bool,
            Doc(
                """
                Include this *path operation* in the generated OpenAPI schema.
    
                This affects the generated OpenAPI (e.g. visible at `/docs`).
    
                Read more about it in the
                [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-parameters-from-openapi).
                """
            ),
        ] = True,
        response_class: Annotated[
            type[Response],
            Doc(
                """
                Response class to be used for this *path operation*.
    
                This will not be used if you return a response directly.
    
                Read more about it in the
                [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).
                """
            ),
        ] = Default(JSONResponse),
        name: Annotated[
            Optional[str],
            Doc(
                """
                Name for this *path operation*. Only used internally.
                """
            ),
        ] = None,
        callbacks: Annotated[
            Optional[list[BaseRoute]],
            Doc(
                """
                List of *path operations* that will be used as OpenAPI callbacks.
    
                This is only for OpenAPI documentation, the callbacks won't be used
                directly.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
    
                Read more about it in the
                [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).
                """
            ),
        ] = None,
        openapi_extra: Annotated[
            Optional[dict[str, Any]],
            Doc(
                """
                Extra metadata to be included in the OpenAPI schema for this *path
                operation*.
    
                Read more about it in the
                [FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).
                """
            ),
        ] = None,
        generate_unique_id_function: Annotated[
            Callable[[routing.APIRoute], str],
            Doc(
                """
                Customize the function used to generate unique IDs for the *path
                operations* shown in the generated OpenAPI.
    
                This is particularly useful when automatically generating clients or
                SDKs for your API.
    
                Read more about it in the
                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
                """
            ),
        ] = Default(generate_unique_id),
    ) -> Callable[[DecoratedCallable], DecoratedCallable]:
        """
        Add a *path operation* using an HTTP GET operation.
    
        ## Example
    
        ```python
        from fastapi import FastAPI
    
        app = FastAPI()
    
        @app.get("/items/")
        def read_items():
            return [{"name": "Empanada"}, {"name": "Arepa"}]
        ```
        """
        return self.router.get(
            path,
            response_model=response_model,
            status_code=status_code,
            tags=tags,
            dependencies=dependencies,
            summary=summary,
            description=description,
            response_description=response_description,
            responses=responses,
            deprecated=deprecated,
            operation_id=operation_id,
            response_model_include=response_model_include,
            response_model_exclude=response_model_exclude,
            response_model_by_alias=response_model_by_alias,
            response_model_exclude_unset=response_model_exclude_unset,
            response_model_exclude_defaults=response_model_exclude_defaults,
            response_model_exclude_none=response_model_exclude_none,
            include_in_schema=include_in_schema,
            response_class=response_class,
            name=name,
            callbacks=callbacks,
            openapi_extra=openapi_extra,
            generate_unique_id_function=generate_unique_id_function,
        )
      
  
---|---  
  
###  `` put [¶](#fastapi.FastAPI.put "Permanent link")
    
    
    put(
        path,
        *,
        response_model=Default(None),
        status_code=None,
        tags=None,
        dependencies=None,
        summary=None,
        description=None,
        response_description="Successful Response",
        responses=None,
        deprecated=None,
        operation_id=None,
        response_model_include=None,
        response_model_exclude=None,
        response_model_by_alias=True,
        response_model_exclude_unset=False,
        response_model_exclude_defaults=False,
        response_model_exclude_none=False,
        include_in_schema=True,
        response_class=Default([JSONResponse](../responses/#fastapi.responses.JSONResponse "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">fastapi.responses.JSONResponse</span> \(<code>starlette.responses.JSONResponse</code>\)")),
        name=None,
        callbacks=None,
        openapi_extra=None,
        generate_unique_id_function=Default(generate_unique_id)
    )
    

Add a _path operation_ using an HTTP PUT operation.

##### Example[¶](#fastapi.FastAPI.put--example "Permanent link")
    
    
    from fastapi import FastAPI
    from pydantic import BaseModel
    
    class Item(BaseModel):
        name: str
        description: str | None = None
    
    app = FastAPI()
    
    @app.put("/items/{item_id}")
    def replace_item(item_id: str, item: Item):
        return {"message": "Item replaced", "id": item_id}
    

PARAMETER | DESCRIPTION  
---|---  
`path` |  The URL path to be used for this _path operation_. For example, in `http://example.com/items`, the path is `/items`. **TYPE:** `str`  
`response_model` |  The type to use for the response. It could be any valid Pydantic _field_ type. So, it doesn't have to be a Pydantic model, it could be other things, like a `list`, `dict`, etc. It will be used for:

  * Documentation: the generated OpenAPI (and the UI at `/docs`) will show it as the response (JSON Schema).
  * Serialization: you could return an arbitrary object and the `response_model` would be used to serialize that object into the corresponding JSON.
  * Filtering: the JSON sent to the client will only contain the data (fields) defined in the `response_model`. If you returned an object that contains an attribute `password` but the `response_model` does not include that field, the JSON sent to the client would not have that `password`.
  * Validation: whatever you return will be serialized with the `response_model`, converting any data as necessary to generate the corresponding JSON. But if the data in the object returned is not valid, that would mean a violation of the contract with the client, so it's an error from the API developer. So, FastAPI will raise an error and return a 500 error code (Internal Server Error).

Read more about it in the [FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/). **TYPE:** `Any` **DEFAULT:** `Default(None)`  
`status_code` |  The default status code to be used for the response. You could override the status code by returning a response directly. Read more about it in the [FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/). **TYPE:** `Optional[int]` **DEFAULT:** `None`  
`tags` |  A list of tags to be applied to the _path operation_. It will be added to the generated OpenAPI (e.g. visible at `/docs`). Read more about it in the [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags). **TYPE:** `Optional[list[Union[str, Enum]]]` **DEFAULT:** `None`  
`dependencies` |  A list of dependencies (using `Depends()`) to be applied to the _path operation_. Read more about it in the [FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/). **TYPE:** `Optional[Sequence[Depends]]` **DEFAULT:** `None`  
`summary` |  A summary for the _path operation_. It will be added to the generated OpenAPI (e.g. visible at `/docs`). Read more about it in the [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/). **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`description` |  A description for the _path operation_. If not provided, it will be extracted automatically from the docstring of the _path operation function_. It can contain Markdown. It will be added to the generated OpenAPI (e.g. visible at `/docs`). Read more about it in the [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/). **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`response_description` |  The description for the default response. It will be added to the generated OpenAPI (e.g. visible at `/docs`). **TYPE:** `str` **DEFAULT:** `'Successful Response'`  
`responses` |  Additional responses that could be returned by this _path operation_. It will be added to the generated OpenAPI (e.g. visible at `/docs`). **TYPE:** `Optional[dict[Union[int, str], dict[str, Any]]]` **DEFAULT:** `None`  
`deprecated` |  Mark this _path operation_ as deprecated. It will be added to the generated OpenAPI (e.g. visible at `/docs`). **TYPE:** `Optional[bool]` **DEFAULT:** `None`  
`operation_id` |  Custom operation ID to be used by this _path operation_. By default, it is generated automatically. If you provide a custom operation ID, you need to make sure it is unique for the whole API. You can customize the operation ID generation with the parameter `generate_unique_id_function` in the `FastAPI` class. Read more about it in the [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function). **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`response_model_include` |  Configuration passed to Pydantic to include only certain fields in the response data. Read more about it in the [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude). **TYPE:** `Optional[IncEx]` **DEFAULT:** `None`  
`response_model_exclude` |  Configuration passed to Pydantic to exclude certain fields in the response data. Read more about it in the [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude). **TYPE:** `Optional[IncEx]` **DEFAULT:** `None`  
`response_model_by_alias` |  Configuration passed to Pydantic to define if the response model should be serialized by alias when an alias is used. Read more about it in the [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude). **TYPE:** `bool` **DEFAULT:** `True`  
`response_model_exclude_unset` |  Configuration passed to Pydantic to define if the response data should have all the fields, including the ones that were not set and have their default values. This is different from `response_model_exclude_defaults` in that if the fields are set, they will be included in the response, even if the value is the same as the default. When `True`, default values are omitted from the response. Read more about it in the [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter). **TYPE:** `bool` **DEFAULT:** `False`  
`response_model_exclude_defaults` |  Configuration passed to Pydantic to define if the response data should have all the fields, including the ones that have the same value as the default. This is different from `response_model_exclude_unset` in that if the fields are set but contain the same default values, they will be excluded from the response. When `True`, default values are omitted from the response. Read more about it in the [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter). **TYPE:** `bool` **DEFAULT:** `False`  
`response_model_exclude_none` |  Configuration passed to Pydantic to define if the response data should exclude fields set to `None`. This is much simpler (less smart) than `response_model_exclude_unset` and `response_model_exclude_defaults`. You probably want to use one of those two instead of this one, as those allow returning `None` values when it makes sense. Read more about it in the [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none). **TYPE:** `bool` **DEFAULT:** `False`  
`include_in_schema` |  Include this _path operation_ in the generated OpenAPI schema. This affects the generated OpenAPI (e.g. visible at `/docs`). Read more about it in the [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-parameters-from-openapi). **TYPE:** `bool` **DEFAULT:** `True`  
`response_class` |  Response class to be used for this _path operation_. This will not be used if you return a response directly. Read more about it in the [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse). **TYPE:** `type[[Response](../response/#fastapi.Response "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">fastapi.Response</span> \(<code>starlette.responses.Response</code>\)")]` **DEFAULT:** `Default([JSONResponse](../responses/#fastapi.responses.JSONResponse "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">fastapi.responses.JSONResponse</span> \(<code>starlette.responses.JSONResponse</code>\)"))`  
`name` |  Name for this _path operation_. Only used internally. **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`callbacks` |  List of _path operations_ that will be used as OpenAPI callbacks. This is only for OpenAPI documentation, the callbacks won't be used directly. It will be added to the generated OpenAPI (e.g. visible at `/docs`). Read more about it in the [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/). **TYPE:** `Optional[list[BaseRoute]]` **DEFAULT:** `None`  
`openapi_extra` |  Extra metadata to be included in the OpenAPI schema for this _path operation_. Read more about it in the [FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema). **TYPE:** `Optional[dict[str, Any]]` **DEFAULT:** `None`  
`generate_unique_id_function` |  Customize the function used to generate unique IDs for the _path operations_ shown in the generated OpenAPI. This is particularly useful when automatically generating clients or SDKs for your API. Read more about it in the [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function). **TYPE:** `Callable[[APIRoute], str]` **DEFAULT:** `Default(generate_unique_id)`  
Source code in `fastapi/applications.py`
    
    
    1917
    1918
    1919
    1920
    1921
    1922
    1923
    1924
    1925
    1926
    1927
    1928
    1929
    1930
    1931
    1932
    1933
    1934
    1935
    1936
    1937
    1938
    1939
    1940
    1941
    1942
    1943
    1944
    1945
    1946
    1947
    1948
    1949
    1950
    1951
    1952
    1953
    1954
    1955
    1956
    1957
    1958
    1959
    1960
    1961
    1962
    1963
    1964
    1965
    1966
    1967
    1968
    1969
    1970
    1971
    1972
    1973
    1974
    1975
    1976
    1977
    1978
    1979
    1980
    1981
    1982
    1983
    1984
    1985
    1986
    1987
    1988
    1989
    1990
    1991
    1992
    1993
    1994
    1995
    1996
    1997
    1998
    1999
    2000
    2001
    2002
    2003
    2004
    2005
    2006
    2007
    2008
    2009
    2010
    2011
    2012
    2013
    2014
    2015
    2016
    2017
    2018
    2019
    2020
    2021
    2022
    2023
    2024
    2025
    2026
    2027
    2028
    2029
    2030
    2031
    2032
    2033
    2034
    2035
    2036
    2037
    2038
    2039
    2040
    2041
    2042
    2043
    2044
    2045
    2046
    2047
    2048
    2049
    2050
    2051
    2052
    2053
    2054
    2055
    2056
    2057
    2058
    2059
    2060
    2061
    2062
    2063
    2064
    2065
    2066
    2067
    2068
    2069
    2070
    2071
    2072
    2073
    2074
    2075
    2076
    2077
    2078
    2079
    2080
    2081
    2082
    2083
    2084
    2085
    2086
    2087
    2088
    2089
    2090
    2091
    2092
    2093
    2094
    2095
    2096
    2097
    2098
    2099
    2100
    2101
    2102
    2103
    2104
    2105
    2106
    2107
    2108
    2109
    2110
    2111
    2112
    2113
    2114
    2115
    2116
    2117
    2118
    2119
    2120
    2121
    2122
    2123
    2124
    2125
    2126
    2127
    2128
    2129
    2130
    2131
    2132
    2133
    2134
    2135
    2136
    2137
    2138
    2139
    2140
    2141
    2142
    2143
    2144
    2145
    2146
    2147
    2148
    2149
    2150
    2151
    2152
    2153
    2154
    2155
    2156
    2157
    2158
    2159
    2160
    2161
    2162
    2163
    2164
    2165
    2166
    2167
    2168
    2169
    2170
    2171
    2172
    2173
    2174
    2175
    2176
    2177
    2178
    2179
    2180
    2181
    2182
    2183
    2184
    2185
    2186
    2187
    2188
    2189
    2190
    2191
    2192
    2193
    2194
    2195
    2196
    2197
    2198
    2199
    2200
    2201
    2202
    2203
    2204
    2205
    2206
    2207
    2208
    2209
    2210
    2211
    2212
    2213
    2214
    2215
    2216
    2217
    2218
    2219
    2220
    2221
    2222
    2223
    2224
    2225
    2226
    2227
    2228
    2229
    2230
    2231
    2232
    2233
    2234
    2235
    2236
    2237
    2238
    2239
    2240
    2241
    2242
    2243
    2244
    2245
    2246
    2247
    2248
    2249
    2250
    2251
    2252
    2253
    2254
    2255
    2256
    2257
    2258
    2259
    2260
    2261
    2262
    2263
    2264
    2265
    2266
    2267
    2268
    2269
    2270
    2271
    2272
    2273
    2274
    2275
    2276
    2277
    2278
    2279
    2280
    2281
    2282
    2283
    2284
    2285
    2286
    2287
    2288
    2289
    2290
    2291
    2292
    2293

| 
    
    
    def put(
        self,
        path: Annotated[
            str,
            Doc(
                """
                The URL path to be used for this *path operation*.
    
                For example, in `http://example.com/items`, the path is `/items`.
                """
            ),
        ],
        *,
        response_model: Annotated[
            Any,
            Doc(
                """
                The type to use for the response.
    
                It could be any valid Pydantic *field* type. So, it doesn't have to
                be a Pydantic model, it could be other things, like a `list`, `dict`,
                etc.
    
                It will be used for:
    
                * Documentation: the generated OpenAPI (and the UI at `/docs`) will
                    show it as the response (JSON Schema).
                * Serialization: you could return an arbitrary object and the
                    `response_model` would be used to serialize that object into the
                    corresponding JSON.
                * Filtering: the JSON sent to the client will only contain the data
                    (fields) defined in the `response_model`. If you returned an object
                    that contains an attribute `password` but the `response_model` does
                    not include that field, the JSON sent to the client would not have
                    that `password`.
                * Validation: whatever you return will be serialized with the
                    `response_model`, converting any data as necessary to generate the
                    corresponding JSON. But if the data in the object returned is not
                    valid, that would mean a violation of the contract with the client,
                    so it's an error from the API developer. So, FastAPI will raise an
                    error and return a 500 error code (Internal Server Error).
    
                Read more about it in the
                [FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).
                """
            ),
        ] = Default(None),
        status_code: Annotated[
            Optional[int],
            Doc(
                """
                The default status code to be used for the response.
    
                You could override the status code by returning a response directly.
    
                Read more about it in the
                [FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).
                """
            ),
        ] = None,
        tags: Annotated[
            Optional[list[Union[str, Enum]]],
            Doc(
                """
                A list of tags to be applied to the *path operation*.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
    
                Read more about it in the
                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).
                """
            ),
        ] = None,
        dependencies: Annotated[
            Optional[Sequence[Depends]],
            Doc(
                """
                A list of dependencies (using `Depends()`) to be applied to the
                *path operation*.
    
                Read more about it in the
                [FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).
                """
            ),
        ] = None,
        summary: Annotated[
            Optional[str],
            Doc(
                """
                A summary for the *path operation*.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
    
                Read more about it in the
                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
                """
            ),
        ] = None,
        description: Annotated[
            Optional[str],
            Doc(
                """
                A description for the *path operation*.
    
                If not provided, it will be extracted automatically from the docstring
                of the *path operation function*.
    
                It can contain Markdown.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
    
                Read more about it in the
                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
                """
            ),
        ] = None,
        response_description: Annotated[
            str,
            Doc(
                """
                The description for the default response.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
                """
            ),
        ] = "Successful Response",
        responses: Annotated[
            Optional[dict[Union[int, str], dict[str, Any]]],
            Doc(
                """
                Additional responses that could be returned by this *path operation*.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
                """
            ),
        ] = None,
        deprecated: Annotated[
            Optional[bool],
            Doc(
                """
                Mark this *path operation* as deprecated.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
                """
            ),
        ] = None,
        operation_id: Annotated[
            Optional[str],
            Doc(
                """
                Custom operation ID to be used by this *path operation*.
    
                By default, it is generated automatically.
    
                If you provide a custom operation ID, you need to make sure it is
                unique for the whole API.
    
                You can customize the
                operation ID generation with the parameter
                `generate_unique_id_function` in the `FastAPI` class.
    
                Read more about it in the
                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
                """
            ),
        ] = None,
        response_model_include: Annotated[
            Optional[IncEx],
            Doc(
                """
                Configuration passed to Pydantic to include only certain fields in the
                response data.
    
                Read more about it in the
                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
                """
            ),
        ] = None,
        response_model_exclude: Annotated[
            Optional[IncEx],
            Doc(
                """
                Configuration passed to Pydantic to exclude certain fields in the
                response data.
    
                Read more about it in the
                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
                """
            ),
        ] = None,
        response_model_by_alias: Annotated[
            bool,
            Doc(
                """
                Configuration passed to Pydantic to define if the response model
                should be serialized by alias when an alias is used.
    
                Read more about it in the
                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
                """
            ),
        ] = True,
        response_model_exclude_unset: Annotated[
            bool,
            Doc(
                """
                Configuration passed to Pydantic to define if the response data
                should have all the fields, including the ones that were not set and
                have their default values. This is different from
                `response_model_exclude_defaults` in that if the fields are set,
                they will be included in the response, even if the value is the same
                as the default.
    
                When `True`, default values are omitted from the response.
    
                Read more about it in the
                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).
                """
            ),
        ] = False,
        response_model_exclude_defaults: Annotated[
            bool,
            Doc(
                """
                Configuration passed to Pydantic to define if the response data
                should have all the fields, including the ones that have the same value
                as the default. This is different from `response_model_exclude_unset`
                in that if the fields are set but contain the same default values,
                they will be excluded from the response.
    
                When `True`, default values are omitted from the response.
    
                Read more about it in the
                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).
                """
            ),
        ] = False,
        response_model_exclude_none: Annotated[
            bool,
            Doc(
                """
                Configuration passed to Pydantic to define if the response data should
                exclude fields set to `None`.
    
                This is much simpler (less smart) than `response_model_exclude_unset`
                and `response_model_exclude_defaults`. You probably want to use one of
                those two instead of this one, as those allow returning `None` values
                when it makes sense.
    
                Read more about it in the
                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).
                """
            ),
        ] = False,
        include_in_schema: Annotated[
            bool,
            Doc(
                """
                Include this *path operation* in the generated OpenAPI schema.
    
                This affects the generated OpenAPI (e.g. visible at `/docs`).
    
                Read more about it in the
                [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-parameters-from-openapi).
                """
            ),
        ] = True,
        response_class: Annotated[
            type[Response],
            Doc(
                """
                Response class to be used for this *path operation*.
    
                This will not be used if you return a response directly.
    
                Read more about it in the
                [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).
                """
            ),
        ] = Default(JSONResponse),
        name: Annotated[
            Optional[str],
            Doc(
                """
                Name for this *path operation*. Only used internally.
                """
            ),
        ] = None,
        callbacks: Annotated[
            Optional[list[BaseRoute]],
            Doc(
                """
                List of *path operations* that will be used as OpenAPI callbacks.
    
                This is only for OpenAPI documentation, the callbacks won't be used
                directly.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
    
                Read more about it in the
                [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).
                """
            ),
        ] = None,
        openapi_extra: Annotated[
            Optional[dict[str, Any]],
            Doc(
                """
                Extra metadata to be included in the OpenAPI schema for this *path
                operation*.
    
                Read more about it in the
                [FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).
                """
            ),
        ] = None,
        generate_unique_id_function: Annotated[
            Callable[[routing.APIRoute], str],
            Doc(
                """
                Customize the function used to generate unique IDs for the *path
                operations* shown in the generated OpenAPI.
    
                This is particularly useful when automatically generating clients or
                SDKs for your API.
    
                Read more about it in the
                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
                """
            ),
        ] = Default(generate_unique_id),
    ) -> Callable[[DecoratedCallable], DecoratedCallable]:
        """
        Add a *path operation* using an HTTP PUT operation.
    
        ## Example
    
        ```python
        from fastapi import FastAPI
        from pydantic import BaseModel
    
        class Item(BaseModel):
            name: str
            description: str | None = None
    
        app = FastAPI()
    
        @app.put("/items/{item_id}")
        def replace_item(item_id: str, item: Item):
            return {"message": "Item replaced", "id": item_id}
        ```
        """
        return self.router.put(
            path,
            response_model=response_model,
            status_code=status_code,
            tags=tags,
            dependencies=dependencies,
            summary=summary,
            description=description,
            response_description=response_description,
            responses=responses,
            deprecated=deprecated,
            operation_id=operation_id,
            response_model_include=response_model_include,
            response_model_exclude=response_model_exclude,
            response_model_by_alias=response_model_by_alias,
            response_model_exclude_unset=response_model_exclude_unset,
            response_model_exclude_defaults=response_model_exclude_defaults,
            response_model_exclude_none=response_model_exclude_none,
            include_in_schema=include_in_schema,
            response_class=response_class,
            name=name,
            callbacks=callbacks,
            openapi_extra=openapi_extra,
            generate_unique_id_function=generate_unique_id_function,
        )
      
  
---|---  
  
###  `` post [¶](#fastapi.FastAPI.post "Permanent link")
    
    
    post(
        path,
        *,
        response_model=Default(None),
        status_code=None,
        tags=None,
        dependencies=None,
        summary=None,
        description=None,
        response_description="Successful Response",
        responses=None,
        deprecated=None,
        operation_id=None,
        response_model_include=None,
        response_model_exclude=None,
        response_model_by_alias=True,
        response_model_exclude_unset=False,
        response_model_exclude_defaults=False,
        response_model_exclude_none=False,
        include_in_schema=True,
        response_class=Default([JSONResponse](../responses/#fastapi.responses.JSONResponse "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">fastapi.responses.JSONResponse</span> \(<code>starlette.responses.JSONResponse</code>\)")),
        name=None,
        callbacks=None,
        openapi_extra=None,
        generate_unique_id_function=Default(generate_unique_id)
    )
    

Add a _path operation_ using an HTTP POST operation.

##### Example[¶](#fastapi.FastAPI.post--example "Permanent link")
    
    
    from fastapi import FastAPI
    from pydantic import BaseModel
    
    class Item(BaseModel):
        name: str
        description: str | None = None
    
    app = FastAPI()
    
    @app.post("/items/")
    def create_item(item: Item):
        return {"message": "Item created"}
    

PARAMETER | DESCRIPTION  
---|---  
`path` |  The URL path to be used for this _path operation_. For example, in `http://example.com/items`, the path is `/items`. **TYPE:** `str`  
`response_model` |  The type to use for the response. It could be any valid Pydantic _field_ type. So, it doesn't have to be a Pydantic model, it could be other things, like a `list`, `dict`, etc. It will be used for:

  * Documentation: the generated OpenAPI (and the UI at `/docs`) will show it as the response (JSON Schema).
  * Serialization: you could return an arbitrary object and the `response_model` would be used to serialize that object into the corresponding JSON.
  * Filtering: the JSON sent to the client will only contain the data (fields) defined in the `response_model`. If you returned an object that contains an attribute `password` but the `response_model` does not include that field, the JSON sent to the client would not have that `password`.
  * Validation: whatever you return will be serialized with the `response_model`, converting any data as necessary to generate the corresponding JSON. But if the data in the object returned is not valid, that would mean a violation of the contract with the client, so it's an error from the API developer. So, FastAPI will raise an error and return a 500 error code (Internal Server Error).

Read more about it in the [FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/). **TYPE:** `Any` **DEFAULT:** `Default(None)`  
`status_code` |  The default status code to be used for the response. You could override the status code by returning a response directly. Read more about it in the [FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/). **TYPE:** `Optional[int]` **DEFAULT:** `None`  
`tags` |  A list of tags to be applied to the _path operation_. It will be added to the generated OpenAPI (e.g. visible at `/docs`). Read more about it in the [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags). **TYPE:** `Optional[list[Union[str, Enum]]]` **DEFAULT:** `None`  
`dependencies` |  A list of dependencies (using `Depends()`) to be applied to the _path operation_. Read more about it in the [FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/). **TYPE:** `Optional[Sequence[Depends]]` **DEFAULT:** `None`  
`summary` |  A summary for the _path operation_. It will be added to the generated OpenAPI (e.g. visible at `/docs`). Read more about it in the [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/). **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`description` |  A description for the _path operation_. If not provided, it will be extracted automatically from the docstring of the _path operation function_. It can contain Markdown. It will be added to the generated OpenAPI (e.g. visible at `/docs`). Read more about it in the [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/). **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`response_description` |  The description for the default response. It will be added to the generated OpenAPI (e.g. visible at `/docs`). **TYPE:** `str` **DEFAULT:** `'Successful Response'`  
`responses` |  Additional responses that could be returned by this _path operation_. It will be added to the generated OpenAPI (e.g. visible at `/docs`). **TYPE:** `Optional[dict[Union[int, str], dict[str, Any]]]` **DEFAULT:** `None`  
`deprecated` |  Mark this _path operation_ as deprecated. It will be added to the generated OpenAPI (e.g. visible at `/docs`). **TYPE:** `Optional[bool]` **DEFAULT:** `None`  
`operation_id` |  Custom operation ID to be used by this _path operation_. By default, it is generated automatically. If you provide a custom operation ID, you need to make sure it is unique for the whole API. You can customize the operation ID generation with the parameter `generate_unique_id_function` in the `FastAPI` class. Read more about it in the [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function). **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`response_model_include` |  Configuration passed to Pydantic to include only certain fields in the response data. Read more about it in the [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude). **TYPE:** `Optional[IncEx]` **DEFAULT:** `None`  
`response_model_exclude` |  Configuration passed to Pydantic to exclude certain fields in the response data. Read more about it in the [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude). **TYPE:** `Optional[IncEx]` **DEFAULT:** `None`  
`response_model_by_alias` |  Configuration passed to Pydantic to define if the response model should be serialized by alias when an alias is used. Read more about it in the [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude). **TYPE:** `bool` **DEFAULT:** `True`  
`response_model_exclude_unset` |  Configuration passed to Pydantic to define if the response data should have all the fields, including the ones that were not set and have their default values. This is different from `response_model_exclude_defaults` in that if the fields are set, they will be included in the response, even if the value is the same as the default. When `True`, default values are omitted from the response. Read more about it in the [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter). **TYPE:** `bool` **DEFAULT:** `False`  
`response_model_exclude_defaults` |  Configuration passed to Pydantic to define if the response data should have all the fields, including the ones that have the same value as the default. This is different from `response_model_exclude_unset` in that if the fields are set but contain the same default values, they will be excluded from the response. When `True`, default values are omitted from the response. Read more about it in the [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter). **TYPE:** `bool` **DEFAULT:** `False`  
`response_model_exclude_none` |  Configuration passed to Pydantic to define if the response data should exclude fields set to `None`. This is much simpler (less smart) than `response_model_exclude_unset` and `response_model_exclude_defaults`. You probably want to use one of those two instead of this one, as those allow returning `None` values when it makes sense. Read more about it in the [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none). **TYPE:** `bool` **DEFAULT:** `False`  
`include_in_schema` |  Include this _path operation_ in the generated OpenAPI schema. This affects the generated OpenAPI (e.g. visible at `/docs`). Read more about it in the [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-parameters-from-openapi). **TYPE:** `bool` **DEFAULT:** `True`  
`response_class` |  Response class to be used for this _path operation_. This will not be used if you return a response directly. Read more about it in the [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse). **TYPE:** `type[[Response](../response/#fastapi.Response "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">fastapi.Response</span> \(<code>starlette.responses.Response</code>\)")]` **DEFAULT:** `Default([JSONResponse](../responses/#fastapi.responses.JSONResponse "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">fastapi.responses.JSONResponse</span> \(<code>starlette.responses.JSONResponse</code>\)"))`  
`name` |  Name for this _path operation_. Only used internally. **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`callbacks` |  List of _path operations_ that will be used as OpenAPI callbacks. This is only for OpenAPI documentation, the callbacks won't be used directly. It will be added to the generated OpenAPI (e.g. visible at `/docs`). Read more about it in the [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/). **TYPE:** `Optional[list[BaseRoute]]` **DEFAULT:** `None`  
`openapi_extra` |  Extra metadata to be included in the OpenAPI schema for this _path operation_. Read more about it in the [FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema). **TYPE:** `Optional[dict[str, Any]]` **DEFAULT:** `None`  
`generate_unique_id_function` |  Customize the function used to generate unique IDs for the _path operations_ shown in the generated OpenAPI. This is particularly useful when automatically generating clients or SDKs for your API. Read more about it in the [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function). **TYPE:** `Callable[[APIRoute], str]` **DEFAULT:** `Default(generate_unique_id)`  
Source code in `fastapi/applications.py`
    
    
    2295
    2296
    2297
    2298
    2299
    2300
    2301
    2302
    2303
    2304
    2305
    2306
    2307
    2308
    2309
    2310
    2311
    2312
    2313
    2314
    2315
    2316
    2317
    2318
    2319
    2320
    2321
    2322
    2323
    2324
    2325
    2326
    2327
    2328
    2329
    2330
    2331
    2332
    2333
    2334
    2335
    2336
    2337
    2338
    2339
    2340
    2341
    2342
    2343
    2344
    2345
    2346
    2347
    2348
    2349
    2350
    2351
    2352
    2353
    2354
    2355
    2356
    2357
    2358
    2359
    2360
    2361
    2362
    2363
    2364
    2365
    2366
    2367
    2368
    2369
    2370
    2371
    2372
    2373
    2374
    2375
    2376
    2377
    2378
    2379
    2380
    2381
    2382
    2383
    2384
    2385
    2386
    2387
    2388
    2389
    2390
    2391
    2392
    2393
    2394
    2395
    2396
    2397
    2398
    2399
    2400
    2401
    2402
    2403
    2404
    2405
    2406
    2407
    2408
    2409
    2410
    2411
    2412
    2413
    2414
    2415
    2416
    2417
    2418
    2419
    2420
    2421
    2422
    2423
    2424
    2425
    2426
    2427
    2428
    2429
    2430
    2431
    2432
    2433
    2434
    2435
    2436
    2437
    2438
    2439
    2440
    2441
    2442
    2443
    2444
    2445
    2446
    2447
    2448
    2449
    2450
    2451
    2452
    2453
    2454
    2455
    2456
    2457
    2458
    2459
    2460
    2461
    2462
    2463
    2464
    2465
    2466
    2467
    2468
    2469
    2470
    2471
    2472
    2473
    2474
    2475
    2476
    2477
    2478
    2479
    2480
    2481
    2482
    2483
    2484
    2485
    2486
    2487
    2488
    2489
    2490
    2491
    2492
    2493
    2494
    2495
    2496
    2497
    2498
    2499
    2500
    2501
    2502
    2503
    2504
    2505
    2506
    2507
    2508
    2509
    2510
    2511
    2512
    2513
    2514
    2515
    2516
    2517
    2518
    2519
    2520
    2521
    2522
    2523
    2524
    2525
    2526
    2527
    2528
    2529
    2530
    2531
    2532
    2533
    2534
    2535
    2536
    2537
    2538
    2539
    2540
    2541
    2542
    2543
    2544
    2545
    2546
    2547
    2548
    2549
    2550
    2551
    2552
    2553
    2554
    2555
    2556
    2557
    2558
    2559
    2560
    2561
    2562
    2563
    2564
    2565
    2566
    2567
    2568
    2569
    2570
    2571
    2572
    2573
    2574
    2575
    2576
    2577
    2578
    2579
    2580
    2581
    2582
    2583
    2584
    2585
    2586
    2587
    2588
    2589
    2590
    2591
    2592
    2593
    2594
    2595
    2596
    2597
    2598
    2599
    2600
    2601
    2602
    2603
    2604
    2605
    2606
    2607
    2608
    2609
    2610
    2611
    2612
    2613
    2614
    2615
    2616
    2617
    2618
    2619
    2620
    2621
    2622
    2623
    2624
    2625
    2626
    2627
    2628
    2629
    2630
    2631
    2632
    2633
    2634
    2635
    2636
    2637
    2638
    2639
    2640
    2641
    2642
    2643
    2644
    2645
    2646
    2647
    2648
    2649
    2650
    2651
    2652
    2653
    2654
    2655
    2656
    2657
    2658
    2659
    2660
    2661
    2662
    2663
    2664
    2665
    2666
    2667
    2668
    2669
    2670
    2671

| 
    
    
    def post(
        self,
        path: Annotated[
            str,
            Doc(
                """
                The URL path to be used for this *path operation*.
    
                For example, in `http://example.com/items`, the path is `/items`.
                """
            ),
        ],
        *,
        response_model: Annotated[
            Any,
            Doc(
                """
                The type to use for the response.
    
                It could be any valid Pydantic *field* type. So, it doesn't have to
                be a Pydantic model, it could be other things, like a `list`, `dict`,
                etc.
    
                It will be used for:
    
                * Documentation: the generated OpenAPI (and the UI at `/docs`) will
                    show it as the response (JSON Schema).
                * Serialization: you could return an arbitrary object and the
                    `response_model` would be used to serialize that object into the
                    corresponding JSON.
                * Filtering: the JSON sent to the client will only contain the data
                    (fields) defined in the `response_model`. If you returned an object
                    that contains an attribute `password` but the `response_model` does
                    not include that field, the JSON sent to the client would not have
                    that `password`.
                * Validation: whatever you return will be serialized with the
                    `response_model`, converting any data as necessary to generate the
                    corresponding JSON. But if the data in the object returned is not
                    valid, that would mean a violation of the contract with the client,
                    so it's an error from the API developer. So, FastAPI will raise an
                    error and return a 500 error code (Internal Server Error).
    
                Read more about it in the
                [FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).
                """
            ),
        ] = Default(None),
        status_code: Annotated[
            Optional[int],
            Doc(
                """
                The default status code to be used for the response.
    
                You could override the status code by returning a response directly.
    
                Read more about it in the
                [FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).
                """
            ),
        ] = None,
        tags: Annotated[
            Optional[list[Union[str, Enum]]],
            Doc(
                """
                A list of tags to be applied to the *path operation*.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
    
                Read more about it in the
                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).
                """
            ),
        ] = None,
        dependencies: Annotated[
            Optional[Sequence[Depends]],
            Doc(
                """
                A list of dependencies (using `Depends()`) to be applied to the
                *path operation*.
    
                Read more about it in the
                [FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).
                """
            ),
        ] = None,
        summary: Annotated[
            Optional[str],
            Doc(
                """
                A summary for the *path operation*.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
    
                Read more about it in the
                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
                """
            ),
        ] = None,
        description: Annotated[
            Optional[str],
            Doc(
                """
                A description for the *path operation*.
    
                If not provided, it will be extracted automatically from the docstring
                of the *path operation function*.
    
                It can contain Markdown.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
    
                Read more about it in the
                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
                """
            ),
        ] = None,
        response_description: Annotated[
            str,
            Doc(
                """
                The description for the default response.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
                """
            ),
        ] = "Successful Response",
        responses: Annotated[
            Optional[dict[Union[int, str], dict[str, Any]]],
            Doc(
                """
                Additional responses that could be returned by this *path operation*.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
                """
            ),
        ] = None,
        deprecated: Annotated[
            Optional[bool],
            Doc(
                """
                Mark this *path operation* as deprecated.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
                """
            ),
        ] = None,
        operation_id: Annotated[
            Optional[str],
            Doc(
                """
                Custom operation ID to be used by this *path operation*.
    
                By default, it is generated automatically.
    
                If you provide a custom operation ID, you need to make sure it is
                unique for the whole API.
    
                You can customize the
                operation ID generation with the parameter
                `generate_unique_id_function` in the `FastAPI` class.
    
                Read more about it in the
                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
                """
            ),
        ] = None,
        response_model_include: Annotated[
            Optional[IncEx],
            Doc(
                """
                Configuration passed to Pydantic to include only certain fields in the
                response data.
    
                Read more about it in the
                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
                """
            ),
        ] = None,
        response_model_exclude: Annotated[
            Optional[IncEx],
            Doc(
                """
                Configuration passed to Pydantic to exclude certain fields in the
                response data.
    
                Read more about it in the
                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
                """
            ),
        ] = None,
        response_model_by_alias: Annotated[
            bool,
            Doc(
                """
                Configuration passed to Pydantic to define if the response model
                should be serialized by alias when an alias is used.
    
                Read more about it in the
                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
                """
            ),
        ] = True,
        response_model_exclude_unset: Annotated[
            bool,
            Doc(
                """
                Configuration passed to Pydantic to define if the response data
                should have all the fields, including the ones that were not set and
                have their default values. This is different from
                `response_model_exclude_defaults` in that if the fields are set,
                they will be included in the response, even if the value is the same
                as the default.
    
                When `True`, default values are omitted from the response.
    
                Read more about it in the
                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).
                """
            ),
        ] = False,
        response_model_exclude_defaults: Annotated[
            bool,
            Doc(
                """
                Configuration passed to Pydantic to define if the response data
                should have all the fields, including the ones that have the same value
                as the default. This is different from `response_model_exclude_unset`
                in that if the fields are set but contain the same default values,
                they will be excluded from the response.
    
                When `True`, default values are omitted from the response.
    
                Read more about it in the
                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).
                """
            ),
        ] = False,
        response_model_exclude_none: Annotated[
            bool,
            Doc(
                """
                Configuration passed to Pydantic to define if the response data should
                exclude fields set to `None`.
    
                This is much simpler (less smart) than `response_model_exclude_unset`
                and `response_model_exclude_defaults`. You probably want to use one of
                those two instead of this one, as those allow returning `None` values
                when it makes sense.
    
                Read more about it in the
                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).
                """
            ),
        ] = False,
        include_in_schema: Annotated[
            bool,
            Doc(
                """
                Include this *path operation* in the generated OpenAPI schema.
    
                This affects the generated OpenAPI (e.g. visible at `/docs`).
    
                Read more about it in the
                [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-parameters-from-openapi).
                """
            ),
        ] = True,
        response_class: Annotated[
            type[Response],
            Doc(
                """
                Response class to be used for this *path operation*.
    
                This will not be used if you return a response directly.
    
                Read more about it in the
                [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).
                """
            ),
        ] = Default(JSONResponse),
        name: Annotated[
            Optional[str],
            Doc(
                """
                Name for this *path operation*. Only used internally.
                """
            ),
        ] = None,
        callbacks: Annotated[
            Optional[list[BaseRoute]],
            Doc(
                """
                List of *path operations* that will be used as OpenAPI callbacks.
    
                This is only for OpenAPI documentation, the callbacks won't be used
                directly.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
    
                Read more about it in the
                [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).
                """
            ),
        ] = None,
        openapi_extra: Annotated[
            Optional[dict[str, Any]],
            Doc(
                """
                Extra metadata to be included in the OpenAPI schema for this *path
                operation*.
    
                Read more about it in the
                [FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).
                """
            ),
        ] = None,
        generate_unique_id_function: Annotated[
            Callable[[routing.APIRoute], str],
            Doc(
                """
                Customize the function used to generate unique IDs for the *path
                operations* shown in the generated OpenAPI.
    
                This is particularly useful when automatically generating clients or
                SDKs for your API.
    
                Read more about it in the
                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
                """
            ),
        ] = Default(generate_unique_id),
    ) -> Callable[[DecoratedCallable], DecoratedCallable]:
        """
        Add a *path operation* using an HTTP POST operation.
    
        ## Example
    
        ```python
        from fastapi import FastAPI
        from pydantic import BaseModel
    
        class Item(BaseModel):
            name: str
            description: str | None = None
    
        app = FastAPI()
    
        @app.post("/items/")
        def create_item(item: Item):
            return {"message": "Item created"}
        ```
        """
        return self.router.post(
            path,
            response_model=response_model,
            status_code=status_code,
            tags=tags,
            dependencies=dependencies,
            summary=summary,
            description=description,
            response_description=response_description,
            responses=responses,
            deprecated=deprecated,
            operation_id=operation_id,
            response_model_include=response_model_include,
            response_model_exclude=response_model_exclude,
            response_model_by_alias=response_model_by_alias,
            response_model_exclude_unset=response_model_exclude_unset,
            response_model_exclude_defaults=response_model_exclude_defaults,
            response_model_exclude_none=response_model_exclude_none,
            include_in_schema=include_in_schema,
            response_class=response_class,
            name=name,
            callbacks=callbacks,
            openapi_extra=openapi_extra,
            generate_unique_id_function=generate_unique_id_function,
        )
      
  
---|---  
  
###  `` delete [¶](#fastapi.FastAPI.delete "Permanent link")
    
    
    delete(
        path,
        *,
        response_model=Default(None),
        status_code=None,
        tags=None,
        dependencies=None,
        summary=None,
        description=None,
        response_description="Successful Response",
        responses=None,
        deprecated=None,
        operation_id=None,
        response_model_include=None,
        response_model_exclude=None,
        response_model_by_alias=True,
        response_model_exclude_unset=False,
        response_model_exclude_defaults=False,
        response_model_exclude_none=False,
        include_in_schema=True,
        response_class=Default([JSONResponse](../responses/#fastapi.responses.JSONResponse "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">fastapi.responses.JSONResponse</span> \(<code>starlette.responses.JSONResponse</code>\)")),
        name=None,
        callbacks=None,
        openapi_extra=None,
        generate_unique_id_function=Default(generate_unique_id)
    )
    

Add a _path operation_ using an HTTP DELETE operation.

##### Example[¶](#fastapi.FastAPI.delete--example "Permanent link")
    
    
    from fastapi import FastAPI
    
    app = FastAPI()
    
    @app.delete("/items/{item_id}")
    def delete_item(item_id: str):
        return {"message": "Item deleted"}
    

PARAMETER | DESCRIPTION  
---|---  
`path` |  The URL path to be used for this _path operation_. For example, in `http://example.com/items`, the path is `/items`. **TYPE:** `str`  
`response_model` |  The type to use for the response. It could be any valid Pydantic _field_ type. So, it doesn't have to be a Pydantic model, it could be other things, like a `list`, `dict`, etc. It will be used for:

  * Documentation: the generated OpenAPI (and the UI at `/docs`) will show it as the response (JSON Schema).
  * Serialization: you could return an arbitrary object and the `response_model` would be used to serialize that object into the corresponding JSON.
  * Filtering: the JSON sent to the client will only contain the data (fields) defined in the `response_model`. If you returned an object that contains an attribute `password` but the `response_model` does not include that field, the JSON sent to the client would not have that `password`.
  * Validation: whatever you return will be serialized with the `response_model`, converting any data as necessary to generate the corresponding JSON. But if the data in the object returned is not valid, that would mean a violation of the contract with the client, so it's an error from the API developer. So, FastAPI will raise an error and return a 500 error code (Internal Server Error).

Read more about it in the [FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/). **TYPE:** `Any` **DEFAULT:** `Default(None)`  
`status_code` |  The default status code to be used for the response. You could override the status code by returning a response directly. Read more about it in the [FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/). **TYPE:** `Optional[int]` **DEFAULT:** `None`  
`tags` |  A list of tags to be applied to the _path operation_. It will be added to the generated OpenAPI (e.g. visible at `/docs`). Read more about it in the [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags). **TYPE:** `Optional[list[Union[str, Enum]]]` **DEFAULT:** `None`  
`dependencies` |  A list of dependencies (using `Depends()`) to be applied to the _path operation_. Read more about it in the [FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/). **TYPE:** `Optional[Sequence[Depends]]` **DEFAULT:** `None`  
`summary` |  A summary for the _path operation_. It will be added to the generated OpenAPI (e.g. visible at `/docs`). Read more about it in the [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/). **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`description` |  A description for the _path operation_. If not provided, it will be extracted automatically from the docstring of the _path operation function_. It can contain Markdown. It will be added to the generated OpenAPI (e.g. visible at `/docs`). Read more about it in the [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/). **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`response_description` |  The description for the default response. It will be added to the generated OpenAPI (e.g. visible at `/docs`). **TYPE:** `str` **DEFAULT:** `'Successful Response'`  
`responses` |  Additional responses that could be returned by this _path operation_. It will be added to the generated OpenAPI (e.g. visible at `/docs`). **TYPE:** `Optional[dict[Union[int, str], dict[str, Any]]]` **DEFAULT:** `None`  
`deprecated` |  Mark this _path operation_ as deprecated. It will be added to the generated OpenAPI (e.g. visible at `/docs`). **TYPE:** `Optional[bool]` **DEFAULT:** `None`  
`operation_id` |  Custom operation ID to be used by this _path operation_. By default, it is generated automatically. If you provide a custom operation ID, you need to make sure it is unique for the whole API. You can customize the operation ID generation with the parameter `generate_unique_id_function` in the `FastAPI` class. Read more about it in the [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function). **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`response_model_include` |  Configuration passed to Pydantic to include only certain fields in the response data. Read more about it in the [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude). **TYPE:** `Optional[IncEx]` **DEFAULT:** `None`  
`response_model_exclude` |  Configuration passed to Pydantic to exclude certain fields in the response data. Read more about it in the [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude). **TYPE:** `Optional[IncEx]` **DEFAULT:** `None`  
`response_model_by_alias` |  Configuration passed to Pydantic to define if the response model should be serialized by alias when an alias is used. Read more about it in the [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude). **TYPE:** `bool` **DEFAULT:** `True`  
`response_model_exclude_unset` |  Configuration passed to Pydantic to define if the response data should have all the fields, including the ones that were not set and have their default values. This is different from `response_model_exclude_defaults` in that if the fields are set, they will be included in the response, even if the value is the same as the default. When `True`, default values are omitted from the response. Read more about it in the [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter). **TYPE:** `bool` **DEFAULT:** `False`  
`response_model_exclude_defaults` |  Configuration passed to Pydantic to define if the response data should have all the fields, including the ones that have the same value as the default. This is different from `response_model_exclude_unset` in that if the fields are set but contain the same default values, they will be excluded from the response. When `True`, default values are omitted from the response. Read more about it in the [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter). **TYPE:** `bool` **DEFAULT:** `False`  
`response_model_exclude_none` |  Configuration passed to Pydantic to define if the response data should exclude fields set to `None`. This is much simpler (less smart) than `response_model_exclude_unset` and `response_model_exclude_defaults`. You probably want to use one of those two instead of this one, as those allow returning `None` values when it makes sense. Read more about it in the [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none). **TYPE:** `bool` **DEFAULT:** `False`  
`include_in_schema` |  Include this _path operation_ in the generated OpenAPI schema. This affects the generated OpenAPI (e.g. visible at `/docs`). Read more about it in the [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-parameters-from-openapi). **TYPE:** `bool` **DEFAULT:** `True`  
`response_class` |  Response class to be used for this _path operation_. This will not be used if you return a response directly. Read more about it in the [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse). **TYPE:** `type[[Response](../response/#fastapi.Response "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">fastapi.Response</span> \(<code>starlette.responses.Response</code>\)")]` **DEFAULT:** `Default([JSONResponse](../responses/#fastapi.responses.JSONResponse "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">fastapi.responses.JSONResponse</span> \(<code>starlette.responses.JSONResponse</code>\)"))`  
`name` |  Name for this _path operation_. Only used internally. **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`callbacks` |  List of _path operations_ that will be used as OpenAPI callbacks. This is only for OpenAPI documentation, the callbacks won't be used directly. It will be added to the generated OpenAPI (e.g. visible at `/docs`). Read more about it in the [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/). **TYPE:** `Optional[list[BaseRoute]]` **DEFAULT:** `None`  
`openapi_extra` |  Extra metadata to be included in the OpenAPI schema for this _path operation_. Read more about it in the [FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema). **TYPE:** `Optional[dict[str, Any]]` **DEFAULT:** `None`  
`generate_unique_id_function` |  Customize the function used to generate unique IDs for the _path operations_ shown in the generated OpenAPI. This is particularly useful when automatically generating clients or SDKs for your API. Read more about it in the [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function). **TYPE:** `Callable[[APIRoute], str]` **DEFAULT:** `Default(generate_unique_id)`  
Source code in `fastapi/applications.py`
    
    
    2673
    2674
    2675
    2676
    2677
    2678
    2679
    2680
    2681
    2682
    2683
    2684
    2685
    2686
    2687
    2688
    2689
    2690
    2691
    2692
    2693
    2694
    2695
    2696
    2697
    2698
    2699
    2700
    2701
    2702
    2703
    2704
    2705
    2706
    2707
    2708
    2709
    2710
    2711
    2712
    2713
    2714
    2715
    2716
    2717
    2718
    2719
    2720
    2721
    2722
    2723
    2724
    2725
    2726
    2727
    2728
    2729
    2730
    2731
    2732
    2733
    2734
    2735
    2736
    2737
    2738
    2739
    2740
    2741
    2742
    2743
    2744
    2745
    2746
    2747
    2748
    2749
    2750
    2751
    2752
    2753
    2754
    2755
    2756
    2757
    2758
    2759
    2760
    2761
    2762
    2763
    2764
    2765
    2766
    2767
    2768
    2769
    2770
    2771
    2772
    2773
    2774
    2775
    2776
    2777
    2778
    2779
    2780
    2781
    2782
    2783
    2784
    2785
    2786
    2787
    2788
    2789
    2790
    2791
    2792
    2793
    2794
    2795
    2796
    2797
    2798
    2799
    2800
    2801
    2802
    2803
    2804
    2805
    2806
    2807
    2808
    2809
    2810
    2811
    2812
    2813
    2814
    2815
    2816
    2817
    2818
    2819
    2820
    2821
    2822
    2823
    2824
    2825
    2826
    2827
    2828
    2829
    2830
    2831
    2832
    2833
    2834
    2835
    2836
    2837
    2838
    2839
    2840
    2841
    2842
    2843
    2844
    2845
    2846
    2847
    2848
    2849
    2850
    2851
    2852
    2853
    2854
    2855
    2856
    2857
    2858
    2859
    2860
    2861
    2862
    2863
    2864
    2865
    2866
    2867
    2868
    2869
    2870
    2871
    2872
    2873
    2874
    2875
    2876
    2877
    2878
    2879
    2880
    2881
    2882
    2883
    2884
    2885
    2886
    2887
    2888
    2889
    2890
    2891
    2892
    2893
    2894
    2895
    2896
    2897
    2898
    2899
    2900
    2901
    2902
    2903
    2904
    2905
    2906
    2907
    2908
    2909
    2910
    2911
    2912
    2913
    2914
    2915
    2916
    2917
    2918
    2919
    2920
    2921
    2922
    2923
    2924
    2925
    2926
    2927
    2928
    2929
    2930
    2931
    2932
    2933
    2934
    2935
    2936
    2937
    2938
    2939
    2940
    2941
    2942
    2943
    2944
    2945
    2946
    2947
    2948
    2949
    2950
    2951
    2952
    2953
    2954
    2955
    2956
    2957
    2958
    2959
    2960
    2961
    2962
    2963
    2964
    2965
    2966
    2967
    2968
    2969
    2970
    2971
    2972
    2973
    2974
    2975
    2976
    2977
    2978
    2979
    2980
    2981
    2982
    2983
    2984
    2985
    2986
    2987
    2988
    2989
    2990
    2991
    2992
    2993
    2994
    2995
    2996
    2997
    2998
    2999
    3000
    3001
    3002
    3003
    3004
    3005
    3006
    3007
    3008
    3009
    3010
    3011
    3012
    3013
    3014
    3015
    3016
    3017
    3018
    3019
    3020
    3021
    3022
    3023
    3024
    3025
    3026
    3027
    3028
    3029
    3030
    3031
    3032
    3033
    3034
    3035
    3036
    3037
    3038
    3039
    3040
    3041
    3042
    3043
    3044

| 
    
    
    def delete(
        self,
        path: Annotated[
            str,
            Doc(
                """
                The URL path to be used for this *path operation*.
    
                For example, in `http://example.com/items`, the path is `/items`.
                """
            ),
        ],
        *,
        response_model: Annotated[
            Any,
            Doc(
                """
                The type to use for the response.
    
                It could be any valid Pydantic *field* type. So, it doesn't have to
                be a Pydantic model, it could be other things, like a `list`, `dict`,
                etc.
    
                It will be used for:
    
                * Documentation: the generated OpenAPI (and the UI at `/docs`) will
                    show it as the response (JSON Schema).
                * Serialization: you could return an arbitrary object and the
                    `response_model` would be used to serialize that object into the
                    corresponding JSON.
                * Filtering: the JSON sent to the client will only contain the data
                    (fields) defined in the `response_model`. If you returned an object
                    that contains an attribute `password` but the `response_model` does
                    not include that field, the JSON sent to the client would not have
                    that `password`.
                * Validation: whatever you return will be serialized with the
                    `response_model`, converting any data as necessary to generate the
                    corresponding JSON. But if the data in the object returned is not
                    valid, that would mean a violation of the contract with the client,
                    so it's an error from the API developer. So, FastAPI will raise an
                    error and return a 500 error code (Internal Server Error).
    
                Read more about it in the
                [FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).
                """
            ),
        ] = Default(None),
        status_code: Annotated[
            Optional[int],
            Doc(
                """
                The default status code to be used for the response.
    
                You could override the status code by returning a response directly.
    
                Read more about it in the
                [FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).
                """
            ),
        ] = None,
        tags: Annotated[
            Optional[list[Union[str, Enum]]],
            Doc(
                """
                A list of tags to be applied to the *path operation*.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
    
                Read more about it in the
                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).
                """
            ),
        ] = None,
        dependencies: Annotated[
            Optional[Sequence[Depends]],
            Doc(
                """
                A list of dependencies (using `Depends()`) to be applied to the
                *path operation*.
    
                Read more about it in the
                [FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).
                """
            ),
        ] = None,
        summary: Annotated[
            Optional[str],
            Doc(
                """
                A summary for the *path operation*.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
    
                Read more about it in the
                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
                """
            ),
        ] = None,
        description: Annotated[
            Optional[str],
            Doc(
                """
                A description for the *path operation*.
    
                If not provided, it will be extracted automatically from the docstring
                of the *path operation function*.
    
                It can contain Markdown.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
    
                Read more about it in the
                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
                """
            ),
        ] = None,
        response_description: Annotated[
            str,
            Doc(
                """
                The description for the default response.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
                """
            ),
        ] = "Successful Response",
        responses: Annotated[
            Optional[dict[Union[int, str], dict[str, Any]]],
            Doc(
                """
                Additional responses that could be returned by this *path operation*.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
                """
            ),
        ] = None,
        deprecated: Annotated[
            Optional[bool],
            Doc(
                """
                Mark this *path operation* as deprecated.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
                """
            ),
        ] = None,
        operation_id: Annotated[
            Optional[str],
            Doc(
                """
                Custom operation ID to be used by this *path operation*.
    
                By default, it is generated automatically.
    
                If you provide a custom operation ID, you need to make sure it is
                unique for the whole API.
    
                You can customize the
                operation ID generation with the parameter
                `generate_unique_id_function` in the `FastAPI` class.
    
                Read more about it in the
                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
                """
            ),
        ] = None,
        response_model_include: Annotated[
            Optional[IncEx],
            Doc(
                """
                Configuration passed to Pydantic to include only certain fields in the
                response data.
    
                Read more about it in the
                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
                """
            ),
        ] = None,
        response_model_exclude: Annotated[
            Optional[IncEx],
            Doc(
                """
                Configuration passed to Pydantic to exclude certain fields in the
                response data.
    
                Read more about it in the
                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
                """
            ),
        ] = None,
        response_model_by_alias: Annotated[
            bool,
            Doc(
                """
                Configuration passed to Pydantic to define if the response model
                should be serialized by alias when an alias is used.
    
                Read more about it in the
                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
                """
            ),
        ] = True,
        response_model_exclude_unset: Annotated[
            bool,
            Doc(
                """
                Configuration passed to Pydantic to define if the response data
                should have all the fields, including the ones that were not set and
                have their default values. This is different from
                `response_model_exclude_defaults` in that if the fields are set,
                they will be included in the response, even if the value is the same
                as the default.
    
                When `True`, default values are omitted from the response.
    
                Read more about it in the
                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).
                """
            ),
        ] = False,
        response_model_exclude_defaults: Annotated[
            bool,
            Doc(
                """
                Configuration passed to Pydantic to define if the response data
                should have all the fields, including the ones that have the same value
                as the default. This is different from `response_model_exclude_unset`
                in that if the fields are set but contain the same default values,
                they will be excluded from the response.
    
                When `True`, default values are omitted from the response.
    
                Read more about it in the
                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).
                """
            ),
        ] = False,
        response_model_exclude_none: Annotated[
            bool,
            Doc(
                """
                Configuration passed to Pydantic to define if the response data should
                exclude fields set to `None`.
    
                This is much simpler (less smart) than `response_model_exclude_unset`
                and `response_model_exclude_defaults`. You probably want to use one of
                those two instead of this one, as those allow returning `None` values
                when it makes sense.
    
                Read more about it in the
                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).
                """
            ),
        ] = False,
        include_in_schema: Annotated[
            bool,
            Doc(
                """
                Include this *path operation* in the generated OpenAPI schema.
    
                This affects the generated OpenAPI (e.g. visible at `/docs`).
    
                Read more about it in the
                [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-parameters-from-openapi).
                """
            ),
        ] = True,
        response_class: Annotated[
            type[Response],
            Doc(
                """
                Response class to be used for this *path operation*.
    
                This will not be used if you return a response directly.
    
                Read more about it in the
                [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).
                """
            ),
        ] = Default(JSONResponse),
        name: Annotated[
            Optional[str],
            Doc(
                """
                Name for this *path operation*. Only used internally.
                """
            ),
        ] = None,
        callbacks: Annotated[
            Optional[list[BaseRoute]],
            Doc(
                """
                List of *path operations* that will be used as OpenAPI callbacks.
    
                This is only for OpenAPI documentation, the callbacks won't be used
                directly.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
    
                Read more about it in the
                [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).
                """
            ),
        ] = None,
        openapi_extra: Annotated[
            Optional[dict[str, Any]],
            Doc(
                """
                Extra metadata to be included in the OpenAPI schema for this *path
                operation*.
    
                Read more about it in the
                [FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).
                """
            ),
        ] = None,
        generate_unique_id_function: Annotated[
            Callable[[routing.APIRoute], str],
            Doc(
                """
                Customize the function used to generate unique IDs for the *path
                operations* shown in the generated OpenAPI.
    
                This is particularly useful when automatically generating clients or
                SDKs for your API.
    
                Read more about it in the
                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
                """
            ),
        ] = Default(generate_unique_id),
    ) -> Callable[[DecoratedCallable], DecoratedCallable]:
        """
        Add a *path operation* using an HTTP DELETE operation.
    
        ## Example
    
        ```python
        from fastapi import FastAPI
    
        app = FastAPI()
    
        @app.delete("/items/{item_id}")
        def delete_item(item_id: str):
            return {"message": "Item deleted"}
        ```
        """
        return self.router.delete(
            path,
            response_model=response_model,
            status_code=status_code,
            tags=tags,
            dependencies=dependencies,
            summary=summary,
            description=description,
            response_description=response_description,
            responses=responses,
            deprecated=deprecated,
            operation_id=operation_id,
            response_model_include=response_model_include,
            response_model_exclude=response_model_exclude,
            response_model_by_alias=response_model_by_alias,
            response_model_exclude_unset=response_model_exclude_unset,
            response_model_exclude_defaults=response_model_exclude_defaults,
            response_model_exclude_none=response_model_exclude_none,
            include_in_schema=include_in_schema,
            response_class=response_class,
            name=name,
            callbacks=callbacks,
            openapi_extra=openapi_extra,
            generate_unique_id_function=generate_unique_id_function,
        )
      
  
---|---  
  
###  `` options [¶](#fastapi.FastAPI.options "Permanent link")
    
    
    options(
        path,
        *,
        response_model=Default(None),
        status_code=None,
        tags=None,
        dependencies=None,
        summary=None,
        description=None,
        response_description="Successful Response",
        responses=None,
        deprecated=None,
        operation_id=None,
        response_model_include=None,
        response_model_exclude=None,
        response_model_by_alias=True,
        response_model_exclude_unset=False,
        response_model_exclude_defaults=False,
        response_model_exclude_none=False,
        include_in_schema=True,
        response_class=Default([JSONResponse](../responses/#fastapi.responses.JSONResponse "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">fastapi.responses.JSONResponse</span> \(<code>starlette.responses.JSONResponse</code>\)")),
        name=None,
        callbacks=None,
        openapi_extra=None,
        generate_unique_id_function=Default(generate_unique_id)
    )
    

Add a _path operation_ using an HTTP OPTIONS operation.

##### Example[¶](#fastapi.FastAPI.options--example "Permanent link")
    
    
    from fastapi import FastAPI
    
    app = FastAPI()
    
    @app.options("/items/")
    def get_item_options():
        return {"additions": ["Aji", "Guacamole"]}
    

PARAMETER | DESCRIPTION  
---|---  
`path` |  The URL path to be used for this _path operation_. For example, in `http://example.com/items`, the path is `/items`. **TYPE:** `str`  
`response_model` |  The type to use for the response. It could be any valid Pydantic _field_ type. So, it doesn't have to be a Pydantic model, it could be other things, like a `list`, `dict`, etc. It will be used for:

  * Documentation: the generated OpenAPI (and the UI at `/docs`) will show it as the response (JSON Schema).
  * Serialization: you could return an arbitrary object and the `response_model` would be used to serialize that object into the corresponding JSON.
  * Filtering: the JSON sent to the client will only contain the data (fields) defined in the `response_model`. If you returned an object that contains an attribute `password` but the `response_model` does not include that field, the JSON sent to the client would not have that `password`.
  * Validation: whatever you return will be serialized with the `response_model`, converting any data as necessary to generate the corresponding JSON. But if the data in the object returned is not valid, that would mean a violation of the contract with the client, so it's an error from the API developer. So, FastAPI will raise an error and return a 500 error code (Internal Server Error).

Read more about it in the [FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/). **TYPE:** `Any` **DEFAULT:** `Default(None)`  
`status_code` |  The default status code to be used for the response. You could override the status code by returning a response directly. Read more about it in the [FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/). **TYPE:** `Optional[int]` **DEFAULT:** `None`  
`tags` |  A list of tags to be applied to the _path operation_. It will be added to the generated OpenAPI (e.g. visible at `/docs`). Read more about it in the [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags). **TYPE:** `Optional[list[Union[str, Enum]]]` **DEFAULT:** `None`  
`dependencies` |  A list of dependencies (using `Depends()`) to be applied to the _path operation_. Read more about it in the [FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/). **TYPE:** `Optional[Sequence[Depends]]` **DEFAULT:** `None`  
`summary` |  A summary for the _path operation_. It will be added to the generated OpenAPI (e.g. visible at `/docs`). Read more about it in the [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/). **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`description` |  A description for the _path operation_. If not provided, it will be extracted automatically from the docstring of the _path operation function_. It can contain Markdown. It will be added to the generated OpenAPI (e.g. visible at `/docs`). Read more about it in the [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/). **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`response_description` |  The description for the default response. It will be added to the generated OpenAPI (e.g. visible at `/docs`). **TYPE:** `str` **DEFAULT:** `'Successful Response'`  
`responses` |  Additional responses that could be returned by this _path operation_. It will be added to the generated OpenAPI (e.g. visible at `/docs`). **TYPE:** `Optional[dict[Union[int, str], dict[str, Any]]]` **DEFAULT:** `None`  
`deprecated` |  Mark this _path operation_ as deprecated. It will be added to the generated OpenAPI (e.g. visible at `/docs`). **TYPE:** `Optional[bool]` **DEFAULT:** `None`  
`operation_id` |  Custom operation ID to be used by this _path operation_. By default, it is generated automatically. If you provide a custom operation ID, you need to make sure it is unique for the whole API. You can customize the operation ID generation with the parameter `generate_unique_id_function` in the `FastAPI` class. Read more about it in the [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function). **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`response_model_include` |  Configuration passed to Pydantic to include only certain fields in the response data. Read more about it in the [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude). **TYPE:** `Optional[IncEx]` **DEFAULT:** `None`  
`response_model_exclude` |  Configuration passed to Pydantic to exclude certain fields in the response data. Read more about it in the [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude). **TYPE:** `Optional[IncEx]` **DEFAULT:** `None`  
`response_model_by_alias` |  Configuration passed to Pydantic to define if the response model should be serialized by alias when an alias is used. Read more about it in the [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude). **TYPE:** `bool` **DEFAULT:** `True`  
`response_model_exclude_unset` |  Configuration passed to Pydantic to define if the response data should have all the fields, including the ones that were not set and have their default values. This is different from `response_model_exclude_defaults` in that if the fields are set, they will be included in the response, even if the value is the same as the default. When `True`, default values are omitted from the response. Read more about it in the [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter). **TYPE:** `bool` **DEFAULT:** `False`  
`response_model_exclude_defaults` |  Configuration passed to Pydantic to define if the response data should have all the fields, including the ones that have the same value as the default. This is different from `response_model_exclude_unset` in that if the fields are set but contain the same default values, they will be excluded from the response. When `True`, default values are omitted from the response. Read more about it in the [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter). **TYPE:** `bool` **DEFAULT:** `False`  
`response_model_exclude_none` |  Configuration passed to Pydantic to define if the response data should exclude fields set to `None`. This is much simpler (less smart) than `response_model_exclude_unset` and `response_model_exclude_defaults`. You probably want to use one of those two instead of this one, as those allow returning `None` values when it makes sense. Read more about it in the [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none). **TYPE:** `bool` **DEFAULT:** `False`  
`include_in_schema` |  Include this _path operation_ in the generated OpenAPI schema. This affects the generated OpenAPI (e.g. visible at `/docs`). Read more about it in the [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-parameters-from-openapi). **TYPE:** `bool` **DEFAULT:** `True`  
`response_class` |  Response class to be used for this _path operation_. This will not be used if you return a response directly. Read more about it in the [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse). **TYPE:** `type[[Response](../response/#fastapi.Response "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">fastapi.Response</span> \(<code>starlette.responses.Response</code>\)")]` **DEFAULT:** `Default([JSONResponse](../responses/#fastapi.responses.JSONResponse "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">fastapi.responses.JSONResponse</span> \(<code>starlette.responses.JSONResponse</code>\)"))`  
`name` |  Name for this _path operation_. Only used internally. **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`callbacks` |  List of _path operations_ that will be used as OpenAPI callbacks. This is only for OpenAPI documentation, the callbacks won't be used directly. It will be added to the generated OpenAPI (e.g. visible at `/docs`). Read more about it in the [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/). **TYPE:** `Optional[list[BaseRoute]]` **DEFAULT:** `None`  
`openapi_extra` |  Extra metadata to be included in the OpenAPI schema for this _path operation_. Read more about it in the [FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema). **TYPE:** `Optional[dict[str, Any]]` **DEFAULT:** `None`  
`generate_unique_id_function` |  Customize the function used to generate unique IDs for the _path operations_ shown in the generated OpenAPI. This is particularly useful when automatically generating clients or SDKs for your API. Read more about it in the [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function). **TYPE:** `Callable[[APIRoute], str]` **DEFAULT:** `Default(generate_unique_id)`  
Source code in `fastapi/applications.py`
    
    
    3046
    3047
    3048
    3049
    3050
    3051
    3052
    3053
    3054
    3055
    3056
    3057
    3058
    3059
    3060
    3061
    3062
    3063
    3064
    3065
    3066
    3067
    3068
    3069
    3070
    3071
    3072
    3073
    3074
    3075
    3076
    3077
    3078
    3079
    3080
    3081
    3082
    3083
    3084
    3085
    3086
    3087
    3088
    3089
    3090
    3091
    3092
    3093
    3094
    3095
    3096
    3097
    3098
    3099
    3100
    3101
    3102
    3103
    3104
    3105
    3106
    3107
    3108
    3109
    3110
    3111
    3112
    3113
    3114
    3115
    3116
    3117
    3118
    3119
    3120
    3121
    3122
    3123
    3124
    3125
    3126
    3127
    3128
    3129
    3130
    3131
    3132
    3133
    3134
    3135
    3136
    3137
    3138
    3139
    3140
    3141
    3142
    3143
    3144
    3145
    3146
    3147
    3148
    3149
    3150
    3151
    3152
    3153
    3154
    3155
    3156
    3157
    3158
    3159
    3160
    3161
    3162
    3163
    3164
    3165
    3166
    3167
    3168
    3169
    3170
    3171
    3172
    3173
    3174
    3175
    3176
    3177
    3178
    3179
    3180
    3181
    3182
    3183
    3184
    3185
    3186
    3187
    3188
    3189
    3190
    3191
    3192
    3193
    3194
    3195
    3196
    3197
    3198
    3199
    3200
    3201
    3202
    3203
    3204
    3205
    3206
    3207
    3208
    3209
    3210
    3211
    3212
    3213
    3214
    3215
    3216
    3217
    3218
    3219
    3220
    3221
    3222
    3223
    3224
    3225
    3226
    3227
    3228
    3229
    3230
    3231
    3232
    3233
    3234
    3235
    3236
    3237
    3238
    3239
    3240
    3241
    3242
    3243
    3244
    3245
    3246
    3247
    3248
    3249
    3250
    3251
    3252
    3253
    3254
    3255
    3256
    3257
    3258
    3259
    3260
    3261
    3262
    3263
    3264
    3265
    3266
    3267
    3268
    3269
    3270
    3271
    3272
    3273
    3274
    3275
    3276
    3277
    3278
    3279
    3280
    3281
    3282
    3283
    3284
    3285
    3286
    3287
    3288
    3289
    3290
    3291
    3292
    3293
    3294
    3295
    3296
    3297
    3298
    3299
    3300
    3301
    3302
    3303
    3304
    3305
    3306
    3307
    3308
    3309
    3310
    3311
    3312
    3313
    3314
    3315
    3316
    3317
    3318
    3319
    3320
    3321
    3322
    3323
    3324
    3325
    3326
    3327
    3328
    3329
    3330
    3331
    3332
    3333
    3334
    3335
    3336
    3337
    3338
    3339
    3340
    3341
    3342
    3343
    3344
    3345
    3346
    3347
    3348
    3349
    3350
    3351
    3352
    3353
    3354
    3355
    3356
    3357
    3358
    3359
    3360
    3361
    3362
    3363
    3364
    3365
    3366
    3367
    3368
    3369
    3370
    3371
    3372
    3373
    3374
    3375
    3376
    3377
    3378
    3379
    3380
    3381
    3382
    3383
    3384
    3385
    3386
    3387
    3388
    3389
    3390
    3391
    3392
    3393
    3394
    3395
    3396
    3397
    3398
    3399
    3400
    3401
    3402
    3403
    3404
    3405
    3406
    3407
    3408
    3409
    3410
    3411
    3412
    3413
    3414
    3415
    3416
    3417

| 
    
    
    def options(
        self,
        path: Annotated[
            str,
            Doc(
                """
                The URL path to be used for this *path operation*.
    
                For example, in `http://example.com/items`, the path is `/items`.
                """
            ),
        ],
        *,
        response_model: Annotated[
            Any,
            Doc(
                """
                The type to use for the response.
    
                It could be any valid Pydantic *field* type. So, it doesn't have to
                be a Pydantic model, it could be other things, like a `list`, `dict`,
                etc.
    
                It will be used for:
    
                * Documentation: the generated OpenAPI (and the UI at `/docs`) will
                    show it as the response (JSON Schema).
                * Serialization: you could return an arbitrary object and the
                    `response_model` would be used to serialize that object into the
                    corresponding JSON.
                * Filtering: the JSON sent to the client will only contain the data
                    (fields) defined in the `response_model`. If you returned an object
                    that contains an attribute `password` but the `response_model` does
                    not include that field, the JSON sent to the client would not have
                    that `password`.
                * Validation: whatever you return will be serialized with the
                    `response_model`, converting any data as necessary to generate the
                    corresponding JSON. But if the data in the object returned is not
                    valid, that would mean a violation of the contract with the client,
                    so it's an error from the API developer. So, FastAPI will raise an
                    error and return a 500 error code (Internal Server Error).
    
                Read more about it in the
                [FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).
                """
            ),
        ] = Default(None),
        status_code: Annotated[
            Optional[int],
            Doc(
                """
                The default status code to be used for the response.
    
                You could override the status code by returning a response directly.
    
                Read more about it in the
                [FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).
                """
            ),
        ] = None,
        tags: Annotated[
            Optional[list[Union[str, Enum]]],
            Doc(
                """
                A list of tags to be applied to the *path operation*.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
    
                Read more about it in the
                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).
                """
            ),
        ] = None,
        dependencies: Annotated[
            Optional[Sequence[Depends]],
            Doc(
                """
                A list of dependencies (using `Depends()`) to be applied to the
                *path operation*.
    
                Read more about it in the
                [FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).
                """
            ),
        ] = None,
        summary: Annotated[
            Optional[str],
            Doc(
                """
                A summary for the *path operation*.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
    
                Read more about it in the
                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
                """
            ),
        ] = None,
        description: Annotated[
            Optional[str],
            Doc(
                """
                A description for the *path operation*.
    
                If not provided, it will be extracted automatically from the docstring
                of the *path operation function*.
    
                It can contain Markdown.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
    
                Read more about it in the
                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
                """
            ),
        ] = None,
        response_description: Annotated[
            str,
            Doc(
                """
                The description for the default response.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
                """
            ),
        ] = "Successful Response",
        responses: Annotated[
            Optional[dict[Union[int, str], dict[str, Any]]],
            Doc(
                """
                Additional responses that could be returned by this *path operation*.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
                """
            ),
        ] = None,
        deprecated: Annotated[
            Optional[bool],
            Doc(
                """
                Mark this *path operation* as deprecated.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
                """
            ),
        ] = None,
        operation_id: Annotated[
            Optional[str],
            Doc(
                """
                Custom operation ID to be used by this *path operation*.
    
                By default, it is generated automatically.
    
                If you provide a custom operation ID, you need to make sure it is
                unique for the whole API.
    
                You can customize the
                operation ID generation with the parameter
                `generate_unique_id_function` in the `FastAPI` class.
    
                Read more about it in the
                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
                """
            ),
        ] = None,
        response_model_include: Annotated[
            Optional[IncEx],
            Doc(
                """
                Configuration passed to Pydantic to include only certain fields in the
                response data.
    
                Read more about it in the
                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
                """
            ),
        ] = None,
        response_model_exclude: Annotated[
            Optional[IncEx],
            Doc(
                """
                Configuration passed to Pydantic to exclude certain fields in the
                response data.
    
                Read more about it in the
                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
                """
            ),
        ] = None,
        response_model_by_alias: Annotated[
            bool,
            Doc(
                """
                Configuration passed to Pydantic to define if the response model
                should be serialized by alias when an alias is used.
    
                Read more about it in the
                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
                """
            ),
        ] = True,
        response_model_exclude_unset: Annotated[
            bool,
            Doc(
                """
                Configuration passed to Pydantic to define if the response data
                should have all the fields, including the ones that were not set and
                have their default values. This is different from
                `response_model_exclude_defaults` in that if the fields are set,
                they will be included in the response, even if the value is the same
                as the default.
    
                When `True`, default values are omitted from the response.
    
                Read more about it in the
                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).
                """
            ),
        ] = False,
        response_model_exclude_defaults: Annotated[
            bool,
            Doc(
                """
                Configuration passed to Pydantic to define if the response data
                should have all the fields, including the ones that have the same value
                as the default. This is different from `response_model_exclude_unset`
                in that if the fields are set but contain the same default values,
                they will be excluded from the response.
    
                When `True`, default values are omitted from the response.
    
                Read more about it in the
                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).
                """
            ),
        ] = False,
        response_model_exclude_none: Annotated[
            bool,
            Doc(
                """
                Configuration passed to Pydantic to define if the response data should
                exclude fields set to `None`.
    
                This is much simpler (less smart) than `response_model_exclude_unset`
                and `response_model_exclude_defaults`. You probably want to use one of
                those two instead of this one, as those allow returning `None` values
                when it makes sense.
    
                Read more about it in the
                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).
                """
            ),
        ] = False,
        include_in_schema: Annotated[
            bool,
            Doc(
                """
                Include this *path operation* in the generated OpenAPI schema.
    
                This affects the generated OpenAPI (e.g. visible at `/docs`).
    
                Read more about it in the
                [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-parameters-from-openapi).
                """
            ),
        ] = True,
        response_class: Annotated[
            type[Response],
            Doc(
                """
                Response class to be used for this *path operation*.
    
                This will not be used if you return a response directly.
    
                Read more about it in the
                [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).
                """
            ),
        ] = Default(JSONResponse),
        name: Annotated[
            Optional[str],
            Doc(
                """
                Name for this *path operation*. Only used internally.
                """
            ),
        ] = None,
        callbacks: Annotated[
            Optional[list[BaseRoute]],
            Doc(
                """
                List of *path operations* that will be used as OpenAPI callbacks.
    
                This is only for OpenAPI documentation, the callbacks won't be used
                directly.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
    
                Read more about it in the
                [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).
                """
            ),
        ] = None,
        openapi_extra: Annotated[
            Optional[dict[str, Any]],
            Doc(
                """
                Extra metadata to be included in the OpenAPI schema for this *path
                operation*.
    
                Read more about it in the
                [FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).
                """
            ),
        ] = None,
        generate_unique_id_function: Annotated[
            Callable[[routing.APIRoute], str],
            Doc(
                """
                Customize the function used to generate unique IDs for the *path
                operations* shown in the generated OpenAPI.
    
                This is particularly useful when automatically generating clients or
                SDKs for your API.
    
                Read more about it in the
                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
                """
            ),
        ] = Default(generate_unique_id),
    ) -> Callable[[DecoratedCallable], DecoratedCallable]:
        """
        Add a *path operation* using an HTTP OPTIONS operation.
    
        ## Example
    
        ```python
        from fastapi import FastAPI
    
        app = FastAPI()
    
        @app.options("/items/")
        def get_item_options():
            return {"additions": ["Aji", "Guacamole"]}
        ```
        """
        return self.router.options(
            path,
            response_model=response_model,
            status_code=status_code,
            tags=tags,
            dependencies=dependencies,
            summary=summary,
            description=description,
            response_description=response_description,
            responses=responses,
            deprecated=deprecated,
            operation_id=operation_id,
            response_model_include=response_model_include,
            response_model_exclude=response_model_exclude,
            response_model_by_alias=response_model_by_alias,
            response_model_exclude_unset=response_model_exclude_unset,
            response_model_exclude_defaults=response_model_exclude_defaults,
            response_model_exclude_none=response_model_exclude_none,
            include_in_schema=include_in_schema,
            response_class=response_class,
            name=name,
            callbacks=callbacks,
            openapi_extra=openapi_extra,
            generate_unique_id_function=generate_unique_id_function,
        )
      
  
---|---  
  
###  `` head [¶](#fastapi.FastAPI.head "Permanent link")
    
    
    head(
        path,
        *,
        response_model=Default(None),
        status_code=None,
        tags=None,
        dependencies=None,
        summary=None,
        description=None,
        response_description="Successful Response",
        responses=None,
        deprecated=None,
        operation_id=None,
        response_model_include=None,
        response_model_exclude=None,
        response_model_by_alias=True,
        response_model_exclude_unset=False,
        response_model_exclude_defaults=False,
        response_model_exclude_none=False,
        include_in_schema=True,
        response_class=Default([JSONResponse](../responses/#fastapi.responses.JSONResponse "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">fastapi.responses.JSONResponse</span> \(<code>starlette.responses.JSONResponse</code>\)")),
        name=None,
        callbacks=None,
        openapi_extra=None,
        generate_unique_id_function=Default(generate_unique_id)
    )
    

Add a _path operation_ using an HTTP HEAD operation.

##### Example[¶](#fastapi.FastAPI.head--example "Permanent link")
    
    
    from fastapi import FastAPI, Response
    
    app = FastAPI()
    
    @app.head("/items/", status_code=204)
    def get_items_headers(response: Response):
        response.headers["X-Cat-Dog"] = "Alone in the world"
    

PARAMETER | DESCRIPTION  
---|---  
`path` |  The URL path to be used for this _path operation_. For example, in `http://example.com/items`, the path is `/items`. **TYPE:** `str`  
`response_model` |  The type to use for the response. It could be any valid Pydantic _field_ type. So, it doesn't have to be a Pydantic model, it could be other things, like a `list`, `dict`, etc. It will be used for:

  * Documentation: the generated OpenAPI (and the UI at `/docs`) will show it as the response (JSON Schema).
  * Serialization: you could return an arbitrary object and the `response_model` would be used to serialize that object into the corresponding JSON.
  * Filtering: the JSON sent to the client will only contain the data (fields) defined in the `response_model`. If you returned an object that contains an attribute `password` but the `response_model` does not include that field, the JSON sent to the client would not have that `password`.
  * Validation: whatever you return will be serialized with the `response_model`, converting any data as necessary to generate the corresponding JSON. But if the data in the object returned is not valid, that would mean a violation of the contract with the client, so it's an error from the API developer. So, FastAPI will raise an error and return a 500 error code (Internal Server Error).

Read more about it in the [FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/). **TYPE:** `Any` **DEFAULT:** `Default(None)`  
`status_code` |  The default status code to be used for the response. You could override the status code by returning a response directly. Read more about it in the [FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/). **TYPE:** `Optional[int]` **DEFAULT:** `None`  
`tags` |  A list of tags to be applied to the _path operation_. It will be added to the generated OpenAPI (e.g. visible at `/docs`). Read more about it in the [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags). **TYPE:** `Optional[list[Union[str, Enum]]]` **DEFAULT:** `None`  
`dependencies` |  A list of dependencies (using `Depends()`) to be applied to the _path operation_. Read more about it in the [FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/). **TYPE:** `Optional[Sequence[Depends]]` **DEFAULT:** `None`  
`summary` |  A summary for the _path operation_. It will be added to the generated OpenAPI (e.g. visible at `/docs`). Read more about it in the [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/). **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`description` |  A description for the _path operation_. If not provided, it will be extracted automatically from the docstring of the _path operation function_. It can contain Markdown. It will be added to the generated OpenAPI (e.g. visible at `/docs`). Read more about it in the [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/). **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`response_description` |  The description for the default response. It will be added to the generated OpenAPI (e.g. visible at `/docs`). **TYPE:** `str` **DEFAULT:** `'Successful Response'`  
`responses` |  Additional responses that could be returned by this _path operation_. It will be added to the generated OpenAPI (e.g. visible at `/docs`). **TYPE:** `Optional[dict[Union[int, str], dict[str, Any]]]` **DEFAULT:** `None`  
`deprecated` |  Mark this _path operation_ as deprecated. It will be added to the generated OpenAPI (e.g. visible at `/docs`). **TYPE:** `Optional[bool]` **DEFAULT:** `None`  
`operation_id` |  Custom operation ID to be used by this _path operation_. By default, it is generated automatically. If you provide a custom operation ID, you need to make sure it is unique for the whole API. You can customize the operation ID generation with the parameter `generate_unique_id_function` in the `FastAPI` class. Read more about it in the [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function). **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`response_model_include` |  Configuration passed to Pydantic to include only certain fields in the response data. Read more about it in the [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude). **TYPE:** `Optional[IncEx]` **DEFAULT:** `None`  
`response_model_exclude` |  Configuration passed to Pydantic to exclude certain fields in the response data. Read more about it in the [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude). **TYPE:** `Optional[IncEx]` **DEFAULT:** `None`  
`response_model_by_alias` |  Configuration passed to Pydantic to define if the response model should be serialized by alias when an alias is used. Read more about it in the [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude). **TYPE:** `bool` **DEFAULT:** `True`  
`response_model_exclude_unset` |  Configuration passed to Pydantic to define if the response data should have all the fields, including the ones that were not set and have their default values. This is different from `response_model_exclude_defaults` in that if the fields are set, they will be included in the response, even if the value is the same as the default. When `True`, default values are omitted from the response. Read more about it in the [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter). **TYPE:** `bool` **DEFAULT:** `False`  
`response_model_exclude_defaults` |  Configuration passed to Pydantic to define if the response data should have all the fields, including the ones that have the same value as the default. This is different from `response_model_exclude_unset` in that if the fields are set but contain the same default values, they will be excluded from the response. When `True`, default values are omitted from the response. Read more about it in the [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter). **TYPE:** `bool` **DEFAULT:** `False`  
`response_model_exclude_none` |  Configuration passed to Pydantic to define if the response data should exclude fields set to `None`. This is much simpler (less smart) than `response_model_exclude_unset` and `response_model_exclude_defaults`. You probably want to use one of those two instead of this one, as those allow returning `None` values when it makes sense. Read more about it in the [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none). **TYPE:** `bool` **DEFAULT:** `False`  
`include_in_schema` |  Include this _path operation_ in the generated OpenAPI schema. This affects the generated OpenAPI (e.g. visible at `/docs`). Read more about it in the [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-parameters-from-openapi). **TYPE:** `bool` **DEFAULT:** `True`  
`response_class` |  Response class to be used for this _path operation_. This will not be used if you return a response directly. Read more about it in the [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse). **TYPE:** `type[[Response](../response/#fastapi.Response "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">fastapi.Response</span> \(<code>starlette.responses.Response</code>\)")]` **DEFAULT:** `Default([JSONResponse](../responses/#fastapi.responses.JSONResponse "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">fastapi.responses.JSONResponse</span> \(<code>starlette.responses.JSONResponse</code>\)"))`  
`name` |  Name for this _path operation_. Only used internally. **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`callbacks` |  List of _path operations_ that will be used as OpenAPI callbacks. This is only for OpenAPI documentation, the callbacks won't be used directly. It will be added to the generated OpenAPI (e.g. visible at `/docs`). Read more about it in the [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/). **TYPE:** `Optional[list[BaseRoute]]` **DEFAULT:** `None`  
`openapi_extra` |  Extra metadata to be included in the OpenAPI schema for this _path operation_. Read more about it in the [FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema). **TYPE:** `Optional[dict[str, Any]]` **DEFAULT:** `None`  
`generate_unique_id_function` |  Customize the function used to generate unique IDs for the _path operations_ shown in the generated OpenAPI. This is particularly useful when automatically generating clients or SDKs for your API. Read more about it in the [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function). **TYPE:** `Callable[[APIRoute], str]` **DEFAULT:** `Default(generate_unique_id)`  
Source code in `fastapi/applications.py`
    
    
    3419
    3420
    3421
    3422
    3423
    3424
    3425
    3426
    3427
    3428
    3429
    3430
    3431
    3432
    3433
    3434
    3435
    3436
    3437
    3438
    3439
    3440
    3441
    3442
    3443
    3444
    3445
    3446
    3447
    3448
    3449
    3450
    3451
    3452
    3453
    3454
    3455
    3456
    3457
    3458
    3459
    3460
    3461
    3462
    3463
    3464
    3465
    3466
    3467
    3468
    3469
    3470
    3471
    3472
    3473
    3474
    3475
    3476
    3477
    3478
    3479
    3480
    3481
    3482
    3483
    3484
    3485
    3486
    3487
    3488
    3489
    3490
    3491
    3492
    3493
    3494
    3495
    3496
    3497
    3498
    3499
    3500
    3501
    3502
    3503
    3504
    3505
    3506
    3507
    3508
    3509
    3510
    3511
    3512
    3513
    3514
    3515
    3516
    3517
    3518
    3519
    3520
    3521
    3522
    3523
    3524
    3525
    3526
    3527
    3528
    3529
    3530
    3531
    3532
    3533
    3534
    3535
    3536
    3537
    3538
    3539
    3540
    3541
    3542
    3543
    3544
    3545
    3546
    3547
    3548
    3549
    3550
    3551
    3552
    3553
    3554
    3555
    3556
    3557
    3558
    3559
    3560
    3561
    3562
    3563
    3564
    3565
    3566
    3567
    3568
    3569
    3570
    3571
    3572
    3573
    3574
    3575
    3576
    3577
    3578
    3579
    3580
    3581
    3582
    3583
    3584
    3585
    3586
    3587
    3588
    3589
    3590
    3591
    3592
    3593
    3594
    3595
    3596
    3597
    3598
    3599
    3600
    3601
    3602
    3603
    3604
    3605
    3606
    3607
    3608
    3609
    3610
    3611
    3612
    3613
    3614
    3615
    3616
    3617
    3618
    3619
    3620
    3621
    3622
    3623
    3624
    3625
    3626
    3627
    3628
    3629
    3630
    3631
    3632
    3633
    3634
    3635
    3636
    3637
    3638
    3639
    3640
    3641
    3642
    3643
    3644
    3645
    3646
    3647
    3648
    3649
    3650
    3651
    3652
    3653
    3654
    3655
    3656
    3657
    3658
    3659
    3660
    3661
    3662
    3663
    3664
    3665
    3666
    3667
    3668
    3669
    3670
    3671
    3672
    3673
    3674
    3675
    3676
    3677
    3678
    3679
    3680
    3681
    3682
    3683
    3684
    3685
    3686
    3687
    3688
    3689
    3690
    3691
    3692
    3693
    3694
    3695
    3696
    3697
    3698
    3699
    3700
    3701
    3702
    3703
    3704
    3705
    3706
    3707
    3708
    3709
    3710
    3711
    3712
    3713
    3714
    3715
    3716
    3717
    3718
    3719
    3720
    3721
    3722
    3723
    3724
    3725
    3726
    3727
    3728
    3729
    3730
    3731
    3732
    3733
    3734
    3735
    3736
    3737
    3738
    3739
    3740
    3741
    3742
    3743
    3744
    3745
    3746
    3747
    3748
    3749
    3750
    3751
    3752
    3753
    3754
    3755
    3756
    3757
    3758
    3759
    3760
    3761
    3762
    3763
    3764
    3765
    3766
    3767
    3768
    3769
    3770
    3771
    3772
    3773
    3774
    3775
    3776
    3777
    3778
    3779
    3780
    3781
    3782
    3783
    3784
    3785
    3786
    3787
    3788
    3789
    3790

| 
    
    
    def head(
        self,
        path: Annotated[
            str,
            Doc(
                """
                The URL path to be used for this *path operation*.
    
                For example, in `http://example.com/items`, the path is `/items`.
                """
            ),
        ],
        *,
        response_model: Annotated[
            Any,
            Doc(
                """
                The type to use for the response.
    
                It could be any valid Pydantic *field* type. So, it doesn't have to
                be a Pydantic model, it could be other things, like a `list`, `dict`,
                etc.
    
                It will be used for:
    
                * Documentation: the generated OpenAPI (and the UI at `/docs`) will
                    show it as the response (JSON Schema).
                * Serialization: you could return an arbitrary object and the
                    `response_model` would be used to serialize that object into the
                    corresponding JSON.
                * Filtering: the JSON sent to the client will only contain the data
                    (fields) defined in the `response_model`. If you returned an object
                    that contains an attribute `password` but the `response_model` does
                    not include that field, the JSON sent to the client would not have
                    that `password`.
                * Validation: whatever you return will be serialized with the
                    `response_model`, converting any data as necessary to generate the
                    corresponding JSON. But if the data in the object returned is not
                    valid, that would mean a violation of the contract with the client,
                    so it's an error from the API developer. So, FastAPI will raise an
                    error and return a 500 error code (Internal Server Error).
    
                Read more about it in the
                [FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).
                """
            ),
        ] = Default(None),
        status_code: Annotated[
            Optional[int],
            Doc(
                """
                The default status code to be used for the response.
    
                You could override the status code by returning a response directly.
    
                Read more about it in the
                [FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).
                """
            ),
        ] = None,
        tags: Annotated[
            Optional[list[Union[str, Enum]]],
            Doc(
                """
                A list of tags to be applied to the *path operation*.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
    
                Read more about it in the
                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).
                """
            ),
        ] = None,
        dependencies: Annotated[
            Optional[Sequence[Depends]],
            Doc(
                """
                A list of dependencies (using `Depends()`) to be applied to the
                *path operation*.
    
                Read more about it in the
                [FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).
                """
            ),
        ] = None,
        summary: Annotated[
            Optional[str],
            Doc(
                """
                A summary for the *path operation*.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
    
                Read more about it in the
                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
                """
            ),
        ] = None,
        description: Annotated[
            Optional[str],
            Doc(
                """
                A description for the *path operation*.
    
                If not provided, it will be extracted automatically from the docstring
                of the *path operation function*.
    
                It can contain Markdown.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
    
                Read more about it in the
                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
                """
            ),
        ] = None,
        response_description: Annotated[
            str,
            Doc(
                """
                The description for the default response.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
                """
            ),
        ] = "Successful Response",
        responses: Annotated[
            Optional[dict[Union[int, str], dict[str, Any]]],
            Doc(
                """
                Additional responses that could be returned by this *path operation*.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
                """
            ),
        ] = None,
        deprecated: Annotated[
            Optional[bool],
            Doc(
                """
                Mark this *path operation* as deprecated.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
                """
            ),
        ] = None,
        operation_id: Annotated[
            Optional[str],
            Doc(
                """
                Custom operation ID to be used by this *path operation*.
    
                By default, it is generated automatically.
    
                If you provide a custom operation ID, you need to make sure it is
                unique for the whole API.
    
                You can customize the
                operation ID generation with the parameter
                `generate_unique_id_function` in the `FastAPI` class.
    
                Read more about it in the
                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
                """
            ),
        ] = None,
        response_model_include: Annotated[
            Optional[IncEx],
            Doc(
                """
                Configuration passed to Pydantic to include only certain fields in the
                response data.
    
                Read more about it in the
                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
                """
            ),
        ] = None,
        response_model_exclude: Annotated[
            Optional[IncEx],
            Doc(
                """
                Configuration passed to Pydantic to exclude certain fields in the
                response data.
    
                Read more about it in the
                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
                """
            ),
        ] = None,
        response_model_by_alias: Annotated[
            bool,
            Doc(
                """
                Configuration passed to Pydantic to define if the response model
                should be serialized by alias when an alias is used.
    
                Read more about it in the
                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
                """
            ),
        ] = True,
        response_model_exclude_unset: Annotated[
            bool,
            Doc(
                """
                Configuration passed to Pydantic to define if the response data
                should have all the fields, including the ones that were not set and
                have their default values. This is different from
                `response_model_exclude_defaults` in that if the fields are set,
                they will be included in the response, even if the value is the same
                as the default.
    
                When `True`, default values are omitted from the response.
    
                Read more about it in the
                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).
                """
            ),
        ] = False,
        response_model_exclude_defaults: Annotated[
            bool,
            Doc(
                """
                Configuration passed to Pydantic to define if the response data
                should have all the fields, including the ones that have the same value
                as the default. This is different from `response_model_exclude_unset`
                in that if the fields are set but contain the same default values,
                they will be excluded from the response.
    
                When `True`, default values are omitted from the response.
    
                Read more about it in the
                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).
                """
            ),
        ] = False,
        response_model_exclude_none: Annotated[
            bool,
            Doc(
                """
                Configuration passed to Pydantic to define if the response data should
                exclude fields set to `None`.
    
                This is much simpler (less smart) than `response_model_exclude_unset`
                and `response_model_exclude_defaults`. You probably want to use one of
                those two instead of this one, as those allow returning `None` values
                when it makes sense.
    
                Read more about it in the
                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).
                """
            ),
        ] = False,
        include_in_schema: Annotated[
            bool,
            Doc(
                """
                Include this *path operation* in the generated OpenAPI schema.
    
                This affects the generated OpenAPI (e.g. visible at `/docs`).
    
                Read more about it in the
                [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-parameters-from-openapi).
                """
            ),
        ] = True,
        response_class: Annotated[
            type[Response],
            Doc(
                """
                Response class to be used for this *path operation*.
    
                This will not be used if you return a response directly.
    
                Read more about it in the
                [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).
                """
            ),
        ] = Default(JSONResponse),
        name: Annotated[
            Optional[str],
            Doc(
                """
                Name for this *path operation*. Only used internally.
                """
            ),
        ] = None,
        callbacks: Annotated[
            Optional[list[BaseRoute]],
            Doc(
                """
                List of *path operations* that will be used as OpenAPI callbacks.
    
                This is only for OpenAPI documentation, the callbacks won't be used
                directly.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
    
                Read more about it in the
                [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).
                """
            ),
        ] = None,
        openapi_extra: Annotated[
            Optional[dict[str, Any]],
            Doc(
                """
                Extra metadata to be included in the OpenAPI schema for this *path
                operation*.
    
                Read more about it in the
                [FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).
                """
            ),
        ] = None,
        generate_unique_id_function: Annotated[
            Callable[[routing.APIRoute], str],
            Doc(
                """
                Customize the function used to generate unique IDs for the *path
                operations* shown in the generated OpenAPI.
    
                This is particularly useful when automatically generating clients or
                SDKs for your API.
    
                Read more about it in the
                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
                """
            ),
        ] = Default(generate_unique_id),
    ) -> Callable[[DecoratedCallable], DecoratedCallable]:
        """
        Add a *path operation* using an HTTP HEAD operation.
    
        ## Example
    
        ```python
        from fastapi import FastAPI, Response
    
        app = FastAPI()
    
        @app.head("/items/", status_code=204)
        def get_items_headers(response: Response):
            response.headers["X-Cat-Dog"] = "Alone in the world"
        ```
        """
        return self.router.head(
            path,
            response_model=response_model,
            status_code=status_code,
            tags=tags,
            dependencies=dependencies,
            summary=summary,
            description=description,
            response_description=response_description,
            responses=responses,
            deprecated=deprecated,
            operation_id=operation_id,
            response_model_include=response_model_include,
            response_model_exclude=response_model_exclude,
            response_model_by_alias=response_model_by_alias,
            response_model_exclude_unset=response_model_exclude_unset,
            response_model_exclude_defaults=response_model_exclude_defaults,
            response_model_exclude_none=response_model_exclude_none,
            include_in_schema=include_in_schema,
            response_class=response_class,
            name=name,
            callbacks=callbacks,
            openapi_extra=openapi_extra,
            generate_unique_id_function=generate_unique_id_function,
        )
      
  
---|---  
  
###  `` patch [¶](#fastapi.FastAPI.patch "Permanent link")
    
    
    patch(
        path,
        *,
        response_model=Default(None),
        status_code=None,
        tags=None,
        dependencies=None,
        summary=None,
        description=None,
        response_description="Successful Response",
        responses=None,
        deprecated=None,
        operation_id=None,
        response_model_include=None,
        response_model_exclude=None,
        response_model_by_alias=True,
        response_model_exclude_unset=False,
        response_model_exclude_defaults=False,
        response_model_exclude_none=False,
        include_in_schema=True,
        response_class=Default([JSONResponse](../responses/#fastapi.responses.JSONResponse "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">fastapi.responses.JSONResponse</span> \(<code>starlette.responses.JSONResponse</code>\)")),
        name=None,
        callbacks=None,
        openapi_extra=None,
        generate_unique_id_function=Default(generate_unique_id)
    )
    

Add a _path operation_ using an HTTP PATCH operation.

##### Example[¶](#fastapi.FastAPI.patch--example "Permanent link")
    
    
    from fastapi import FastAPI
    from pydantic import BaseModel
    
    class Item(BaseModel):
        name: str
        description: str | None = None
    
    app = FastAPI()
    
    @app.patch("/items/")
    def update_item(item: Item):
        return {"message": "Item updated in place"}
    

PARAMETER | DESCRIPTION  
---|---  
`path` |  The URL path to be used for this _path operation_. For example, in `http://example.com/items`, the path is `/items`. **TYPE:** `str`  
`response_model` |  The type to use for the response. It could be any valid Pydantic _field_ type. So, it doesn't have to be a Pydantic model, it could be other things, like a `list`, `dict`, etc. It will be used for:

  * Documentation: the generated OpenAPI (and the UI at `/docs`) will show it as the response (JSON Schema).
  * Serialization: you could return an arbitrary object and the `response_model` would be used to serialize that object into the corresponding JSON.
  * Filtering: the JSON sent to the client will only contain the data (fields) defined in the `response_model`. If you returned an object that contains an attribute `password` but the `response_model` does not include that field, the JSON sent to the client would not have that `password`.
  * Validation: whatever you return will be serialized with the `response_model`, converting any data as necessary to generate the corresponding JSON. But if the data in the object returned is not valid, that would mean a violation of the contract with the client, so it's an error from the API developer. So, FastAPI will raise an error and return a 500 error code (Internal Server Error).

Read more about it in the [FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/). **TYPE:** `Any` **DEFAULT:** `Default(None)`  
`status_code` |  The default status code to be used for the response. You could override the status code by returning a response directly. Read more about it in the [FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/). **TYPE:** `Optional[int]` **DEFAULT:** `None`  
`tags` |  A list of tags to be applied to the _path operation_. It will be added to the generated OpenAPI (e.g. visible at `/docs`). Read more about it in the [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags). **TYPE:** `Optional[list[Union[str, Enum]]]` **DEFAULT:** `None`  
`dependencies` |  A list of dependencies (using `Depends()`) to be applied to the _path operation_. Read more about it in the [FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/). **TYPE:** `Optional[Sequence[Depends]]` **DEFAULT:** `None`  
`summary` |  A summary for the _path operation_. It will be added to the generated OpenAPI (e.g. visible at `/docs`). Read more about it in the [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/). **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`description` |  A description for the _path operation_. If not provided, it will be extracted automatically from the docstring of the _path operation function_. It can contain Markdown. It will be added to the generated OpenAPI (e.g. visible at `/docs`). Read more about it in the [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/). **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`response_description` |  The description for the default response. It will be added to the generated OpenAPI (e.g. visible at `/docs`). **TYPE:** `str` **DEFAULT:** `'Successful Response'`  
`responses` |  Additional responses that could be returned by this _path operation_. It will be added to the generated OpenAPI (e.g. visible at `/docs`). **TYPE:** `Optional[dict[Union[int, str], dict[str, Any]]]` **DEFAULT:** `None`  
`deprecated` |  Mark this _path operation_ as deprecated. It will be added to the generated OpenAPI (e.g. visible at `/docs`). **TYPE:** `Optional[bool]` **DEFAULT:** `None`  
`operation_id` |  Custom operation ID to be used by this _path operation_. By default, it is generated automatically. If you provide a custom operation ID, you need to make sure it is unique for the whole API. You can customize the operation ID generation with the parameter `generate_unique_id_function` in the `FastAPI` class. Read more about it in the [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function). **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`response_model_include` |  Configuration passed to Pydantic to include only certain fields in the response data. Read more about it in the [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude). **TYPE:** `Optional[IncEx]` **DEFAULT:** `None`  
`response_model_exclude` |  Configuration passed to Pydantic to exclude certain fields in the response data. Read more about it in the [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude). **TYPE:** `Optional[IncEx]` **DEFAULT:** `None`  
`response_model_by_alias` |  Configuration passed to Pydantic to define if the response model should be serialized by alias when an alias is used. Read more about it in the [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude). **TYPE:** `bool` **DEFAULT:** `True`  
`response_model_exclude_unset` |  Configuration passed to Pydantic to define if the response data should have all the fields, including the ones that were not set and have their default values. This is different from `response_model_exclude_defaults` in that if the fields are set, they will be included in the response, even if the value is the same as the default. When `True`, default values are omitted from the response. Read more about it in the [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter). **TYPE:** `bool` **DEFAULT:** `False`  
`response_model_exclude_defaults` |  Configuration passed to Pydantic to define if the response data should have all the fields, including the ones that have the same value as the default. This is different from `response_model_exclude_unset` in that if the fields are set but contain the same default values, they will be excluded from the response. When `True`, default values are omitted from the response. Read more about it in the [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter). **TYPE:** `bool` **DEFAULT:** `False`  
`response_model_exclude_none` |  Configuration passed to Pydantic to define if the response data should exclude fields set to `None`. This is much simpler (less smart) than `response_model_exclude_unset` and `response_model_exclude_defaults`. You probably want to use one of those two instead of this one, as those allow returning `None` values when it makes sense. Read more about it in the [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none). **TYPE:** `bool` **DEFAULT:** `False`  
`include_in_schema` |  Include this _path operation_ in the generated OpenAPI schema. This affects the generated OpenAPI (e.g. visible at `/docs`). Read more about it in the [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-parameters-from-openapi). **TYPE:** `bool` **DEFAULT:** `True`  
`response_class` |  Response class to be used for this _path operation_. This will not be used if you return a response directly. Read more about it in the [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse). **TYPE:** `type[[Response](../response/#fastapi.Response "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">fastapi.Response</span> \(<code>starlette.responses.Response</code>\)")]` **DEFAULT:** `Default([JSONResponse](../responses/#fastapi.responses.JSONResponse "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">fastapi.responses.JSONResponse</span> \(<code>starlette.responses.JSONResponse</code>\)"))`  
`name` |  Name for this _path operation_. Only used internally. **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`callbacks` |  List of _path operations_ that will be used as OpenAPI callbacks. This is only for OpenAPI documentation, the callbacks won't be used directly. It will be added to the generated OpenAPI (e.g. visible at `/docs`). Read more about it in the [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/). **TYPE:** `Optional[list[BaseRoute]]` **DEFAULT:** `None`  
`openapi_extra` |  Extra metadata to be included in the OpenAPI schema for this _path operation_. Read more about it in the [FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema). **TYPE:** `Optional[dict[str, Any]]` **DEFAULT:** `None`  
`generate_unique_id_function` |  Customize the function used to generate unique IDs for the _path operations_ shown in the generated OpenAPI. This is particularly useful when automatically generating clients or SDKs for your API. Read more about it in the [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function). **TYPE:** `Callable[[APIRoute], str]` **DEFAULT:** `Default(generate_unique_id)`  
Source code in `fastapi/applications.py`
    
    
    3792
    3793
    3794
    3795
    3796
    3797
    3798
    3799
    3800
    3801
    3802
    3803
    3804
    3805
    3806
    3807
    3808
    3809
    3810
    3811
    3812
    3813
    3814
    3815
    3816
    3817
    3818
    3819
    3820
    3821
    3822
    3823
    3824
    3825
    3826
    3827
    3828
    3829
    3830
    3831
    3832
    3833
    3834
    3835
    3836
    3837
    3838
    3839
    3840
    3841
    3842
    3843
    3844
    3845
    3846
    3847
    3848
    3849
    3850
    3851
    3852
    3853
    3854
    3855
    3856
    3857
    3858
    3859
    3860
    3861
    3862
    3863
    3864
    3865
    3866
    3867
    3868
    3869
    3870
    3871
    3872
    3873
    3874
    3875
    3876
    3877
    3878
    3879
    3880
    3881
    3882
    3883
    3884
    3885
    3886
    3887
    3888
    3889
    3890
    3891
    3892
    3893
    3894
    3895
    3896
    3897
    3898
    3899
    3900
    3901
    3902
    3903
    3904
    3905
    3906
    3907
    3908
    3909
    3910
    3911
    3912
    3913
    3914
    3915
    3916
    3917
    3918
    3919
    3920
    3921
    3922
    3923
    3924
    3925
    3926
    3927
    3928
    3929
    3930
    3931
    3932
    3933
    3934
    3935
    3936
    3937
    3938
    3939
    3940
    3941
    3942
    3943
    3944
    3945
    3946
    3947
    3948
    3949
    3950
    3951
    3952
    3953
    3954
    3955
    3956
    3957
    3958
    3959
    3960
    3961
    3962
    3963
    3964
    3965
    3966
    3967
    3968
    3969
    3970
    3971
    3972
    3973
    3974
    3975
    3976
    3977
    3978
    3979
    3980
    3981
    3982
    3983
    3984
    3985
    3986
    3987
    3988
    3989
    3990
    3991
    3992
    3993
    3994
    3995
    3996
    3997
    3998
    3999
    4000
    4001
    4002
    4003
    4004
    4005
    4006
    4007
    4008
    4009
    4010
    4011
    4012
    4013
    4014
    4015
    4016
    4017
    4018
    4019
    4020
    4021
    4022
    4023
    4024
    4025
    4026
    4027
    4028
    4029
    4030
    4031
    4032
    4033
    4034
    4035
    4036
    4037
    4038
    4039
    4040
    4041
    4042
    4043
    4044
    4045
    4046
    4047
    4048
    4049
    4050
    4051
    4052
    4053
    4054
    4055
    4056
    4057
    4058
    4059
    4060
    4061
    4062
    4063
    4064
    4065
    4066
    4067
    4068
    4069
    4070
    4071
    4072
    4073
    4074
    4075
    4076
    4077
    4078
    4079
    4080
    4081
    4082
    4083
    4084
    4085
    4086
    4087
    4088
    4089
    4090
    4091
    4092
    4093
    4094
    4095
    4096
    4097
    4098
    4099
    4100
    4101
    4102
    4103
    4104
    4105
    4106
    4107
    4108
    4109
    4110
    4111
    4112
    4113
    4114
    4115
    4116
    4117
    4118
    4119
    4120
    4121
    4122
    4123
    4124
    4125
    4126
    4127
    4128
    4129
    4130
    4131
    4132
    4133
    4134
    4135
    4136
    4137
    4138
    4139
    4140
    4141
    4142
    4143
    4144
    4145
    4146
    4147
    4148
    4149
    4150
    4151
    4152
    4153
    4154
    4155
    4156
    4157
    4158
    4159
    4160
    4161
    4162
    4163
    4164
    4165
    4166
    4167
    4168

| 
    
    
    def patch(
        self,
        path: Annotated[
            str,
            Doc(
                """
                The URL path to be used for this *path operation*.
    
                For example, in `http://example.com/items`, the path is `/items`.
                """
            ),
        ],
        *,
        response_model: Annotated[
            Any,
            Doc(
                """
                The type to use for the response.
    
                It could be any valid Pydantic *field* type. So, it doesn't have to
                be a Pydantic model, it could be other things, like a `list`, `dict`,
                etc.
    
                It will be used for:
    
                * Documentation: the generated OpenAPI (and the UI at `/docs`) will
                    show it as the response (JSON Schema).
                * Serialization: you could return an arbitrary object and the
                    `response_model` would be used to serialize that object into the
                    corresponding JSON.
                * Filtering: the JSON sent to the client will only contain the data
                    (fields) defined in the `response_model`. If you returned an object
                    that contains an attribute `password` but the `response_model` does
                    not include that field, the JSON sent to the client would not have
                    that `password`.
                * Validation: whatever you return will be serialized with the
                    `response_model`, converting any data as necessary to generate the
                    corresponding JSON. But if the data in the object returned is not
                    valid, that would mean a violation of the contract with the client,
                    so it's an error from the API developer. So, FastAPI will raise an
                    error and return a 500 error code (Internal Server Error).
    
                Read more about it in the
                [FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).
                """
            ),
        ] = Default(None),
        status_code: Annotated[
            Optional[int],
            Doc(
                """
                The default status code to be used for the response.
    
                You could override the status code by returning a response directly.
    
                Read more about it in the
                [FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).
                """
            ),
        ] = None,
        tags: Annotated[
            Optional[list[Union[str, Enum]]],
            Doc(
                """
                A list of tags to be applied to the *path operation*.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
    
                Read more about it in the
                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).
                """
            ),
        ] = None,
        dependencies: Annotated[
            Optional[Sequence[Depends]],
            Doc(
                """
                A list of dependencies (using `Depends()`) to be applied to the
                *path operation*.
    
                Read more about it in the
                [FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).
                """
            ),
        ] = None,
        summary: Annotated[
            Optional[str],
            Doc(
                """
                A summary for the *path operation*.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
    
                Read more about it in the
                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
                """
            ),
        ] = None,
        description: Annotated[
            Optional[str],
            Doc(
                """
                A description for the *path operation*.
    
                If not provided, it will be extracted automatically from the docstring
                of the *path operation function*.
    
                It can contain Markdown.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
    
                Read more about it in the
                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
                """
            ),
        ] = None,
        response_description: Annotated[
            str,
            Doc(
                """
                The description for the default response.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
                """
            ),
        ] = "Successful Response",
        responses: Annotated[
            Optional[dict[Union[int, str], dict[str, Any]]],
            Doc(
                """
                Additional responses that could be returned by this *path operation*.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
                """
            ),
        ] = None,
        deprecated: Annotated[
            Optional[bool],
            Doc(
                """
                Mark this *path operation* as deprecated.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
                """
            ),
        ] = None,
        operation_id: Annotated[
            Optional[str],
            Doc(
                """
                Custom operation ID to be used by this *path operation*.
    
                By default, it is generated automatically.
    
                If you provide a custom operation ID, you need to make sure it is
                unique for the whole API.
    
                You can customize the
                operation ID generation with the parameter
                `generate_unique_id_function` in the `FastAPI` class.
    
                Read more about it in the
                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
                """
            ),
        ] = None,
        response_model_include: Annotated[
            Optional[IncEx],
            Doc(
                """
                Configuration passed to Pydantic to include only certain fields in the
                response data.
    
                Read more about it in the
                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
                """
            ),
        ] = None,
        response_model_exclude: Annotated[
            Optional[IncEx],
            Doc(
                """
                Configuration passed to Pydantic to exclude certain fields in the
                response data.
    
                Read more about it in the
                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
                """
            ),
        ] = None,
        response_model_by_alias: Annotated[
            bool,
            Doc(
                """
                Configuration passed to Pydantic to define if the response model
                should be serialized by alias when an alias is used.
    
                Read more about it in the
                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
                """
            ),
        ] = True,
        response_model_exclude_unset: Annotated[
            bool,
            Doc(
                """
                Configuration passed to Pydantic to define if the response data
                should have all the fields, including the ones that were not set and
                have their default values. This is different from
                `response_model_exclude_defaults` in that if the fields are set,
                they will be included in the response, even if the value is the same
                as the default.
    
                When `True`, default values are omitted from the response.
    
                Read more about it in the
                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).
                """
            ),
        ] = False,
        response_model_exclude_defaults: Annotated[
            bool,
            Doc(
                """
                Configuration passed to Pydantic to define if the response data
                should have all the fields, including the ones that have the same value
                as the default. This is different from `response_model_exclude_unset`
                in that if the fields are set but contain the same default values,
                they will be excluded from the response.
    
                When `True`, default values are omitted from the response.
    
                Read more about it in the
                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).
                """
            ),
        ] = False,
        response_model_exclude_none: Annotated[
            bool,
            Doc(
                """
                Configuration passed to Pydantic to define if the response data should
                exclude fields set to `None`.
    
                This is much simpler (less smart) than `response_model_exclude_unset`
                and `response_model_exclude_defaults`. You probably want to use one of
                those two instead of this one, as those allow returning `None` values
                when it makes sense.
    
                Read more about it in the
                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).
                """
            ),
        ] = False,
        include_in_schema: Annotated[
            bool,
            Doc(
                """
                Include this *path operation* in the generated OpenAPI schema.
    
                This affects the generated OpenAPI (e.g. visible at `/docs`).
    
                Read more about it in the
                [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-parameters-from-openapi).
                """
            ),
        ] = True,
        response_class: Annotated[
            type[Response],
            Doc(
                """
                Response class to be used for this *path operation*.
    
                This will not be used if you return a response directly.
    
                Read more about it in the
                [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).
                """
            ),
        ] = Default(JSONResponse),
        name: Annotated[
            Optional[str],
            Doc(
                """
                Name for this *path operation*. Only used internally.
                """
            ),
        ] = None,
        callbacks: Annotated[
            Optional[list[BaseRoute]],
            Doc(
                """
                List of *path operations* that will be used as OpenAPI callbacks.
    
                This is only for OpenAPI documentation, the callbacks won't be used
                directly.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
    
                Read more about it in the
                [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).
                """
            ),
        ] = None,
        openapi_extra: Annotated[
            Optional[dict[str, Any]],
            Doc(
                """
                Extra metadata to be included in the OpenAPI schema for this *path
                operation*.
    
                Read more about it in the
                [FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).
                """
            ),
        ] = None,
        generate_unique_id_function: Annotated[
            Callable[[routing.APIRoute], str],
            Doc(
                """
                Customize the function used to generate unique IDs for the *path
                operations* shown in the generated OpenAPI.
    
                This is particularly useful when automatically generating clients or
                SDKs for your API.
    
                Read more about it in the
                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
                """
            ),
        ] = Default(generate_unique_id),
    ) -> Callable[[DecoratedCallable], DecoratedCallable]:
        """
        Add a *path operation* using an HTTP PATCH operation.
    
        ## Example
    
        ```python
        from fastapi import FastAPI
        from pydantic import BaseModel
    
        class Item(BaseModel):
            name: str
            description: str | None = None
    
        app = FastAPI()
    
        @app.patch("/items/")
        def update_item(item: Item):
            return {"message": "Item updated in place"}
        ```
        """
        return self.router.patch(
            path,
            response_model=response_model,
            status_code=status_code,
            tags=tags,
            dependencies=dependencies,
            summary=summary,
            description=description,
            response_description=response_description,
            responses=responses,
            deprecated=deprecated,
            operation_id=operation_id,
            response_model_include=response_model_include,
            response_model_exclude=response_model_exclude,
            response_model_by_alias=response_model_by_alias,
            response_model_exclude_unset=response_model_exclude_unset,
            response_model_exclude_defaults=response_model_exclude_defaults,
            response_model_exclude_none=response_model_exclude_none,
            include_in_schema=include_in_schema,
            response_class=response_class,
            name=name,
            callbacks=callbacks,
            openapi_extra=openapi_extra,
            generate_unique_id_function=generate_unique_id_function,
        )
      
  
---|---  
  
###  `` trace [¶](#fastapi.FastAPI.trace "Permanent link")
    
    
    trace(
        path,
        *,
        response_model=Default(None),
        status_code=None,
        tags=None,
        dependencies=None,
        summary=None,
        description=None,
        response_description="Successful Response",
        responses=None,
        deprecated=None,
        operation_id=None,
        response_model_include=None,
        response_model_exclude=None,
        response_model_by_alias=True,
        response_model_exclude_unset=False,
        response_model_exclude_defaults=False,
        response_model_exclude_none=False,
        include_in_schema=True,
        response_class=Default([JSONResponse](../responses/#fastapi.responses.JSONResponse "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">fastapi.responses.JSONResponse</span> \(<code>starlette.responses.JSONResponse</code>\)")),
        name=None,
        callbacks=None,
        openapi_extra=None,
        generate_unique_id_function=Default(generate_unique_id)
    )
    

Add a _path operation_ using an HTTP TRACE operation.

##### Example[¶](#fastapi.FastAPI.trace--example "Permanent link")
    
    
    from fastapi import FastAPI
    
    app = FastAPI()
    
    @app.trace("/items/{item_id}")
    def trace_item(item_id: str):
        return None
    

PARAMETER | DESCRIPTION  
---|---  
`path` |  The URL path to be used for this _path operation_. For example, in `http://example.com/items`, the path is `/items`. **TYPE:** `str`  
`response_model` |  The type to use for the response. It could be any valid Pydantic _field_ type. So, it doesn't have to be a Pydantic model, it could be other things, like a `list`, `dict`, etc. It will be used for:

  * Documentation: the generated OpenAPI (and the UI at `/docs`) will show it as the response (JSON Schema).
  * Serialization: you could return an arbitrary object and the `response_model` would be used to serialize that object into the corresponding JSON.
  * Filtering: the JSON sent to the client will only contain the data (fields) defined in the `response_model`. If you returned an object that contains an attribute `password` but the `response_model` does not include that field, the JSON sent to the client would not have that `password`.
  * Validation: whatever you return will be serialized with the `response_model`, converting any data as necessary to generate the corresponding JSON. But if the data in the object returned is not valid, that would mean a violation of the contract with the client, so it's an error from the API developer. So, FastAPI will raise an error and return a 500 error code (Internal Server Error).

Read more about it in the [FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/). **TYPE:** `Any` **DEFAULT:** `Default(None)`  
`status_code` |  The default status code to be used for the response. You could override the status code by returning a response directly. Read more about it in the [FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/). **TYPE:** `Optional[int]` **DEFAULT:** `None`  
`tags` |  A list of tags to be applied to the _path operation_. It will be added to the generated OpenAPI (e.g. visible at `/docs`). Read more about it in the [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags). **TYPE:** `Optional[list[Union[str, Enum]]]` **DEFAULT:** `None`  
`dependencies` |  A list of dependencies (using `Depends()`) to be applied to the _path operation_. Read more about it in the [FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/). **TYPE:** `Optional[Sequence[Depends]]` **DEFAULT:** `None`  
`summary` |  A summary for the _path operation_. It will be added to the generated OpenAPI (e.g. visible at `/docs`). Read more about it in the [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/). **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`description` |  A description for the _path operation_. If not provided, it will be extracted automatically from the docstring of the _path operation function_. It can contain Markdown. It will be added to the generated OpenAPI (e.g. visible at `/docs`). Read more about it in the [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/). **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`response_description` |  The description for the default response. It will be added to the generated OpenAPI (e.g. visible at `/docs`). **TYPE:** `str` **DEFAULT:** `'Successful Response'`  
`responses` |  Additional responses that could be returned by this _path operation_. It will be added to the generated OpenAPI (e.g. visible at `/docs`). **TYPE:** `Optional[dict[Union[int, str], dict[str, Any]]]` **DEFAULT:** `None`  
`deprecated` |  Mark this _path operation_ as deprecated. It will be added to the generated OpenAPI (e.g. visible at `/docs`). **TYPE:** `Optional[bool]` **DEFAULT:** `None`  
`operation_id` |  Custom operation ID to be used by this _path operation_. By default, it is generated automatically. If you provide a custom operation ID, you need to make sure it is unique for the whole API. You can customize the operation ID generation with the parameter `generate_unique_id_function` in the `FastAPI` class. Read more about it in the [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function). **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`response_model_include` |  Configuration passed to Pydantic to include only certain fields in the response data. Read more about it in the [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude). **TYPE:** `Optional[IncEx]` **DEFAULT:** `None`  
`response_model_exclude` |  Configuration passed to Pydantic to exclude certain fields in the response data. Read more about it in the [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude). **TYPE:** `Optional[IncEx]` **DEFAULT:** `None`  
`response_model_by_alias` |  Configuration passed to Pydantic to define if the response model should be serialized by alias when an alias is used. Read more about it in the [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude). **TYPE:** `bool` **DEFAULT:** `True`  
`response_model_exclude_unset` |  Configuration passed to Pydantic to define if the response data should have all the fields, including the ones that were not set and have their default values. This is different from `response_model_exclude_defaults` in that if the fields are set, they will be included in the response, even if the value is the same as the default. When `True`, default values are omitted from the response. Read more about it in the [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter). **TYPE:** `bool` **DEFAULT:** `False`  
`response_model_exclude_defaults` |  Configuration passed to Pydantic to define if the response data should have all the fields, including the ones that have the same value as the default. This is different from `response_model_exclude_unset` in that if the fields are set but contain the same default values, they will be excluded from the response. When `True`, default values are omitted from the response. Read more about it in the [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter). **TYPE:** `bool` **DEFAULT:** `False`  
`response_model_exclude_none` |  Configuration passed to Pydantic to define if the response data should exclude fields set to `None`. This is much simpler (less smart) than `response_model_exclude_unset` and `response_model_exclude_defaults`. You probably want to use one of those two instead of this one, as those allow returning `None` values when it makes sense. Read more about it in the [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none). **TYPE:** `bool` **DEFAULT:** `False`  
`include_in_schema` |  Include this _path operation_ in the generated OpenAPI schema. This affects the generated OpenAPI (e.g. visible at `/docs`). Read more about it in the [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-parameters-from-openapi). **TYPE:** `bool` **DEFAULT:** `True`  
`response_class` |  Response class to be used for this _path operation_. This will not be used if you return a response directly. Read more about it in the [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse). **TYPE:** `type[[Response](../response/#fastapi.Response "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">fastapi.Response</span> \(<code>starlette.responses.Response</code>\)")]` **DEFAULT:** `Default([JSONResponse](../responses/#fastapi.responses.JSONResponse "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">fastapi.responses.JSONResponse</span> \(<code>starlette.responses.JSONResponse</code>\)"))`  
`name` |  Name for this _path operation_. Only used internally. **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`callbacks` |  List of _path operations_ that will be used as OpenAPI callbacks. This is only for OpenAPI documentation, the callbacks won't be used directly. It will be added to the generated OpenAPI (e.g. visible at `/docs`). Read more about it in the [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/). **TYPE:** `Optional[list[BaseRoute]]` **DEFAULT:** `None`  
`openapi_extra` |  Extra metadata to be included in the OpenAPI schema for this _path operation_. Read more about it in the [FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema). **TYPE:** `Optional[dict[str, Any]]` **DEFAULT:** `None`  
`generate_unique_id_function` |  Customize the function used to generate unique IDs for the _path operations_ shown in the generated OpenAPI. This is particularly useful when automatically generating clients or SDKs for your API. Read more about it in the [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function). **TYPE:** `Callable[[APIRoute], str]` **DEFAULT:** `Default(generate_unique_id)`  
Source code in `fastapi/applications.py`
    
    
    4170
    4171
    4172
    4173
    4174
    4175
    4176
    4177
    4178
    4179
    4180
    4181
    4182
    4183
    4184
    4185
    4186
    4187
    4188
    4189
    4190
    4191
    4192
    4193
    4194
    4195
    4196
    4197
    4198
    4199
    4200
    4201
    4202
    4203
    4204
    4205
    4206
    4207
    4208
    4209
    4210
    4211
    4212
    4213
    4214
    4215
    4216
    4217
    4218
    4219
    4220
    4221
    4222
    4223
    4224
    4225
    4226
    4227
    4228
    4229
    4230
    4231
    4232
    4233
    4234
    4235
    4236
    4237
    4238
    4239
    4240
    4241
    4242
    4243
    4244
    4245
    4246
    4247
    4248
    4249
    4250
    4251
    4252
    4253
    4254
    4255
    4256
    4257
    4258
    4259
    4260
    4261
    4262
    4263
    4264
    4265
    4266
    4267
    4268
    4269
    4270
    4271
    4272
    4273
    4274
    4275
    4276
    4277
    4278
    4279
    4280
    4281
    4282
    4283
    4284
    4285
    4286
    4287
    4288
    4289
    4290
    4291
    4292
    4293
    4294
    4295
    4296
    4297
    4298
    4299
    4300
    4301
    4302
    4303
    4304
    4305
    4306
    4307
    4308
    4309
    4310
    4311
    4312
    4313
    4314
    4315
    4316
    4317
    4318
    4319
    4320
    4321
    4322
    4323
    4324
    4325
    4326
    4327
    4328
    4329
    4330
    4331
    4332
    4333
    4334
    4335
    4336
    4337
    4338
    4339
    4340
    4341
    4342
    4343
    4344
    4345
    4346
    4347
    4348
    4349
    4350
    4351
    4352
    4353
    4354
    4355
    4356
    4357
    4358
    4359
    4360
    4361
    4362
    4363
    4364
    4365
    4366
    4367
    4368
    4369
    4370
    4371
    4372
    4373
    4374
    4375
    4376
    4377
    4378
    4379
    4380
    4381
    4382
    4383
    4384
    4385
    4386
    4387
    4388
    4389
    4390
    4391
    4392
    4393
    4394
    4395
    4396
    4397
    4398
    4399
    4400
    4401
    4402
    4403
    4404
    4405
    4406
    4407
    4408
    4409
    4410
    4411
    4412
    4413
    4414
    4415
    4416
    4417
    4418
    4419
    4420
    4421
    4422
    4423
    4424
    4425
    4426
    4427
    4428
    4429
    4430
    4431
    4432
    4433
    4434
    4435
    4436
    4437
    4438
    4439
    4440
    4441
    4442
    4443
    4444
    4445
    4446
    4447
    4448
    4449
    4450
    4451
    4452
    4453
    4454
    4455
    4456
    4457
    4458
    4459
    4460
    4461
    4462
    4463
    4464
    4465
    4466
    4467
    4468
    4469
    4470
    4471
    4472
    4473
    4474
    4475
    4476
    4477
    4478
    4479
    4480
    4481
    4482
    4483
    4484
    4485
    4486
    4487
    4488
    4489
    4490
    4491
    4492
    4493
    4494
    4495
    4496
    4497
    4498
    4499
    4500
    4501
    4502
    4503
    4504
    4505
    4506
    4507
    4508
    4509
    4510
    4511
    4512
    4513
    4514
    4515
    4516
    4517
    4518
    4519
    4520
    4521
    4522
    4523
    4524
    4525
    4526
    4527
    4528
    4529
    4530
    4531
    4532
    4533
    4534
    4535
    4536
    4537
    4538
    4539
    4540
    4541

| 
    
    
    def trace(
        self,
        path: Annotated[
            str,
            Doc(
                """
                The URL path to be used for this *path operation*.
    
                For example, in `http://example.com/items`, the path is `/items`.
                """
            ),
        ],
        *,
        response_model: Annotated[
            Any,
            Doc(
                """
                The type to use for the response.
    
                It could be any valid Pydantic *field* type. So, it doesn't have to
                be a Pydantic model, it could be other things, like a `list`, `dict`,
                etc.
    
                It will be used for:
    
                * Documentation: the generated OpenAPI (and the UI at `/docs`) will
                    show it as the response (JSON Schema).
                * Serialization: you could return an arbitrary object and the
                    `response_model` would be used to serialize that object into the
                    corresponding JSON.
                * Filtering: the JSON sent to the client will only contain the data
                    (fields) defined in the `response_model`. If you returned an object
                    that contains an attribute `password` but the `response_model` does
                    not include that field, the JSON sent to the client would not have
                    that `password`.
                * Validation: whatever you return will be serialized with the
                    `response_model`, converting any data as necessary to generate the
                    corresponding JSON. But if the data in the object returned is not
                    valid, that would mean a violation of the contract with the client,
                    so it's an error from the API developer. So, FastAPI will raise an
                    error and return a 500 error code (Internal Server Error).
    
                Read more about it in the
                [FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).
                """
            ),
        ] = Default(None),
        status_code: Annotated[
            Optional[int],
            Doc(
                """
                The default status code to be used for the response.
    
                You could override the status code by returning a response directly.
    
                Read more about it in the
                [FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).
                """
            ),
        ] = None,
        tags: Annotated[
            Optional[list[Union[str, Enum]]],
            Doc(
                """
                A list of tags to be applied to the *path operation*.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
    
                Read more about it in the
                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).
                """
            ),
        ] = None,
        dependencies: Annotated[
            Optional[Sequence[Depends]],
            Doc(
                """
                A list of dependencies (using `Depends()`) to be applied to the
                *path operation*.
    
                Read more about it in the
                [FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).
                """
            ),
        ] = None,
        summary: Annotated[
            Optional[str],
            Doc(
                """
                A summary for the *path operation*.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
    
                Read more about it in the
                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
                """
            ),
        ] = None,
        description: Annotated[
            Optional[str],
            Doc(
                """
                A description for the *path operation*.
    
                If not provided, it will be extracted automatically from the docstring
                of the *path operation function*.
    
                It can contain Markdown.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
    
                Read more about it in the
                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
                """
            ),
        ] = None,
        response_description: Annotated[
            str,
            Doc(
                """
                The description for the default response.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
                """
            ),
        ] = "Successful Response",
        responses: Annotated[
            Optional[dict[Union[int, str], dict[str, Any]]],
            Doc(
                """
                Additional responses that could be returned by this *path operation*.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
                """
            ),
        ] = None,
        deprecated: Annotated[
            Optional[bool],
            Doc(
                """
                Mark this *path operation* as deprecated.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
                """
            ),
        ] = None,
        operation_id: Annotated[
            Optional[str],
            Doc(
                """
                Custom operation ID to be used by this *path operation*.
    
                By default, it is generated automatically.
    
                If you provide a custom operation ID, you need to make sure it is
                unique for the whole API.
    
                You can customize the
                operation ID generation with the parameter
                `generate_unique_id_function` in the `FastAPI` class.
    
                Read more about it in the
                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
                """
            ),
        ] = None,
        response_model_include: Annotated[
            Optional[IncEx],
            Doc(
                """
                Configuration passed to Pydantic to include only certain fields in the
                response data.
    
                Read more about it in the
                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
                """
            ),
        ] = None,
        response_model_exclude: Annotated[
            Optional[IncEx],
            Doc(
                """
                Configuration passed to Pydantic to exclude certain fields in the
                response data.
    
                Read more about it in the
                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
                """
            ),
        ] = None,
        response_model_by_alias: Annotated[
            bool,
            Doc(
                """
                Configuration passed to Pydantic to define if the response model
                should be serialized by alias when an alias is used.
    
                Read more about it in the
                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
                """
            ),
        ] = True,
        response_model_exclude_unset: Annotated[
            bool,
            Doc(
                """
                Configuration passed to Pydantic to define if the response data
                should have all the fields, including the ones that were not set and
                have their default values. This is different from
                `response_model_exclude_defaults` in that if the fields are set,
                they will be included in the response, even if the value is the same
                as the default.
    
                When `True`, default values are omitted from the response.
    
                Read more about it in the
                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).
                """
            ),
        ] = False,
        response_model_exclude_defaults: Annotated[
            bool,
            Doc(
                """
                Configuration passed to Pydantic to define if the response data
                should have all the fields, including the ones that have the same value
                as the default. This is different from `response_model_exclude_unset`
                in that if the fields are set but contain the same default values,
                they will be excluded from the response.
    
                When `True`, default values are omitted from the response.
    
                Read more about it in the
                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).
                """
            ),
        ] = False,
        response_model_exclude_none: Annotated[
            bool,
            Doc(
                """
                Configuration passed to Pydantic to define if the response data should
                exclude fields set to `None`.
    
                This is much simpler (less smart) than `response_model_exclude_unset`
                and `response_model_exclude_defaults`. You probably want to use one of
                those two instead of this one, as those allow returning `None` values
                when it makes sense.
    
                Read more about it in the
                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).
                """
            ),
        ] = False,
        include_in_schema: Annotated[
            bool,
            Doc(
                """
                Include this *path operation* in the generated OpenAPI schema.
    
                This affects the generated OpenAPI (e.g. visible at `/docs`).
    
                Read more about it in the
                [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-parameters-from-openapi).
                """
            ),
        ] = True,
        response_class: Annotated[
            type[Response],
            Doc(
                """
                Response class to be used for this *path operation*.
    
                This will not be used if you return a response directly.
    
                Read more about it in the
                [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).
                """
            ),
        ] = Default(JSONResponse),
        name: Annotated[
            Optional[str],
            Doc(
                """
                Name for this *path operation*. Only used internally.
                """
            ),
        ] = None,
        callbacks: Annotated[
            Optional[list[BaseRoute]],
            Doc(
                """
                List of *path operations* that will be used as OpenAPI callbacks.
    
                This is only for OpenAPI documentation, the callbacks won't be used
                directly.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
    
                Read more about it in the
                [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).
                """
            ),
        ] = None,
        openapi_extra: Annotated[
            Optional[dict[str, Any]],
            Doc(
                """
                Extra metadata to be included in the OpenAPI schema for this *path
                operation*.
    
                Read more about it in the
                [FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).
                """
            ),
        ] = None,
        generate_unique_id_function: Annotated[
            Callable[[routing.APIRoute], str],
            Doc(
                """
                Customize the function used to generate unique IDs for the *path
                operations* shown in the generated OpenAPI.
    
                This is particularly useful when automatically generating clients or
                SDKs for your API.
    
                Read more about it in the
                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
                """
            ),
        ] = Default(generate_unique_id),
    ) -> Callable[[DecoratedCallable], DecoratedCallable]:
        """
        Add a *path operation* using an HTTP TRACE operation.
    
        ## Example
    
        ```python
        from fastapi import FastAPI
    
        app = FastAPI()
    
        @app.trace("/items/{item_id}")
        def trace_item(item_id: str):
            return None
        ```
        """
        return self.router.trace(
            path,
            response_model=response_model,
            status_code=status_code,
            tags=tags,
            dependencies=dependencies,
            summary=summary,
            description=description,
            response_description=response_description,
            responses=responses,
            deprecated=deprecated,
            operation_id=operation_id,
            response_model_include=response_model_include,
            response_model_exclude=response_model_exclude,
            response_model_by_alias=response_model_by_alias,
            response_model_exclude_unset=response_model_exclude_unset,
            response_model_exclude_defaults=response_model_exclude_defaults,
            response_model_exclude_none=response_model_exclude_none,
            include_in_schema=include_in_schema,
            response_class=response_class,
            name=name,
            callbacks=callbacks,
            openapi_extra=openapi_extra,
            generate_unique_id_function=generate_unique_id_function,
        )
      
  
---|---  
  
###  `` on_event [¶](#fastapi.FastAPI.on_event "Permanent link")
    
    
    on_event(event_type)
    

Add an event handler for the application.

`on_event` is deprecated, use `lifespan` event handlers instead.

Read more about it in the [FastAPI docs for Lifespan Events](https://fastapi.tiangolo.com/advanced/events/#alternative-events-deprecated).

PARAMETER | DESCRIPTION  
---|---  
`event_type` |  The type of event. `startup` or `shutdown`. **TYPE:** `str`  
Source code in `fastapi/applications.py`
    
    
    4552
    4553
    4554
    4555
    4556
    4557
    4558
    4559
    4560
    4561
    4562
    4563
    4564
    4565
    4566
    4567
    4568
    4569
    4570
    4571
    4572
    4573
    4574
    4575
    4576
    4577
    4578
    4579

| 
    
    
    @deprecated(
        """
        on_event is deprecated, use lifespan event handlers instead.
    
        Read more about it in the
        [FastAPI docs for Lifespan Events](https://fastapi.tiangolo.com/advanced/events/).
        """
    )
    def on_event(
        self,
        event_type: Annotated[
            str,
            Doc(
                """
                The type of event. `startup` or `shutdown`.
                """
            ),
        ],
    ) -> Callable[[DecoratedCallable], DecoratedCallable]:
        """
        Add an event handler for the application.
    
        `on_event` is deprecated, use `lifespan` event handlers instead.
    
        Read more about it in the
        [FastAPI docs for Lifespan Events](https://fastapi.tiangolo.com/advanced/events/#alternative-events-deprecated).
        """
        return self.router.on_event(event_type)
      
  
---|---  
  
###  `` middleware [¶](#fastapi.FastAPI.middleware "Permanent link")
    
    
    middleware(middleware_type)
    

Add a middleware to the application.

Read more about it in the [FastAPI docs for Middleware](https://fastapi.tiangolo.com/tutorial/middleware/).

##### Example[¶](#fastapi.FastAPI.middleware--example "Permanent link")
    
    
    import time
    from typing import Awaitable, Callable
    
    from fastapi import FastAPI, Request, Response
    
    app = FastAPI()
    
    
    @app.middleware("http")
    async def add_process_time_header(
        request: Request, call_next: Callable[[Request], Awaitable[Response]]
    ) -> Response:
        start_time = time.time()
        response = await call_next(request)
        process_time = time.time() - start_time
        response.headers["X-Process-Time"] = str(process_time)
        return response
    

PARAMETER | DESCRIPTION  
---|---  
`middleware_type` |  The type of middleware. Currently only supports `http`. **TYPE:** `str`  
Source code in `fastapi/applications.py`
    
    
    4581
    4582
    4583
    4584
    4585
    4586
    4587
    4588
    4589
    4590
    4591
    4592
    4593
    4594
    4595
    4596
    4597
    4598
    4599
    4600
    4601
    4602
    4603
    4604
    4605
    4606
    4607
    4608
    4609
    4610
    4611
    4612
    4613
    4614
    4615
    4616
    4617
    4618
    4619
    4620
    4621
    4622
    4623
    4624
    4625

| 
    
    
    def middleware(
        self,
        middleware_type: Annotated[
            str,
            Doc(
                """
                The type of middleware. Currently only supports `http`.
                """
            ),
        ],
    ) -> Callable[[DecoratedCallable], DecoratedCallable]:
        """
        Add a middleware to the application.
    
        Read more about it in the
        [FastAPI docs for Middleware](https://fastapi.tiangolo.com/tutorial/middleware/).
    
        ## Example
    
        ```python
        import time
        from typing import Awaitable, Callable
    
        from fastapi import FastAPI, Request, Response
    
        app = FastAPI()
    
    
        @app.middleware("http")
        async def add_process_time_header(
            request: Request, call_next: Callable[[Request], Awaitable[Response]]
        ) -> Response:
            start_time = time.time()
            response = await call_next(request)
            process_time = time.time() - start_time
            response.headers["X-Process-Time"] = str(process_time)
            return response
        ```
        """
    
        def decorator(func: DecoratedCallable) -> DecoratedCallable:
            self.add_middleware(BaseHTTPMiddleware, dispatch=func)
            return func
    
        return decorator
      
  
---|---  
  
###  `` exception_handler [¶](#fastapi.FastAPI.exception_handler "Permanent link")
    
    
    exception_handler(exc_class_or_status_code)
    

Add an exception handler to the app.

Read more about it in the [FastAPI docs for Handling Errors](https://fastapi.tiangolo.com/tutorial/handling-errors/).

##### Example[¶](#fastapi.FastAPI.exception_handler--example "Permanent link")
    
    
    from fastapi import FastAPI, Request
    from fastapi.responses import JSONResponse
    
    
    class UnicornException(Exception):
        def __init__(self, name: str):
            self.name = name
    
    
    app = FastAPI()
    
    
    @app.exception_handler(UnicornException)
    async def unicorn_exception_handler(request: Request, exc: UnicornException):
        return JSONResponse(
            status_code=418,
            content={"message": f"Oops! {exc.name} did something. There goes a rainbow..."},
        )
    

PARAMETER | DESCRIPTION  
---|---  
`exc_class_or_status_code` |  The Exception class this would handle, or a status code. **TYPE:** `Union[int, type[Exception]]`  
Source code in `fastapi/applications.py`
    
    
    4627
    4628
    4629
    4630
    4631
    4632
    4633
    4634
    4635
    4636
    4637
    4638
    4639
    4640
    4641
    4642
    4643
    4644
    4645
    4646
    4647
    4648
    4649
    4650
    4651
    4652
    4653
    4654
    4655
    4656
    4657
    4658
    4659
    4660
    4661
    4662
    4663
    4664
    4665
    4666
    4667
    4668
    4669
    4670
    4671
    4672

| 
    
    
    def exception_handler(
        self,
        exc_class_or_status_code: Annotated[
            Union[int, type[Exception]],
            Doc(
                """
                The Exception class this would handle, or a status code.
                """
            ),
        ],
    ) -> Callable[[DecoratedCallable], DecoratedCallable]:
        """
        Add an exception handler to the app.
    
        Read more about it in the
        [FastAPI docs for Handling Errors](https://fastapi.tiangolo.com/tutorial/handling-errors/).
    
        ## Example
    
        ```python
        from fastapi import FastAPI, Request
        from fastapi.responses import JSONResponse
    
    
        class UnicornException(Exception):
            def __init__(self, name: str):
                self.name = name
    
    
        app = FastAPI()
    
    
        @app.exception_handler(UnicornException)
        async def unicorn_exception_handler(request: Request, exc: UnicornException):
            return JSONResponse(
                status_code=418,
                content={"message": f"Oops! {exc.name} did something. There goes a rainbow..."},
            )
        ```
        """
    
        def decorator(func: DecoratedCallable) -> DecoratedCallable:
            self.add_exception_handler(exc_class_or_status_code, func)
            return func
    
        return decorator
      
  
---|---

---

###### Request Parameters¶

# Request Parameters[¶](#request-parameters "Permanent link")

Here's the reference information for the request parameters.

These are the special functions that you can put in _path operation function_ parameters or dependency functions with `Annotated` to get data from the request.

It includes:

  * `Query()`
  * `Path()`
  * `Body()`
  * `Cookie()`
  * `Header()`
  * `Form()`
  * `File()`

You can import them all directly from `fastapi`:
    
    
    from fastapi import Body, Cookie, File, Form, Header, Path, Query
    

##  `` fastapi.Query [¶](#fastapi.Query "Permanent link")
    
    
    Query(
        default=Undefined,
        *,
        default_factory=_Unset,
        alias=None,
        alias_priority=_Unset,
        validation_alias=None,
        serialization_alias=None,
        title=None,
        description=None,
        gt=None,
        ge=None,
        lt=None,
        le=None,
        min_length=None,
        max_length=None,
        pattern=None,
        regex=None,
        discriminator=None,
        strict=_Unset,
        multiple_of=_Unset,
        allow_inf_nan=_Unset,
        max_digits=_Unset,
        decimal_places=_Unset,
        examples=None,
        example=_Unset,
        openapi_examples=None,
        deprecated=None,
        include_in_schema=True,
        json_schema_extra=None,
        **extra
    )
    

PARAMETER | DESCRIPTION  
---|---  
`default` |  Default value if the parameter field is not set. Read more about it in the [FastAPI docs about Query parameters](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#alternative-old-query-as-the-default-value) **TYPE:** `Any` **DEFAULT:** `Undefined`  
`default_factory` |  A callable to generate the default value. This doesn't affect `Path` parameters as the value is always required. The parameter is available only for compatibility. **TYPE:** `Union[Callable[[], Any], None]` **DEFAULT:** `_Unset`  
`alias` |  An alternative name for the parameter field. This will be used to extract the data and for the generated OpenAPI. It is particularly useful when you can't use the name you want because it is a Python reserved keyword or similar. Read more about it in the [FastAPI docs about Query parameters](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#alias-parameters) **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`alias_priority` |  Priority of the alias. This affects whether an alias generator is used. **TYPE:** `Union[int, None]` **DEFAULT:** `_Unset`  
`validation_alias` |  'Whitelist' validation step. The parameter field will be the single one allowed by the alias or set of aliases defined. **TYPE:** `Union[str, AliasPath, AliasChoices, None]` **DEFAULT:** `None`  
`serialization_alias` |  'Blacklist' validation step. The vanilla parameter field will be the single one of the alias' or set of aliases' fields and all the other fields will be ignored at serialization time. **TYPE:** `Union[str, None]` **DEFAULT:** `None`  
`title` |  Human-readable title. Read more about it in the [FastAPI docs about Query parameters](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#declare-more-metadata) **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`description` |  Human-readable description. Read more about it in the [FastAPI docs about Query parameters](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#declare-more-metadata) **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`gt` |  Greater than. If set, value must be greater than this. Only applicable to numbers. Read more about it in the [FastAPI docs about Path parameters numeric validations](https://fastapi.tiangolo.com/tutorial/path-params-numeric-validations/#number-validations-greater-than-and-less-than-or-equal) **TYPE:** `Optional[float]` **DEFAULT:** `None`  
`ge` |  Greater than or equal. If set, value must be greater than or equal to this. Only applicable to numbers. Read more about it in the [FastAPI docs about Path parameters numeric validations](https://fastapi.tiangolo.com/tutorial/path-params-numeric-validations/#number-validations-greater-than-and-less-than-or-equal) **TYPE:** `Optional[float]` **DEFAULT:** `None`  
`lt` |  Less than. If set, value must be less than this. Only applicable to numbers. Read more about it in the [FastAPI docs about Path parameters numeric validations](https://fastapi.tiangolo.com/tutorial/path-params-numeric-validations/#number-validations-greater-than-and-less-than-or-equal) **TYPE:** `Optional[float]` **DEFAULT:** `None`  
`le` |  Less than or equal. If set, value must be less than or equal to this. Only applicable to numbers. Read more about it in the [FastAPI docs about Path parameters numeric validations](https://fastapi.tiangolo.com/tutorial/path-params-numeric-validations/#number-validations-greater-than-and-less-than-or-equal) **TYPE:** `Optional[float]` **DEFAULT:** `None`  
`min_length` |  Minimum length for strings. Read more about it in the [FastAPI docs about Query parameters](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/) **TYPE:** `Optional[int]` **DEFAULT:** `None`  
`max_length` |  Maximum length for strings. Read more about it in the [FastAPI docs about Query parameters](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/) **TYPE:** `Optional[int]` **DEFAULT:** `None`  
`pattern` |  RegEx pattern for strings. Read more about it in the [FastAPI docs about Query parameters](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#add-regular-expressions **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`regex` |  Deprecated in FastAPI 0.100.0 and Pydantic v2, use `pattern` instead. RegEx pattern for strings. **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`discriminator` |  Parameter field name for discriminating the type in a tagged union. **TYPE:** `Union[str, None]` **DEFAULT:** `None`  
`strict` |  If `True`, strict validation is applied to the field. **TYPE:** `Union[bool, None]` **DEFAULT:** `_Unset`  
`multiple_of` |  Value must be a multiple of this. Only applicable to numbers. **TYPE:** `Union[float, None]` **DEFAULT:** `_Unset`  
`allow_inf_nan` |  Allow `inf`, `-inf`, `nan`. Only applicable to numbers. **TYPE:** `Union[bool, None]` **DEFAULT:** `_Unset`  
`max_digits` |  Maximum number of allow digits for strings. **TYPE:** `Union[int, None]` **DEFAULT:** `_Unset`  
`decimal_places` |  Maximum number of decimal places allowed for numbers. **TYPE:** `Union[int, None]` **DEFAULT:** `_Unset`  
`examples` |  Example values for this field. Read more about it in the [FastAPI docs for Declare Request Example Data](https://fastapi.tiangolo.com/tutorial/schema-extra-example/) **TYPE:** `Optional[list[Any]]` **DEFAULT:** `None`  
`example` |  Deprecated in OpenAPI 3.1.0 that now uses JSON Schema 2020-12, although still supported. Use examples instead.  **TYPE:** `Optional[Any]` **DEFAULT:** `_Unset`  
`openapi_examples` |  OpenAPI-specific examples. It will be added to the generated OpenAPI (e.g. visible at `/docs`). Swagger UI (that provides the `/docs` interface) has better support for the OpenAPI-specific examples than the JSON Schema `examples`, that's the main use case for this. Read more about it in the [FastAPI docs for Declare Request Example Data](https://fastapi.tiangolo.com/tutorial/schema-extra-example/#using-the-openapi_examples-parameter). **TYPE:** `Optional[dict[str, [Example](../openapi/models/#fastapi.openapi.models.Example "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">Example</span> \(<code>fastapi.openapi.models.Example</code>\)")]]` **DEFAULT:** `None`  
`deprecated` |  Mark this parameter field as deprecated. It will affect the generated OpenAPI (e.g. visible at `/docs`). Read more about it in the [FastAPI docs about Query parameters](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#deprecating-parameters) **TYPE:** `Union[deprecated, str, bool, None]` **DEFAULT:** `None`  
`include_in_schema` |  To include (or not) this parameter field in the generated OpenAPI. You probably don't need it, but it's available. This affects the generated OpenAPI (e.g. visible at `/docs`). Read more about it in the [FastAPI docs about Query parameters](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-parameters-from-openapi **TYPE:** `bool` **DEFAULT:** `True`  
`json_schema_extra` |  Any additional JSON schema data. **TYPE:** `Union[dict[str, Any], None]` **DEFAULT:** `None`  
`**extra` |  The `extra` kwargs is deprecated. Use `json_schema_extra` instead. Include extra fields used by the JSON Schema. **TYPE:** `Any` **DEFAULT:** `{}`  
Source code in `fastapi/param_functions.py`
    
    
    358
    359
    360
    361
    362
    363
    364
    365
    366
    367
    368
    369
    370
    371
    372
    373
    374
    375
    376
    377
    378
    379
    380
    381
    382
    383
    384
    385
    386
    387
    388
    389
    390
    391
    392
    393
    394
    395
    396
    397
    398
    399
    400
    401
    402
    403
    404
    405
    406
    407
    408
    409
    410
    411
    412
    413
    414
    415
    416
    417
    418
    419
    420
    421
    422
    423
    424
    425
    426
    427
    428
    429
    430
    431
    432
    433
    434
    435
    436
    437
    438
    439
    440
    441
    442
    443
    444
    445
    446
    447
    448
    449
    450
    451
    452
    453
    454
    455
    456
    457
    458
    459
    460
    461
    462
    463
    464
    465
    466
    467
    468
    469
    470
    471
    472
    473
    474
    475
    476
    477
    478
    479
    480
    481
    482
    483
    484
    485
    486
    487
    488
    489
    490
    491
    492
    493
    494
    495
    496
    497
    498
    499
    500
    501
    502
    503
    504
    505
    506
    507
    508
    509
    510
    511
    512
    513
    514
    515
    516
    517
    518
    519
    520
    521
    522
    523
    524
    525
    526
    527
    528
    529
    530
    531
    532
    533
    534
    535
    536
    537
    538
    539
    540
    541
    542
    543
    544
    545
    546
    547
    548
    549
    550
    551
    552
    553
    554
    555
    556
    557
    558
    559
    560
    561
    562
    563
    564
    565
    566
    567
    568
    569
    570
    571
    572
    573
    574
    575
    576
    577
    578
    579
    580
    581
    582
    583
    584
    585
    586
    587
    588
    589
    590
    591
    592
    593
    594
    595
    596
    597
    598
    599
    600
    601
    602
    603
    604
    605
    606
    607
    608
    609
    610
    611
    612
    613
    614
    615
    616
    617
    618
    619
    620
    621
    622
    623
    624
    625
    626
    627
    628
    629
    630
    631
    632
    633
    634
    635
    636
    637
    638
    639
    640
    641
    642
    643
    644
    645
    646
    647
    648
    649
    650
    651
    652
    653
    654
    655
    656
    657
    658
    659
    660
    661
    662
    663
    664
    665
    666
    667
    668
    669
    670
    671
    672
    673
    674
    675
    676
    677
    678
    679
    680
    681
    682
    683
    684
    685
    686
    687
    688
    689
    690
    691
    692
    693
    694
    695
    696
    697
    698
    699

| 
    
    
    def Query(  # noqa: N802
        default: Annotated[
            Any,
            Doc(
                """
                Default value if the parameter field is not set.
    
                Read more about it in the
                [FastAPI docs about Query parameters](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#alternative-old-query-as-the-default-value)
                """
            ),
        ] = Undefined,
        *,
        default_factory: Annotated[
            Union[Callable[[], Any], None],
            Doc(
                """
                A callable to generate the default value.
    
                This doesn't affect `Path` parameters as the value is always required.
                The parameter is available only for compatibility.
                """
            ),
        ] = _Unset,
        alias: Annotated[
            Optional[str],
            Doc(
                """
                An alternative name for the parameter field.
    
                This will be used to extract the data and for the generated OpenAPI.
                It is particularly useful when you can't use the name you want because it
                is a Python reserved keyword or similar.
    
                Read more about it in the
                [FastAPI docs about Query parameters](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#alias-parameters)
                """
            ),
        ] = None,
        alias_priority: Annotated[
            Union[int, None],
            Doc(
                """
                Priority of the alias. This affects whether an alias generator is used.
                """
            ),
        ] = _Unset,
        validation_alias: Annotated[
            Union[str, AliasPath, AliasChoices, None],
            Doc(
                """
                'Whitelist' validation step. The parameter field will be the single one
                allowed by the alias or set of aliases defined.
                """
            ),
        ] = None,
        serialization_alias: Annotated[
            Union[str, None],
            Doc(
                """
                'Blacklist' validation step. The vanilla parameter field will be the
                single one of the alias' or set of aliases' fields and all the other
                fields will be ignored at serialization time.
                """
            ),
        ] = None,
        title: Annotated[
            Optional[str],
            Doc(
                """
                Human-readable title.
    
                Read more about it in the
                [FastAPI docs about Query parameters](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#declare-more-metadata)
                """
            ),
        ] = None,
        description: Annotated[
            Optional[str],
            Doc(
                """
                Human-readable description.
    
                Read more about it in the
                [FastAPI docs about Query parameters](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#declare-more-metadata)
                """
            ),
        ] = None,
        gt: Annotated[
            Optional[float],
            Doc(
                """
                Greater than. If set, value must be greater than this. Only applicable to
                numbers.
    
                Read more about it in the
                [FastAPI docs about Path parameters numeric validations](https://fastapi.tiangolo.com/tutorial/path-params-numeric-validations/#number-validations-greater-than-and-less-than-or-equal)
                """
            ),
        ] = None,
        ge: Annotated[
            Optional[float],
            Doc(
                """
                Greater than or equal. If set, value must be greater than or equal to
                this. Only applicable to numbers.
    
                Read more about it in the
                [FastAPI docs about Path parameters numeric validations](https://fastapi.tiangolo.com/tutorial/path-params-numeric-validations/#number-validations-greater-than-and-less-than-or-equal)
                """
            ),
        ] = None,
        lt: Annotated[
            Optional[float],
            Doc(
                """
                Less than. If set, value must be less than this. Only applicable to numbers.
    
                Read more about it in the
                [FastAPI docs about Path parameters numeric validations](https://fastapi.tiangolo.com/tutorial/path-params-numeric-validations/#number-validations-greater-than-and-less-than-or-equal)
                """
            ),
        ] = None,
        le: Annotated[
            Optional[float],
            Doc(
                """
                Less than or equal. If set, value must be less than or equal to this.
                Only applicable to numbers.
    
                Read more about it in the
                [FastAPI docs about Path parameters numeric validations](https://fastapi.tiangolo.com/tutorial/path-params-numeric-validations/#number-validations-greater-than-and-less-than-or-equal)
                """
            ),
        ] = None,
        min_length: Annotated[
            Optional[int],
            Doc(
                """
                Minimum length for strings.
    
                Read more about it in the
                [FastAPI docs about Query parameters](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/)
                """
            ),
        ] = None,
        max_length: Annotated[
            Optional[int],
            Doc(
                """
                Maximum length for strings.
    
                Read more about it in the
                [FastAPI docs about Query parameters](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/)
                """
            ),
        ] = None,
        pattern: Annotated[
            Optional[str],
            Doc(
                """
                RegEx pattern for strings.
    
                Read more about it in the
                [FastAPI docs about Query parameters](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#add-regular-expressions
                """
            ),
        ] = None,
        regex: Annotated[
            Optional[str],
            Doc(
                """
                RegEx pattern for strings.
                """
            ),
            deprecated(
                "Deprecated in FastAPI 0.100.0 and Pydantic v2, use `pattern` instead."
            ),
        ] = None,
        discriminator: Annotated[
            Union[str, None],
            Doc(
                """
                Parameter field name for discriminating the type in a tagged union.
                """
            ),
        ] = None,
        strict: Annotated[
            Union[bool, None],
            Doc(
                """
                If `True`, strict validation is applied to the field.
                """
            ),
        ] = _Unset,
        multiple_of: Annotated[
            Union[float, None],
            Doc(
                """
                Value must be a multiple of this. Only applicable to numbers.
                """
            ),
        ] = _Unset,
        allow_inf_nan: Annotated[
            Union[bool, None],
            Doc(
                """
                Allow `inf`, `-inf`, `nan`. Only applicable to numbers.
                """
            ),
        ] = _Unset,
        max_digits: Annotated[
            Union[int, None],
            Doc(
                """
                Maximum number of allow digits for strings.
                """
            ),
        ] = _Unset,
        decimal_places: Annotated[
            Union[int, None],
            Doc(
                """
                Maximum number of decimal places allowed for numbers.
                """
            ),
        ] = _Unset,
        examples: Annotated[
            Optional[list[Any]],
            Doc(
                """
                Example values for this field.
    
                Read more about it in the
                [FastAPI docs for Declare Request Example Data](https://fastapi.tiangolo.com/tutorial/schema-extra-example/)
                """
            ),
        ] = None,
        example: Annotated[
            Optional[Any],
            deprecated(
                "Deprecated in OpenAPI 3.1.0 that now uses JSON Schema 2020-12, "
                "although still supported. Use examples instead."
            ),
        ] = _Unset,
        openapi_examples: Annotated[
            Optional[dict[str, Example]],
            Doc(
                """
                OpenAPI-specific examples.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
    
                Swagger UI (that provides the `/docs` interface) has better support for the
                OpenAPI-specific examples than the JSON Schema `examples`, that's the main
                use case for this.
    
                Read more about it in the
                [FastAPI docs for Declare Request Example Data](https://fastapi.tiangolo.com/tutorial/schema-extra-example/#using-the-openapi_examples-parameter).
                """
            ),
        ] = None,
        deprecated: Annotated[
            Union[deprecated, str, bool, None],
            Doc(
                """
                Mark this parameter field as deprecated.
    
                It will affect the generated OpenAPI (e.g. visible at `/docs`).
    
                Read more about it in the
                [FastAPI docs about Query parameters](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#deprecating-parameters)
                """
            ),
        ] = None,
        include_in_schema: Annotated[
            bool,
            Doc(
                """
                To include (or not) this parameter field in the generated OpenAPI.
                You probably don't need it, but it's available.
    
                This affects the generated OpenAPI (e.g. visible at `/docs`).
    
                Read more about it in the
                [FastAPI docs about Query parameters](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-parameters-from-openapi
                """
            ),
        ] = True,
        json_schema_extra: Annotated[
            Union[dict[str, Any], None],
            Doc(
                """
                Any additional JSON schema data.
                """
            ),
        ] = None,
        **extra: Annotated[
            Any,
            Doc(
                """
                Include extra fields used by the JSON Schema.
                """
            ),
            deprecated(
                """
                The `extra` kwargs is deprecated. Use `json_schema_extra` instead.
                """
            ),
        ],
    ) -> Any:
        return params.Query(
            default=default,
            default_factory=default_factory,
            alias=alias,
            alias_priority=alias_priority,
            validation_alias=validation_alias,
            serialization_alias=serialization_alias,
            title=title,
            description=description,
            gt=gt,
            ge=ge,
            lt=lt,
            le=le,
            min_length=min_length,
            max_length=max_length,
            pattern=pattern,
            regex=regex,
            discriminator=discriminator,
            strict=strict,
            multiple_of=multiple_of,
            allow_inf_nan=allow_inf_nan,
            max_digits=max_digits,
            decimal_places=decimal_places,
            example=example,
            examples=examples,
            openapi_examples=openapi_examples,
            deprecated=deprecated,
            include_in_schema=include_in_schema,
            json_schema_extra=json_schema_extra,
            **extra,
        )
      
  
---|---  
  
##  `` fastapi.Path [¶](#fastapi.Path "Permanent link")
    
    
    Path(
        default=...,
        *,
        default_factory=_Unset,
        alias=None,
        alias_priority=_Unset,
        validation_alias=None,
        serialization_alias=None,
        title=None,
        description=None,
        gt=None,
        ge=None,
        lt=None,
        le=None,
        min_length=None,
        max_length=None,
        pattern=None,
        regex=None,
        discriminator=None,
        strict=_Unset,
        multiple_of=_Unset,
        allow_inf_nan=_Unset,
        max_digits=_Unset,
        decimal_places=_Unset,
        examples=None,
        example=_Unset,
        openapi_examples=None,
        deprecated=None,
        include_in_schema=True,
        json_schema_extra=None,
        **extra
    )
    

Declare a path parameter for a _path operation_.

Read more about it in the [FastAPI docs for Path Parameters and Numeric Validations](https://fastapi.tiangolo.com/tutorial/path-params-numeric-validations/).
    
    
    from typing import Annotated
    
    from fastapi import FastAPI, Path
    
    app = FastAPI()
    
    
    @app.get("/items/{item_id}")
    async def read_items(
        item_id: Annotated[int, Path(title="The ID of the item to get")],
    ):
        return {"item_id": item_id}
    

PARAMETER | DESCRIPTION  
---|---  
`default` |  Default value if the parameter field is not set. This doesn't affect `Path` parameters as the value is always required. The parameter is available only for compatibility. **TYPE:** `Any` **DEFAULT:** `...`  
`default_factory` |  A callable to generate the default value. This doesn't affect `Path` parameters as the value is always required. The parameter is available only for compatibility. **TYPE:** `Union[Callable[[], Any], None]` **DEFAULT:** `_Unset`  
`alias` |  An alternative name for the parameter field. This will be used to extract the data and for the generated OpenAPI. It is particularly useful when you can't use the name you want because it is a Python reserved keyword or similar. **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`alias_priority` |  Priority of the alias. This affects whether an alias generator is used. **TYPE:** `Union[int, None]` **DEFAULT:** `_Unset`  
`validation_alias` |  'Whitelist' validation step. The parameter field will be the single one allowed by the alias or set of aliases defined. **TYPE:** `Union[str, AliasPath, AliasChoices, None]` **DEFAULT:** `None`  
`serialization_alias` |  'Blacklist' validation step. The vanilla parameter field will be the single one of the alias' or set of aliases' fields and all the other fields will be ignored at serialization time. **TYPE:** `Union[str, None]` **DEFAULT:** `None`  
`title` |  Human-readable title. Read more about it in the [FastAPI docs for Path Parameters and Numeric Validations](https://fastapi.tiangolo.com/tutorial/path-params-numeric-validations/#declare-metadata) **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`description` |  Human-readable description. **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`gt` |  Greater than. If set, value must be greater than this. Only applicable to numbers. Read more about it in the [FastAPI docs about Path parameters numeric validations](https://fastapi.tiangolo.com/tutorial/path-params-numeric-validations/#number-validations-greater-than-and-less-than-or-equal) **TYPE:** `Optional[float]` **DEFAULT:** `None`  
`ge` |  Greater than or equal. If set, value must be greater than or equal to this. Only applicable to numbers. Read more about it in the [FastAPI docs about Path parameters numeric validations](https://fastapi.tiangolo.com/tutorial/path-params-numeric-validations/#number-validations-greater-than-and-less-than-or-equal) **TYPE:** `Optional[float]` **DEFAULT:** `None`  
`lt` |  Less than. If set, value must be less than this. Only applicable to numbers. Read more about it in the [FastAPI docs about Path parameters numeric validations](https://fastapi.tiangolo.com/tutorial/path-params-numeric-validations/#number-validations-greater-than-and-less-than-or-equal) **TYPE:** `Optional[float]` **DEFAULT:** `None`  
`le` |  Less than or equal. If set, value must be less than or equal to this. Only applicable to numbers. Read more about it in the [FastAPI docs about Path parameters numeric validations](https://fastapi.tiangolo.com/tutorial/path-params-numeric-validations/#number-validations-greater-than-and-less-than-or-equal) **TYPE:** `Optional[float]` **DEFAULT:** `None`  
`min_length` |  Minimum length for strings. **TYPE:** `Optional[int]` **DEFAULT:** `None`  
`max_length` |  Maximum length for strings. **TYPE:** `Optional[int]` **DEFAULT:** `None`  
`pattern` |  RegEx pattern for strings. **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`regex` |  Deprecated in FastAPI 0.100.0 and Pydantic v2, use `pattern` instead. RegEx pattern for strings. **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`discriminator` |  Parameter field name for discriminating the type in a tagged union. **TYPE:** `Union[str, None]` **DEFAULT:** `None`  
`strict` |  If `True`, strict validation is applied to the field. **TYPE:** `Union[bool, None]` **DEFAULT:** `_Unset`  
`multiple_of` |  Value must be a multiple of this. Only applicable to numbers. **TYPE:** `Union[float, None]` **DEFAULT:** `_Unset`  
`allow_inf_nan` |  Allow `inf`, `-inf`, `nan`. Only applicable to numbers. **TYPE:** `Union[bool, None]` **DEFAULT:** `_Unset`  
`max_digits` |  Maximum number of allow digits for strings. **TYPE:** `Union[int, None]` **DEFAULT:** `_Unset`  
`decimal_places` |  Maximum number of decimal places allowed for numbers. **TYPE:** `Union[int, None]` **DEFAULT:** `_Unset`  
`examples` |  Example values for this field. Read more about it in the [FastAPI docs for Declare Request Example Data](https://fastapi.tiangolo.com/tutorial/schema-extra-example/) **TYPE:** `Optional[list[Any]]` **DEFAULT:** `None`  
`example` |  Deprecated in OpenAPI 3.1.0 that now uses JSON Schema 2020-12, although still supported. Use examples instead.  **TYPE:** `Optional[Any]` **DEFAULT:** `_Unset`  
`openapi_examples` |  OpenAPI-specific examples. It will be added to the generated OpenAPI (e.g. visible at `/docs`). Swagger UI (that provides the `/docs` interface) has better support for the OpenAPI-specific examples than the JSON Schema `examples`, that's the main use case for this. Read more about it in the [FastAPI docs for Declare Request Example Data](https://fastapi.tiangolo.com/tutorial/schema-extra-example/#using-the-openapi_examples-parameter). **TYPE:** `Optional[dict[str, [Example](../openapi/models/#fastapi.openapi.models.Example "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">Example</span> \(<code>fastapi.openapi.models.Example</code>\)")]]` **DEFAULT:** `None`  
`deprecated` |  Mark this parameter field as deprecated. It will affect the generated OpenAPI (e.g. visible at `/docs`). **TYPE:** `Union[deprecated, str, bool, None]` **DEFAULT:** `None`  
`include_in_schema` |  To include (or not) this parameter field in the generated OpenAPI. You probably don't need it, but it's available. This affects the generated OpenAPI (e.g. visible at `/docs`). **TYPE:** `bool` **DEFAULT:** `True`  
`json_schema_extra` |  Any additional JSON schema data. **TYPE:** `Union[dict[str, Any], None]` **DEFAULT:** `None`  
`**extra` |  The `extra` kwargs is deprecated. Use `json_schema_extra` instead. Include extra fields used by the JSON Schema. **TYPE:** `Any` **DEFAULT:** `{}`  
Source code in `fastapi/param_functions.py`
    
    
     14
     15
     16
     17
     18
     19
     20
     21
     22
     23
     24
     25
     26
     27
     28
     29
     30
     31
     32
     33
     34
     35
     36
     37
     38
     39
     40
     41
     42
     43
     44
     45
     46
     47
     48
     49
     50
     51
     52
     53
     54
     55
     56
     57
     58
     59
     60
     61
     62
     63
     64
     65
     66
     67
     68
     69
     70
     71
     72
     73
     74
     75
     76
     77
     78
     79
     80
     81
     82
     83
     84
     85
     86
     87
     88
     89
     90
     91
     92
     93
     94
     95
     96
     97
     98
     99
    100
    101
    102
    103
    104
    105
    106
    107
    108
    109
    110
    111
    112
    113
    114
    115
    116
    117
    118
    119
    120
    121
    122
    123
    124
    125
    126
    127
    128
    129
    130
    131
    132
    133
    134
    135
    136
    137
    138
    139
    140
    141
    142
    143
    144
    145
    146
    147
    148
    149
    150
    151
    152
    153
    154
    155
    156
    157
    158
    159
    160
    161
    162
    163
    164
    165
    166
    167
    168
    169
    170
    171
    172
    173
    174
    175
    176
    177
    178
    179
    180
    181
    182
    183
    184
    185
    186
    187
    188
    189
    190
    191
    192
    193
    194
    195
    196
    197
    198
    199
    200
    201
    202
    203
    204
    205
    206
    207
    208
    209
    210
    211
    212
    213
    214
    215
    216
    217
    218
    219
    220
    221
    222
    223
    224
    225
    226
    227
    228
    229
    230
    231
    232
    233
    234
    235
    236
    237
    238
    239
    240
    241
    242
    243
    244
    245
    246
    247
    248
    249
    250
    251
    252
    253
    254
    255
    256
    257
    258
    259
    260
    261
    262
    263
    264
    265
    266
    267
    268
    269
    270
    271
    272
    273
    274
    275
    276
    277
    278
    279
    280
    281
    282
    283
    284
    285
    286
    287
    288
    289
    290
    291
    292
    293
    294
    295
    296
    297
    298
    299
    300
    301
    302
    303
    304
    305
    306
    307
    308
    309
    310
    311
    312
    313
    314
    315
    316
    317
    318
    319
    320
    321
    322
    323
    324
    325
    326
    327
    328
    329
    330
    331
    332
    333
    334
    335
    336
    337
    338
    339
    340
    341
    342
    343
    344
    345
    346
    347
    348
    349
    350
    351
    352
    353
    354
    355

| 
    
    
    def Path(  # noqa: N802
        default: Annotated[
            Any,
            Doc(
                """
                Default value if the parameter field is not set.
    
                This doesn't affect `Path` parameters as the value is always required.
                The parameter is available only for compatibility.
                """
            ),
        ] = ...,
        *,
        default_factory: Annotated[
            Union[Callable[[], Any], None],
            Doc(
                """
                A callable to generate the default value.
    
                This doesn't affect `Path` parameters as the value is always required.
                The parameter is available only for compatibility.
                """
            ),
        ] = _Unset,
        alias: Annotated[
            Optional[str],
            Doc(
                """
                An alternative name for the parameter field.
    
                This will be used to extract the data and for the generated OpenAPI.
                It is particularly useful when you can't use the name you want because it
                is a Python reserved keyword or similar.
                """
            ),
        ] = None,
        alias_priority: Annotated[
            Union[int, None],
            Doc(
                """
                Priority of the alias. This affects whether an alias generator is used.
                """
            ),
        ] = _Unset,
        validation_alias: Annotated[
            Union[str, AliasPath, AliasChoices, None],
            Doc(
                """
                'Whitelist' validation step. The parameter field will be the single one
                allowed by the alias or set of aliases defined.
                """
            ),
        ] = None,
        serialization_alias: Annotated[
            Union[str, None],
            Doc(
                """
                'Blacklist' validation step. The vanilla parameter field will be the
                single one of the alias' or set of aliases' fields and all the other
                fields will be ignored at serialization time.
                """
            ),
        ] = None,
        title: Annotated[
            Optional[str],
            Doc(
                """
                Human-readable title.
    
                Read more about it in the
                [FastAPI docs for Path Parameters and Numeric Validations](https://fastapi.tiangolo.com/tutorial/path-params-numeric-validations/#declare-metadata)
                """
            ),
        ] = None,
        description: Annotated[
            Optional[str],
            Doc(
                """
                Human-readable description.
                """
            ),
        ] = None,
        gt: Annotated[
            Optional[float],
            Doc(
                """
                Greater than. If set, value must be greater than this. Only applicable to
                numbers.
    
                Read more about it in the
                [FastAPI docs about Path parameters numeric validations](https://fastapi.tiangolo.com/tutorial/path-params-numeric-validations/#number-validations-greater-than-and-less-than-or-equal)
                """
            ),
        ] = None,
        ge: Annotated[
            Optional[float],
            Doc(
                """
                Greater than or equal. If set, value must be greater than or equal to
                this. Only applicable to numbers.
    
                Read more about it in the
                [FastAPI docs about Path parameters numeric validations](https://fastapi.tiangolo.com/tutorial/path-params-numeric-validations/#number-validations-greater-than-and-less-than-or-equal)
                """
            ),
        ] = None,
        lt: Annotated[
            Optional[float],
            Doc(
                """
                Less than. If set, value must be less than this. Only applicable to numbers.
    
                Read more about it in the
                [FastAPI docs about Path parameters numeric validations](https://fastapi.tiangolo.com/tutorial/path-params-numeric-validations/#number-validations-greater-than-and-less-than-or-equal)
                """
            ),
        ] = None,
        le: Annotated[
            Optional[float],
            Doc(
                """
                Less than or equal. If set, value must be less than or equal to this.
                Only applicable to numbers.
    
                Read more about it in the
                [FastAPI docs about Path parameters numeric validations](https://fastapi.tiangolo.com/tutorial/path-params-numeric-validations/#number-validations-greater-than-and-less-than-or-equal)
                """
            ),
        ] = None,
        min_length: Annotated[
            Optional[int],
            Doc(
                """
                Minimum length for strings.
                """
            ),
        ] = None,
        max_length: Annotated[
            Optional[int],
            Doc(
                """
                Maximum length for strings.
                """
            ),
        ] = None,
        pattern: Annotated[
            Optional[str],
            Doc(
                """
                RegEx pattern for strings.
                """
            ),
        ] = None,
        regex: Annotated[
            Optional[str],
            Doc(
                """
                RegEx pattern for strings.
                """
            ),
            deprecated(
                "Deprecated in FastAPI 0.100.0 and Pydantic v2, use `pattern` instead."
            ),
        ] = None,
        discriminator: Annotated[
            Union[str, None],
            Doc(
                """
                Parameter field name for discriminating the type in a tagged union.
                """
            ),
        ] = None,
        strict: Annotated[
            Union[bool, None],
            Doc(
                """
                If `True`, strict validation is applied to the field.
                """
            ),
        ] = _Unset,
        multiple_of: Annotated[
            Union[float, None],
            Doc(
                """
                Value must be a multiple of this. Only applicable to numbers.
                """
            ),
        ] = _Unset,
        allow_inf_nan: Annotated[
            Union[bool, None],
            Doc(
                """
                Allow `inf`, `-inf`, `nan`. Only applicable to numbers.
                """
            ),
        ] = _Unset,
        max_digits: Annotated[
            Union[int, None],
            Doc(
                """
                Maximum number of allow digits for strings.
                """
            ),
        ] = _Unset,
        decimal_places: Annotated[
            Union[int, None],
            Doc(
                """
                Maximum number of decimal places allowed for numbers.
                """
            ),
        ] = _Unset,
        examples: Annotated[
            Optional[list[Any]],
            Doc(
                """
                Example values for this field.
    
                Read more about it in the
                [FastAPI docs for Declare Request Example Data](https://fastapi.tiangolo.com/tutorial/schema-extra-example/)
                """
            ),
        ] = None,
        example: Annotated[
            Optional[Any],
            deprecated(
                "Deprecated in OpenAPI 3.1.0 that now uses JSON Schema 2020-12, "
                "although still supported. Use examples instead."
            ),
        ] = _Unset,
        openapi_examples: Annotated[
            Optional[dict[str, Example]],
            Doc(
                """
                OpenAPI-specific examples.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
    
                Swagger UI (that provides the `/docs` interface) has better support for the
                OpenAPI-specific examples than the JSON Schema `examples`, that's the main
                use case for this.
    
                Read more about it in the
                [FastAPI docs for Declare Request Example Data](https://fastapi.tiangolo.com/tutorial/schema-extra-example/#using-the-openapi_examples-parameter).
                """
            ),
        ] = None,
        deprecated: Annotated[
            Union[deprecated, str, bool, None],
            Doc(
                """
                Mark this parameter field as deprecated.
    
                It will affect the generated OpenAPI (e.g. visible at `/docs`).
                """
            ),
        ] = None,
        include_in_schema: Annotated[
            bool,
            Doc(
                """
                To include (or not) this parameter field in the generated OpenAPI.
                You probably don't need it, but it's available.
    
                This affects the generated OpenAPI (e.g. visible at `/docs`).
                """
            ),
        ] = True,
        json_schema_extra: Annotated[
            Union[dict[str, Any], None],
            Doc(
                """
                Any additional JSON schema data.
                """
            ),
        ] = None,
        **extra: Annotated[
            Any,
            Doc(
                """
                Include extra fields used by the JSON Schema.
                """
            ),
            deprecated(
                """
                The `extra` kwargs is deprecated. Use `json_schema_extra` instead.
                """
            ),
        ],
    ) -> Any:
        """
        Declare a path parameter for a *path operation*.
    
        Read more about it in the
        [FastAPI docs for Path Parameters and Numeric Validations](https://fastapi.tiangolo.com/tutorial/path-params-numeric-validations/).
    
        ```python
        from typing import Annotated
    
        from fastapi import FastAPI, Path
    
        app = FastAPI()
    
    
        @app.get("/items/{item_id}")
        async def read_items(
            item_id: Annotated[int, Path(title="The ID of the item to get")],
        ):
            return {"item_id": item_id}
        ```
        """
        return params.Path(
            default=default,
            default_factory=default_factory,
            alias=alias,
            alias_priority=alias_priority,
            validation_alias=validation_alias,
            serialization_alias=serialization_alias,
            title=title,
            description=description,
            gt=gt,
            ge=ge,
            lt=lt,
            le=le,
            min_length=min_length,
            max_length=max_length,
            pattern=pattern,
            regex=regex,
            discriminator=discriminator,
            strict=strict,
            multiple_of=multiple_of,
            allow_inf_nan=allow_inf_nan,
            max_digits=max_digits,
            decimal_places=decimal_places,
            example=example,
            examples=examples,
            openapi_examples=openapi_examples,
            deprecated=deprecated,
            include_in_schema=include_in_schema,
            json_schema_extra=json_schema_extra,
            **extra,
        )
      
  
---|---  
  
##  `` fastapi.Body [¶](#fastapi.Body "Permanent link")
    
    
    Body(
        default=Undefined,
        *,
        default_factory=_Unset,
        embed=None,
        media_type="application/json",
        alias=None,
        alias_priority=_Unset,
        validation_alias=None,
        serialization_alias=None,
        title=None,
        description=None,
        gt=None,
        ge=None,
        lt=None,
        le=None,
        min_length=None,
        max_length=None,
        pattern=None,
        regex=None,
        discriminator=None,
        strict=_Unset,
        multiple_of=_Unset,
        allow_inf_nan=_Unset,
        max_digits=_Unset,
        decimal_places=_Unset,
        examples=None,
        example=_Unset,
        openapi_examples=None,
        deprecated=None,
        include_in_schema=True,
        json_schema_extra=None,
        **extra
    )
    

PARAMETER | DESCRIPTION  
---|---  
`default` |  Default value if the parameter field is not set. **TYPE:** `Any` **DEFAULT:** `Undefined`  
`default_factory` |  A callable to generate the default value. This doesn't affect `Path` parameters as the value is always required. The parameter is available only for compatibility. **TYPE:** `Union[Callable[[], Any], None]` **DEFAULT:** `_Unset`  
`embed` |  When `embed` is `True`, the parameter will be expected in a JSON body as a key instead of being the JSON body itself. This happens automatically when more than one `Body` parameter is declared. Read more about it in the [FastAPI docs for Body - Multiple Parameters](https://fastapi.tiangolo.com/tutorial/body-multiple-params/#embed-a-single-body-parameter). **TYPE:** `Union[bool, None]` **DEFAULT:** `None`  
`media_type` |  The media type of this parameter field. Changing it would affect the generated OpenAPI, but currently it doesn't affect the parsing of the data. **TYPE:** `str` **DEFAULT:** `'application/json'`  
`alias` |  An alternative name for the parameter field. This will be used to extract the data and for the generated OpenAPI. It is particularly useful when you can't use the name you want because it is a Python reserved keyword or similar. **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`alias_priority` |  Priority of the alias. This affects whether an alias generator is used. **TYPE:** `Union[int, None]` **DEFAULT:** `_Unset`  
`validation_alias` |  'Whitelist' validation step. The parameter field will be the single one allowed by the alias or set of aliases defined. **TYPE:** `Union[str, AliasPath, AliasChoices, None]` **DEFAULT:** `None`  
`serialization_alias` |  'Blacklist' validation step. The vanilla parameter field will be the single one of the alias' or set of aliases' fields and all the other fields will be ignored at serialization time. **TYPE:** `Union[str, None]` **DEFAULT:** `None`  
`title` |  Human-readable title. **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`description` |  Human-readable description. **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`gt` |  Greater than. If set, value must be greater than this. Only applicable to numbers. **TYPE:** `Optional[float]` **DEFAULT:** `None`  
`ge` |  Greater than or equal. If set, value must be greater than or equal to this. Only applicable to numbers. **TYPE:** `Optional[float]` **DEFAULT:** `None`  
`lt` |  Less than. If set, value must be less than this. Only applicable to numbers. **TYPE:** `Optional[float]` **DEFAULT:** `None`  
`le` |  Less than or equal. If set, value must be less than or equal to this. Only applicable to numbers. **TYPE:** `Optional[float]` **DEFAULT:** `None`  
`min_length` |  Minimum length for strings. **TYPE:** `Optional[int]` **DEFAULT:** `None`  
`max_length` |  Maximum length for strings. **TYPE:** `Optional[int]` **DEFAULT:** `None`  
`pattern` |  RegEx pattern for strings. **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`regex` |  Deprecated in FastAPI 0.100.0 and Pydantic v2, use `pattern` instead. RegEx pattern for strings. **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`discriminator` |  Parameter field name for discriminating the type in a tagged union. **TYPE:** `Union[str, None]` **DEFAULT:** `None`  
`strict` |  If `True`, strict validation is applied to the field. **TYPE:** `Union[bool, None]` **DEFAULT:** `_Unset`  
`multiple_of` |  Value must be a multiple of this. Only applicable to numbers. **TYPE:** `Union[float, None]` **DEFAULT:** `_Unset`  
`allow_inf_nan` |  Allow `inf`, `-inf`, `nan`. Only applicable to numbers. **TYPE:** `Union[bool, None]` **DEFAULT:** `_Unset`  
`max_digits` |  Maximum number of allow digits for strings. **TYPE:** `Union[int, None]` **DEFAULT:** `_Unset`  
`decimal_places` |  Maximum number of decimal places allowed for numbers. **TYPE:** `Union[int, None]` **DEFAULT:** `_Unset`  
`examples` |  Example values for this field. Read more about it in the [FastAPI docs for Declare Request Example Data](https://fastapi.tiangolo.com/tutorial/schema-extra-example/) **TYPE:** `Optional[list[Any]]` **DEFAULT:** `None`  
`example` |  Deprecated in OpenAPI 3.1.0 that now uses JSON Schema 2020-12, although still supported. Use examples instead.  **TYPE:** `Optional[Any]` **DEFAULT:** `_Unset`  
`openapi_examples` |  OpenAPI-specific examples. It will be added to the generated OpenAPI (e.g. visible at `/docs`). Swagger UI (that provides the `/docs` interface) has better support for the OpenAPI-specific examples than the JSON Schema `examples`, that's the main use case for this. Read more about it in the [FastAPI docs for Declare Request Example Data](https://fastapi.tiangolo.com/tutorial/schema-extra-example/#using-the-openapi_examples-parameter). **TYPE:** `Optional[dict[str, [Example](../openapi/models/#fastapi.openapi.models.Example "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">Example</span> \(<code>fastapi.openapi.models.Example</code>\)")]]` **DEFAULT:** `None`  
`deprecated` |  Mark this parameter field as deprecated. It will affect the generated OpenAPI (e.g. visible at `/docs`). **TYPE:** `Union[deprecated, str, bool, None]` **DEFAULT:** `None`  
`include_in_schema` |  To include (or not) this parameter field in the generated OpenAPI. You probably don't need it, but it's available. This affects the generated OpenAPI (e.g. visible at `/docs`). **TYPE:** `bool` **DEFAULT:** `True`  
`json_schema_extra` |  Any additional JSON schema data. **TYPE:** `Union[dict[str, Any], None]` **DEFAULT:** `None`  
`**extra` |  The `extra` kwargs is deprecated. Use `json_schema_extra` instead. Include extra fields used by the JSON Schema. **TYPE:** `Any` **DEFAULT:** `{}`  
Source code in `fastapi/param_functions.py`
    
    
    1324
    1325
    1326
    1327
    1328
    1329
    1330
    1331
    1332
    1333
    1334
    1335
    1336
    1337
    1338
    1339
    1340
    1341
    1342
    1343
    1344
    1345
    1346
    1347
    1348
    1349
    1350
    1351
    1352
    1353
    1354
    1355
    1356
    1357
    1358
    1359
    1360
    1361
    1362
    1363
    1364
    1365
    1366
    1367
    1368
    1369
    1370
    1371
    1372
    1373
    1374
    1375
    1376
    1377
    1378
    1379
    1380
    1381
    1382
    1383
    1384
    1385
    1386
    1387
    1388
    1389
    1390
    1391
    1392
    1393
    1394
    1395
    1396
    1397
    1398
    1399
    1400
    1401
    1402
    1403
    1404
    1405
    1406
    1407
    1408
    1409
    1410
    1411
    1412
    1413
    1414
    1415
    1416
    1417
    1418
    1419
    1420
    1421
    1422
    1423
    1424
    1425
    1426
    1427
    1428
    1429
    1430
    1431
    1432
    1433
    1434
    1435
    1436
    1437
    1438
    1439
    1440
    1441
    1442
    1443
    1444
    1445
    1446
    1447
    1448
    1449
    1450
    1451
    1452
    1453
    1454
    1455
    1456
    1457
    1458
    1459
    1460
    1461
    1462
    1463
    1464
    1465
    1466
    1467
    1468
    1469
    1470
    1471
    1472
    1473
    1474
    1475
    1476
    1477
    1478
    1479
    1480
    1481
    1482
    1483
    1484
    1485
    1486
    1487
    1488
    1489
    1490
    1491
    1492
    1493
    1494
    1495
    1496
    1497
    1498
    1499
    1500
    1501
    1502
    1503
    1504
    1505
    1506
    1507
    1508
    1509
    1510
    1511
    1512
    1513
    1514
    1515
    1516
    1517
    1518
    1519
    1520
    1521
    1522
    1523
    1524
    1525
    1526
    1527
    1528
    1529
    1530
    1531
    1532
    1533
    1534
    1535
    1536
    1537
    1538
    1539
    1540
    1541
    1542
    1543
    1544
    1545
    1546
    1547
    1548
    1549
    1550
    1551
    1552
    1553
    1554
    1555
    1556
    1557
    1558
    1559
    1560
    1561
    1562
    1563
    1564
    1565
    1566
    1567
    1568
    1569
    1570
    1571
    1572
    1573
    1574
    1575
    1576
    1577
    1578
    1579
    1580
    1581
    1582
    1583
    1584
    1585
    1586
    1587
    1588
    1589
    1590
    1591
    1592
    1593
    1594
    1595
    1596
    1597
    1598
    1599
    1600
    1601
    1602
    1603
    1604
    1605
    1606
    1607
    1608
    1609
    1610
    1611
    1612
    1613
    1614
    1615
    1616
    1617
    1618
    1619
    1620
    1621
    1622
    1623
    1624
    1625
    1626
    1627
    1628
    1629
    1630
    1631
    1632
    1633
    1634
    1635
    1636
    1637
    1638
    1639
    1640
    1641
    1642
    1643
    1644
    1645
    1646
    1647
    1648
    1649
    1650
    1651

| 
    
    
    def Body(  # noqa: N802
        default: Annotated[
            Any,
            Doc(
                """
                Default value if the parameter field is not set.
                """
            ),
        ] = Undefined,
        *,
        default_factory: Annotated[
            Union[Callable[[], Any], None],
            Doc(
                """
                A callable to generate the default value.
    
                This doesn't affect `Path` parameters as the value is always required.
                The parameter is available only for compatibility.
                """
            ),
        ] = _Unset,
        embed: Annotated[
            Union[bool, None],
            Doc(
                """
                When `embed` is `True`, the parameter will be expected in a JSON body as a
                key instead of being the JSON body itself.
    
                This happens automatically when more than one `Body` parameter is declared.
    
                Read more about it in the
                [FastAPI docs for Body - Multiple Parameters](https://fastapi.tiangolo.com/tutorial/body-multiple-params/#embed-a-single-body-parameter).
                """
            ),
        ] = None,
        media_type: Annotated[
            str,
            Doc(
                """
                The media type of this parameter field. Changing it would affect the
                generated OpenAPI, but currently it doesn't affect the parsing of the data.
                """
            ),
        ] = "application/json",
        alias: Annotated[
            Optional[str],
            Doc(
                """
                An alternative name for the parameter field.
    
                This will be used to extract the data and for the generated OpenAPI.
                It is particularly useful when you can't use the name you want because it
                is a Python reserved keyword or similar.
                """
            ),
        ] = None,
        alias_priority: Annotated[
            Union[int, None],
            Doc(
                """
                Priority of the alias. This affects whether an alias generator is used.
                """
            ),
        ] = _Unset,
        validation_alias: Annotated[
            Union[str, AliasPath, AliasChoices, None],
            Doc(
                """
                'Whitelist' validation step. The parameter field will be the single one
                allowed by the alias or set of aliases defined.
                """
            ),
        ] = None,
        serialization_alias: Annotated[
            Union[str, None],
            Doc(
                """
                'Blacklist' validation step. The vanilla parameter field will be the
                single one of the alias' or set of aliases' fields and all the other
                fields will be ignored at serialization time.
                """
            ),
        ] = None,
        title: Annotated[
            Optional[str],
            Doc(
                """
                Human-readable title.
                """
            ),
        ] = None,
        description: Annotated[
            Optional[str],
            Doc(
                """
                Human-readable description.
                """
            ),
        ] = None,
        gt: Annotated[
            Optional[float],
            Doc(
                """
                Greater than. If set, value must be greater than this. Only applicable to
                numbers.
                """
            ),
        ] = None,
        ge: Annotated[
            Optional[float],
            Doc(
                """
                Greater than or equal. If set, value must be greater than or equal to
                this. Only applicable to numbers.
                """
            ),
        ] = None,
        lt: Annotated[
            Optional[float],
            Doc(
                """
                Less than. If set, value must be less than this. Only applicable to numbers.
                """
            ),
        ] = None,
        le: Annotated[
            Optional[float],
            Doc(
                """
                Less than or equal. If set, value must be less than or equal to this.
                Only applicable to numbers.
                """
            ),
        ] = None,
        min_length: Annotated[
            Optional[int],
            Doc(
                """
                Minimum length for strings.
                """
            ),
        ] = None,
        max_length: Annotated[
            Optional[int],
            Doc(
                """
                Maximum length for strings.
                """
            ),
        ] = None,
        pattern: Annotated[
            Optional[str],
            Doc(
                """
                RegEx pattern for strings.
                """
            ),
        ] = None,
        regex: Annotated[
            Optional[str],
            Doc(
                """
                RegEx pattern for strings.
                """
            ),
            deprecated(
                "Deprecated in FastAPI 0.100.0 and Pydantic v2, use `pattern` instead."
            ),
        ] = None,
        discriminator: Annotated[
            Union[str, None],
            Doc(
                """
                Parameter field name for discriminating the type in a tagged union.
                """
            ),
        ] = None,
        strict: Annotated[
            Union[bool, None],
            Doc(
                """
                If `True`, strict validation is applied to the field.
                """
            ),
        ] = _Unset,
        multiple_of: Annotated[
            Union[float, None],
            Doc(
                """
                Value must be a multiple of this. Only applicable to numbers.
                """
            ),
        ] = _Unset,
        allow_inf_nan: Annotated[
            Union[bool, None],
            Doc(
                """
                Allow `inf`, `-inf`, `nan`. Only applicable to numbers.
                """
            ),
        ] = _Unset,
        max_digits: Annotated[
            Union[int, None],
            Doc(
                """
                Maximum number of allow digits for strings.
                """
            ),
        ] = _Unset,
        decimal_places: Annotated[
            Union[int, None],
            Doc(
                """
                Maximum number of decimal places allowed for numbers.
                """
            ),
        ] = _Unset,
        examples: Annotated[
            Optional[list[Any]],
            Doc(
                """
                Example values for this field.
    
                Read more about it in the
                [FastAPI docs for Declare Request Example Data](https://fastapi.tiangolo.com/tutorial/schema-extra-example/)
                """
            ),
        ] = None,
        example: Annotated[
            Optional[Any],
            deprecated(
                "Deprecated in OpenAPI 3.1.0 that now uses JSON Schema 2020-12, "
                "although still supported. Use examples instead."
            ),
        ] = _Unset,
        openapi_examples: Annotated[
            Optional[dict[str, Example]],
            Doc(
                """
                OpenAPI-specific examples.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
    
                Swagger UI (that provides the `/docs` interface) has better support for the
                OpenAPI-specific examples than the JSON Schema `examples`, that's the main
                use case for this.
    
                Read more about it in the
                [FastAPI docs for Declare Request Example Data](https://fastapi.tiangolo.com/tutorial/schema-extra-example/#using-the-openapi_examples-parameter).
                """
            ),
        ] = None,
        deprecated: Annotated[
            Union[deprecated, str, bool, None],
            Doc(
                """
                Mark this parameter field as deprecated.
    
                It will affect the generated OpenAPI (e.g. visible at `/docs`).
                """
            ),
        ] = None,
        include_in_schema: Annotated[
            bool,
            Doc(
                """
                To include (or not) this parameter field in the generated OpenAPI.
                You probably don't need it, but it's available.
    
                This affects the generated OpenAPI (e.g. visible at `/docs`).
                """
            ),
        ] = True,
        json_schema_extra: Annotated[
            Union[dict[str, Any], None],
            Doc(
                """
                Any additional JSON schema data.
                """
            ),
        ] = None,
        **extra: Annotated[
            Any,
            Doc(
                """
                Include extra fields used by the JSON Schema.
                """
            ),
            deprecated(
                """
                The `extra` kwargs is deprecated. Use `json_schema_extra` instead.
                """
            ),
        ],
    ) -> Any:
        return params.Body(
            default=default,
            default_factory=default_factory,
            embed=embed,
            media_type=media_type,
            alias=alias,
            alias_priority=alias_priority,
            validation_alias=validation_alias,
            serialization_alias=serialization_alias,
            title=title,
            description=description,
            gt=gt,
            ge=ge,
            lt=lt,
            le=le,
            min_length=min_length,
            max_length=max_length,
            pattern=pattern,
            regex=regex,
            discriminator=discriminator,
            strict=strict,
            multiple_of=multiple_of,
            allow_inf_nan=allow_inf_nan,
            max_digits=max_digits,
            decimal_places=decimal_places,
            example=example,
            examples=examples,
            openapi_examples=openapi_examples,
            deprecated=deprecated,
            include_in_schema=include_in_schema,
            json_schema_extra=json_schema_extra,
            **extra,
        )
      
  
---|---  
  
##  `` fastapi.Cookie [¶](#fastapi.Cookie "Permanent link")
    
    
    Cookie(
        default=Undefined,
        *,
        default_factory=_Unset,
        alias=None,
        alias_priority=_Unset,
        validation_alias=None,
        serialization_alias=None,
        title=None,
        description=None,
        gt=None,
        ge=None,
        lt=None,
        le=None,
        min_length=None,
        max_length=None,
        pattern=None,
        regex=None,
        discriminator=None,
        strict=_Unset,
        multiple_of=_Unset,
        allow_inf_nan=_Unset,
        max_digits=_Unset,
        decimal_places=_Unset,
        examples=None,
        example=_Unset,
        openapi_examples=None,
        deprecated=None,
        include_in_schema=True,
        json_schema_extra=None,
        **extra
    )
    

PARAMETER | DESCRIPTION  
---|---  
`default` |  Default value if the parameter field is not set. **TYPE:** `Any` **DEFAULT:** `Undefined`  
`default_factory` |  A callable to generate the default value. This doesn't affect `Path` parameters as the value is always required. The parameter is available only for compatibility. **TYPE:** `Union[Callable[[], Any], None]` **DEFAULT:** `_Unset`  
`alias` |  An alternative name for the parameter field. This will be used to extract the data and for the generated OpenAPI. It is particularly useful when you can't use the name you want because it is a Python reserved keyword or similar. **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`alias_priority` |  Priority of the alias. This affects whether an alias generator is used. **TYPE:** `Union[int, None]` **DEFAULT:** `_Unset`  
`validation_alias` |  'Whitelist' validation step. The parameter field will be the single one allowed by the alias or set of aliases defined. **TYPE:** `Union[str, AliasPath, AliasChoices, None]` **DEFAULT:** `None`  
`serialization_alias` |  'Blacklist' validation step. The vanilla parameter field will be the single one of the alias' or set of aliases' fields and all the other fields will be ignored at serialization time. **TYPE:** `Union[str, None]` **DEFAULT:** `None`  
`title` |  Human-readable title. **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`description` |  Human-readable description. **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`gt` |  Greater than. If set, value must be greater than this. Only applicable to numbers. **TYPE:** `Optional[float]` **DEFAULT:** `None`  
`ge` |  Greater than or equal. If set, value must be greater than or equal to this. Only applicable to numbers. **TYPE:** `Optional[float]` **DEFAULT:** `None`  
`lt` |  Less than. If set, value must be less than this. Only applicable to numbers. **TYPE:** `Optional[float]` **DEFAULT:** `None`  
`le` |  Less than or equal. If set, value must be less than or equal to this. Only applicable to numbers. **TYPE:** `Optional[float]` **DEFAULT:** `None`  
`min_length` |  Minimum length for strings. **TYPE:** `Optional[int]` **DEFAULT:** `None`  
`max_length` |  Maximum length for strings. **TYPE:** `Optional[int]` **DEFAULT:** `None`  
`pattern` |  RegEx pattern for strings. **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`regex` |  Deprecated in FastAPI 0.100.0 and Pydantic v2, use `pattern` instead. RegEx pattern for strings. **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`discriminator` |  Parameter field name for discriminating the type in a tagged union. **TYPE:** `Union[str, None]` **DEFAULT:** `None`  
`strict` |  If `True`, strict validation is applied to the field. **TYPE:** `Union[bool, None]` **DEFAULT:** `_Unset`  
`multiple_of` |  Value must be a multiple of this. Only applicable to numbers. **TYPE:** `Union[float, None]` **DEFAULT:** `_Unset`  
`allow_inf_nan` |  Allow `inf`, `-inf`, `nan`. Only applicable to numbers. **TYPE:** `Union[bool, None]` **DEFAULT:** `_Unset`  
`max_digits` |  Maximum number of allow digits for strings. **TYPE:** `Union[int, None]` **DEFAULT:** `_Unset`  
`decimal_places` |  Maximum number of decimal places allowed for numbers. **TYPE:** `Union[int, None]` **DEFAULT:** `_Unset`  
`examples` |  Example values for this field. Read more about it in the [FastAPI docs for Declare Request Example Data](https://fastapi.tiangolo.com/tutorial/schema-extra-example/) **TYPE:** `Optional[list[Any]]` **DEFAULT:** `None`  
`example` |  Deprecated in OpenAPI 3.1.0 that now uses JSON Schema 2020-12, although still supported. Use examples instead.  **TYPE:** `Optional[Any]` **DEFAULT:** `_Unset`  
`openapi_examples` |  OpenAPI-specific examples. It will be added to the generated OpenAPI (e.g. visible at `/docs`). Swagger UI (that provides the `/docs` interface) has better support for the OpenAPI-specific examples than the JSON Schema `examples`, that's the main use case for this. Read more about it in the [FastAPI docs for Declare Request Example Data](https://fastapi.tiangolo.com/tutorial/schema-extra-example/#using-the-openapi_examples-parameter). **TYPE:** `Optional[dict[str, [Example](../openapi/models/#fastapi.openapi.models.Example "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">Example</span> \(<code>fastapi.openapi.models.Example</code>\)")]]` **DEFAULT:** `None`  
`deprecated` |  Mark this parameter field as deprecated. It will affect the generated OpenAPI (e.g. visible at `/docs`). **TYPE:** `Union[deprecated, str, bool, None]` **DEFAULT:** `None`  
`include_in_schema` |  To include (or not) this parameter field in the generated OpenAPI. You probably don't need it, but it's available. This affects the generated OpenAPI (e.g. visible at `/docs`). **TYPE:** `bool` **DEFAULT:** `True`  
`json_schema_extra` |  Any additional JSON schema data. **TYPE:** `Union[dict[str, Any], None]` **DEFAULT:** `None`  
`**extra` |  The `extra` kwargs is deprecated. Use `json_schema_extra` instead. Include extra fields used by the JSON Schema. **TYPE:** `Any` **DEFAULT:** `{}`  
Source code in `fastapi/param_functions.py`
    
    
    1019
    1020
    1021
    1022
    1023
    1024
    1025
    1026
    1027
    1028
    1029
    1030
    1031
    1032
    1033
    1034
    1035
    1036
    1037
    1038
    1039
    1040
    1041
    1042
    1043
    1044
    1045
    1046
    1047
    1048
    1049
    1050
    1051
    1052
    1053
    1054
    1055
    1056
    1057
    1058
    1059
    1060
    1061
    1062
    1063
    1064
    1065
    1066
    1067
    1068
    1069
    1070
    1071
    1072
    1073
    1074
    1075
    1076
    1077
    1078
    1079
    1080
    1081
    1082
    1083
    1084
    1085
    1086
    1087
    1088
    1089
    1090
    1091
    1092
    1093
    1094
    1095
    1096
    1097
    1098
    1099
    1100
    1101
    1102
    1103
    1104
    1105
    1106
    1107
    1108
    1109
    1110
    1111
    1112
    1113
    1114
    1115
    1116
    1117
    1118
    1119
    1120
    1121
    1122
    1123
    1124
    1125
    1126
    1127
    1128
    1129
    1130
    1131
    1132
    1133
    1134
    1135
    1136
    1137
    1138
    1139
    1140
    1141
    1142
    1143
    1144
    1145
    1146
    1147
    1148
    1149
    1150
    1151
    1152
    1153
    1154
    1155
    1156
    1157
    1158
    1159
    1160
    1161
    1162
    1163
    1164
    1165
    1166
    1167
    1168
    1169
    1170
    1171
    1172
    1173
    1174
    1175
    1176
    1177
    1178
    1179
    1180
    1181
    1182
    1183
    1184
    1185
    1186
    1187
    1188
    1189
    1190
    1191
    1192
    1193
    1194
    1195
    1196
    1197
    1198
    1199
    1200
    1201
    1202
    1203
    1204
    1205
    1206
    1207
    1208
    1209
    1210
    1211
    1212
    1213
    1214
    1215
    1216
    1217
    1218
    1219
    1220
    1221
    1222
    1223
    1224
    1225
    1226
    1227
    1228
    1229
    1230
    1231
    1232
    1233
    1234
    1235
    1236
    1237
    1238
    1239
    1240
    1241
    1242
    1243
    1244
    1245
    1246
    1247
    1248
    1249
    1250
    1251
    1252
    1253
    1254
    1255
    1256
    1257
    1258
    1259
    1260
    1261
    1262
    1263
    1264
    1265
    1266
    1267
    1268
    1269
    1270
    1271
    1272
    1273
    1274
    1275
    1276
    1277
    1278
    1279
    1280
    1281
    1282
    1283
    1284
    1285
    1286
    1287
    1288
    1289
    1290
    1291
    1292
    1293
    1294
    1295
    1296
    1297
    1298
    1299
    1300
    1301
    1302
    1303
    1304
    1305
    1306
    1307
    1308
    1309
    1310
    1311
    1312
    1313
    1314
    1315
    1316
    1317
    1318
    1319
    1320
    1321

| 
    
    
    def Cookie(  # noqa: N802
        default: Annotated[
            Any,
            Doc(
                """
                Default value if the parameter field is not set.
                """
            ),
        ] = Undefined,
        *,
        default_factory: Annotated[
            Union[Callable[[], Any], None],
            Doc(
                """
                A callable to generate the default value.
    
                This doesn't affect `Path` parameters as the value is always required.
                The parameter is available only for compatibility.
                """
            ),
        ] = _Unset,
        alias: Annotated[
            Optional[str],
            Doc(
                """
                An alternative name for the parameter field.
    
                This will be used to extract the data and for the generated OpenAPI.
                It is particularly useful when you can't use the name you want because it
                is a Python reserved keyword or similar.
                """
            ),
        ] = None,
        alias_priority: Annotated[
            Union[int, None],
            Doc(
                """
                Priority of the alias. This affects whether an alias generator is used.
                """
            ),
        ] = _Unset,
        validation_alias: Annotated[
            Union[str, AliasPath, AliasChoices, None],
            Doc(
                """
                'Whitelist' validation step. The parameter field will be the single one
                allowed by the alias or set of aliases defined.
                """
            ),
        ] = None,
        serialization_alias: Annotated[
            Union[str, None],
            Doc(
                """
                'Blacklist' validation step. The vanilla parameter field will be the
                single one of the alias' or set of aliases' fields and all the other
                fields will be ignored at serialization time.
                """
            ),
        ] = None,
        title: Annotated[
            Optional[str],
            Doc(
                """
                Human-readable title.
                """
            ),
        ] = None,
        description: Annotated[
            Optional[str],
            Doc(
                """
                Human-readable description.
                """
            ),
        ] = None,
        gt: Annotated[
            Optional[float],
            Doc(
                """
                Greater than. If set, value must be greater than this. Only applicable to
                numbers.
                """
            ),
        ] = None,
        ge: Annotated[
            Optional[float],
            Doc(
                """
                Greater than or equal. If set, value must be greater than or equal to
                this. Only applicable to numbers.
                """
            ),
        ] = None,
        lt: Annotated[
            Optional[float],
            Doc(
                """
                Less than. If set, value must be less than this. Only applicable to numbers.
                """
            ),
        ] = None,
        le: Annotated[
            Optional[float],
            Doc(
                """
                Less than or equal. If set, value must be less than or equal to this.
                Only applicable to numbers.
                """
            ),
        ] = None,
        min_length: Annotated[
            Optional[int],
            Doc(
                """
                Minimum length for strings.
                """
            ),
        ] = None,
        max_length: Annotated[
            Optional[int],
            Doc(
                """
                Maximum length for strings.
                """
            ),
        ] = None,
        pattern: Annotated[
            Optional[str],
            Doc(
                """
                RegEx pattern for strings.
                """
            ),
        ] = None,
        regex: Annotated[
            Optional[str],
            Doc(
                """
                RegEx pattern for strings.
                """
            ),
            deprecated(
                "Deprecated in FastAPI 0.100.0 and Pydantic v2, use `pattern` instead."
            ),
        ] = None,
        discriminator: Annotated[
            Union[str, None],
            Doc(
                """
                Parameter field name for discriminating the type in a tagged union.
                """
            ),
        ] = None,
        strict: Annotated[
            Union[bool, None],
            Doc(
                """
                If `True`, strict validation is applied to the field.
                """
            ),
        ] = _Unset,
        multiple_of: Annotated[
            Union[float, None],
            Doc(
                """
                Value must be a multiple of this. Only applicable to numbers.
                """
            ),
        ] = _Unset,
        allow_inf_nan: Annotated[
            Union[bool, None],
            Doc(
                """
                Allow `inf`, `-inf`, `nan`. Only applicable to numbers.
                """
            ),
        ] = _Unset,
        max_digits: Annotated[
            Union[int, None],
            Doc(
                """
                Maximum number of allow digits for strings.
                """
            ),
        ] = _Unset,
        decimal_places: Annotated[
            Union[int, None],
            Doc(
                """
                Maximum number of decimal places allowed for numbers.
                """
            ),
        ] = _Unset,
        examples: Annotated[
            Optional[list[Any]],
            Doc(
                """
                Example values for this field.
    
                Read more about it in the
                [FastAPI docs for Declare Request Example Data](https://fastapi.tiangolo.com/tutorial/schema-extra-example/)
                """
            ),
        ] = None,
        example: Annotated[
            Optional[Any],
            deprecated(
                "Deprecated in OpenAPI 3.1.0 that now uses JSON Schema 2020-12, "
                "although still supported. Use examples instead."
            ),
        ] = _Unset,
        openapi_examples: Annotated[
            Optional[dict[str, Example]],
            Doc(
                """
                OpenAPI-specific examples.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
    
                Swagger UI (that provides the `/docs` interface) has better support for the
                OpenAPI-specific examples than the JSON Schema `examples`, that's the main
                use case for this.
    
                Read more about it in the
                [FastAPI docs for Declare Request Example Data](https://fastapi.tiangolo.com/tutorial/schema-extra-example/#using-the-openapi_examples-parameter).
                """
            ),
        ] = None,
        deprecated: Annotated[
            Union[deprecated, str, bool, None],
            Doc(
                """
                Mark this parameter field as deprecated.
    
                It will affect the generated OpenAPI (e.g. visible at `/docs`).
                """
            ),
        ] = None,
        include_in_schema: Annotated[
            bool,
            Doc(
                """
                To include (or not) this parameter field in the generated OpenAPI.
                You probably don't need it, but it's available.
    
                This affects the generated OpenAPI (e.g. visible at `/docs`).
                """
            ),
        ] = True,
        json_schema_extra: Annotated[
            Union[dict[str, Any], None],
            Doc(
                """
                Any additional JSON schema data.
                """
            ),
        ] = None,
        **extra: Annotated[
            Any,
            Doc(
                """
                Include extra fields used by the JSON Schema.
                """
            ),
            deprecated(
                """
                The `extra` kwargs is deprecated. Use `json_schema_extra` instead.
                """
            ),
        ],
    ) -> Any:
        return params.Cookie(
            default=default,
            default_factory=default_factory,
            alias=alias,
            alias_priority=alias_priority,
            validation_alias=validation_alias,
            serialization_alias=serialization_alias,
            title=title,
            description=description,
            gt=gt,
            ge=ge,
            lt=lt,
            le=le,
            min_length=min_length,
            max_length=max_length,
            pattern=pattern,
            regex=regex,
            discriminator=discriminator,
            strict=strict,
            multiple_of=multiple_of,
            allow_inf_nan=allow_inf_nan,
            max_digits=max_digits,
            decimal_places=decimal_places,
            example=example,
            examples=examples,
            openapi_examples=openapi_examples,
            deprecated=deprecated,
            include_in_schema=include_in_schema,
            json_schema_extra=json_schema_extra,
            **extra,
        )
      
  
---|---  
  
##  `` fastapi.Header [¶](#fastapi.Header "Permanent link")
    
    
    Header(
        default=Undefined,
        *,
        default_factory=_Unset,
        alias=None,
        alias_priority=_Unset,
        validation_alias=None,
        serialization_alias=None,
        convert_underscores=True,
        title=None,
        description=None,
        gt=None,
        ge=None,
        lt=None,
        le=None,
        min_length=None,
        max_length=None,
        pattern=None,
        regex=None,
        discriminator=None,
        strict=_Unset,
        multiple_of=_Unset,
        allow_inf_nan=_Unset,
        max_digits=_Unset,
        decimal_places=_Unset,
        examples=None,
        example=_Unset,
        openapi_examples=None,
        deprecated=None,
        include_in_schema=True,
        json_schema_extra=None,
        **extra
    )
    

PARAMETER | DESCRIPTION  
---|---  
`default` |  Default value if the parameter field is not set. **TYPE:** `Any` **DEFAULT:** `Undefined`  
`default_factory` |  A callable to generate the default value. This doesn't affect `Path` parameters as the value is always required. The parameter is available only for compatibility. **TYPE:** `Union[Callable[[], Any], None]` **DEFAULT:** `_Unset`  
`alias` |  An alternative name for the parameter field. This will be used to extract the data and for the generated OpenAPI. It is particularly useful when you can't use the name you want because it is a Python reserved keyword or similar. **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`alias_priority` |  Priority of the alias. This affects whether an alias generator is used. **TYPE:** `Union[int, None]` **DEFAULT:** `_Unset`  
`validation_alias` |  'Whitelist' validation step. The parameter field will be the single one allowed by the alias or set of aliases defined. **TYPE:** `Union[str, AliasPath, AliasChoices, None]` **DEFAULT:** `None`  
`serialization_alias` |  'Blacklist' validation step. The vanilla parameter field will be the single one of the alias' or set of aliases' fields and all the other fields will be ignored at serialization time. **TYPE:** `Union[str, None]` **DEFAULT:** `None`  
`convert_underscores` |  Automatically convert underscores to hyphens in the parameter field name. Read more about it in the [FastAPI docs for Header Parameters](https://fastapi.tiangolo.com/tutorial/header-params/#automatic-conversion) **TYPE:** `bool` **DEFAULT:** `True`  
`title` |  Human-readable title. **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`description` |  Human-readable description. **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`gt` |  Greater than. If set, value must be greater than this. Only applicable to numbers. **TYPE:** `Optional[float]` **DEFAULT:** `None`  
`ge` |  Greater than or equal. If set, value must be greater than or equal to this. Only applicable to numbers. **TYPE:** `Optional[float]` **DEFAULT:** `None`  
`lt` |  Less than. If set, value must be less than this. Only applicable to numbers. **TYPE:** `Optional[float]` **DEFAULT:** `None`  
`le` |  Less than or equal. If set, value must be less than or equal to this. Only applicable to numbers. **TYPE:** `Optional[float]` **DEFAULT:** `None`  
`min_length` |  Minimum length for strings. **TYPE:** `Optional[int]` **DEFAULT:** `None`  
`max_length` |  Maximum length for strings. **TYPE:** `Optional[int]` **DEFAULT:** `None`  
`pattern` |  RegEx pattern for strings. **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`regex` |  Deprecated in FastAPI 0.100.0 and Pydantic v2, use `pattern` instead. RegEx pattern for strings. **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`discriminator` |  Parameter field name for discriminating the type in a tagged union. **TYPE:** `Union[str, None]` **DEFAULT:** `None`  
`strict` |  If `True`, strict validation is applied to the field. **TYPE:** `Union[bool, None]` **DEFAULT:** `_Unset`  
`multiple_of` |  Value must be a multiple of this. Only applicable to numbers. **TYPE:** `Union[float, None]` **DEFAULT:** `_Unset`  
`allow_inf_nan` |  Allow `inf`, `-inf`, `nan`. Only applicable to numbers. **TYPE:** `Union[bool, None]` **DEFAULT:** `_Unset`  
`max_digits` |  Maximum number of allow digits for strings. **TYPE:** `Union[int, None]` **DEFAULT:** `_Unset`  
`decimal_places` |  Maximum number of decimal places allowed for numbers. **TYPE:** `Union[int, None]` **DEFAULT:** `_Unset`  
`examples` |  Example values for this field. Read more about it in the [FastAPI docs for Declare Request Example Data](https://fastapi.tiangolo.com/tutorial/schema-extra-example/) **TYPE:** `Optional[list[Any]]` **DEFAULT:** `None`  
`example` |  Deprecated in OpenAPI 3.1.0 that now uses JSON Schema 2020-12, although still supported. Use examples instead.  **TYPE:** `Optional[Any]` **DEFAULT:** `_Unset`  
`openapi_examples` |  OpenAPI-specific examples. It will be added to the generated OpenAPI (e.g. visible at `/docs`). Swagger UI (that provides the `/docs` interface) has better support for the OpenAPI-specific examples than the JSON Schema `examples`, that's the main use case for this. Read more about it in the [FastAPI docs for Declare Request Example Data](https://fastapi.tiangolo.com/tutorial/schema-extra-example/#using-the-openapi_examples-parameter). **TYPE:** `Optional[dict[str, [Example](../openapi/models/#fastapi.openapi.models.Example "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">Example</span> \(<code>fastapi.openapi.models.Example</code>\)")]]` **DEFAULT:** `None`  
`deprecated` |  Mark this parameter field as deprecated. It will affect the generated OpenAPI (e.g. visible at `/docs`). **TYPE:** `Union[deprecated, str, bool, None]` **DEFAULT:** `None`  
`include_in_schema` |  To include (or not) this parameter field in the generated OpenAPI. You probably don't need it, but it's available. This affects the generated OpenAPI (e.g. visible at `/docs`). **TYPE:** `bool` **DEFAULT:** `True`  
`json_schema_extra` |  Any additional JSON schema data. **TYPE:** `Union[dict[str, Any], None]` **DEFAULT:** `None`  
`**extra` |  The `extra` kwargs is deprecated. Use `json_schema_extra` instead. Include extra fields used by the JSON Schema. **TYPE:** `Any` **DEFAULT:** `{}`  
Source code in `fastapi/param_functions.py`
    
    
     702
     703
     704
     705
     706
     707
     708
     709
     710
     711
     712
     713
     714
     715
     716
     717
     718
     719
     720
     721
     722
     723
     724
     725
     726
     727
     728
     729
     730
     731
     732
     733
     734
     735
     736
     737
     738
     739
     740
     741
     742
     743
     744
     745
     746
     747
     748
     749
     750
     751
     752
     753
     754
     755
     756
     757
     758
     759
     760
     761
     762
     763
     764
     765
     766
     767
     768
     769
     770
     771
     772
     773
     774
     775
     776
     777
     778
     779
     780
     781
     782
     783
     784
     785
     786
     787
     788
     789
     790
     791
     792
     793
     794
     795
     796
     797
     798
     799
     800
     801
     802
     803
     804
     805
     806
     807
     808
     809
     810
     811
     812
     813
     814
     815
     816
     817
     818
     819
     820
     821
     822
     823
     824
     825
     826
     827
     828
     829
     830
     831
     832
     833
     834
     835
     836
     837
     838
     839
     840
     841
     842
     843
     844
     845
     846
     847
     848
     849
     850
     851
     852
     853
     854
     855
     856
     857
     858
     859
     860
     861
     862
     863
     864
     865
     866
     867
     868
     869
     870
     871
     872
     873
     874
     875
     876
     877
     878
     879
     880
     881
     882
     883
     884
     885
     886
     887
     888
     889
     890
     891
     892
     893
     894
     895
     896
     897
     898
     899
     900
     901
     902
     903
     904
     905
     906
     907
     908
     909
     910
     911
     912
     913
     914
     915
     916
     917
     918
     919
     920
     921
     922
     923
     924
     925
     926
     927
     928
     929
     930
     931
     932
     933
     934
     935
     936
     937
     938
     939
     940
     941
     942
     943
     944
     945
     946
     947
     948
     949
     950
     951
     952
     953
     954
     955
     956
     957
     958
     959
     960
     961
     962
     963
     964
     965
     966
     967
     968
     969
     970
     971
     972
     973
     974
     975
     976
     977
     978
     979
     980
     981
     982
     983
     984
     985
     986
     987
     988
     989
     990
     991
     992
     993
     994
     995
     996
     997
     998
     999
    1000
    1001
    1002
    1003
    1004
    1005
    1006
    1007
    1008
    1009
    1010
    1011
    1012
    1013
    1014
    1015
    1016

| 
    
    
    def Header(  # noqa: N802
        default: Annotated[
            Any,
            Doc(
                """
                Default value if the parameter field is not set.
                """
            ),
        ] = Undefined,
        *,
        default_factory: Annotated[
            Union[Callable[[], Any], None],
            Doc(
                """
                A callable to generate the default value.
    
                This doesn't affect `Path` parameters as the value is always required.
                The parameter is available only for compatibility.
                """
            ),
        ] = _Unset,
        alias: Annotated[
            Optional[str],
            Doc(
                """
                An alternative name for the parameter field.
    
                This will be used to extract the data and for the generated OpenAPI.
                It is particularly useful when you can't use the name you want because it
                is a Python reserved keyword or similar.
                """
            ),
        ] = None,
        alias_priority: Annotated[
            Union[int, None],
            Doc(
                """
                Priority of the alias. This affects whether an alias generator is used.
                """
            ),
        ] = _Unset,
        validation_alias: Annotated[
            Union[str, AliasPath, AliasChoices, None],
            Doc(
                """
                'Whitelist' validation step. The parameter field will be the single one
                allowed by the alias or set of aliases defined.
                """
            ),
        ] = None,
        serialization_alias: Annotated[
            Union[str, None],
            Doc(
                """
                'Blacklist' validation step. The vanilla parameter field will be the
                single one of the alias' or set of aliases' fields and all the other
                fields will be ignored at serialization time.
                """
            ),
        ] = None,
        convert_underscores: Annotated[
            bool,
            Doc(
                """
                Automatically convert underscores to hyphens in the parameter field name.
    
                Read more about it in the
                [FastAPI docs for Header Parameters](https://fastapi.tiangolo.com/tutorial/header-params/#automatic-conversion)
                """
            ),
        ] = True,
        title: Annotated[
            Optional[str],
            Doc(
                """
                Human-readable title.
                """
            ),
        ] = None,
        description: Annotated[
            Optional[str],
            Doc(
                """
                Human-readable description.
                """
            ),
        ] = None,
        gt: Annotated[
            Optional[float],
            Doc(
                """
                Greater than. If set, value must be greater than this. Only applicable to
                numbers.
                """
            ),
        ] = None,
        ge: Annotated[
            Optional[float],
            Doc(
                """
                Greater than or equal. If set, value must be greater than or equal to
                this. Only applicable to numbers.
                """
            ),
        ] = None,
        lt: Annotated[
            Optional[float],
            Doc(
                """
                Less than. If set, value must be less than this. Only applicable to numbers.
                """
            ),
        ] = None,
        le: Annotated[
            Optional[float],
            Doc(
                """
                Less than or equal. If set, value must be less than or equal to this.
                Only applicable to numbers.
                """
            ),
        ] = None,
        min_length: Annotated[
            Optional[int],
            Doc(
                """
                Minimum length for strings.
                """
            ),
        ] = None,
        max_length: Annotated[
            Optional[int],
            Doc(
                """
                Maximum length for strings.
                """
            ),
        ] = None,
        pattern: Annotated[
            Optional[str],
            Doc(
                """
                RegEx pattern for strings.
                """
            ),
        ] = None,
        regex: Annotated[
            Optional[str],
            Doc(
                """
                RegEx pattern for strings.
                """
            ),
            deprecated(
                "Deprecated in FastAPI 0.100.0 and Pydantic v2, use `pattern` instead."
            ),
        ] = None,
        discriminator: Annotated[
            Union[str, None],
            Doc(
                """
                Parameter field name for discriminating the type in a tagged union.
                """
            ),
        ] = None,
        strict: Annotated[
            Union[bool, None],
            Doc(
                """
                If `True`, strict validation is applied to the field.
                """
            ),
        ] = _Unset,
        multiple_of: Annotated[
            Union[float, None],
            Doc(
                """
                Value must be a multiple of this. Only applicable to numbers.
                """
            ),
        ] = _Unset,
        allow_inf_nan: Annotated[
            Union[bool, None],
            Doc(
                """
                Allow `inf`, `-inf`, `nan`. Only applicable to numbers.
                """
            ),
        ] = _Unset,
        max_digits: Annotated[
            Union[int, None],
            Doc(
                """
                Maximum number of allow digits for strings.
                """
            ),
        ] = _Unset,
        decimal_places: Annotated[
            Union[int, None],
            Doc(
                """
                Maximum number of decimal places allowed for numbers.
                """
            ),
        ] = _Unset,
        examples: Annotated[
            Optional[list[Any]],
            Doc(
                """
                Example values for this field.
    
                Read more about it in the
                [FastAPI docs for Declare Request Example Data](https://fastapi.tiangolo.com/tutorial/schema-extra-example/)
                """
            ),
        ] = None,
        example: Annotated[
            Optional[Any],
            deprecated(
                "Deprecated in OpenAPI 3.1.0 that now uses JSON Schema 2020-12, "
                "although still supported. Use examples instead."
            ),
        ] = _Unset,
        openapi_examples: Annotated[
            Optional[dict[str, Example]],
            Doc(
                """
                OpenAPI-specific examples.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
    
                Swagger UI (that provides the `/docs` interface) has better support for the
                OpenAPI-specific examples than the JSON Schema `examples`, that's the main
                use case for this.
    
                Read more about it in the
                [FastAPI docs for Declare Request Example Data](https://fastapi.tiangolo.com/tutorial/schema-extra-example/#using-the-openapi_examples-parameter).
                """
            ),
        ] = None,
        deprecated: Annotated[
            Union[deprecated, str, bool, None],
            Doc(
                """
                Mark this parameter field as deprecated.
    
                It will affect the generated OpenAPI (e.g. visible at `/docs`).
                """
            ),
        ] = None,
        include_in_schema: Annotated[
            bool,
            Doc(
                """
                To include (or not) this parameter field in the generated OpenAPI.
                You probably don't need it, but it's available.
    
                This affects the generated OpenAPI (e.g. visible at `/docs`).
                """
            ),
        ] = True,
        json_schema_extra: Annotated[
            Union[dict[str, Any], None],
            Doc(
                """
                Any additional JSON schema data.
                """
            ),
        ] = None,
        **extra: Annotated[
            Any,
            Doc(
                """
                Include extra fields used by the JSON Schema.
                """
            ),
            deprecated(
                """
                The `extra` kwargs is deprecated. Use `json_schema_extra` instead.
                """
            ),
        ],
    ) -> Any:
        return params.Header(
            default=default,
            default_factory=default_factory,
            alias=alias,
            alias_priority=alias_priority,
            validation_alias=validation_alias,
            serialization_alias=serialization_alias,
            convert_underscores=convert_underscores,
            title=title,
            description=description,
            gt=gt,
            ge=ge,
            lt=lt,
            le=le,
            min_length=min_length,
            max_length=max_length,
            pattern=pattern,
            regex=regex,
            discriminator=discriminator,
            strict=strict,
            multiple_of=multiple_of,
            allow_inf_nan=allow_inf_nan,
            max_digits=max_digits,
            decimal_places=decimal_places,
            example=example,
            examples=examples,
            openapi_examples=openapi_examples,
            deprecated=deprecated,
            include_in_schema=include_in_schema,
            json_schema_extra=json_schema_extra,
            **extra,
        )
      
  
---|---  
  
##  `` fastapi.Form [¶](#fastapi.Form "Permanent link")
    
    
    Form(
        default=Undefined,
        *,
        default_factory=_Unset,
        media_type="application/x-www-form-urlencoded",
        alias=None,
        alias_priority=_Unset,
        validation_alias=None,
        serialization_alias=None,
        title=None,
        description=None,
        gt=None,
        ge=None,
        lt=None,
        le=None,
        min_length=None,
        max_length=None,
        pattern=None,
        regex=None,
        discriminator=None,
        strict=_Unset,
        multiple_of=_Unset,
        allow_inf_nan=_Unset,
        max_digits=_Unset,
        decimal_places=_Unset,
        examples=None,
        example=_Unset,
        openapi_examples=None,
        deprecated=None,
        include_in_schema=True,
        json_schema_extra=None,
        **extra
    )
    

PARAMETER | DESCRIPTION  
---|---  
`default` |  Default value if the parameter field is not set. **TYPE:** `Any` **DEFAULT:** `Undefined`  
`default_factory` |  A callable to generate the default value. This doesn't affect `Path` parameters as the value is always required. The parameter is available only for compatibility. **TYPE:** `Union[Callable[[], Any], None]` **DEFAULT:** `_Unset`  
`media_type` |  The media type of this parameter field. Changing it would affect the generated OpenAPI, but currently it doesn't affect the parsing of the data. **TYPE:** `str` **DEFAULT:** `'application/x-www-form-urlencoded'`  
`alias` |  An alternative name for the parameter field. This will be used to extract the data and for the generated OpenAPI. It is particularly useful when you can't use the name you want because it is a Python reserved keyword or similar. **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`alias_priority` |  Priority of the alias. This affects whether an alias generator is used. **TYPE:** `Union[int, None]` **DEFAULT:** `_Unset`  
`validation_alias` |  'Whitelist' validation step. The parameter field will be the single one allowed by the alias or set of aliases defined. **TYPE:** `Union[str, AliasPath, AliasChoices, None]` **DEFAULT:** `None`  
`serialization_alias` |  'Blacklist' validation step. The vanilla parameter field will be the single one of the alias' or set of aliases' fields and all the other fields will be ignored at serialization time. **TYPE:** `Union[str, None]` **DEFAULT:** `None`  
`title` |  Human-readable title. **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`description` |  Human-readable description. **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`gt` |  Greater than. If set, value must be greater than this. Only applicable to numbers. **TYPE:** `Optional[float]` **DEFAULT:** `None`  
`ge` |  Greater than or equal. If set, value must be greater than or equal to this. Only applicable to numbers. **TYPE:** `Optional[float]` **DEFAULT:** `None`  
`lt` |  Less than. If set, value must be less than this. Only applicable to numbers. **TYPE:** `Optional[float]` **DEFAULT:** `None`  
`le` |  Less than or equal. If set, value must be less than or equal to this. Only applicable to numbers. **TYPE:** `Optional[float]` **DEFAULT:** `None`  
`min_length` |  Minimum length for strings. **TYPE:** `Optional[int]` **DEFAULT:** `None`  
`max_length` |  Maximum length for strings. **TYPE:** `Optional[int]` **DEFAULT:** `None`  
`pattern` |  RegEx pattern for strings. **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`regex` |  Deprecated in FastAPI 0.100.0 and Pydantic v2, use `pattern` instead. RegEx pattern for strings. **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`discriminator` |  Parameter field name for discriminating the type in a tagged union. **TYPE:** `Union[str, None]` **DEFAULT:** `None`  
`strict` |  If `True`, strict validation is applied to the field. **TYPE:** `Union[bool, None]` **DEFAULT:** `_Unset`  
`multiple_of` |  Value must be a multiple of this. Only applicable to numbers. **TYPE:** `Union[float, None]` **DEFAULT:** `_Unset`  
`allow_inf_nan` |  Allow `inf`, `-inf`, `nan`. Only applicable to numbers. **TYPE:** `Union[bool, None]` **DEFAULT:** `_Unset`  
`max_digits` |  Maximum number of allow digits for strings. **TYPE:** `Union[int, None]` **DEFAULT:** `_Unset`  
`decimal_places` |  Maximum number of decimal places allowed for numbers. **TYPE:** `Union[int, None]` **DEFAULT:** `_Unset`  
`examples` |  Example values for this field. Read more about it in the [FastAPI docs for Declare Request Example Data](https://fastapi.tiangolo.com/tutorial/schema-extra-example/) **TYPE:** `Optional[list[Any]]` **DEFAULT:** `None`  
`example` |  Deprecated in OpenAPI 3.1.0 that now uses JSON Schema 2020-12, although still supported. Use examples instead.  **TYPE:** `Optional[Any]` **DEFAULT:** `_Unset`  
`openapi_examples` |  OpenAPI-specific examples. It will be added to the generated OpenAPI (e.g. visible at `/docs`). Swagger UI (that provides the `/docs` interface) has better support for the OpenAPI-specific examples than the JSON Schema `examples`, that's the main use case for this. Read more about it in the [FastAPI docs for Declare Request Example Data](https://fastapi.tiangolo.com/tutorial/schema-extra-example/#using-the-openapi_examples-parameter). **TYPE:** `Optional[dict[str, [Example](../openapi/models/#fastapi.openapi.models.Example "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">Example</span> \(<code>fastapi.openapi.models.Example</code>\)")]]` **DEFAULT:** `None`  
`deprecated` |  Mark this parameter field as deprecated. It will affect the generated OpenAPI (e.g. visible at `/docs`). **TYPE:** `Union[deprecated, str, bool, None]` **DEFAULT:** `None`  
`include_in_schema` |  To include (or not) this parameter field in the generated OpenAPI. You probably don't need it, but it's available. This affects the generated OpenAPI (e.g. visible at `/docs`). **TYPE:** `bool` **DEFAULT:** `True`  
`json_schema_extra` |  Any additional JSON schema data. **TYPE:** `Union[dict[str, Any], None]` **DEFAULT:** `None`  
`**extra` |  The `extra` kwargs is deprecated. Use `json_schema_extra` instead. Include extra fields used by the JSON Schema. **TYPE:** `Any` **DEFAULT:** `{}`  
Source code in `fastapi/param_functions.py`
    
    
    1654
    1655
    1656
    1657
    1658
    1659
    1660
    1661
    1662
    1663
    1664
    1665
    1666
    1667
    1668
    1669
    1670
    1671
    1672
    1673
    1674
    1675
    1676
    1677
    1678
    1679
    1680
    1681
    1682
    1683
    1684
    1685
    1686
    1687
    1688
    1689
    1690
    1691
    1692
    1693
    1694
    1695
    1696
    1697
    1698
    1699
    1700
    1701
    1702
    1703
    1704
    1705
    1706
    1707
    1708
    1709
    1710
    1711
    1712
    1713
    1714
    1715
    1716
    1717
    1718
    1719
    1720
    1721
    1722
    1723
    1724
    1725
    1726
    1727
    1728
    1729
    1730
    1731
    1732
    1733
    1734
    1735
    1736
    1737
    1738
    1739
    1740
    1741
    1742
    1743
    1744
    1745
    1746
    1747
    1748
    1749
    1750
    1751
    1752
    1753
    1754
    1755
    1756
    1757
    1758
    1759
    1760
    1761
    1762
    1763
    1764
    1765
    1766
    1767
    1768
    1769
    1770
    1771
    1772
    1773
    1774
    1775
    1776
    1777
    1778
    1779
    1780
    1781
    1782
    1783
    1784
    1785
    1786
    1787
    1788
    1789
    1790
    1791
    1792
    1793
    1794
    1795
    1796
    1797
    1798
    1799
    1800
    1801
    1802
    1803
    1804
    1805
    1806
    1807
    1808
    1809
    1810
    1811
    1812
    1813
    1814
    1815
    1816
    1817
    1818
    1819
    1820
    1821
    1822
    1823
    1824
    1825
    1826
    1827
    1828
    1829
    1830
    1831
    1832
    1833
    1834
    1835
    1836
    1837
    1838
    1839
    1840
    1841
    1842
    1843
    1844
    1845
    1846
    1847
    1848
    1849
    1850
    1851
    1852
    1853
    1854
    1855
    1856
    1857
    1858
    1859
    1860
    1861
    1862
    1863
    1864
    1865
    1866
    1867
    1868
    1869
    1870
    1871
    1872
    1873
    1874
    1875
    1876
    1877
    1878
    1879
    1880
    1881
    1882
    1883
    1884
    1885
    1886
    1887
    1888
    1889
    1890
    1891
    1892
    1893
    1894
    1895
    1896
    1897
    1898
    1899
    1900
    1901
    1902
    1903
    1904
    1905
    1906
    1907
    1908
    1909
    1910
    1911
    1912
    1913
    1914
    1915
    1916
    1917
    1918
    1919
    1920
    1921
    1922
    1923
    1924
    1925
    1926
    1927
    1928
    1929
    1930
    1931
    1932
    1933
    1934
    1935
    1936
    1937
    1938
    1939
    1940
    1941
    1942
    1943
    1944
    1945
    1946
    1947
    1948
    1949
    1950
    1951
    1952
    1953
    1954
    1955
    1956
    1957
    1958
    1959
    1960
    1961
    1962
    1963
    1964
    1965
    1966

| 
    
    
    def Form(  # noqa: N802
        default: Annotated[
            Any,
            Doc(
                """
                Default value if the parameter field is not set.
                """
            ),
        ] = Undefined,
        *,
        default_factory: Annotated[
            Union[Callable[[], Any], None],
            Doc(
                """
                A callable to generate the default value.
    
                This doesn't affect `Path` parameters as the value is always required.
                The parameter is available only for compatibility.
                """
            ),
        ] = _Unset,
        media_type: Annotated[
            str,
            Doc(
                """
                The media type of this parameter field. Changing it would affect the
                generated OpenAPI, but currently it doesn't affect the parsing of the data.
                """
            ),
        ] = "application/x-www-form-urlencoded",
        alias: Annotated[
            Optional[str],
            Doc(
                """
                An alternative name for the parameter field.
    
                This will be used to extract the data and for the generated OpenAPI.
                It is particularly useful when you can't use the name you want because it
                is a Python reserved keyword or similar.
                """
            ),
        ] = None,
        alias_priority: Annotated[
            Union[int, None],
            Doc(
                """
                Priority of the alias. This affects whether an alias generator is used.
                """
            ),
        ] = _Unset,
        validation_alias: Annotated[
            Union[str, AliasPath, AliasChoices, None],
            Doc(
                """
                'Whitelist' validation step. The parameter field will be the single one
                allowed by the alias or set of aliases defined.
                """
            ),
        ] = None,
        serialization_alias: Annotated[
            Union[str, None],
            Doc(
                """
                'Blacklist' validation step. The vanilla parameter field will be the
                single one of the alias' or set of aliases' fields and all the other
                fields will be ignored at serialization time.
                """
            ),
        ] = None,
        title: Annotated[
            Optional[str],
            Doc(
                """
                Human-readable title.
                """
            ),
        ] = None,
        description: Annotated[
            Optional[str],
            Doc(
                """
                Human-readable description.
                """
            ),
        ] = None,
        gt: Annotated[
            Optional[float],
            Doc(
                """
                Greater than. If set, value must be greater than this. Only applicable to
                numbers.
                """
            ),
        ] = None,
        ge: Annotated[
            Optional[float],
            Doc(
                """
                Greater than or equal. If set, value must be greater than or equal to
                this. Only applicable to numbers.
                """
            ),
        ] = None,
        lt: Annotated[
            Optional[float],
            Doc(
                """
                Less than. If set, value must be less than this. Only applicable to numbers.
                """
            ),
        ] = None,
        le: Annotated[
            Optional[float],
            Doc(
                """
                Less than or equal. If set, value must be less than or equal to this.
                Only applicable to numbers.
                """
            ),
        ] = None,
        min_length: Annotated[
            Optional[int],
            Doc(
                """
                Minimum length for strings.
                """
            ),
        ] = None,
        max_length: Annotated[
            Optional[int],
            Doc(
                """
                Maximum length for strings.
                """
            ),
        ] = None,
        pattern: Annotated[
            Optional[str],
            Doc(
                """
                RegEx pattern for strings.
                """
            ),
        ] = None,
        regex: Annotated[
            Optional[str],
            Doc(
                """
                RegEx pattern for strings.
                """
            ),
            deprecated(
                "Deprecated in FastAPI 0.100.0 and Pydantic v2, use `pattern` instead."
            ),
        ] = None,
        discriminator: Annotated[
            Union[str, None],
            Doc(
                """
                Parameter field name for discriminating the type in a tagged union.
                """
            ),
        ] = None,
        strict: Annotated[
            Union[bool, None],
            Doc(
                """
                If `True`, strict validation is applied to the field.
                """
            ),
        ] = _Unset,
        multiple_of: Annotated[
            Union[float, None],
            Doc(
                """
                Value must be a multiple of this. Only applicable to numbers.
                """
            ),
        ] = _Unset,
        allow_inf_nan: Annotated[
            Union[bool, None],
            Doc(
                """
                Allow `inf`, `-inf`, `nan`. Only applicable to numbers.
                """
            ),
        ] = _Unset,
        max_digits: Annotated[
            Union[int, None],
            Doc(
                """
                Maximum number of allow digits for strings.
                """
            ),
        ] = _Unset,
        decimal_places: Annotated[
            Union[int, None],
            Doc(
                """
                Maximum number of decimal places allowed for numbers.
                """
            ),
        ] = _Unset,
        examples: Annotated[
            Optional[list[Any]],
            Doc(
                """
                Example values for this field.
    
                Read more about it in the
                [FastAPI docs for Declare Request Example Data](https://fastapi.tiangolo.com/tutorial/schema-extra-example/)
                """
            ),
        ] = None,
        example: Annotated[
            Optional[Any],
            deprecated(
                "Deprecated in OpenAPI 3.1.0 that now uses JSON Schema 2020-12, "
                "although still supported. Use examples instead."
            ),
        ] = _Unset,
        openapi_examples: Annotated[
            Optional[dict[str, Example]],
            Doc(
                """
                OpenAPI-specific examples.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
    
                Swagger UI (that provides the `/docs` interface) has better support for the
                OpenAPI-specific examples than the JSON Schema `examples`, that's the main
                use case for this.
    
                Read more about it in the
                [FastAPI docs for Declare Request Example Data](https://fastapi.tiangolo.com/tutorial/schema-extra-example/#using-the-openapi_examples-parameter).
                """
            ),
        ] = None,
        deprecated: Annotated[
            Union[deprecated, str, bool, None],
            Doc(
                """
                Mark this parameter field as deprecated.
    
                It will affect the generated OpenAPI (e.g. visible at `/docs`).
                """
            ),
        ] = None,
        include_in_schema: Annotated[
            bool,
            Doc(
                """
                To include (or not) this parameter field in the generated OpenAPI.
                You probably don't need it, but it's available.
    
                This affects the generated OpenAPI (e.g. visible at `/docs`).
                """
            ),
        ] = True,
        json_schema_extra: Annotated[
            Union[dict[str, Any], None],
            Doc(
                """
                Any additional JSON schema data.
                """
            ),
        ] = None,
        **extra: Annotated[
            Any,
            Doc(
                """
                Include extra fields used by the JSON Schema.
                """
            ),
            deprecated(
                """
                The `extra` kwargs is deprecated. Use `json_schema_extra` instead.
                """
            ),
        ],
    ) -> Any:
        return params.Form(
            default=default,
            default_factory=default_factory,
            media_type=media_type,
            alias=alias,
            alias_priority=alias_priority,
            validation_alias=validation_alias,
            serialization_alias=serialization_alias,
            title=title,
            description=description,
            gt=gt,
            ge=ge,
            lt=lt,
            le=le,
            min_length=min_length,
            max_length=max_length,
            pattern=pattern,
            regex=regex,
            discriminator=discriminator,
            strict=strict,
            multiple_of=multiple_of,
            allow_inf_nan=allow_inf_nan,
            max_digits=max_digits,
            decimal_places=decimal_places,
            example=example,
            examples=examples,
            openapi_examples=openapi_examples,
            deprecated=deprecated,
            include_in_schema=include_in_schema,
            json_schema_extra=json_schema_extra,
            **extra,
        )
      
  
---|---  
  
##  `` fastapi.File [¶](#fastapi.File "Permanent link")
    
    
    File(
        default=Undefined,
        *,
        default_factory=_Unset,
        media_type="multipart/form-data",
        alias=None,
        alias_priority=_Unset,
        validation_alias=None,
        serialization_alias=None,
        title=None,
        description=None,
        gt=None,
        ge=None,
        lt=None,
        le=None,
        min_length=None,
        max_length=None,
        pattern=None,
        regex=None,
        discriminator=None,
        strict=_Unset,
        multiple_of=_Unset,
        allow_inf_nan=_Unset,
        max_digits=_Unset,
        decimal_places=_Unset,
        examples=None,
        example=_Unset,
        openapi_examples=None,
        deprecated=None,
        include_in_schema=True,
        json_schema_extra=None,
        **extra
    )
    

PARAMETER | DESCRIPTION  
---|---  
`default` |  Default value if the parameter field is not set. **TYPE:** `Any` **DEFAULT:** `Undefined`  
`default_factory` |  A callable to generate the default value. This doesn't affect `Path` parameters as the value is always required. The parameter is available only for compatibility. **TYPE:** `Union[Callable[[], Any], None]` **DEFAULT:** `_Unset`  
`media_type` |  The media type of this parameter field. Changing it would affect the generated OpenAPI, but currently it doesn't affect the parsing of the data. **TYPE:** `str` **DEFAULT:** `'multipart/form-data'`  
`alias` |  An alternative name for the parameter field. This will be used to extract the data and for the generated OpenAPI. It is particularly useful when you can't use the name you want because it is a Python reserved keyword or similar. **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`alias_priority` |  Priority of the alias. This affects whether an alias generator is used. **TYPE:** `Union[int, None]` **DEFAULT:** `_Unset`  
`validation_alias` |  'Whitelist' validation step. The parameter field will be the single one allowed by the alias or set of aliases defined. **TYPE:** `Union[str, AliasPath, AliasChoices, None]` **DEFAULT:** `None`  
`serialization_alias` |  'Blacklist' validation step. The vanilla parameter field will be the single one of the alias' or set of aliases' fields and all the other fields will be ignored at serialization time. **TYPE:** `Union[str, None]` **DEFAULT:** `None`  
`title` |  Human-readable title. **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`description` |  Human-readable description. **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`gt` |  Greater than. If set, value must be greater than this. Only applicable to numbers. **TYPE:** `Optional[float]` **DEFAULT:** `None`  
`ge` |  Greater than or equal. If set, value must be greater than or equal to this. Only applicable to numbers. **TYPE:** `Optional[float]` **DEFAULT:** `None`  
`lt` |  Less than. If set, value must be less than this. Only applicable to numbers. **TYPE:** `Optional[float]` **DEFAULT:** `None`  
`le` |  Less than or equal. If set, value must be less than or equal to this. Only applicable to numbers. **TYPE:** `Optional[float]` **DEFAULT:** `None`  
`min_length` |  Minimum length for strings. **TYPE:** `Optional[int]` **DEFAULT:** `None`  
`max_length` |  Maximum length for strings. **TYPE:** `Optional[int]` **DEFAULT:** `None`  
`pattern` |  RegEx pattern for strings. **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`regex` |  Deprecated in FastAPI 0.100.0 and Pydantic v2, use `pattern` instead. RegEx pattern for strings. **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`discriminator` |  Parameter field name for discriminating the type in a tagged union. **TYPE:** `Union[str, None]` **DEFAULT:** `None`  
`strict` |  If `True`, strict validation is applied to the field. **TYPE:** `Union[bool, None]` **DEFAULT:** `_Unset`  
`multiple_of` |  Value must be a multiple of this. Only applicable to numbers. **TYPE:** `Union[float, None]` **DEFAULT:** `_Unset`  
`allow_inf_nan` |  Allow `inf`, `-inf`, `nan`. Only applicable to numbers. **TYPE:** `Union[bool, None]` **DEFAULT:** `_Unset`  
`max_digits` |  Maximum number of allow digits for strings. **TYPE:** `Union[int, None]` **DEFAULT:** `_Unset`  
`decimal_places` |  Maximum number of decimal places allowed for numbers. **TYPE:** `Union[int, None]` **DEFAULT:** `_Unset`  
`examples` |  Example values for this field. Read more about it in the [FastAPI docs for Declare Request Example Data](https://fastapi.tiangolo.com/tutorial/schema-extra-example/) **TYPE:** `Optional[list[Any]]` **DEFAULT:** `None`  
`example` |  Deprecated in OpenAPI 3.1.0 that now uses JSON Schema 2020-12, although still supported. Use examples instead.  **TYPE:** `Optional[Any]` **DEFAULT:** `_Unset`  
`openapi_examples` |  OpenAPI-specific examples. It will be added to the generated OpenAPI (e.g. visible at `/docs`). Swagger UI (that provides the `/docs` interface) has better support for the OpenAPI-specific examples than the JSON Schema `examples`, that's the main use case for this. Read more about it in the [FastAPI docs for Declare Request Example Data](https://fastapi.tiangolo.com/tutorial/schema-extra-example/#using-the-openapi_examples-parameter). **TYPE:** `Optional[dict[str, [Example](../openapi/models/#fastapi.openapi.models.Example "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">Example</span> \(<code>fastapi.openapi.models.Example</code>\)")]]` **DEFAULT:** `None`  
`deprecated` |  Mark this parameter field as deprecated. It will affect the generated OpenAPI (e.g. visible at `/docs`). **TYPE:** `Union[deprecated, str, bool, None]` **DEFAULT:** `None`  
`include_in_schema` |  To include (or not) this parameter field in the generated OpenAPI. You probably don't need it, but it's available. This affects the generated OpenAPI (e.g. visible at `/docs`). **TYPE:** `bool` **DEFAULT:** `True`  
`json_schema_extra` |  Any additional JSON schema data. **TYPE:** `Union[dict[str, Any], None]` **DEFAULT:** `None`  
`**extra` |  The `extra` kwargs is deprecated. Use `json_schema_extra` instead. Include extra fields used by the JSON Schema. **TYPE:** `Any` **DEFAULT:** `{}`  
Source code in `fastapi/param_functions.py`
    
    
    1969
    1970
    1971
    1972
    1973
    1974
    1975
    1976
    1977
    1978
    1979
    1980
    1981
    1982
    1983
    1984
    1985
    1986
    1987
    1988
    1989
    1990
    1991
    1992
    1993
    1994
    1995
    1996
    1997
    1998
    1999
    2000
    2001
    2002
    2003
    2004
    2005
    2006
    2007
    2008
    2009
    2010
    2011
    2012
    2013
    2014
    2015
    2016
    2017
    2018
    2019
    2020
    2021
    2022
    2023
    2024
    2025
    2026
    2027
    2028
    2029
    2030
    2031
    2032
    2033
    2034
    2035
    2036
    2037
    2038
    2039
    2040
    2041
    2042
    2043
    2044
    2045
    2046
    2047
    2048
    2049
    2050
    2051
    2052
    2053
    2054
    2055
    2056
    2057
    2058
    2059
    2060
    2061
    2062
    2063
    2064
    2065
    2066
    2067
    2068
    2069
    2070
    2071
    2072
    2073
    2074
    2075
    2076
    2077
    2078
    2079
    2080
    2081
    2082
    2083
    2084
    2085
    2086
    2087
    2088
    2089
    2090
    2091
    2092
    2093
    2094
    2095
    2096
    2097
    2098
    2099
    2100
    2101
    2102
    2103
    2104
    2105
    2106
    2107
    2108
    2109
    2110
    2111
    2112
    2113
    2114
    2115
    2116
    2117
    2118
    2119
    2120
    2121
    2122
    2123
    2124
    2125
    2126
    2127
    2128
    2129
    2130
    2131
    2132
    2133
    2134
    2135
    2136
    2137
    2138
    2139
    2140
    2141
    2142
    2143
    2144
    2145
    2146
    2147
    2148
    2149
    2150
    2151
    2152
    2153
    2154
    2155
    2156
    2157
    2158
    2159
    2160
    2161
    2162
    2163
    2164
    2165
    2166
    2167
    2168
    2169
    2170
    2171
    2172
    2173
    2174
    2175
    2176
    2177
    2178
    2179
    2180
    2181
    2182
    2183
    2184
    2185
    2186
    2187
    2188
    2189
    2190
    2191
    2192
    2193
    2194
    2195
    2196
    2197
    2198
    2199
    2200
    2201
    2202
    2203
    2204
    2205
    2206
    2207
    2208
    2209
    2210
    2211
    2212
    2213
    2214
    2215
    2216
    2217
    2218
    2219
    2220
    2221
    2222
    2223
    2224
    2225
    2226
    2227
    2228
    2229
    2230
    2231
    2232
    2233
    2234
    2235
    2236
    2237
    2238
    2239
    2240
    2241
    2242
    2243
    2244
    2245
    2246
    2247
    2248
    2249
    2250
    2251
    2252
    2253
    2254
    2255
    2256
    2257
    2258
    2259
    2260
    2261
    2262
    2263
    2264
    2265
    2266
    2267
    2268
    2269
    2270
    2271
    2272
    2273
    2274
    2275
    2276
    2277
    2278
    2279
    2280
    2281

| 
    
    
    def File(  # noqa: N802
        default: Annotated[
            Any,
            Doc(
                """
                Default value if the parameter field is not set.
                """
            ),
        ] = Undefined,
        *,
        default_factory: Annotated[
            Union[Callable[[], Any], None],
            Doc(
                """
                A callable to generate the default value.
    
                This doesn't affect `Path` parameters as the value is always required.
                The parameter is available only for compatibility.
                """
            ),
        ] = _Unset,
        media_type: Annotated[
            str,
            Doc(
                """
                The media type of this parameter field. Changing it would affect the
                generated OpenAPI, but currently it doesn't affect the parsing of the data.
                """
            ),
        ] = "multipart/form-data",
        alias: Annotated[
            Optional[str],
            Doc(
                """
                An alternative name for the parameter field.
    
                This will be used to extract the data and for the generated OpenAPI.
                It is particularly useful when you can't use the name you want because it
                is a Python reserved keyword or similar.
                """
            ),
        ] = None,
        alias_priority: Annotated[
            Union[int, None],
            Doc(
                """
                Priority of the alias. This affects whether an alias generator is used.
                """
            ),
        ] = _Unset,
        validation_alias: Annotated[
            Union[str, AliasPath, AliasChoices, None],
            Doc(
                """
                'Whitelist' validation step. The parameter field will be the single one
                allowed by the alias or set of aliases defined.
                """
            ),
        ] = None,
        serialization_alias: Annotated[
            Union[str, None],
            Doc(
                """
                'Blacklist' validation step. The vanilla parameter field will be the
                single one of the alias' or set of aliases' fields and all the other
                fields will be ignored at serialization time.
                """
            ),
        ] = None,
        title: Annotated[
            Optional[str],
            Doc(
                """
                Human-readable title.
                """
            ),
        ] = None,
        description: Annotated[
            Optional[str],
            Doc(
                """
                Human-readable description.
                """
            ),
        ] = None,
        gt: Annotated[
            Optional[float],
            Doc(
                """
                Greater than. If set, value must be greater than this. Only applicable to
                numbers.
                """
            ),
        ] = None,
        ge: Annotated[
            Optional[float],
            Doc(
                """
                Greater than or equal. If set, value must be greater than or equal to
                this. Only applicable to numbers.
                """
            ),
        ] = None,
        lt: Annotated[
            Optional[float],
            Doc(
                """
                Less than. If set, value must be less than this. Only applicable to numbers.
                """
            ),
        ] = None,
        le: Annotated[
            Optional[float],
            Doc(
                """
                Less than or equal. If set, value must be less than or equal to this.
                Only applicable to numbers.
                """
            ),
        ] = None,
        min_length: Annotated[
            Optional[int],
            Doc(
                """
                Minimum length for strings.
                """
            ),
        ] = None,
        max_length: Annotated[
            Optional[int],
            Doc(
                """
                Maximum length for strings.
                """
            ),
        ] = None,
        pattern: Annotated[
            Optional[str],
            Doc(
                """
                RegEx pattern for strings.
                """
            ),
        ] = None,
        regex: Annotated[
            Optional[str],
            Doc(
                """
                RegEx pattern for strings.
                """
            ),
            deprecated(
                "Deprecated in FastAPI 0.100.0 and Pydantic v2, use `pattern` instead."
            ),
        ] = None,
        discriminator: Annotated[
            Union[str, None],
            Doc(
                """
                Parameter field name for discriminating the type in a tagged union.
                """
            ),
        ] = None,
        strict: Annotated[
            Union[bool, None],
            Doc(
                """
                If `True`, strict validation is applied to the field.
                """
            ),
        ] = _Unset,
        multiple_of: Annotated[
            Union[float, None],
            Doc(
                """
                Value must be a multiple of this. Only applicable to numbers.
                """
            ),
        ] = _Unset,
        allow_inf_nan: Annotated[
            Union[bool, None],
            Doc(
                """
                Allow `inf`, `-inf`, `nan`. Only applicable to numbers.
                """
            ),
        ] = _Unset,
        max_digits: Annotated[
            Union[int, None],
            Doc(
                """
                Maximum number of allow digits for strings.
                """
            ),
        ] = _Unset,
        decimal_places: Annotated[
            Union[int, None],
            Doc(
                """
                Maximum number of decimal places allowed for numbers.
                """
            ),
        ] = _Unset,
        examples: Annotated[
            Optional[list[Any]],
            Doc(
                """
                Example values for this field.
    
                Read more about it in the
                [FastAPI docs for Declare Request Example Data](https://fastapi.tiangolo.com/tutorial/schema-extra-example/)
                """
            ),
        ] = None,
        example: Annotated[
            Optional[Any],
            deprecated(
                "Deprecated in OpenAPI 3.1.0 that now uses JSON Schema 2020-12, "
                "although still supported. Use examples instead."
            ),
        ] = _Unset,
        openapi_examples: Annotated[
            Optional[dict[str, Example]],
            Doc(
                """
                OpenAPI-specific examples.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
    
                Swagger UI (that provides the `/docs` interface) has better support for the
                OpenAPI-specific examples than the JSON Schema `examples`, that's the main
                use case for this.
    
                Read more about it in the
                [FastAPI docs for Declare Request Example Data](https://fastapi.tiangolo.com/tutorial/schema-extra-example/#using-the-openapi_examples-parameter).
                """
            ),
        ] = None,
        deprecated: Annotated[
            Union[deprecated, str, bool, None],
            Doc(
                """
                Mark this parameter field as deprecated.
    
                It will affect the generated OpenAPI (e.g. visible at `/docs`).
                """
            ),
        ] = None,
        include_in_schema: Annotated[
            bool,
            Doc(
                """
                To include (or not) this parameter field in the generated OpenAPI.
                You probably don't need it, but it's available.
    
                This affects the generated OpenAPI (e.g. visible at `/docs`).
                """
            ),
        ] = True,
        json_schema_extra: Annotated[
            Union[dict[str, Any], None],
            Doc(
                """
                Any additional JSON schema data.
                """
            ),
        ] = None,
        **extra: Annotated[
            Any,
            Doc(
                """
                Include extra fields used by the JSON Schema.
                """
            ),
            deprecated(
                """
                The `extra` kwargs is deprecated. Use `json_schema_extra` instead.
                """
            ),
        ],
    ) -> Any:
        return params.File(
            default=default,
            default_factory=default_factory,
            media_type=media_type,
            alias=alias,
            alias_priority=alias_priority,
            validation_alias=validation_alias,
            serialization_alias=serialization_alias,
            title=title,
            description=description,
            gt=gt,
            ge=ge,
            lt=lt,
            le=le,
            min_length=min_length,
            max_length=max_length,
            pattern=pattern,
            regex=regex,
            discriminator=discriminator,
            strict=strict,
            multiple_of=multiple_of,
            allow_inf_nan=allow_inf_nan,
            max_digits=max_digits,
            decimal_places=decimal_places,
            example=example,
            examples=examples,
            openapi_examples=openapi_examples,
            deprecated=deprecated,
            include_in_schema=include_in_schema,
            json_schema_extra=json_schema_extra,
            **extra,
        )
      
  
---|---

---

###### Status Codes¶

# Status Codes[¶](#status-codes "Permanent link")

You can import the `status` module from `fastapi`:
    
    
    from fastapi import status
    

`status` is provided directly by Starlette.

It contains a group of named constants (variables) with integer status codes.

For example:

  * 200: `status.HTTP_200_OK`
  * 403: `status.HTTP_403_FORBIDDEN`
  * etc.

It can be convenient to quickly access HTTP (and WebSocket) status codes in your app, using autocompletion for the name without having to remember the integer status codes by memory.

Read more about it in the [FastAPI docs about Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).

## Example[¶](#example "Permanent link")
    
    
    from fastapi import FastAPI, status
    
    app = FastAPI()
    
    
    @app.get("/items/", status_code=status.HTTP_418_IM_A_TEAPOT)
    def read_items():
        return [{"name": "Plumbus"}, {"name": "Portal Gun"}]
    

##  `` fastapi.status [¶](#fastapi.status "Permanent link")

HTTP codes See HTTP Status Code Registry: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml

And RFC 9110 - https://www.rfc-editor.org/rfc/rfc9110

###  `` HTTP_100_CONTINUE `module-attribute` [¶](#fastapi.status.HTTP_100_CONTINUE "Permanent link")
    
    
    HTTP_100_CONTINUE = 100
    

###  `` HTTP_101_SWITCHING_PROTOCOLS `module-attribute` [¶](#fastapi.status.HTTP_101_SWITCHING_PROTOCOLS "Permanent link")
    
    
    HTTP_101_SWITCHING_PROTOCOLS = 101
    

###  `` HTTP_102_PROCESSING `module-attribute` [¶](#fastapi.status.HTTP_102_PROCESSING "Permanent link")
    
    
    HTTP_102_PROCESSING = 102
    

###  `` HTTP_103_EARLY_HINTS `module-attribute` [¶](#fastapi.status.HTTP_103_EARLY_HINTS "Permanent link")
    
    
    HTTP_103_EARLY_HINTS = 103
    

###  `` HTTP_200_OK `module-attribute` [¶](#fastapi.status.HTTP_200_OK "Permanent link")
    
    
    HTTP_200_OK = 200
    

###  `` HTTP_201_CREATED `module-attribute` [¶](#fastapi.status.HTTP_201_CREATED "Permanent link")
    
    
    HTTP_201_CREATED = 201
    

###  `` HTTP_202_ACCEPTED `module-attribute` [¶](#fastapi.status.HTTP_202_ACCEPTED "Permanent link")
    
    
    HTTP_202_ACCEPTED = 202
    

###  `` HTTP_203_NON_AUTHORITATIVE_INFORMATION `module-attribute` [¶](#fastapi.status.HTTP_203_NON_AUTHORITATIVE_INFORMATION "Permanent link")
    
    
    HTTP_203_NON_AUTHORITATIVE_INFORMATION = 203
    

###  `` HTTP_204_NO_CONTENT `module-attribute` [¶](#fastapi.status.HTTP_204_NO_CONTENT "Permanent link")
    
    
    HTTP_204_NO_CONTENT = 204
    

###  `` HTTP_205_RESET_CONTENT `module-attribute` [¶](#fastapi.status.HTTP_205_RESET_CONTENT "Permanent link")
    
    
    HTTP_205_RESET_CONTENT = 205
    

###  `` HTTP_206_PARTIAL_CONTENT `module-attribute` [¶](#fastapi.status.HTTP_206_PARTIAL_CONTENT "Permanent link")
    
    
    HTTP_206_PARTIAL_CONTENT = 206
    

###  `` HTTP_207_MULTI_STATUS `module-attribute` [¶](#fastapi.status.HTTP_207_MULTI_STATUS "Permanent link")
    
    
    HTTP_207_MULTI_STATUS = 207
    

###  `` HTTP_208_ALREADY_REPORTED `module-attribute` [¶](#fastapi.status.HTTP_208_ALREADY_REPORTED "Permanent link")
    
    
    HTTP_208_ALREADY_REPORTED = 208
    

###  `` HTTP_226_IM_USED `module-attribute` [¶](#fastapi.status.HTTP_226_IM_USED "Permanent link")
    
    
    HTTP_226_IM_USED = 226
    

###  `` HTTP_300_MULTIPLE_CHOICES `module-attribute` [¶](#fastapi.status.HTTP_300_MULTIPLE_CHOICES "Permanent link")
    
    
    HTTP_300_MULTIPLE_CHOICES = 300
    

###  `` HTTP_301_MOVED_PERMANENTLY `module-attribute` [¶](#fastapi.status.HTTP_301_MOVED_PERMANENTLY "Permanent link")
    
    
    HTTP_301_MOVED_PERMANENTLY = 301
    

###  `` HTTP_302_FOUND `module-attribute` [¶](#fastapi.status.HTTP_302_FOUND "Permanent link")
    
    
    HTTP_302_FOUND = 302
    

###  `` HTTP_303_SEE_OTHER `module-attribute` [¶](#fastapi.status.HTTP_303_SEE_OTHER "Permanent link")
    
    
    HTTP_303_SEE_OTHER = 303
    

###  `` HTTP_304_NOT_MODIFIED `module-attribute` [¶](#fastapi.status.HTTP_304_NOT_MODIFIED "Permanent link")
    
    
    HTTP_304_NOT_MODIFIED = 304
    

###  `` HTTP_305_USE_PROXY `module-attribute` [¶](#fastapi.status.HTTP_305_USE_PROXY "Permanent link")
    
    
    HTTP_305_USE_PROXY = 305
    

###  `` HTTP_306_RESERVED `module-attribute` [¶](#fastapi.status.HTTP_306_RESERVED "Permanent link")
    
    
    HTTP_306_RESERVED = 306
    

###  `` HTTP_307_TEMPORARY_REDIRECT `module-attribute` [¶](#fastapi.status.HTTP_307_TEMPORARY_REDIRECT "Permanent link")
    
    
    HTTP_307_TEMPORARY_REDIRECT = 307
    

###  `` HTTP_308_PERMANENT_REDIRECT `module-attribute` [¶](#fastapi.status.HTTP_308_PERMANENT_REDIRECT "Permanent link")
    
    
    HTTP_308_PERMANENT_REDIRECT = 308
    

###  `` HTTP_400_BAD_REQUEST `module-attribute` [¶](#fastapi.status.HTTP_400_BAD_REQUEST "Permanent link")
    
    
    HTTP_400_BAD_REQUEST = 400
    

###  `` HTTP_401_UNAUTHORIZED `module-attribute` [¶](#fastapi.status.HTTP_401_UNAUTHORIZED "Permanent link")
    
    
    HTTP_401_UNAUTHORIZED = 401
    

###  `` HTTP_402_PAYMENT_REQUIRED `module-attribute` [¶](#fastapi.status.HTTP_402_PAYMENT_REQUIRED "Permanent link")
    
    
    HTTP_402_PAYMENT_REQUIRED = 402
    

###  `` HTTP_403_FORBIDDEN `module-attribute` [¶](#fastapi.status.HTTP_403_FORBIDDEN "Permanent link")
    
    
    HTTP_403_FORBIDDEN = 403
    

###  `` HTTP_404_NOT_FOUND `module-attribute` [¶](#fastapi.status.HTTP_404_NOT_FOUND "Permanent link")
    
    
    HTTP_404_NOT_FOUND = 404
    

###  `` HTTP_405_METHOD_NOT_ALLOWED `module-attribute` [¶](#fastapi.status.HTTP_405_METHOD_NOT_ALLOWED "Permanent link")
    
    
    HTTP_405_METHOD_NOT_ALLOWED = 405
    

###  `` HTTP_406_NOT_ACCEPTABLE `module-attribute` [¶](#fastapi.status.HTTP_406_NOT_ACCEPTABLE "Permanent link")
    
    
    HTTP_406_NOT_ACCEPTABLE = 406
    

###  `` HTTP_407_PROXY_AUTHENTICATION_REQUIRED `module-attribute` [¶](#fastapi.status.HTTP_407_PROXY_AUTHENTICATION_REQUIRED "Permanent link")
    
    
    HTTP_407_PROXY_AUTHENTICATION_REQUIRED = 407
    

###  `` HTTP_408_REQUEST_TIMEOUT `module-attribute` [¶](#fastapi.status.HTTP_408_REQUEST_TIMEOUT "Permanent link")
    
    
    HTTP_408_REQUEST_TIMEOUT = 408
    

###  `` HTTP_409_CONFLICT `module-attribute` [¶](#fastapi.status.HTTP_409_CONFLICT "Permanent link")
    
    
    HTTP_409_CONFLICT = 409
    

###  `` HTTP_410_GONE `module-attribute` [¶](#fastapi.status.HTTP_410_GONE "Permanent link")
    
    
    HTTP_410_GONE = 410
    

###  `` HTTP_411_LENGTH_REQUIRED `module-attribute` [¶](#fastapi.status.HTTP_411_LENGTH_REQUIRED "Permanent link")
    
    
    HTTP_411_LENGTH_REQUIRED = 411
    

###  `` HTTP_412_PRECONDITION_FAILED `module-attribute` [¶](#fastapi.status.HTTP_412_PRECONDITION_FAILED "Permanent link")
    
    
    HTTP_412_PRECONDITION_FAILED = 412
    

###  `` HTTP_413_CONTENT_TOO_LARGE `module-attribute` [¶](#fastapi.status.HTTP_413_CONTENT_TOO_LARGE "Permanent link")
    
    
    HTTP_413_CONTENT_TOO_LARGE = 413
    

###  `` HTTP_414_URI_TOO_LONG `module-attribute` [¶](#fastapi.status.HTTP_414_URI_TOO_LONG "Permanent link")
    
    
    HTTP_414_URI_TOO_LONG = 414
    

###  `` HTTP_415_UNSUPPORTED_MEDIA_TYPE `module-attribute` [¶](#fastapi.status.HTTP_415_UNSUPPORTED_MEDIA_TYPE "Permanent link")
    
    
    HTTP_415_UNSUPPORTED_MEDIA_TYPE = 415
    

###  `` HTTP_416_RANGE_NOT_SATISFIABLE `module-attribute` [¶](#fastapi.status.HTTP_416_RANGE_NOT_SATISFIABLE "Permanent link")
    
    
    HTTP_416_RANGE_NOT_SATISFIABLE = 416
    

###  `` HTTP_417_EXPECTATION_FAILED `module-attribute` [¶](#fastapi.status.HTTP_417_EXPECTATION_FAILED "Permanent link")
    
    
    HTTP_417_EXPECTATION_FAILED = 417
    

###  `` HTTP_418_IM_A_TEAPOT `module-attribute` [¶](#fastapi.status.HTTP_418_IM_A_TEAPOT "Permanent link")
    
    
    HTTP_418_IM_A_TEAPOT = 418
    

###  `` HTTP_421_MISDIRECTED_REQUEST `module-attribute` [¶](#fastapi.status.HTTP_421_MISDIRECTED_REQUEST "Permanent link")
    
    
    HTTP_421_MISDIRECTED_REQUEST = 421
    

###  `` HTTP_422_UNPROCESSABLE_CONTENT `module-attribute` [¶](#fastapi.status.HTTP_422_UNPROCESSABLE_CONTENT "Permanent link")
    
    
    HTTP_422_UNPROCESSABLE_CONTENT = 422
    

###  `` HTTP_423_LOCKED `module-attribute` [¶](#fastapi.status.HTTP_423_LOCKED "Permanent link")
    
    
    HTTP_423_LOCKED = 423
    

###  `` HTTP_424_FAILED_DEPENDENCY `module-attribute` [¶](#fastapi.status.HTTP_424_FAILED_DEPENDENCY "Permanent link")
    
    
    HTTP_424_FAILED_DEPENDENCY = 424
    

###  `` HTTP_425_TOO_EARLY `module-attribute` [¶](#fastapi.status.HTTP_425_TOO_EARLY "Permanent link")
    
    
    HTTP_425_TOO_EARLY = 425
    

###  `` HTTP_426_UPGRADE_REQUIRED `module-attribute` [¶](#fastapi.status.HTTP_426_UPGRADE_REQUIRED "Permanent link")
    
    
    HTTP_426_UPGRADE_REQUIRED = 426
    

###  `` HTTP_428_PRECONDITION_REQUIRED `module-attribute` [¶](#fastapi.status.HTTP_428_PRECONDITION_REQUIRED "Permanent link")
    
    
    HTTP_428_PRECONDITION_REQUIRED = 428
    

###  `` HTTP_429_TOO_MANY_REQUESTS `module-attribute` [¶](#fastapi.status.HTTP_429_TOO_MANY_REQUESTS "Permanent link")
    
    
    HTTP_429_TOO_MANY_REQUESTS = 429
    

###  `` HTTP_431_REQUEST_HEADER_FIELDS_TOO_LARGE `module-attribute` [¶](#fastapi.status.HTTP_431_REQUEST_HEADER_FIELDS_TOO_LARGE "Permanent link")
    
    
    HTTP_431_REQUEST_HEADER_FIELDS_TOO_LARGE = 431
    

###  `` HTTP_451_UNAVAILABLE_FOR_LEGAL_REASONS `module-attribute` [¶](#fastapi.status.HTTP_451_UNAVAILABLE_FOR_LEGAL_REASONS "Permanent link")
    
    
    HTTP_451_UNAVAILABLE_FOR_LEGAL_REASONS = 451
    

###  `` HTTP_500_INTERNAL_SERVER_ERROR `module-attribute` [¶](#fastapi.status.HTTP_500_INTERNAL_SERVER_ERROR "Permanent link")
    
    
    HTTP_500_INTERNAL_SERVER_ERROR = 500
    

###  `` HTTP_501_NOT_IMPLEMENTED `module-attribute` [¶](#fastapi.status.HTTP_501_NOT_IMPLEMENTED "Permanent link")
    
    
    HTTP_501_NOT_IMPLEMENTED = 501
    

###  `` HTTP_502_BAD_GATEWAY `module-attribute` [¶](#fastapi.status.HTTP_502_BAD_GATEWAY "Permanent link")
    
    
    HTTP_502_BAD_GATEWAY = 502
    

###  `` HTTP_503_SERVICE_UNAVAILABLE `module-attribute` [¶](#fastapi.status.HTTP_503_SERVICE_UNAVAILABLE "Permanent link")
    
    
    HTTP_503_SERVICE_UNAVAILABLE = 503
    

###  `` HTTP_504_GATEWAY_TIMEOUT `module-attribute` [¶](#fastapi.status.HTTP_504_GATEWAY_TIMEOUT "Permanent link")
    
    
    HTTP_504_GATEWAY_TIMEOUT = 504
    

###  `` HTTP_505_HTTP_VERSION_NOT_SUPPORTED `module-attribute` [¶](#fastapi.status.HTTP_505_HTTP_VERSION_NOT_SUPPORTED "Permanent link")
    
    
    HTTP_505_HTTP_VERSION_NOT_SUPPORTED = 505
    

###  `` HTTP_506_VARIANT_ALSO_NEGOTIATES `module-attribute` [¶](#fastapi.status.HTTP_506_VARIANT_ALSO_NEGOTIATES "Permanent link")
    
    
    HTTP_506_VARIANT_ALSO_NEGOTIATES = 506
    

###  `` HTTP_507_INSUFFICIENT_STORAGE `module-attribute` [¶](#fastapi.status.HTTP_507_INSUFFICIENT_STORAGE "Permanent link")
    
    
    HTTP_507_INSUFFICIENT_STORAGE = 507
    

###  `` HTTP_508_LOOP_DETECTED `module-attribute` [¶](#fastapi.status.HTTP_508_LOOP_DETECTED "Permanent link")
    
    
    HTTP_508_LOOP_DETECTED = 508
    

###  `` HTTP_510_NOT_EXTENDED `module-attribute` [¶](#fastapi.status.HTTP_510_NOT_EXTENDED "Permanent link")
    
    
    HTTP_510_NOT_EXTENDED = 510
    

###  `` HTTP_511_NETWORK_AUTHENTICATION_REQUIRED `module-attribute` [¶](#fastapi.status.HTTP_511_NETWORK_AUTHENTICATION_REQUIRED "Permanent link")
    
    
    HTTP_511_NETWORK_AUTHENTICATION_REQUIRED = 511
    

WebSocket codes https://www.iana.org/assignments/websocket/websocket.xml#close-code-number https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent

###  `` WS_1000_NORMAL_CLOSURE `module-attribute` [¶](#fastapi.status.WS_1000_NORMAL_CLOSURE "Permanent link")
    
    
    WS_1000_NORMAL_CLOSURE = 1000
    

###  `` WS_1001_GOING_AWAY `module-attribute` [¶](#fastapi.status.WS_1001_GOING_AWAY "Permanent link")
    
    
    WS_1001_GOING_AWAY = 1001
    

###  `` WS_1002_PROTOCOL_ERROR `module-attribute` [¶](#fastapi.status.WS_1002_PROTOCOL_ERROR "Permanent link")
    
    
    WS_1002_PROTOCOL_ERROR = 1002
    

###  `` WS_1003_UNSUPPORTED_DATA `module-attribute` [¶](#fastapi.status.WS_1003_UNSUPPORTED_DATA "Permanent link")
    
    
    WS_1003_UNSUPPORTED_DATA = 1003
    

###  `` WS_1005_NO_STATUS_RCVD `module-attribute` [¶](#fastapi.status.WS_1005_NO_STATUS_RCVD "Permanent link")
    
    
    WS_1005_NO_STATUS_RCVD = 1005
    

###  `` WS_1006_ABNORMAL_CLOSURE `module-attribute` [¶](#fastapi.status.WS_1006_ABNORMAL_CLOSURE "Permanent link")
    
    
    WS_1006_ABNORMAL_CLOSURE = 1006
    

###  `` WS_1007_INVALID_FRAME_PAYLOAD_DATA `module-attribute` [¶](#fastapi.status.WS_1007_INVALID_FRAME_PAYLOAD_DATA "Permanent link")
    
    
    WS_1007_INVALID_FRAME_PAYLOAD_DATA = 1007
    

###  `` WS_1008_POLICY_VIOLATION `module-attribute` [¶](#fastapi.status.WS_1008_POLICY_VIOLATION "Permanent link")
    
    
    WS_1008_POLICY_VIOLATION = 1008
    

###  `` WS_1009_MESSAGE_TOO_BIG `module-attribute` [¶](#fastapi.status.WS_1009_MESSAGE_TOO_BIG "Permanent link")
    
    
    WS_1009_MESSAGE_TOO_BIG = 1009
    

###  `` WS_1010_MANDATORY_EXT `module-attribute` [¶](#fastapi.status.WS_1010_MANDATORY_EXT "Permanent link")
    
    
    WS_1010_MANDATORY_EXT = 1010
    

###  `` WS_1011_INTERNAL_ERROR `module-attribute` [¶](#fastapi.status.WS_1011_INTERNAL_ERROR "Permanent link")
    
    
    WS_1011_INTERNAL_ERROR = 1011
    

###  `` WS_1012_SERVICE_RESTART `module-attribute` [¶](#fastapi.status.WS_1012_SERVICE_RESTART "Permanent link")
    
    
    WS_1012_SERVICE_RESTART = 1012
    

###  `` WS_1013_TRY_AGAIN_LATER `module-attribute` [¶](#fastapi.status.WS_1013_TRY_AGAIN_LATER "Permanent link")
    
    
    WS_1013_TRY_AGAIN_LATER = 1013
    

###  `` WS_1014_BAD_GATEWAY `module-attribute` [¶](#fastapi.status.WS_1014_BAD_GATEWAY "Permanent link")
    
    
    WS_1014_BAD_GATEWAY = 1014
    

###  `` WS_1015_TLS_HANDSHAKE `module-attribute` [¶](#fastapi.status.WS_1015_TLS_HANDSHAKE "Permanent link")
    
    
    WS_1015_TLS_HANDSHAKE = 1015

---

###### UploadFileclass¶

# `UploadFile` class[¶](#uploadfile-class "Permanent link")

You can define _path operation function_ parameters to be of the type `UploadFile` to receive files from the request.

You can import it directly from `fastapi`:
    
    
    from fastapi import UploadFile
    

##  `` fastapi.UploadFile [¶](#fastapi.UploadFile "Permanent link")
    
    
    UploadFile(file, *, size=None, filename=None, headers=None)
    

Bases: `UploadFile`

A file uploaded in a request.

Define it as a _path operation function_ (or dependency) parameter.

If you are using a regular `def` function, you can use the `upload_file.file` attribute to access the raw standard Python file (blocking, not async), useful and needed for non-async code.

Read more about it in the [FastAPI docs for Request Files](https://fastapi.tiangolo.com/tutorial/request-files/).

#### Example[¶](#fastapi.UploadFile--example "Permanent link")
    
    
    from typing import Annotated
    
    from fastapi import FastAPI, File, UploadFile
    
    app = FastAPI()
    
    
    @app.post("/files/")
    async def create_file(file: Annotated[bytes, File()]):
        return {"file_size": len(file)}
    
    
    @app.post("/uploadfile/")
    async def create_upload_file(file: UploadFile):
        return {"filename": file.filename}
    

Source code in `starlette/datastructures.py`
    
    
    417
    418
    419
    420
    421
    422
    423
    424
    425
    426
    427
    428
    429
    430
    431
    432

| 
    
    
    def __init__(
        self,
        file: BinaryIO,
        *,
        size: int | None = None,
        filename: str | None = None,
        headers: Headers | None = None,
    ) -> None:
        self.filename = filename
        self.file = file
        self.size = size
        self.headers = headers or Headers()
    
        # Capture max size from SpooledTemporaryFile if one is provided. This slightly speeds up future checks.
        # Note 0 means unlimited mirroring SpooledTemporaryFile's __init__
        self._max_mem_size = getattr(self.file, "_max_size", 0)
      
  
---|---  
  
###  `` file `instance-attribute` [¶](#fastapi.UploadFile.file "Permanent link")
    
    
    file
    

The standard Python file object (non-async).

###  `` filename `instance-attribute` [¶](#fastapi.UploadFile.filename "Permanent link")
    
    
    filename
    

The original file name.

###  `` size `instance-attribute` [¶](#fastapi.UploadFile.size "Permanent link")
    
    
    size
    

The size of the file in bytes.

###  `` headers `instance-attribute` [¶](#fastapi.UploadFile.headers "Permanent link")
    
    
    headers
    

The headers of the request.

###  `` content_type `instance-attribute` [¶](#fastapi.UploadFile.content_type "Permanent link")
    
    
    content_type
    

The content type of the request, from the headers.

###  `` read `async` [¶](#fastapi.UploadFile.read "Permanent link")
    
    
    read(size=-1)
    

Read some bytes from the file.

To be awaitable, compatible with async, this is run in threadpool.

PARAMETER | DESCRIPTION  
---|---  
`size` |  The number of bytes to read from the file. **TYPE:** `int` **DEFAULT:** `-1`  
Source code in `fastapi/datastructures.py`
    
    
     88
     89
     90
     91
     92
     93
     94
     95
     96
     97
     98
     99
    100
    101
    102
    103
    104

| 
    
    
    async def read(
        self,
        size: Annotated[
            int,
            Doc(
                """
                The number of bytes to read from the file.
                """
            ),
        ] = -1,
    ) -> bytes:
        """
        Read some bytes from the file.
    
        To be awaitable, compatible with async, this is run in threadpool.
        """
        return await super().read(size)
      
  
---|---  
  
###  `` write `async` [¶](#fastapi.UploadFile.write "Permanent link")
    
    
    write(data)
    

Write some bytes to the file.

You normally wouldn't use this from a file you read in a request.

To be awaitable, compatible with async, this is run in threadpool.

PARAMETER | DESCRIPTION  
---|---  
`data` |  The bytes to write to the file. **TYPE:** `bytes`  
Source code in `fastapi/datastructures.py`
    
    
    68
    69
    70
    71
    72
    73
    74
    75
    76
    77
    78
    79
    80
    81
    82
    83
    84
    85
    86

| 
    
    
    async def write(
        self,
        data: Annotated[
            bytes,
            Doc(
                """
                The bytes to write to the file.
                """
            ),
        ],
    ) -> None:
        """
        Write some bytes to the file.
    
        You normally wouldn't use this from a file you read in a request.
    
        To be awaitable, compatible with async, this is run in threadpool.
        """
        return await super().write(data)
      
  
---|---  
  
###  `` seek `async` [¶](#fastapi.UploadFile.seek "Permanent link")
    
    
    seek(offset)
    

Move to a position in the file.

Any next read or write will be done from that position.

To be awaitable, compatible with async, this is run in threadpool.

PARAMETER | DESCRIPTION  
---|---  
`offset` |  The position in bytes to seek to in the file. **TYPE:** `int`  
Source code in `fastapi/datastructures.py`
    
    
    106
    107
    108
    109
    110
    111
    112
    113
    114
    115
    116
    117
    118
    119
    120
    121
    122
    123
    124

| 
    
    
    async def seek(
        self,
        offset: Annotated[
            int,
            Doc(
                """
                The position in bytes to seek to in the file.
                """
            ),
        ],
    ) -> None:
        """
        Move to a position in the file.
    
        Any next read or write will be done from that position.
    
        To be awaitable, compatible with async, this is run in threadpool.
        """
        return await super().seek(offset)
      
  
---|---  
  
###  `` close `async` [¶](#fastapi.UploadFile.close "Permanent link")
    
    
    close()
    

Close the file.

To be awaitable, compatible with async, this is run in threadpool.

Source code in `fastapi/datastructures.py`
    
    
    126
    127
    128
    129
    130
    131
    132

| 
    
    
    async def close(self) -> None:
        """
        Close the file.
    
        To be awaitable, compatible with async, this is run in threadpool.
        """
        return await super().close()
      
  
---|---

---

###### Exceptions -HTTPExceptionandWebSocketException¶

# Exceptions - `HTTPException` and `WebSocketException`[¶](#exceptions-httpexception-and-websocketexception "Permanent link")

These are the exceptions that you can raise to show errors to the client.

When you raise an exception, as would happen with normal Python, the rest of the execution is aborted. This way you can raise these exceptions from anywhere in the code to abort a request and show the error to the client.

You can use:

  * `HTTPException`
  * `WebSocketException`

These exceptions can be imported directly from `fastapi`:
    
    
    from fastapi import HTTPException, WebSocketException
    

##  `` fastapi.HTTPException [¶](#fastapi.HTTPException "Permanent link")
    
    
    HTTPException(status_code, detail=None, headers=None)
    

Bases: `HTTPException`

An HTTP exception you can raise in your own code to show errors to the client.

This is for client errors, invalid authentication, invalid data, etc. Not for server errors in your code.

Read more about it in the [FastAPI docs for Handling Errors](https://fastapi.tiangolo.com/tutorial/handling-errors/).

#### Example[¶](#fastapi.HTTPException--example "Permanent link")
    
    
    from fastapi import FastAPI, HTTPException
    
    app = FastAPI()
    
    items = {"foo": "The Foo Wrestlers"}
    
    
    @app.get("/items/{item_id}")
    async def read_item(item_id: str):
        if item_id not in items:
            raise HTTPException(status_code=404, detail="Item not found")
        return {"item": items[item_id]}
    

PARAMETER | DESCRIPTION  
---|---  
`status_code` |  HTTP status code to send to the client. Read more about it in the [FastAPI docs for Handling Errors](https://fastapi.tiangolo.com/tutorial/handling-errors/#use-httpexception) **TYPE:** `int`  
`detail` |  Any data to be sent to the client in the `detail` key of the JSON response. Read more about it in the [FastAPI docs for Handling Errors](https://fastapi.tiangolo.com/tutorial/handling-errors/#use-httpexception) **TYPE:** `Any` **DEFAULT:** `None`  
`headers` |  Any headers to send to the client in the response. Read more about it in the [FastAPI docs for Handling Errors](https://fastapi.tiangolo.com/tutorial/handling-errors/#add-custom-headers) **TYPE:** `Optional[dict[str, str]]` **DEFAULT:** `None`  
Source code in `fastapi/exceptions.py`
    
    
    45
    46
    47
    48
    49
    50
    51
    52
    53
    54
    55
    56
    57
    58
    59
    60
    61
    62
    63
    64
    65
    66
    67
    68
    69
    70
    71
    72
    73
    74
    75
    76
    77
    78
    79
    80
    81
    82
    83

| 
    
    
    def __init__(
        self,
        status_code: Annotated[
            int,
            Doc(
                """
                HTTP status code to send to the client.
    
                Read more about it in the
                [FastAPI docs for Handling Errors](https://fastapi.tiangolo.com/tutorial/handling-errors/#use-httpexception)
                """
            ),
        ],
        detail: Annotated[
            Any,
            Doc(
                """
                Any data to be sent to the client in the `detail` key of the JSON
                response.
    
                Read more about it in the
                [FastAPI docs for Handling Errors](https://fastapi.tiangolo.com/tutorial/handling-errors/#use-httpexception)
                """
            ),
        ] = None,
        headers: Annotated[
            Optional[dict[str, str]],
            Doc(
                """
                Any headers to send to the client in the response.
    
                Read more about it in the
                [FastAPI docs for Handling Errors](https://fastapi.tiangolo.com/tutorial/handling-errors/#add-custom-headers)
    
                """
            ),
        ] = None,
    ) -> None:
        super().__init__(status_code=status_code, detail=detail, headers=headers)
      
  
---|---  
  
###  `` status_code `instance-attribute` [¶](#fastapi.HTTPException.status_code "Permanent link")
    
    
    status_code = status_code
    

###  `` detail `instance-attribute` [¶](#fastapi.HTTPException.detail "Permanent link")
    
    
    detail = detail
    

###  `` headers `instance-attribute` [¶](#fastapi.HTTPException.headers "Permanent link")
    
    
    headers = headers
    

##  `` fastapi.WebSocketException [¶](#fastapi.WebSocketException "Permanent link")
    
    
    WebSocketException(code, reason=None)
    

Bases: `WebSocketException`

A WebSocket exception you can raise in your own code to show errors to the client.

This is for client errors, invalid authentication, invalid data, etc. Not for server errors in your code.

Read more about it in the [FastAPI docs for WebSockets](https://fastapi.tiangolo.com/advanced/websockets/).

#### Example[¶](#fastapi.WebSocketException--example "Permanent link")
    
    
    from typing import Annotated
    
    from fastapi import (
        Cookie,
        FastAPI,
        WebSocket,
        WebSocketException,
        status,
    )
    
    app = FastAPI()
    
    @app.websocket("/items/{item_id}/ws")
    async def websocket_endpoint(
        *,
        websocket: WebSocket,
        session: Annotated[str | None, Cookie()] = None,
        item_id: str,
    ):
        if session is None:
            raise WebSocketException(code=status.WS_1008_POLICY_VIOLATION)
        await websocket.accept()
        while True:
            data = await websocket.receive_text()
            await websocket.send_text(f"Session cookie is: {session}")
            await websocket.send_text(f"Message text was: {data}, for item ID: {item_id}")
    

PARAMETER | DESCRIPTION  
---|---  
`code` |  A closing code from the [valid codes defined in the specification](https://datatracker.ietf.org/doc/html/rfc6455#section-7.4.1). **TYPE:** `int`  
`reason` |  The reason to close the WebSocket connection. It is UTF-8-encoded data. The interpretation of the reason is up to the application, it is not specified by the WebSocket specification. It could contain text that could be human-readable or interpretable by the client code, etc. **TYPE:** `Union[str, None]` **DEFAULT:** `None`  
Source code in `fastapi/exceptions.py`
    
    
    128
    129
    130
    131
    132
    133
    134
    135
    136
    137
    138
    139
    140
    141
    142
    143
    144
    145
    146
    147
    148
    149
    150
    151
    152
    153
    154

| 
    
    
    def __init__(
        self,
        code: Annotated[
            int,
            Doc(
                """
                A closing code from the
                [valid codes defined in the specification](https://datatracker.ietf.org/doc/html/rfc6455#section-7.4.1).
                """
            ),
        ],
        reason: Annotated[
            Union[str, None],
            Doc(
                """
                The reason to close the WebSocket connection.
    
                It is UTF-8-encoded data. The interpretation of the reason is up to the
                application, it is not specified by the WebSocket specification.
    
                It could contain text that could be human-readable or interpretable
                by the client code, etc.
                """
            ),
        ] = None,
    ) -> None:
        super().__init__(code=code, reason=reason)
      
  
---|---  
  
###  `` code `instance-attribute` [¶](#fastapi.WebSocketException.code "Permanent link")
    
    
    code = code
    

###  `` reason `instance-attribute` [¶](#fastapi.WebSocketException.reason "Permanent link")
    
    
    reason = reason or ''

---

###### Dependencies -Depends()andSecurity()¶

# Dependencies - `Depends()` and `Security()`[¶](#dependencies-depends-and-security "Permanent link")

## `Depends()`[¶](#depends "Permanent link")

Dependencies are handled mainly with the special function `Depends()` that takes a callable.

Here is the reference for it and its parameters.

You can import it directly from `fastapi`:
    
    
    from fastapi import Depends
    

##  `` fastapi.Depends [¶](#fastapi.Depends "Permanent link")
    
    
    Depends(dependency=None, *, use_cache=True, scope=None)
    

Declare a FastAPI dependency.

It takes a single "dependable" callable (like a function).

Don't call it directly, FastAPI will call it for you.

Read more about it in the [FastAPI docs for Dependencies](https://fastapi.tiangolo.com/tutorial/dependencies/).

**Example**
    
    
    from typing import Annotated
    
    from fastapi import Depends, FastAPI
    
    app = FastAPI()
    
    
    async def common_parameters(q: str | None = None, skip: int = 0, limit: int = 100):
        return {"q": q, "skip": skip, "limit": limit}
    
    
    @app.get("/items/")
    async def read_items(commons: Annotated[dict, Depends(common_parameters)]):
        return commons
    

PARAMETER | DESCRIPTION  
---|---  
`dependency` |  A "dependable" callable (like a function). Don't call it directly, FastAPI will call it for you, just pass the object directly. Read more about it in the [FastAPI docs for Dependencies](https://fastapi.tiangolo.com/tutorial/dependencies/) **TYPE:** `Optional[Callable[..., Any]]` **DEFAULT:** `None`  
`use_cache` |  By default, after a dependency is called the first time in a request, if the dependency is declared again for the rest of the request (for example if the dependency is needed by several dependencies), the value will be re-used for the rest of the request. Set `use_cache` to `False` to disable this behavior and ensure the dependency is called again (if declared more than once) in the same request. Read more about it in the [FastAPI docs about sub-dependencies](https://fastapi.tiangolo.com/tutorial/dependencies/sub-dependencies/#using-the-same-dependency-multiple-times) **TYPE:** `bool` **DEFAULT:** `True`  
`scope` |  Mainly for dependencies with `yield`, define when the dependency function should start (the code before `yield`) and when it should end (the code after `yield`).

  * `"function"`: start the dependency before the _path operation function_ that handles the request, end the dependency after the _path operation function_ ends, but **before** the response is sent back to the client. So, the dependency function will be executed **around** the _path operation**function**_.
  * `"request"`: start the dependency before the _path operation function_ that handles the request (similar to when using `"function"`), but end **after** the response is sent back to the client. So, the dependency function will be executed **around** the **request** and response cycle.

Read more about it in the [FastAPI docs for FastAPI Dependencies with yield](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-with-yield/#early-exit-and-scope) **TYPE:** `Union[Literal['function', 'request'], None]` **DEFAULT:** `None`  
Source code in `fastapi/param_functions.py`
    
    
    2284
    2285
    2286
    2287
    2288
    2289
    2290
    2291
    2292
    2293
    2294
    2295
    2296
    2297
    2298
    2299
    2300
    2301
    2302
    2303
    2304
    2305
    2306
    2307
    2308
    2309
    2310
    2311
    2312
    2313
    2314
    2315
    2316
    2317
    2318
    2319
    2320
    2321
    2322
    2323
    2324
    2325
    2326
    2327
    2328
    2329
    2330
    2331
    2332
    2333
    2334
    2335
    2336
    2337
    2338
    2339
    2340
    2341
    2342
    2343
    2344
    2345
    2346
    2347
    2348
    2349
    2350
    2351
    2352
    2353
    2354
    2355
    2356
    2357
    2358
    2359
    2360
    2361
    2362
    2363
    2364
    2365
    2366
    2367
    2368
    2369
    2370

| 
    
    
    def Depends(  # noqa: N802
        dependency: Annotated[
            Optional[Callable[..., Any]],
            Doc(
                """
                A "dependable" callable (like a function).
    
                Don't call it directly, FastAPI will call it for you, just pass the object
                directly.
    
                Read more about it in the
                [FastAPI docs for Dependencies](https://fastapi.tiangolo.com/tutorial/dependencies/)
                """
            ),
        ] = None,
        *,
        use_cache: Annotated[
            bool,
            Doc(
                """
                By default, after a dependency is called the first time in a request, if
                the dependency is declared again for the rest of the request (for example
                if the dependency is needed by several dependencies), the value will be
                re-used for the rest of the request.
    
                Set `use_cache` to `False` to disable this behavior and ensure the
                dependency is called again (if declared more than once) in the same request.
    
                Read more about it in the
                [FastAPI docs about sub-dependencies](https://fastapi.tiangolo.com/tutorial/dependencies/sub-dependencies/#using-the-same-dependency-multiple-times)
                """
            ),
        ] = True,
        scope: Annotated[
            Union[Literal["function", "request"], None],
            Doc(
                """
                Mainly for dependencies with `yield`, define when the dependency function
                should start (the code before `yield`) and when it should end (the code
                after `yield`).
    
                * `"function"`: start the dependency before the *path operation function*
                    that handles the request, end the dependency after the *path operation
                    function* ends, but **before** the response is sent back to the client.
                    So, the dependency function will be executed **around** the *path operation
                    **function***.
                * `"request"`: start the dependency before the *path operation function*
                    that handles the request (similar to when using `"function"`), but end
                    **after** the response is sent back to the client. So, the dependency
                    function will be executed **around** the **request** and response cycle.
    
                Read more about it in the
                [FastAPI docs for FastAPI Dependencies with yield](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-with-yield/#early-exit-and-scope)
                """
            ),
        ] = None,
    ) -> Any:
        """
        Declare a FastAPI dependency.
    
        It takes a single "dependable" callable (like a function).
    
        Don't call it directly, FastAPI will call it for you.
    
        Read more about it in the
        [FastAPI docs for Dependencies](https://fastapi.tiangolo.com/tutorial/dependencies/).
    
        **Example**
    
        ```python
        from typing import Annotated
    
        from fastapi import Depends, FastAPI
    
        app = FastAPI()
    
    
        async def common_parameters(q: str | None = None, skip: int = 0, limit: int = 100):
            return {"q": q, "skip": skip, "limit": limit}
    
    
        @app.get("/items/")
        async def read_items(commons: Annotated[dict, Depends(common_parameters)]):
            return commons
        ```
        """
        return params.Depends(dependency=dependency, use_cache=use_cache, scope=scope)
      
  
---|---  
  
## `Security()`[¶](#security "Permanent link")

For many scenarios, you can handle security (authorization, authentication, etc.) with dependencies, using `Depends()`.

But when you want to also declare OAuth2 scopes, you can use `Security()` instead of `Depends()`.

You can import `Security()` directly from `fastapi`:
    
    
    from fastapi import Security
    

##  `` fastapi.Security [¶](#fastapi.Security "Permanent link")
    
    
    Security(dependency=None, *, scopes=None, use_cache=True)
    

Declare a FastAPI Security dependency.

The only difference with a regular dependency is that it can declare OAuth2 scopes that will be integrated with OpenAPI and the automatic UI docs (by default at `/docs`).

It takes a single "dependable" callable (like a function).

Don't call it directly, FastAPI will call it for you.

Read more about it in the [FastAPI docs for Security](https://fastapi.tiangolo.com/tutorial/security/) and in the [FastAPI docs for OAuth2 scopes](https://fastapi.tiangolo.com/advanced/security/oauth2-scopes/).

**Example**
    
    
    from typing import Annotated
    
    from fastapi import Security, FastAPI
    
    from .db import User
    from .security import get_current_active_user
    
    app = FastAPI()
    
    @app.get("/users/me/items/")
    async def read_own_items(
        current_user: Annotated[User, Security(get_current_active_user, scopes=["items"])]
    ):
        return [{"item_id": "Foo", "owner": current_user.username}]
    

PARAMETER | DESCRIPTION  
---|---  
`dependency` |  A "dependable" callable (like a function). Don't call it directly, FastAPI will call it for you, just pass the object directly. Read more about it in the [FastAPI docs for Dependencies](https://fastapi.tiangolo.com/tutorial/dependencies/) **TYPE:** `Optional[Callable[..., Any]]` **DEFAULT:** `None`  
`scopes` |  OAuth2 scopes required for the _path operation_ that uses this Security dependency. The term "scope" comes from the OAuth2 specification, it seems to be intentionally vague and interpretable. It normally refers to permissions, in cases to roles. These scopes are integrated with OpenAPI (and the API docs at `/docs`). So they are visible in the OpenAPI specification. Read more about it in the [FastAPI docs about OAuth2 scopes](https://fastapi.tiangolo.com/advanced/security/oauth2-scopes/) **TYPE:** `Optional[Sequence[str]]` **DEFAULT:** `None`  
`use_cache` |  By default, after a dependency is called the first time in a request, if the dependency is declared again for the rest of the request (for example if the dependency is needed by several dependencies), the value will be re-used for the rest of the request. Set `use_cache` to `False` to disable this behavior and ensure the dependency is called again (if declared more than once) in the same request. Read more about it in the [FastAPI docs about sub-dependencies](https://fastapi.tiangolo.com/tutorial/dependencies/sub-dependencies/#using-the-same-dependency-multiple-times) **TYPE:** `bool` **DEFAULT:** `True`  
Source code in `fastapi/param_functions.py`
    
    
    2373
    2374
    2375
    2376
    2377
    2378
    2379
    2380
    2381
    2382
    2383
    2384
    2385
    2386
    2387
    2388
    2389
    2390
    2391
    2392
    2393
    2394
    2395
    2396
    2397
    2398
    2399
    2400
    2401
    2402
    2403
    2404
    2405
    2406
    2407
    2408
    2409
    2410
    2411
    2412
    2413
    2414
    2415
    2416
    2417
    2418
    2419
    2420
    2421
    2422
    2423
    2424
    2425
    2426
    2427
    2428
    2429
    2430
    2431
    2432
    2433
    2434
    2435
    2436
    2437
    2438
    2439
    2440
    2441
    2442
    2443
    2444
    2445
    2446
    2447
    2448
    2449
    2450
    2451
    2452
    2453
    2454
    2455
    2456
    2457
    2458
    2459
    2460
    2461

| 
    
    
    def Security(  # noqa: N802
        dependency: Annotated[
            Optional[Callable[..., Any]],
            Doc(
                """
                A "dependable" callable (like a function).
    
                Don't call it directly, FastAPI will call it for you, just pass the object
                directly.
    
                Read more about it in the
                [FastAPI docs for Dependencies](https://fastapi.tiangolo.com/tutorial/dependencies/)
                """
            ),
        ] = None,
        *,
        scopes: Annotated[
            Optional[Sequence[str]],
            Doc(
                """
                OAuth2 scopes required for the *path operation* that uses this Security
                dependency.
    
                The term "scope" comes from the OAuth2 specification, it seems to be
                intentionally vague and interpretable. It normally refers to permissions,
                in cases to roles.
    
                These scopes are integrated with OpenAPI (and the API docs at `/docs`).
                So they are visible in the OpenAPI specification.
    
                Read more about it in the
                [FastAPI docs about OAuth2 scopes](https://fastapi.tiangolo.com/advanced/security/oauth2-scopes/)
                """
            ),
        ] = None,
        use_cache: Annotated[
            bool,
            Doc(
                """
                By default, after a dependency is called the first time in a request, if
                the dependency is declared again for the rest of the request (for example
                if the dependency is needed by several dependencies), the value will be
                re-used for the rest of the request.
    
                Set `use_cache` to `False` to disable this behavior and ensure the
                dependency is called again (if declared more than once) in the same request.
    
                Read more about it in the
                [FastAPI docs about sub-dependencies](https://fastapi.tiangolo.com/tutorial/dependencies/sub-dependencies/#using-the-same-dependency-multiple-times)
                """
            ),
        ] = True,
    ) -> Any:
        """
        Declare a FastAPI Security dependency.
    
        The only difference with a regular dependency is that it can declare OAuth2
        scopes that will be integrated with OpenAPI and the automatic UI docs (by default
        at `/docs`).
    
        It takes a single "dependable" callable (like a function).
    
        Don't call it directly, FastAPI will call it for you.
    
        Read more about it in the
        [FastAPI docs for Security](https://fastapi.tiangolo.com/tutorial/security/) and
        in the
        [FastAPI docs for OAuth2 scopes](https://fastapi.tiangolo.com/advanced/security/oauth2-scopes/).
    
        **Example**
    
        ```python
        from typing import Annotated
    
        from fastapi import Security, FastAPI
    
        from .db import User
        from .security import get_current_active_user
    
        app = FastAPI()
    
        @app.get("/users/me/items/")
        async def read_own_items(
            current_user: Annotated[User, Security(get_current_active_user, scopes=["items"])]
        ):
            return [{"item_id": "Foo", "owner": current_user.username}]
        ```
        """
        return params.Security(dependency=dependency, scopes=scopes, use_cache=use_cache)
      
  
---|---

---

###### APIRouterclass¶

# `APIRouter` class[¶](#apirouter-class "Permanent link")

Here's the reference information for the `APIRouter` class, with all its parameters, attributes and methods.

You can import the `APIRouter` class directly from `fastapi`:
    
    
    from fastapi import APIRouter
    

##  `` fastapi.APIRouter [¶](#fastapi.APIRouter "Permanent link")
    
    
    APIRouter(
        *,
        prefix="",
        tags=None,
        dependencies=None,
        default_response_class=Default([JSONResponse](../responses/#fastapi.responses.JSONResponse "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">fastapi.responses.JSONResponse</span> \(<code>starlette.responses.JSONResponse</code>\)")),
        responses=None,
        callbacks=None,
        routes=None,
        redirect_slashes=True,
        default=None,
        dependency_overrides_provider=None,
        route_class=APIRoute,
        on_startup=None,
        on_shutdown=None,
        lifespan=None,
        deprecated=None,
        include_in_schema=True,
        generate_unique_id_function=Default(generate_unique_id)
    )
    

Bases: `Router`

`APIRouter` class, used to group _path operations_ , for example to structure an app in multiple files. It would then be included in the `FastAPI` app, or in another `APIRouter` (ultimately included in the app).

Read more about it in the [FastAPI docs for Bigger Applications - Multiple Files](https://fastapi.tiangolo.com/tutorial/bigger-applications/).

#### Example[¶](#fastapi.APIRouter--example "Permanent link")
    
    
    from fastapi import APIRouter, FastAPI
    
    app = FastAPI()
    router = APIRouter()
    
    
    @router.get("/users/", tags=["users"])
    async def read_users():
        return [{"username": "Rick"}, {"username": "Morty"}]
    
    
    app.include_router(router)
    

PARAMETER | DESCRIPTION  
---|---  
`prefix` |  An optional path prefix for the router. **TYPE:** `str` **DEFAULT:** `''`  
`tags` |  A list of tags to be applied to all the _path operations_ in this router. It will be added to the generated OpenAPI (e.g. visible at `/docs`). Read more about it in the [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/). **TYPE:** `Optional[list[Union[str, Enum]]]` **DEFAULT:** `None`  
`dependencies` |  A list of dependencies (using `Depends()`) to be applied to all the _path operations_ in this router. Read more about it in the [FastAPI docs for Bigger Applications - Multiple Files](https://fastapi.tiangolo.com/tutorial/bigger-applications/#include-an-apirouter-with-a-custom-prefix-tags-responses-and-dependencies). **TYPE:** `Optional[Sequence[Depends]]` **DEFAULT:** `None`  
`default_response_class` |  The default response class to be used. Read more in the [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#default-response-class). **TYPE:** `type[[Response](../response/#fastapi.Response "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">fastapi.Response</span> \(<code>starlette.responses.Response</code>\)")]` **DEFAULT:** `Default([JSONResponse](../responses/#fastapi.responses.JSONResponse "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">fastapi.responses.JSONResponse</span> \(<code>starlette.responses.JSONResponse</code>\)"))`  
`responses` |  Additional responses to be shown in OpenAPI. It will be added to the generated OpenAPI (e.g. visible at `/docs`). Read more about it in the [FastAPI docs for Additional Responses in OpenAPI](https://fastapi.tiangolo.com/advanced/additional-responses/). And in the [FastAPI docs for Bigger Applications](https://fastapi.tiangolo.com/tutorial/bigger-applications/#include-an-apirouter-with-a-custom-prefix-tags-responses-and-dependencies). **TYPE:** `Optional[dict[Union[int, str], dict[str, Any]]]` **DEFAULT:** `None`  
`callbacks` |  OpenAPI callbacks that should apply to all _path operations_ in this router. It will be added to the generated OpenAPI (e.g. visible at `/docs`). Read more about it in the [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/). **TYPE:** `Optional[list[BaseRoute]]` **DEFAULT:** `None`  
`routes` |  **Note** : you probably shouldn't use this parameter, it is inherited from Starlette and supported for compatibility.

* * *

A list of routes to serve incoming HTTP and WebSocket requests. **TYPE:** `Optional[list[BaseRoute]]` **DEFAULT:** `None`  
`redirect_slashes` |  Whether to detect and redirect slashes in URLs when the client doesn't use the same format. **TYPE:** `bool` **DEFAULT:** `True`  
`default` |  Default function handler for this router. Used to handle 404 Not Found errors. **TYPE:** `Optional[ASGIApp]` **DEFAULT:** `None`  
`dependency_overrides_provider` |  Only used internally by FastAPI to handle dependency overrides. You shouldn't need to use it. It normally points to the `FastAPI` app object. **TYPE:** `Optional[Any]` **DEFAULT:** `None`  
`route_class` |  Custom route (_path operation_) class to be used by this router. Read more about it in the [FastAPI docs for Custom Request and APIRoute class](https://fastapi.tiangolo.com/how-to/custom-request-and-route/#custom-apiroute-class-in-a-router). **TYPE:** `type[APIRoute]` **DEFAULT:** `APIRoute`  
`on_startup` |  A list of startup event handler functions. You should instead use the `lifespan` handlers. Read more in the [FastAPI docs for `lifespan`](https://fastapi.tiangolo.com/advanced/events/). **TYPE:** `Optional[Sequence[Callable[[], Any]]]` **DEFAULT:** `None`  
`on_shutdown` |  A list of shutdown event handler functions. You should instead use the `lifespan` handlers. Read more in the [FastAPI docs for `lifespan`](https://fastapi.tiangolo.com/advanced/events/). **TYPE:** `Optional[Sequence[Callable[[], Any]]]` **DEFAULT:** `None`  
`lifespan` |  A `Lifespan` context manager handler. This replaces `startup` and `shutdown` functions with a single context manager. Read more in the [FastAPI docs for `lifespan`](https://fastapi.tiangolo.com/advanced/events/). **TYPE:** `Optional[Lifespan[Any]]` **DEFAULT:** `None`  
`deprecated` |  Mark all _path operations_ in this router as deprecated. It will be added to the generated OpenAPI (e.g. visible at `/docs`). Read more about it in the [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/). **TYPE:** `Optional[bool]` **DEFAULT:** `None`  
`include_in_schema` |  To include (or not) all the _path operations_ in this router in the generated OpenAPI. This affects the generated OpenAPI (e.g. visible at `/docs`). Read more about it in the [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-parameters-from-openapi). **TYPE:** `bool` **DEFAULT:** `True`  
`generate_unique_id_function` |  Customize the function used to generate unique IDs for the _path operations_ shown in the generated OpenAPI. This is particularly useful when automatically generating clients or SDKs for your API. Read more about it in the [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function). **TYPE:** `Callable[[APIRoute], str]` **DEFAULT:** `Default(generate_unique_id)`  
Source code in `fastapi/routing.py`
    
    
    691
    692
    693
    694
    695
    696
    697
    698
    699
    700
    701
    702
    703
    704
    705
    706
    707
    708
    709
    710
    711
    712
    713
    714
    715
    716
    717
    718
    719
    720
    721
    722
    723
    724
    725
    726
    727
    728
    729
    730
    731
    732
    733
    734
    735
    736
    737
    738
    739
    740
    741
    742
    743
    744
    745
    746
    747
    748
    749
    750
    751
    752
    753
    754
    755
    756
    757
    758
    759
    760
    761
    762
    763
    764
    765
    766
    767
    768
    769
    770
    771
    772
    773
    774
    775
    776
    777
    778
    779
    780
    781
    782
    783
    784
    785
    786
    787
    788
    789
    790
    791
    792
    793
    794
    795
    796
    797
    798
    799
    800
    801
    802
    803
    804
    805
    806
    807
    808
    809
    810
    811
    812
    813
    814
    815
    816
    817
    818
    819
    820
    821
    822
    823
    824
    825
    826
    827
    828
    829
    830
    831
    832
    833
    834
    835
    836
    837
    838
    839
    840
    841
    842
    843
    844
    845
    846
    847
    848
    849
    850
    851
    852
    853
    854
    855
    856
    857
    858
    859
    860
    861
    862
    863
    864
    865
    866
    867
    868
    869
    870
    871
    872
    873
    874
    875
    876
    877
    878
    879
    880
    881
    882
    883
    884
    885
    886
    887
    888
    889
    890
    891
    892
    893
    894
    895
    896
    897
    898
    899
    900
    901
    902
    903
    904
    905
    906
    907
    908
    909
    910
    911
    912
    913
    914
    915
    916
    917
    918
    919
    920
    921
    922
    923
    924
    925
    926
    927
    928
    929

| 
    
    
    def __init__(
        self,
        *,
        prefix: Annotated[str, Doc("An optional path prefix for the router.")] = "",
        tags: Annotated[
            Optional[list[Union[str, Enum]]],
            Doc(
                """
                A list of tags to be applied to all the *path operations* in this
                router.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
    
                Read more about it in the
                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
                """
            ),
        ] = None,
        dependencies: Annotated[
            Optional[Sequence[params.Depends]],
            Doc(
                """
                A list of dependencies (using `Depends()`) to be applied to all the
                *path operations* in this router.
    
                Read more about it in the
                [FastAPI docs for Bigger Applications - Multiple Files](https://fastapi.tiangolo.com/tutorial/bigger-applications/#include-an-apirouter-with-a-custom-prefix-tags-responses-and-dependencies).
                """
            ),
        ] = None,
        default_response_class: Annotated[
            type[Response],
            Doc(
                """
                The default response class to be used.
    
                Read more in the
                [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#default-response-class).
                """
            ),
        ] = Default(JSONResponse),
        responses: Annotated[
            Optional[dict[Union[int, str], dict[str, Any]]],
            Doc(
                """
                Additional responses to be shown in OpenAPI.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
    
                Read more about it in the
                [FastAPI docs for Additional Responses in OpenAPI](https://fastapi.tiangolo.com/advanced/additional-responses/).
    
                And in the
                [FastAPI docs for Bigger Applications](https://fastapi.tiangolo.com/tutorial/bigger-applications/#include-an-apirouter-with-a-custom-prefix-tags-responses-and-dependencies).
                """
            ),
        ] = None,
        callbacks: Annotated[
            Optional[list[BaseRoute]],
            Doc(
                """
                OpenAPI callbacks that should apply to all *path operations* in this
                router.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
    
                Read more about it in the
                [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).
                """
            ),
        ] = None,
        routes: Annotated[
            Optional[list[BaseRoute]],
            Doc(
                """
                **Note**: you probably shouldn't use this parameter, it is inherited
                from Starlette and supported for compatibility.
    
                ---
    
                A list of routes to serve incoming HTTP and WebSocket requests.
                """
            ),
            deprecated(
                """
                You normally wouldn't use this parameter with FastAPI, it is inherited
                from Starlette and supported for compatibility.
    
                In FastAPI, you normally would use the *path operation methods*,
                like `router.get()`, `router.post()`, etc.
                """
            ),
        ] = None,
        redirect_slashes: Annotated[
            bool,
            Doc(
                """
                Whether to detect and redirect slashes in URLs when the client doesn't
                use the same format.
                """
            ),
        ] = True,
        default: Annotated[
            Optional[ASGIApp],
            Doc(
                """
                Default function handler for this router. Used to handle
                404 Not Found errors.
                """
            ),
        ] = None,
        dependency_overrides_provider: Annotated[
            Optional[Any],
            Doc(
                """
                Only used internally by FastAPI to handle dependency overrides.
    
                You shouldn't need to use it. It normally points to the `FastAPI` app
                object.
                """
            ),
        ] = None,
        route_class: Annotated[
            type[APIRoute],
            Doc(
                """
                Custom route (*path operation*) class to be used by this router.
    
                Read more about it in the
                [FastAPI docs for Custom Request and APIRoute class](https://fastapi.tiangolo.com/how-to/custom-request-and-route/#custom-apiroute-class-in-a-router).
                """
            ),
        ] = APIRoute,
        on_startup: Annotated[
            Optional[Sequence[Callable[[], Any]]],
            Doc(
                """
                A list of startup event handler functions.
    
                You should instead use the `lifespan` handlers.
    
                Read more in the [FastAPI docs for `lifespan`](https://fastapi.tiangolo.com/advanced/events/).
                """
            ),
        ] = None,
        on_shutdown: Annotated[
            Optional[Sequence[Callable[[], Any]]],
            Doc(
                """
                A list of shutdown event handler functions.
    
                You should instead use the `lifespan` handlers.
    
                Read more in the
                [FastAPI docs for `lifespan`](https://fastapi.tiangolo.com/advanced/events/).
                """
            ),
        ] = None,
        # the generic to Lifespan[AppType] is the type of the top level application
        # which the router cannot know statically, so we use typing.Any
        lifespan: Annotated[
            Optional[Lifespan[Any]],
            Doc(
                """
                A `Lifespan` context manager handler. This replaces `startup` and
                `shutdown` functions with a single context manager.
    
                Read more in the
                [FastAPI docs for `lifespan`](https://fastapi.tiangolo.com/advanced/events/).
                """
            ),
        ] = None,
        deprecated: Annotated[
            Optional[bool],
            Doc(
                """
                Mark all *path operations* in this router as deprecated.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
    
                Read more about it in the
                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
                """
            ),
        ] = None,
        include_in_schema: Annotated[
            bool,
            Doc(
                """
                To include (or not) all the *path operations* in this router in the
                generated OpenAPI.
    
                This affects the generated OpenAPI (e.g. visible at `/docs`).
    
                Read more about it in the
                [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-parameters-from-openapi).
                """
            ),
        ] = True,
        generate_unique_id_function: Annotated[
            Callable[[APIRoute], str],
            Doc(
                """
                Customize the function used to generate unique IDs for the *path
                operations* shown in the generated OpenAPI.
    
                This is particularly useful when automatically generating clients or
                SDKs for your API.
    
                Read more about it in the
                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
                """
            ),
        ] = Default(generate_unique_id),
    ) -> None:
        super().__init__(
            routes=routes,
            redirect_slashes=redirect_slashes,
            default=default,
            on_startup=on_startup,
            on_shutdown=on_shutdown,
            lifespan=lifespan,
        )
        if prefix:
            assert prefix.startswith("/"), "A path prefix must start with '/'"
            assert not prefix.endswith("/"), (
                "A path prefix must not end with '/', as the routes will start with '/'"
            )
        self.prefix = prefix
        self.tags: list[Union[str, Enum]] = tags or []
        self.dependencies = list(dependencies or [])
        self.deprecated = deprecated
        self.include_in_schema = include_in_schema
        self.responses = responses or {}
        self.callbacks = callbacks or []
        self.dependency_overrides_provider = dependency_overrides_provider
        self.route_class = route_class
        self.default_response_class = default_response_class
        self.generate_unique_id_function = generate_unique_id_function
      
  
---|---  
  
###  `` websocket [¶](#fastapi.APIRouter.websocket "Permanent link")
    
    
    websocket(path, name=None, *, dependencies=None)
    

Decorate a WebSocket function.

Read more about it in the [FastAPI docs for WebSockets](https://fastapi.tiangolo.com/advanced/websockets/).

**Example**

##### Example[¶](#fastapi.APIRouter.websocket--example "Permanent link")
    
    
    from fastapi import APIRouter, FastAPI, WebSocket
    
    app = FastAPI()
    router = APIRouter()
    
    @router.websocket("/ws")
    async def websocket_endpoint(websocket: WebSocket):
        await websocket.accept()
        while True:
            data = await websocket.receive_text()
            await websocket.send_text(f"Message text was: {data}")
    
    app.include_router(router)
    

PARAMETER | DESCRIPTION  
---|---  
`path` |  WebSocket path. **TYPE:** `str`  
`name` |  A name for the WebSocket. Only used internally. **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`dependencies` |  A list of dependencies (using `Depends()`) to be used for this WebSocket. Read more about it in the [FastAPI docs for WebSockets](https://fastapi.tiangolo.com/advanced/websockets/). **TYPE:** `Optional[Sequence[Depends]]` **DEFAULT:** `None`  
Source code in `fastapi/routing.py`
    
    
    1115
    1116
    1117
    1118
    1119
    1120
    1121
    1122
    1123
    1124
    1125
    1126
    1127
    1128
    1129
    1130
    1131
    1132
    1133
    1134
    1135
    1136
    1137
    1138
    1139
    1140
    1141
    1142
    1143
    1144
    1145
    1146
    1147
    1148
    1149
    1150
    1151
    1152
    1153
    1154
    1155
    1156
    1157
    1158
    1159
    1160
    1161
    1162
    1163
    1164
    1165
    1166
    1167
    1168
    1169
    1170
    1171
    1172
    1173
    1174
    1175
    1176
    1177
    1178
    1179
    1180

| 
    
    
    def websocket(
        self,
        path: Annotated[
            str,
            Doc(
                """
                WebSocket path.
                """
            ),
        ],
        name: Annotated[
            Optional[str],
            Doc(
                """
                A name for the WebSocket. Only used internally.
                """
            ),
        ] = None,
        *,
        dependencies: Annotated[
            Optional[Sequence[params.Depends]],
            Doc(
                """
                A list of dependencies (using `Depends()`) to be used for this
                WebSocket.
    
                Read more about it in the
                [FastAPI docs for WebSockets](https://fastapi.tiangolo.com/advanced/websockets/).
                """
            ),
        ] = None,
    ) -> Callable[[DecoratedCallable], DecoratedCallable]:
        """
        Decorate a WebSocket function.
    
        Read more about it in the
        [FastAPI docs for WebSockets](https://fastapi.tiangolo.com/advanced/websockets/).
    
        **Example**
    
        ## Example
    
        ```python
        from fastapi import APIRouter, FastAPI, WebSocket
    
        app = FastAPI()
        router = APIRouter()
    
        @router.websocket("/ws")
        async def websocket_endpoint(websocket: WebSocket):
            await websocket.accept()
            while True:
                data = await websocket.receive_text()
                await websocket.send_text(f"Message text was: {data}")
    
        app.include_router(router)
        ```
        """
    
        def decorator(func: DecoratedCallable) -> DecoratedCallable:
            self.add_api_websocket_route(
                path, func, name=name, dependencies=dependencies
            )
            return func
    
        return decorator
      
  
---|---  
  
###  `` include_router [¶](#fastapi.APIRouter.include_router "Permanent link")
    
    
    include_router(
        router,
        *,
        prefix="",
        tags=None,
        dependencies=None,
        default_response_class=Default([JSONResponse](../responses/#fastapi.responses.JSONResponse "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">fastapi.responses.JSONResponse</span> \(<code>starlette.responses.JSONResponse</code>\)")),
        responses=None,
        callbacks=None,
        deprecated=None,
        include_in_schema=True,
        generate_unique_id_function=Default(generate_unique_id)
    )
    

Include another `APIRouter` in the same current `APIRouter`.

Read more about it in the [FastAPI docs for Bigger Applications](https://fastapi.tiangolo.com/tutorial/bigger-applications/).

##### Example[¶](#fastapi.APIRouter.include_router--example "Permanent link")
    
    
    from fastapi import APIRouter, FastAPI
    
    app = FastAPI()
    internal_router = APIRouter()
    users_router = APIRouter()
    
    @users_router.get("/users/")
    def read_users():
        return [{"name": "Rick"}, {"name": "Morty"}]
    
    internal_router.include_router(users_router)
    app.include_router(internal_router)
    

PARAMETER | DESCRIPTION  
---|---  
`router` |  The `APIRouter` to include. **TYPE:** `[APIRouter](#fastapi.APIRouter "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">fastapi.APIRouter</span> \(<code>fastapi.routing.APIRouter</code>\)")`  
`prefix` |  An optional path prefix for the router. **TYPE:** `str` **DEFAULT:** `''`  
`tags` |  A list of tags to be applied to all the _path operations_ in this router. It will be added to the generated OpenAPI (e.g. visible at `/docs`). Read more about it in the [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/). **TYPE:** `Optional[list[Union[str, Enum]]]` **DEFAULT:** `None`  
`dependencies` |  A list of dependencies (using `Depends()`) to be applied to all the _path operations_ in this router. Read more about it in the [FastAPI docs for Bigger Applications - Multiple Files](https://fastapi.tiangolo.com/tutorial/bigger-applications/#include-an-apirouter-with-a-custom-prefix-tags-responses-and-dependencies). **TYPE:** `Optional[Sequence[Depends]]` **DEFAULT:** `None`  
`default_response_class` |  The default response class to be used. Read more in the [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#default-response-class). **TYPE:** `type[[Response](../response/#fastapi.Response "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">fastapi.Response</span> \(<code>starlette.responses.Response</code>\)")]` **DEFAULT:** `Default([JSONResponse](../responses/#fastapi.responses.JSONResponse "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">fastapi.responses.JSONResponse</span> \(<code>starlette.responses.JSONResponse</code>\)"))`  
`responses` |  Additional responses to be shown in OpenAPI. It will be added to the generated OpenAPI (e.g. visible at `/docs`). Read more about it in the [FastAPI docs for Additional Responses in OpenAPI](https://fastapi.tiangolo.com/advanced/additional-responses/). And in the [FastAPI docs for Bigger Applications](https://fastapi.tiangolo.com/tutorial/bigger-applications/#include-an-apirouter-with-a-custom-prefix-tags-responses-and-dependencies). **TYPE:** `Optional[dict[Union[int, str], dict[str, Any]]]` **DEFAULT:** `None`  
`callbacks` |  OpenAPI callbacks that should apply to all _path operations_ in this router. It will be added to the generated OpenAPI (e.g. visible at `/docs`). Read more about it in the [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/). **TYPE:** `Optional[list[BaseRoute]]` **DEFAULT:** `None`  
`deprecated` |  Mark all _path operations_ in this router as deprecated. It will be added to the generated OpenAPI (e.g. visible at `/docs`). Read more about it in the [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/). **TYPE:** `Optional[bool]` **DEFAULT:** `None`  
`include_in_schema` |  Include (or not) all the _path operations_ in this router in the generated OpenAPI schema. This affects the generated OpenAPI (e.g. visible at `/docs`). **TYPE:** `bool` **DEFAULT:** `True`  
`generate_unique_id_function` |  Customize the function used to generate unique IDs for the _path operations_ shown in the generated OpenAPI. This is particularly useful when automatically generating clients or SDKs for your API. Read more about it in the [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function). **TYPE:** `Callable[[APIRoute], str]` **DEFAULT:** `Default(generate_unique_id)`  
Source code in `fastapi/routing.py`
    
    
    1191
    1192
    1193
    1194
    1195
    1196
    1197
    1198
    1199
    1200
    1201
    1202
    1203
    1204
    1205
    1206
    1207
    1208
    1209
    1210
    1211
    1212
    1213
    1214
    1215
    1216
    1217
    1218
    1219
    1220
    1221
    1222
    1223
    1224
    1225
    1226
    1227
    1228
    1229
    1230
    1231
    1232
    1233
    1234
    1235
    1236
    1237
    1238
    1239
    1240
    1241
    1242
    1243
    1244
    1245
    1246
    1247
    1248
    1249
    1250
    1251
    1252
    1253
    1254
    1255
    1256
    1257
    1258
    1259
    1260
    1261
    1262
    1263
    1264
    1265
    1266
    1267
    1268
    1269
    1270
    1271
    1272
    1273
    1274
    1275
    1276
    1277
    1278
    1279
    1280
    1281
    1282
    1283
    1284
    1285
    1286
    1287
    1288
    1289
    1290
    1291
    1292
    1293
    1294
    1295
    1296
    1297
    1298
    1299
    1300
    1301
    1302
    1303
    1304
    1305
    1306
    1307
    1308
    1309
    1310
    1311
    1312
    1313
    1314
    1315
    1316
    1317
    1318
    1319
    1320
    1321
    1322
    1323
    1324
    1325
    1326
    1327
    1328
    1329
    1330
    1331
    1332
    1333
    1334
    1335
    1336
    1337
    1338
    1339
    1340
    1341
    1342
    1343
    1344
    1345
    1346
    1347
    1348
    1349
    1350
    1351
    1352
    1353
    1354
    1355
    1356
    1357
    1358
    1359
    1360
    1361
    1362
    1363
    1364
    1365
    1366
    1367
    1368
    1369
    1370
    1371
    1372
    1373
    1374
    1375
    1376
    1377
    1378
    1379
    1380
    1381
    1382
    1383
    1384
    1385
    1386
    1387
    1388
    1389
    1390
    1391
    1392
    1393
    1394
    1395
    1396
    1397
    1398
    1399
    1400
    1401
    1402
    1403
    1404
    1405
    1406
    1407
    1408
    1409
    1410
    1411
    1412
    1413
    1414
    1415
    1416
    1417
    1418
    1419
    1420
    1421
    1422
    1423
    1424
    1425
    1426
    1427
    1428
    1429
    1430
    1431
    1432
    1433

| 
    
    
    def include_router(
        self,
        router: Annotated["APIRouter", Doc("The `APIRouter` to include.")],
        *,
        prefix: Annotated[str, Doc("An optional path prefix for the router.")] = "",
        tags: Annotated[
            Optional[list[Union[str, Enum]]],
            Doc(
                """
                A list of tags to be applied to all the *path operations* in this
                router.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
    
                Read more about it in the
                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
                """
            ),
        ] = None,
        dependencies: Annotated[
            Optional[Sequence[params.Depends]],
            Doc(
                """
                A list of dependencies (using `Depends()`) to be applied to all the
                *path operations* in this router.
    
                Read more about it in the
                [FastAPI docs for Bigger Applications - Multiple Files](https://fastapi.tiangolo.com/tutorial/bigger-applications/#include-an-apirouter-with-a-custom-prefix-tags-responses-and-dependencies).
                """
            ),
        ] = None,
        default_response_class: Annotated[
            type[Response],
            Doc(
                """
                The default response class to be used.
    
                Read more in the
                [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#default-response-class).
                """
            ),
        ] = Default(JSONResponse),
        responses: Annotated[
            Optional[dict[Union[int, str], dict[str, Any]]],
            Doc(
                """
                Additional responses to be shown in OpenAPI.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
    
                Read more about it in the
                [FastAPI docs for Additional Responses in OpenAPI](https://fastapi.tiangolo.com/advanced/additional-responses/).
    
                And in the
                [FastAPI docs for Bigger Applications](https://fastapi.tiangolo.com/tutorial/bigger-applications/#include-an-apirouter-with-a-custom-prefix-tags-responses-and-dependencies).
                """
            ),
        ] = None,
        callbacks: Annotated[
            Optional[list[BaseRoute]],
            Doc(
                """
                OpenAPI callbacks that should apply to all *path operations* in this
                router.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
    
                Read more about it in the
                [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).
                """
            ),
        ] = None,
        deprecated: Annotated[
            Optional[bool],
            Doc(
                """
                Mark all *path operations* in this router as deprecated.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
    
                Read more about it in the
                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
                """
            ),
        ] = None,
        include_in_schema: Annotated[
            bool,
            Doc(
                """
                Include (or not) all the *path operations* in this router in the
                generated OpenAPI schema.
    
                This affects the generated OpenAPI (e.g. visible at `/docs`).
                """
            ),
        ] = True,
        generate_unique_id_function: Annotated[
            Callable[[APIRoute], str],
            Doc(
                """
                Customize the function used to generate unique IDs for the *path
                operations* shown in the generated OpenAPI.
    
                This is particularly useful when automatically generating clients or
                SDKs for your API.
    
                Read more about it in the
                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
                """
            ),
        ] = Default(generate_unique_id),
    ) -> None:
        """
        Include another `APIRouter` in the same current `APIRouter`.
    
        Read more about it in the
        [FastAPI docs for Bigger Applications](https://fastapi.tiangolo.com/tutorial/bigger-applications/).
    
        ## Example
    
        ```python
        from fastapi import APIRouter, FastAPI
    
        app = FastAPI()
        internal_router = APIRouter()
        users_router = APIRouter()
    
        @users_router.get("/users/")
        def read_users():
            return [{"name": "Rick"}, {"name": "Morty"}]
    
        internal_router.include_router(users_router)
        app.include_router(internal_router)
        ```
        """
        if prefix:
            assert prefix.startswith("/"), "A path prefix must start with '/'"
            assert not prefix.endswith("/"), (
                "A path prefix must not end with '/', as the routes will start with '/'"
            )
        else:
            for r in router.routes:
                path = getattr(r, "path")  # noqa: B009
                name = getattr(r, "name", "unknown")
                if path is not None and not path:
                    raise FastAPIError(
                        f"Prefix and path cannot be both empty (path operation: {name})"
                    )
        if responses is None:
            responses = {}
        for route in router.routes:
            if isinstance(route, APIRoute):
                combined_responses = {**responses, **route.responses}
                use_response_class = get_value_or_default(
                    route.response_class,
                    router.default_response_class,
                    default_response_class,
                    self.default_response_class,
                )
                current_tags = []
                if tags:
                    current_tags.extend(tags)
                if route.tags:
                    current_tags.extend(route.tags)
                current_dependencies: list[params.Depends] = []
                if dependencies:
                    current_dependencies.extend(dependencies)
                if route.dependencies:
                    current_dependencies.extend(route.dependencies)
                current_callbacks = []
                if callbacks:
                    current_callbacks.extend(callbacks)
                if route.callbacks:
                    current_callbacks.extend(route.callbacks)
                current_generate_unique_id = get_value_or_default(
                    route.generate_unique_id_function,
                    router.generate_unique_id_function,
                    generate_unique_id_function,
                    self.generate_unique_id_function,
                )
                self.add_api_route(
                    prefix + route.path,
                    route.endpoint,
                    response_model=route.response_model,
                    status_code=route.status_code,
                    tags=current_tags,
                    dependencies=current_dependencies,
                    summary=route.summary,
                    description=route.description,
                    response_description=route.response_description,
                    responses=combined_responses,
                    deprecated=route.deprecated or deprecated or self.deprecated,
                    methods=route.methods,
                    operation_id=route.operation_id,
                    response_model_include=route.response_model_include,
                    response_model_exclude=route.response_model_exclude,
                    response_model_by_alias=route.response_model_by_alias,
                    response_model_exclude_unset=route.response_model_exclude_unset,
                    response_model_exclude_defaults=route.response_model_exclude_defaults,
                    response_model_exclude_none=route.response_model_exclude_none,
                    include_in_schema=route.include_in_schema
                    and self.include_in_schema
                    and include_in_schema,
                    response_class=use_response_class,
                    name=route.name,
                    route_class_override=type(route),
                    callbacks=current_callbacks,
                    openapi_extra=route.openapi_extra,
                    generate_unique_id_function=current_generate_unique_id,
                )
            elif isinstance(route, routing.Route):
                methods = list(route.methods or [])
                self.add_route(
                    prefix + route.path,
                    route.endpoint,
                    methods=methods,
                    include_in_schema=route.include_in_schema,
                    name=route.name,
                )
            elif isinstance(route, APIWebSocketRoute):
                current_dependencies = []
                if dependencies:
                    current_dependencies.extend(dependencies)
                if route.dependencies:
                    current_dependencies.extend(route.dependencies)
                self.add_api_websocket_route(
                    prefix + route.path,
                    route.endpoint,
                    dependencies=current_dependencies,
                    name=route.name,
                )
            elif isinstance(route, routing.WebSocketRoute):
                self.add_websocket_route(
                    prefix + route.path, route.endpoint, name=route.name
                )
        for handler in router.on_startup:
            self.add_event_handler("startup", handler)
        for handler in router.on_shutdown:
            self.add_event_handler("shutdown", handler)
        self.lifespan_context = _merge_lifespan_context(
            self.lifespan_context,
            router.lifespan_context,
        )
      
  
---|---  
  
###  `` get [¶](#fastapi.APIRouter.get "Permanent link")
    
    
    get(
        path,
        *,
        response_model=Default(None),
        status_code=None,
        tags=None,
        dependencies=None,
        summary=None,
        description=None,
        response_description="Successful Response",
        responses=None,
        deprecated=None,
        operation_id=None,
        response_model_include=None,
        response_model_exclude=None,
        response_model_by_alias=True,
        response_model_exclude_unset=False,
        response_model_exclude_defaults=False,
        response_model_exclude_none=False,
        include_in_schema=True,
        response_class=Default([JSONResponse](../responses/#fastapi.responses.JSONResponse "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">fastapi.responses.JSONResponse</span> \(<code>starlette.responses.JSONResponse</code>\)")),
        name=None,
        callbacks=None,
        openapi_extra=None,
        generate_unique_id_function=Default(generate_unique_id)
    )
    

Add a _path operation_ using an HTTP GET operation.

##### Example[¶](#fastapi.APIRouter.get--example "Permanent link")
    
    
    from fastapi import APIRouter, FastAPI
    
    app = FastAPI()
    router = APIRouter()
    
    @router.get("/items/")
    def read_items():
        return [{"name": "Empanada"}, {"name": "Arepa"}]
    
    app.include_router(router)
    

PARAMETER | DESCRIPTION  
---|---  
`path` |  The URL path to be used for this _path operation_. For example, in `http://example.com/items`, the path is `/items`. **TYPE:** `str`  
`response_model` |  The type to use for the response. It could be any valid Pydantic _field_ type. So, it doesn't have to be a Pydantic model, it could be other things, like a `list`, `dict`, etc. It will be used for:

  * Documentation: the generated OpenAPI (and the UI at `/docs`) will show it as the response (JSON Schema).
  * Serialization: you could return an arbitrary object and the `response_model` would be used to serialize that object into the corresponding JSON.
  * Filtering: the JSON sent to the client will only contain the data (fields) defined in the `response_model`. If you returned an object that contains an attribute `password` but the `response_model` does not include that field, the JSON sent to the client would not have that `password`.
  * Validation: whatever you return will be serialized with the `response_model`, converting any data as necessary to generate the corresponding JSON. But if the data in the object returned is not valid, that would mean a violation of the contract with the client, so it's an error from the API developer. So, FastAPI will raise an error and return a 500 error code (Internal Server Error).

Read more about it in the [FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/). **TYPE:** `Any` **DEFAULT:** `Default(None)`  
`status_code` |  The default status code to be used for the response. You could override the status code by returning a response directly. Read more about it in the [FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/). **TYPE:** `Optional[int]` **DEFAULT:** `None`  
`tags` |  A list of tags to be applied to the _path operation_. It will be added to the generated OpenAPI (e.g. visible at `/docs`). Read more about it in the [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags). **TYPE:** `Optional[list[Union[str, Enum]]]` **DEFAULT:** `None`  
`dependencies` |  A list of dependencies (using `Depends()`) to be applied to the _path operation_. Read more about it in the [FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/). **TYPE:** `Optional[Sequence[Depends]]` **DEFAULT:** `None`  
`summary` |  A summary for the _path operation_. It will be added to the generated OpenAPI (e.g. visible at `/docs`). Read more about it in the [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/). **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`description` |  A description for the _path operation_. If not provided, it will be extracted automatically from the docstring of the _path operation function_. It can contain Markdown. It will be added to the generated OpenAPI (e.g. visible at `/docs`). Read more about it in the [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/). **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`response_description` |  The description for the default response. It will be added to the generated OpenAPI (e.g. visible at `/docs`). **TYPE:** `str` **DEFAULT:** `'Successful Response'`  
`responses` |  Additional responses that could be returned by this _path operation_. It will be added to the generated OpenAPI (e.g. visible at `/docs`). **TYPE:** `Optional[dict[Union[int, str], dict[str, Any]]]` **DEFAULT:** `None`  
`deprecated` |  Mark this _path operation_ as deprecated. It will be added to the generated OpenAPI (e.g. visible at `/docs`). **TYPE:** `Optional[bool]` **DEFAULT:** `None`  
`operation_id` |  Custom operation ID to be used by this _path operation_. By default, it is generated automatically. If you provide a custom operation ID, you need to make sure it is unique for the whole API. You can customize the operation ID generation with the parameter `generate_unique_id_function` in the `FastAPI` class. Read more about it in the [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function). **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`response_model_include` |  Configuration passed to Pydantic to include only certain fields in the response data. Read more about it in the [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude). **TYPE:** `Optional[IncEx]` **DEFAULT:** `None`  
`response_model_exclude` |  Configuration passed to Pydantic to exclude certain fields in the response data. Read more about it in the [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude). **TYPE:** `Optional[IncEx]` **DEFAULT:** `None`  
`response_model_by_alias` |  Configuration passed to Pydantic to define if the response model should be serialized by alias when an alias is used. Read more about it in the [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude). **TYPE:** `bool` **DEFAULT:** `True`  
`response_model_exclude_unset` |  Configuration passed to Pydantic to define if the response data should have all the fields, including the ones that were not set and have their default values. This is different from `response_model_exclude_defaults` in that if the fields are set, they will be included in the response, even if the value is the same as the default. When `True`, default values are omitted from the response. Read more about it in the [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter). **TYPE:** `bool` **DEFAULT:** `False`  
`response_model_exclude_defaults` |  Configuration passed to Pydantic to define if the response data should have all the fields, including the ones that have the same value as the default. This is different from `response_model_exclude_unset` in that if the fields are set but contain the same default values, they will be excluded from the response. When `True`, default values are omitted from the response. Read more about it in the [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter). **TYPE:** `bool` **DEFAULT:** `False`  
`response_model_exclude_none` |  Configuration passed to Pydantic to define if the response data should exclude fields set to `None`. This is much simpler (less smart) than `response_model_exclude_unset` and `response_model_exclude_defaults`. You probably want to use one of those two instead of this one, as those allow returning `None` values when it makes sense. Read more about it in the [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none). **TYPE:** `bool` **DEFAULT:** `False`  
`include_in_schema` |  Include this _path operation_ in the generated OpenAPI schema. This affects the generated OpenAPI (e.g. visible at `/docs`). Read more about it in the [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-parameters-from-openapi). **TYPE:** `bool` **DEFAULT:** `True`  
`response_class` |  Response class to be used for this _path operation_. This will not be used if you return a response directly. Read more about it in the [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse). **TYPE:** `type[[Response](../response/#fastapi.Response "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">fastapi.Response</span> \(<code>starlette.responses.Response</code>\)")]` **DEFAULT:** `Default([JSONResponse](../responses/#fastapi.responses.JSONResponse "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">fastapi.responses.JSONResponse</span> \(<code>starlette.responses.JSONResponse</code>\)"))`  
`name` |  Name for this _path operation_. Only used internally. **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`callbacks` |  List of _path operations_ that will be used as OpenAPI callbacks. This is only for OpenAPI documentation, the callbacks won't be used directly. It will be added to the generated OpenAPI (e.g. visible at `/docs`). Read more about it in the [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/). **TYPE:** `Optional[list[BaseRoute]]` **DEFAULT:** `None`  
`openapi_extra` |  Extra metadata to be included in the OpenAPI schema for this _path operation_. Read more about it in the [FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema). **TYPE:** `Optional[dict[str, Any]]` **DEFAULT:** `None`  
`generate_unique_id_function` |  Customize the function used to generate unique IDs for the _path operations_ shown in the generated OpenAPI. This is particularly useful when automatically generating clients or SDKs for your API. Read more about it in the [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function). **TYPE:** `Callable[[APIRoute], str]` **DEFAULT:** `Default(generate_unique_id)`  
Source code in `fastapi/routing.py`
    
    
    1435
    1436
    1437
    1438
    1439
    1440
    1441
    1442
    1443
    1444
    1445
    1446
    1447
    1448
    1449
    1450
    1451
    1452
    1453
    1454
    1455
    1456
    1457
    1458
    1459
    1460
    1461
    1462
    1463
    1464
    1465
    1466
    1467
    1468
    1469
    1470
    1471
    1472
    1473
    1474
    1475
    1476
    1477
    1478
    1479
    1480
    1481
    1482
    1483
    1484
    1485
    1486
    1487
    1488
    1489
    1490
    1491
    1492
    1493
    1494
    1495
    1496
    1497
    1498
    1499
    1500
    1501
    1502
    1503
    1504
    1505
    1506
    1507
    1508
    1509
    1510
    1511
    1512
    1513
    1514
    1515
    1516
    1517
    1518
    1519
    1520
    1521
    1522
    1523
    1524
    1525
    1526
    1527
    1528
    1529
    1530
    1531
    1532
    1533
    1534
    1535
    1536
    1537
    1538
    1539
    1540
    1541
    1542
    1543
    1544
    1545
    1546
    1547
    1548
    1549
    1550
    1551
    1552
    1553
    1554
    1555
    1556
    1557
    1558
    1559
    1560
    1561
    1562
    1563
    1564
    1565
    1566
    1567
    1568
    1569
    1570
    1571
    1572
    1573
    1574
    1575
    1576
    1577
    1578
    1579
    1580
    1581
    1582
    1583
    1584
    1585
    1586
    1587
    1588
    1589
    1590
    1591
    1592
    1593
    1594
    1595
    1596
    1597
    1598
    1599
    1600
    1601
    1602
    1603
    1604
    1605
    1606
    1607
    1608
    1609
    1610
    1611
    1612
    1613
    1614
    1615
    1616
    1617
    1618
    1619
    1620
    1621
    1622
    1623
    1624
    1625
    1626
    1627
    1628
    1629
    1630
    1631
    1632
    1633
    1634
    1635
    1636
    1637
    1638
    1639
    1640
    1641
    1642
    1643
    1644
    1645
    1646
    1647
    1648
    1649
    1650
    1651
    1652
    1653
    1654
    1655
    1656
    1657
    1658
    1659
    1660
    1661
    1662
    1663
    1664
    1665
    1666
    1667
    1668
    1669
    1670
    1671
    1672
    1673
    1674
    1675
    1676
    1677
    1678
    1679
    1680
    1681
    1682
    1683
    1684
    1685
    1686
    1687
    1688
    1689
    1690
    1691
    1692
    1693
    1694
    1695
    1696
    1697
    1698
    1699
    1700
    1701
    1702
    1703
    1704
    1705
    1706
    1707
    1708
    1709
    1710
    1711
    1712
    1713
    1714
    1715
    1716
    1717
    1718
    1719
    1720
    1721
    1722
    1723
    1724
    1725
    1726
    1727
    1728
    1729
    1730
    1731
    1732
    1733
    1734
    1735
    1736
    1737
    1738
    1739
    1740
    1741
    1742
    1743
    1744
    1745
    1746
    1747
    1748
    1749
    1750
    1751
    1752
    1753
    1754
    1755
    1756
    1757
    1758
    1759
    1760
    1761
    1762
    1763
    1764
    1765
    1766
    1767
    1768
    1769
    1770
    1771
    1772
    1773
    1774
    1775
    1776
    1777
    1778
    1779
    1780
    1781
    1782
    1783
    1784
    1785
    1786
    1787
    1788
    1789
    1790
    1791
    1792
    1793
    1794
    1795
    1796
    1797
    1798
    1799
    1800
    1801
    1802
    1803
    1804
    1805
    1806
    1807
    1808
    1809
    1810

| 
    
    
    def get(
        self,
        path: Annotated[
            str,
            Doc(
                """
                The URL path to be used for this *path operation*.
    
                For example, in `http://example.com/items`, the path is `/items`.
                """
            ),
        ],
        *,
        response_model: Annotated[
            Any,
            Doc(
                """
                The type to use for the response.
    
                It could be any valid Pydantic *field* type. So, it doesn't have to
                be a Pydantic model, it could be other things, like a `list`, `dict`,
                etc.
    
                It will be used for:
    
                * Documentation: the generated OpenAPI (and the UI at `/docs`) will
                    show it as the response (JSON Schema).
                * Serialization: you could return an arbitrary object and the
                    `response_model` would be used to serialize that object into the
                    corresponding JSON.
                * Filtering: the JSON sent to the client will only contain the data
                    (fields) defined in the `response_model`. If you returned an object
                    that contains an attribute `password` but the `response_model` does
                    not include that field, the JSON sent to the client would not have
                    that `password`.
                * Validation: whatever you return will be serialized with the
                    `response_model`, converting any data as necessary to generate the
                    corresponding JSON. But if the data in the object returned is not
                    valid, that would mean a violation of the contract with the client,
                    so it's an error from the API developer. So, FastAPI will raise an
                    error and return a 500 error code (Internal Server Error).
    
                Read more about it in the
                [FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).
                """
            ),
        ] = Default(None),
        status_code: Annotated[
            Optional[int],
            Doc(
                """
                The default status code to be used for the response.
    
                You could override the status code by returning a response directly.
    
                Read more about it in the
                [FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).
                """
            ),
        ] = None,
        tags: Annotated[
            Optional[list[Union[str, Enum]]],
            Doc(
                """
                A list of tags to be applied to the *path operation*.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
    
                Read more about it in the
                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).
                """
            ),
        ] = None,
        dependencies: Annotated[
            Optional[Sequence[params.Depends]],
            Doc(
                """
                A list of dependencies (using `Depends()`) to be applied to the
                *path operation*.
    
                Read more about it in the
                [FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).
                """
            ),
        ] = None,
        summary: Annotated[
            Optional[str],
            Doc(
                """
                A summary for the *path operation*.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
    
                Read more about it in the
                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
                """
            ),
        ] = None,
        description: Annotated[
            Optional[str],
            Doc(
                """
                A description for the *path operation*.
    
                If not provided, it will be extracted automatically from the docstring
                of the *path operation function*.
    
                It can contain Markdown.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
    
                Read more about it in the
                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
                """
            ),
        ] = None,
        response_description: Annotated[
            str,
            Doc(
                """
                The description for the default response.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
                """
            ),
        ] = "Successful Response",
        responses: Annotated[
            Optional[dict[Union[int, str], dict[str, Any]]],
            Doc(
                """
                Additional responses that could be returned by this *path operation*.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
                """
            ),
        ] = None,
        deprecated: Annotated[
            Optional[bool],
            Doc(
                """
                Mark this *path operation* as deprecated.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
                """
            ),
        ] = None,
        operation_id: Annotated[
            Optional[str],
            Doc(
                """
                Custom operation ID to be used by this *path operation*.
    
                By default, it is generated automatically.
    
                If you provide a custom operation ID, you need to make sure it is
                unique for the whole API.
    
                You can customize the
                operation ID generation with the parameter
                `generate_unique_id_function` in the `FastAPI` class.
    
                Read more about it in the
                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
                """
            ),
        ] = None,
        response_model_include: Annotated[
            Optional[IncEx],
            Doc(
                """
                Configuration passed to Pydantic to include only certain fields in the
                response data.
    
                Read more about it in the
                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
                """
            ),
        ] = None,
        response_model_exclude: Annotated[
            Optional[IncEx],
            Doc(
                """
                Configuration passed to Pydantic to exclude certain fields in the
                response data.
    
                Read more about it in the
                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
                """
            ),
        ] = None,
        response_model_by_alias: Annotated[
            bool,
            Doc(
                """
                Configuration passed to Pydantic to define if the response model
                should be serialized by alias when an alias is used.
    
                Read more about it in the
                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
                """
            ),
        ] = True,
        response_model_exclude_unset: Annotated[
            bool,
            Doc(
                """
                Configuration passed to Pydantic to define if the response data
                should have all the fields, including the ones that were not set and
                have their default values. This is different from
                `response_model_exclude_defaults` in that if the fields are set,
                they will be included in the response, even if the value is the same
                as the default.
    
                When `True`, default values are omitted from the response.
    
                Read more about it in the
                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).
                """
            ),
        ] = False,
        response_model_exclude_defaults: Annotated[
            bool,
            Doc(
                """
                Configuration passed to Pydantic to define if the response data
                should have all the fields, including the ones that have the same value
                as the default. This is different from `response_model_exclude_unset`
                in that if the fields are set but contain the same default values,
                they will be excluded from the response.
    
                When `True`, default values are omitted from the response.
    
                Read more about it in the
                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).
                """
            ),
        ] = False,
        response_model_exclude_none: Annotated[
            bool,
            Doc(
                """
                Configuration passed to Pydantic to define if the response data should
                exclude fields set to `None`.
    
                This is much simpler (less smart) than `response_model_exclude_unset`
                and `response_model_exclude_defaults`. You probably want to use one of
                those two instead of this one, as those allow returning `None` values
                when it makes sense.
    
                Read more about it in the
                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).
                """
            ),
        ] = False,
        include_in_schema: Annotated[
            bool,
            Doc(
                """
                Include this *path operation* in the generated OpenAPI schema.
    
                This affects the generated OpenAPI (e.g. visible at `/docs`).
    
                Read more about it in the
                [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-parameters-from-openapi).
                """
            ),
        ] = True,
        response_class: Annotated[
            type[Response],
            Doc(
                """
                Response class to be used for this *path operation*.
    
                This will not be used if you return a response directly.
    
                Read more about it in the
                [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).
                """
            ),
        ] = Default(JSONResponse),
        name: Annotated[
            Optional[str],
            Doc(
                """
                Name for this *path operation*. Only used internally.
                """
            ),
        ] = None,
        callbacks: Annotated[
            Optional[list[BaseRoute]],
            Doc(
                """
                List of *path operations* that will be used as OpenAPI callbacks.
    
                This is only for OpenAPI documentation, the callbacks won't be used
                directly.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
    
                Read more about it in the
                [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).
                """
            ),
        ] = None,
        openapi_extra: Annotated[
            Optional[dict[str, Any]],
            Doc(
                """
                Extra metadata to be included in the OpenAPI schema for this *path
                operation*.
    
                Read more about it in the
                [FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).
                """
            ),
        ] = None,
        generate_unique_id_function: Annotated[
            Callable[[APIRoute], str],
            Doc(
                """
                Customize the function used to generate unique IDs for the *path
                operations* shown in the generated OpenAPI.
    
                This is particularly useful when automatically generating clients or
                SDKs for your API.
    
                Read more about it in the
                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
                """
            ),
        ] = Default(generate_unique_id),
    ) -> Callable[[DecoratedCallable], DecoratedCallable]:
        """
        Add a *path operation* using an HTTP GET operation.
    
        ## Example
    
        ```python
        from fastapi import APIRouter, FastAPI
    
        app = FastAPI()
        router = APIRouter()
    
        @router.get("/items/")
        def read_items():
            return [{"name": "Empanada"}, {"name": "Arepa"}]
    
        app.include_router(router)
        ```
        """
        return self.api_route(
            path=path,
            response_model=response_model,
            status_code=status_code,
            tags=tags,
            dependencies=dependencies,
            summary=summary,
            description=description,
            response_description=response_description,
            responses=responses,
            deprecated=deprecated,
            methods=["GET"],
            operation_id=operation_id,
            response_model_include=response_model_include,
            response_model_exclude=response_model_exclude,
            response_model_by_alias=response_model_by_alias,
            response_model_exclude_unset=response_model_exclude_unset,
            response_model_exclude_defaults=response_model_exclude_defaults,
            response_model_exclude_none=response_model_exclude_none,
            include_in_schema=include_in_schema,
            response_class=response_class,
            name=name,
            callbacks=callbacks,
            openapi_extra=openapi_extra,
            generate_unique_id_function=generate_unique_id_function,
        )
      
  
---|---  
  
###  `` put [¶](#fastapi.APIRouter.put "Permanent link")
    
    
    put(
        path,
        *,
        response_model=Default(None),
        status_code=None,
        tags=None,
        dependencies=None,
        summary=None,
        description=None,
        response_description="Successful Response",
        responses=None,
        deprecated=None,
        operation_id=None,
        response_model_include=None,
        response_model_exclude=None,
        response_model_by_alias=True,
        response_model_exclude_unset=False,
        response_model_exclude_defaults=False,
        response_model_exclude_none=False,
        include_in_schema=True,
        response_class=Default([JSONResponse](../responses/#fastapi.responses.JSONResponse "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">fastapi.responses.JSONResponse</span> \(<code>starlette.responses.JSONResponse</code>\)")),
        name=None,
        callbacks=None,
        openapi_extra=None,
        generate_unique_id_function=Default(generate_unique_id)
    )
    

Add a _path operation_ using an HTTP PUT operation.

##### Example[¶](#fastapi.APIRouter.put--example "Permanent link")
    
    
    from fastapi import APIRouter, FastAPI
    from pydantic import BaseModel
    
    class Item(BaseModel):
        name: str
        description: str | None = None
    
    app = FastAPI()
    router = APIRouter()
    
    @router.put("/items/{item_id}")
    def replace_item(item_id: str, item: Item):
        return {"message": "Item replaced", "id": item_id}
    
    app.include_router(router)
    

PARAMETER | DESCRIPTION  
---|---  
`path` |  The URL path to be used for this _path operation_. For example, in `http://example.com/items`, the path is `/items`. **TYPE:** `str`  
`response_model` |  The type to use for the response. It could be any valid Pydantic _field_ type. So, it doesn't have to be a Pydantic model, it could be other things, like a `list`, `dict`, etc. It will be used for:

  * Documentation: the generated OpenAPI (and the UI at `/docs`) will show it as the response (JSON Schema).
  * Serialization: you could return an arbitrary object and the `response_model` would be used to serialize that object into the corresponding JSON.
  * Filtering: the JSON sent to the client will only contain the data (fields) defined in the `response_model`. If you returned an object that contains an attribute `password` but the `response_model` does not include that field, the JSON sent to the client would not have that `password`.
  * Validation: whatever you return will be serialized with the `response_model`, converting any data as necessary to generate the corresponding JSON. But if the data in the object returned is not valid, that would mean a violation of the contract with the client, so it's an error from the API developer. So, FastAPI will raise an error and return a 500 error code (Internal Server Error).

Read more about it in the [FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/). **TYPE:** `Any` **DEFAULT:** `Default(None)`  
`status_code` |  The default status code to be used for the response. You could override the status code by returning a response directly. Read more about it in the [FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/). **TYPE:** `Optional[int]` **DEFAULT:** `None`  
`tags` |  A list of tags to be applied to the _path operation_. It will be added to the generated OpenAPI (e.g. visible at `/docs`). Read more about it in the [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags). **TYPE:** `Optional[list[Union[str, Enum]]]` **DEFAULT:** `None`  
`dependencies` |  A list of dependencies (using `Depends()`) to be applied to the _path operation_. Read more about it in the [FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/). **TYPE:** `Optional[Sequence[Depends]]` **DEFAULT:** `None`  
`summary` |  A summary for the _path operation_. It will be added to the generated OpenAPI (e.g. visible at `/docs`). Read more about it in the [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/). **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`description` |  A description for the _path operation_. If not provided, it will be extracted automatically from the docstring of the _path operation function_. It can contain Markdown. It will be added to the generated OpenAPI (e.g. visible at `/docs`). Read more about it in the [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/). **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`response_description` |  The description for the default response. It will be added to the generated OpenAPI (e.g. visible at `/docs`). **TYPE:** `str` **DEFAULT:** `'Successful Response'`  
`responses` |  Additional responses that could be returned by this _path operation_. It will be added to the generated OpenAPI (e.g. visible at `/docs`). **TYPE:** `Optional[dict[Union[int, str], dict[str, Any]]]` **DEFAULT:** `None`  
`deprecated` |  Mark this _path operation_ as deprecated. It will be added to the generated OpenAPI (e.g. visible at `/docs`). **TYPE:** `Optional[bool]` **DEFAULT:** `None`  
`operation_id` |  Custom operation ID to be used by this _path operation_. By default, it is generated automatically. If you provide a custom operation ID, you need to make sure it is unique for the whole API. You can customize the operation ID generation with the parameter `generate_unique_id_function` in the `FastAPI` class. Read more about it in the [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function). **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`response_model_include` |  Configuration passed to Pydantic to include only certain fields in the response data. Read more about it in the [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude). **TYPE:** `Optional[IncEx]` **DEFAULT:** `None`  
`response_model_exclude` |  Configuration passed to Pydantic to exclude certain fields in the response data. Read more about it in the [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude). **TYPE:** `Optional[IncEx]` **DEFAULT:** `None`  
`response_model_by_alias` |  Configuration passed to Pydantic to define if the response model should be serialized by alias when an alias is used. Read more about it in the [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude). **TYPE:** `bool` **DEFAULT:** `True`  
`response_model_exclude_unset` |  Configuration passed to Pydantic to define if the response data should have all the fields, including the ones that were not set and have their default values. This is different from `response_model_exclude_defaults` in that if the fields are set, they will be included in the response, even if the value is the same as the default. When `True`, default values are omitted from the response. Read more about it in the [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter). **TYPE:** `bool` **DEFAULT:** `False`  
`response_model_exclude_defaults` |  Configuration passed to Pydantic to define if the response data should have all the fields, including the ones that have the same value as the default. This is different from `response_model_exclude_unset` in that if the fields are set but contain the same default values, they will be excluded from the response. When `True`, default values are omitted from the response. Read more about it in the [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter). **TYPE:** `bool` **DEFAULT:** `False`  
`response_model_exclude_none` |  Configuration passed to Pydantic to define if the response data should exclude fields set to `None`. This is much simpler (less smart) than `response_model_exclude_unset` and `response_model_exclude_defaults`. You probably want to use one of those two instead of this one, as those allow returning `None` values when it makes sense. Read more about it in the [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none). **TYPE:** `bool` **DEFAULT:** `False`  
`include_in_schema` |  Include this _path operation_ in the generated OpenAPI schema. This affects the generated OpenAPI (e.g. visible at `/docs`). Read more about it in the [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-parameters-from-openapi). **TYPE:** `bool` **DEFAULT:** `True`  
`response_class` |  Response class to be used for this _path operation_. This will not be used if you return a response directly. Read more about it in the [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse). **TYPE:** `type[[Response](../response/#fastapi.Response "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">fastapi.Response</span> \(<code>starlette.responses.Response</code>\)")]` **DEFAULT:** `Default([JSONResponse](../responses/#fastapi.responses.JSONResponse "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">fastapi.responses.JSONResponse</span> \(<code>starlette.responses.JSONResponse</code>\)"))`  
`name` |  Name for this _path operation_. Only used internally. **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`callbacks` |  List of _path operations_ that will be used as OpenAPI callbacks. This is only for OpenAPI documentation, the callbacks won't be used directly. It will be added to the generated OpenAPI (e.g. visible at `/docs`). Read more about it in the [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/). **TYPE:** `Optional[list[BaseRoute]]` **DEFAULT:** `None`  
`openapi_extra` |  Extra metadata to be included in the OpenAPI schema for this _path operation_. Read more about it in the [FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema). **TYPE:** `Optional[dict[str, Any]]` **DEFAULT:** `None`  
`generate_unique_id_function` |  Customize the function used to generate unique IDs for the _path operations_ shown in the generated OpenAPI. This is particularly useful when automatically generating clients or SDKs for your API. Read more about it in the [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function). **TYPE:** `Callable[[APIRoute], str]` **DEFAULT:** `Default(generate_unique_id)`  
Source code in `fastapi/routing.py`
    
    
    1812
    1813
    1814
    1815
    1816
    1817
    1818
    1819
    1820
    1821
    1822
    1823
    1824
    1825
    1826
    1827
    1828
    1829
    1830
    1831
    1832
    1833
    1834
    1835
    1836
    1837
    1838
    1839
    1840
    1841
    1842
    1843
    1844
    1845
    1846
    1847
    1848
    1849
    1850
    1851
    1852
    1853
    1854
    1855
    1856
    1857
    1858
    1859
    1860
    1861
    1862
    1863
    1864
    1865
    1866
    1867
    1868
    1869
    1870
    1871
    1872
    1873
    1874
    1875
    1876
    1877
    1878
    1879
    1880
    1881
    1882
    1883
    1884
    1885
    1886
    1887
    1888
    1889
    1890
    1891
    1892
    1893
    1894
    1895
    1896
    1897
    1898
    1899
    1900
    1901
    1902
    1903
    1904
    1905
    1906
    1907
    1908
    1909
    1910
    1911
    1912
    1913
    1914
    1915
    1916
    1917
    1918
    1919
    1920
    1921
    1922
    1923
    1924
    1925
    1926
    1927
    1928
    1929
    1930
    1931
    1932
    1933
    1934
    1935
    1936
    1937
    1938
    1939
    1940
    1941
    1942
    1943
    1944
    1945
    1946
    1947
    1948
    1949
    1950
    1951
    1952
    1953
    1954
    1955
    1956
    1957
    1958
    1959
    1960
    1961
    1962
    1963
    1964
    1965
    1966
    1967
    1968
    1969
    1970
    1971
    1972
    1973
    1974
    1975
    1976
    1977
    1978
    1979
    1980
    1981
    1982
    1983
    1984
    1985
    1986
    1987
    1988
    1989
    1990
    1991
    1992
    1993
    1994
    1995
    1996
    1997
    1998
    1999
    2000
    2001
    2002
    2003
    2004
    2005
    2006
    2007
    2008
    2009
    2010
    2011
    2012
    2013
    2014
    2015
    2016
    2017
    2018
    2019
    2020
    2021
    2022
    2023
    2024
    2025
    2026
    2027
    2028
    2029
    2030
    2031
    2032
    2033
    2034
    2035
    2036
    2037
    2038
    2039
    2040
    2041
    2042
    2043
    2044
    2045
    2046
    2047
    2048
    2049
    2050
    2051
    2052
    2053
    2054
    2055
    2056
    2057
    2058
    2059
    2060
    2061
    2062
    2063
    2064
    2065
    2066
    2067
    2068
    2069
    2070
    2071
    2072
    2073
    2074
    2075
    2076
    2077
    2078
    2079
    2080
    2081
    2082
    2083
    2084
    2085
    2086
    2087
    2088
    2089
    2090
    2091
    2092
    2093
    2094
    2095
    2096
    2097
    2098
    2099
    2100
    2101
    2102
    2103
    2104
    2105
    2106
    2107
    2108
    2109
    2110
    2111
    2112
    2113
    2114
    2115
    2116
    2117
    2118
    2119
    2120
    2121
    2122
    2123
    2124
    2125
    2126
    2127
    2128
    2129
    2130
    2131
    2132
    2133
    2134
    2135
    2136
    2137
    2138
    2139
    2140
    2141
    2142
    2143
    2144
    2145
    2146
    2147
    2148
    2149
    2150
    2151
    2152
    2153
    2154
    2155
    2156
    2157
    2158
    2159
    2160
    2161
    2162
    2163
    2164
    2165
    2166
    2167
    2168
    2169
    2170
    2171
    2172
    2173
    2174
    2175
    2176
    2177
    2178
    2179
    2180
    2181
    2182
    2183
    2184
    2185
    2186
    2187
    2188
    2189
    2190
    2191
    2192

| 
    
    
    def put(
        self,
        path: Annotated[
            str,
            Doc(
                """
                The URL path to be used for this *path operation*.
    
                For example, in `http://example.com/items`, the path is `/items`.
                """
            ),
        ],
        *,
        response_model: Annotated[
            Any,
            Doc(
                """
                The type to use for the response.
    
                It could be any valid Pydantic *field* type. So, it doesn't have to
                be a Pydantic model, it could be other things, like a `list`, `dict`,
                etc.
    
                It will be used for:
    
                * Documentation: the generated OpenAPI (and the UI at `/docs`) will
                    show it as the response (JSON Schema).
                * Serialization: you could return an arbitrary object and the
                    `response_model` would be used to serialize that object into the
                    corresponding JSON.
                * Filtering: the JSON sent to the client will only contain the data
                    (fields) defined in the `response_model`. If you returned an object
                    that contains an attribute `password` but the `response_model` does
                    not include that field, the JSON sent to the client would not have
                    that `password`.
                * Validation: whatever you return will be serialized with the
                    `response_model`, converting any data as necessary to generate the
                    corresponding JSON. But if the data in the object returned is not
                    valid, that would mean a violation of the contract with the client,
                    so it's an error from the API developer. So, FastAPI will raise an
                    error and return a 500 error code (Internal Server Error).
    
                Read more about it in the
                [FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).
                """
            ),
        ] = Default(None),
        status_code: Annotated[
            Optional[int],
            Doc(
                """
                The default status code to be used for the response.
    
                You could override the status code by returning a response directly.
    
                Read more about it in the
                [FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).
                """
            ),
        ] = None,
        tags: Annotated[
            Optional[list[Union[str, Enum]]],
            Doc(
                """
                A list of tags to be applied to the *path operation*.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
    
                Read more about it in the
                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).
                """
            ),
        ] = None,
        dependencies: Annotated[
            Optional[Sequence[params.Depends]],
            Doc(
                """
                A list of dependencies (using `Depends()`) to be applied to the
                *path operation*.
    
                Read more about it in the
                [FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).
                """
            ),
        ] = None,
        summary: Annotated[
            Optional[str],
            Doc(
                """
                A summary for the *path operation*.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
    
                Read more about it in the
                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
                """
            ),
        ] = None,
        description: Annotated[
            Optional[str],
            Doc(
                """
                A description for the *path operation*.
    
                If not provided, it will be extracted automatically from the docstring
                of the *path operation function*.
    
                It can contain Markdown.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
    
                Read more about it in the
                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
                """
            ),
        ] = None,
        response_description: Annotated[
            str,
            Doc(
                """
                The description for the default response.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
                """
            ),
        ] = "Successful Response",
        responses: Annotated[
            Optional[dict[Union[int, str], dict[str, Any]]],
            Doc(
                """
                Additional responses that could be returned by this *path operation*.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
                """
            ),
        ] = None,
        deprecated: Annotated[
            Optional[bool],
            Doc(
                """
                Mark this *path operation* as deprecated.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
                """
            ),
        ] = None,
        operation_id: Annotated[
            Optional[str],
            Doc(
                """
                Custom operation ID to be used by this *path operation*.
    
                By default, it is generated automatically.
    
                If you provide a custom operation ID, you need to make sure it is
                unique for the whole API.
    
                You can customize the
                operation ID generation with the parameter
                `generate_unique_id_function` in the `FastAPI` class.
    
                Read more about it in the
                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
                """
            ),
        ] = None,
        response_model_include: Annotated[
            Optional[IncEx],
            Doc(
                """
                Configuration passed to Pydantic to include only certain fields in the
                response data.
    
                Read more about it in the
                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
                """
            ),
        ] = None,
        response_model_exclude: Annotated[
            Optional[IncEx],
            Doc(
                """
                Configuration passed to Pydantic to exclude certain fields in the
                response data.
    
                Read more about it in the
                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
                """
            ),
        ] = None,
        response_model_by_alias: Annotated[
            bool,
            Doc(
                """
                Configuration passed to Pydantic to define if the response model
                should be serialized by alias when an alias is used.
    
                Read more about it in the
                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
                """
            ),
        ] = True,
        response_model_exclude_unset: Annotated[
            bool,
            Doc(
                """
                Configuration passed to Pydantic to define if the response data
                should have all the fields, including the ones that were not set and
                have their default values. This is different from
                `response_model_exclude_defaults` in that if the fields are set,
                they will be included in the response, even if the value is the same
                as the default.
    
                When `True`, default values are omitted from the response.
    
                Read more about it in the
                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).
                """
            ),
        ] = False,
        response_model_exclude_defaults: Annotated[
            bool,
            Doc(
                """
                Configuration passed to Pydantic to define if the response data
                should have all the fields, including the ones that have the same value
                as the default. This is different from `response_model_exclude_unset`
                in that if the fields are set but contain the same default values,
                they will be excluded from the response.
    
                When `True`, default values are omitted from the response.
    
                Read more about it in the
                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).
                """
            ),
        ] = False,
        response_model_exclude_none: Annotated[
            bool,
            Doc(
                """
                Configuration passed to Pydantic to define if the response data should
                exclude fields set to `None`.
    
                This is much simpler (less smart) than `response_model_exclude_unset`
                and `response_model_exclude_defaults`. You probably want to use one of
                those two instead of this one, as those allow returning `None` values
                when it makes sense.
    
                Read more about it in the
                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).
                """
            ),
        ] = False,
        include_in_schema: Annotated[
            bool,
            Doc(
                """
                Include this *path operation* in the generated OpenAPI schema.
    
                This affects the generated OpenAPI (e.g. visible at `/docs`).
    
                Read more about it in the
                [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-parameters-from-openapi).
                """
            ),
        ] = True,
        response_class: Annotated[
            type[Response],
            Doc(
                """
                Response class to be used for this *path operation*.
    
                This will not be used if you return a response directly.
    
                Read more about it in the
                [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).
                """
            ),
        ] = Default(JSONResponse),
        name: Annotated[
            Optional[str],
            Doc(
                """
                Name for this *path operation*. Only used internally.
                """
            ),
        ] = None,
        callbacks: Annotated[
            Optional[list[BaseRoute]],
            Doc(
                """
                List of *path operations* that will be used as OpenAPI callbacks.
    
                This is only for OpenAPI documentation, the callbacks won't be used
                directly.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
    
                Read more about it in the
                [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).
                """
            ),
        ] = None,
        openapi_extra: Annotated[
            Optional[dict[str, Any]],
            Doc(
                """
                Extra metadata to be included in the OpenAPI schema for this *path
                operation*.
    
                Read more about it in the
                [FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).
                """
            ),
        ] = None,
        generate_unique_id_function: Annotated[
            Callable[[APIRoute], str],
            Doc(
                """
                Customize the function used to generate unique IDs for the *path
                operations* shown in the generated OpenAPI.
    
                This is particularly useful when automatically generating clients or
                SDKs for your API.
    
                Read more about it in the
                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
                """
            ),
        ] = Default(generate_unique_id),
    ) -> Callable[[DecoratedCallable], DecoratedCallable]:
        """
        Add a *path operation* using an HTTP PUT operation.
    
        ## Example
    
        ```python
        from fastapi import APIRouter, FastAPI
        from pydantic import BaseModel
    
        class Item(BaseModel):
            name: str
            description: str | None = None
    
        app = FastAPI()
        router = APIRouter()
    
        @router.put("/items/{item_id}")
        def replace_item(item_id: str, item: Item):
            return {"message": "Item replaced", "id": item_id}
    
        app.include_router(router)
        ```
        """
        return self.api_route(
            path=path,
            response_model=response_model,
            status_code=status_code,
            tags=tags,
            dependencies=dependencies,
            summary=summary,
            description=description,
            response_description=response_description,
            responses=responses,
            deprecated=deprecated,
            methods=["PUT"],
            operation_id=operation_id,
            response_model_include=response_model_include,
            response_model_exclude=response_model_exclude,
            response_model_by_alias=response_model_by_alias,
            response_model_exclude_unset=response_model_exclude_unset,
            response_model_exclude_defaults=response_model_exclude_defaults,
            response_model_exclude_none=response_model_exclude_none,
            include_in_schema=include_in_schema,
            response_class=response_class,
            name=name,
            callbacks=callbacks,
            openapi_extra=openapi_extra,
            generate_unique_id_function=generate_unique_id_function,
        )
      
  
---|---  
  
###  `` post [¶](#fastapi.APIRouter.post "Permanent link")
    
    
    post(
        path,
        *,
        response_model=Default(None),
        status_code=None,
        tags=None,
        dependencies=None,
        summary=None,
        description=None,
        response_description="Successful Response",
        responses=None,
        deprecated=None,
        operation_id=None,
        response_model_include=None,
        response_model_exclude=None,
        response_model_by_alias=True,
        response_model_exclude_unset=False,
        response_model_exclude_defaults=False,
        response_model_exclude_none=False,
        include_in_schema=True,
        response_class=Default([JSONResponse](../responses/#fastapi.responses.JSONResponse "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">fastapi.responses.JSONResponse</span> \(<code>starlette.responses.JSONResponse</code>\)")),
        name=None,
        callbacks=None,
        openapi_extra=None,
        generate_unique_id_function=Default(generate_unique_id)
    )
    

Add a _path operation_ using an HTTP POST operation.

##### Example[¶](#fastapi.APIRouter.post--example "Permanent link")
    
    
    from fastapi import APIRouter, FastAPI
    from pydantic import BaseModel
    
    class Item(BaseModel):
        name: str
        description: str | None = None
    
    app = FastAPI()
    router = APIRouter()
    
    @router.post("/items/")
    def create_item(item: Item):
        return {"message": "Item created"}
    
    app.include_router(router)
    

PARAMETER | DESCRIPTION  
---|---  
`path` |  The URL path to be used for this _path operation_. For example, in `http://example.com/items`, the path is `/items`. **TYPE:** `str`  
`response_model` |  The type to use for the response. It could be any valid Pydantic _field_ type. So, it doesn't have to be a Pydantic model, it could be other things, like a `list`, `dict`, etc. It will be used for:

  * Documentation: the generated OpenAPI (and the UI at `/docs`) will show it as the response (JSON Schema).
  * Serialization: you could return an arbitrary object and the `response_model` would be used to serialize that object into the corresponding JSON.
  * Filtering: the JSON sent to the client will only contain the data (fields) defined in the `response_model`. If you returned an object that contains an attribute `password` but the `response_model` does not include that field, the JSON sent to the client would not have that `password`.
  * Validation: whatever you return will be serialized with the `response_model`, converting any data as necessary to generate the corresponding JSON. But if the data in the object returned is not valid, that would mean a violation of the contract with the client, so it's an error from the API developer. So, FastAPI will raise an error and return a 500 error code (Internal Server Error).

Read more about it in the [FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/). **TYPE:** `Any` **DEFAULT:** `Default(None)`  
`status_code` |  The default status code to be used for the response. You could override the status code by returning a response directly. Read more about it in the [FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/). **TYPE:** `Optional[int]` **DEFAULT:** `None`  
`tags` |  A list of tags to be applied to the _path operation_. It will be added to the generated OpenAPI (e.g. visible at `/docs`). Read more about it in the [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags). **TYPE:** `Optional[list[Union[str, Enum]]]` **DEFAULT:** `None`  
`dependencies` |  A list of dependencies (using `Depends()`) to be applied to the _path operation_. Read more about it in the [FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/). **TYPE:** `Optional[Sequence[Depends]]` **DEFAULT:** `None`  
`summary` |  A summary for the _path operation_. It will be added to the generated OpenAPI (e.g. visible at `/docs`). Read more about it in the [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/). **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`description` |  A description for the _path operation_. If not provided, it will be extracted automatically from the docstring of the _path operation function_. It can contain Markdown. It will be added to the generated OpenAPI (e.g. visible at `/docs`). Read more about it in the [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/). **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`response_description` |  The description for the default response. It will be added to the generated OpenAPI (e.g. visible at `/docs`). **TYPE:** `str` **DEFAULT:** `'Successful Response'`  
`responses` |  Additional responses that could be returned by this _path operation_. It will be added to the generated OpenAPI (e.g. visible at `/docs`). **TYPE:** `Optional[dict[Union[int, str], dict[str, Any]]]` **DEFAULT:** `None`  
`deprecated` |  Mark this _path operation_ as deprecated. It will be added to the generated OpenAPI (e.g. visible at `/docs`). **TYPE:** `Optional[bool]` **DEFAULT:** `None`  
`operation_id` |  Custom operation ID to be used by this _path operation_. By default, it is generated automatically. If you provide a custom operation ID, you need to make sure it is unique for the whole API. You can customize the operation ID generation with the parameter `generate_unique_id_function` in the `FastAPI` class. Read more about it in the [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function). **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`response_model_include` |  Configuration passed to Pydantic to include only certain fields in the response data. Read more about it in the [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude). **TYPE:** `Optional[IncEx]` **DEFAULT:** `None`  
`response_model_exclude` |  Configuration passed to Pydantic to exclude certain fields in the response data. Read more about it in the [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude). **TYPE:** `Optional[IncEx]` **DEFAULT:** `None`  
`response_model_by_alias` |  Configuration passed to Pydantic to define if the response model should be serialized by alias when an alias is used. Read more about it in the [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude). **TYPE:** `bool` **DEFAULT:** `True`  
`response_model_exclude_unset` |  Configuration passed to Pydantic to define if the response data should have all the fields, including the ones that were not set and have their default values. This is different from `response_model_exclude_defaults` in that if the fields are set, they will be included in the response, even if the value is the same as the default. When `True`, default values are omitted from the response. Read more about it in the [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter). **TYPE:** `bool` **DEFAULT:** `False`  
`response_model_exclude_defaults` |  Configuration passed to Pydantic to define if the response data should have all the fields, including the ones that have the same value as the default. This is different from `response_model_exclude_unset` in that if the fields are set but contain the same default values, they will be excluded from the response. When `True`, default values are omitted from the response. Read more about it in the [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter). **TYPE:** `bool` **DEFAULT:** `False`  
`response_model_exclude_none` |  Configuration passed to Pydantic to define if the response data should exclude fields set to `None`. This is much simpler (less smart) than `response_model_exclude_unset` and `response_model_exclude_defaults`. You probably want to use one of those two instead of this one, as those allow returning `None` values when it makes sense. Read more about it in the [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none). **TYPE:** `bool` **DEFAULT:** `False`  
`include_in_schema` |  Include this _path operation_ in the generated OpenAPI schema. This affects the generated OpenAPI (e.g. visible at `/docs`). Read more about it in the [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-parameters-from-openapi). **TYPE:** `bool` **DEFAULT:** `True`  
`response_class` |  Response class to be used for this _path operation_. This will not be used if you return a response directly. Read more about it in the [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse). **TYPE:** `type[[Response](../response/#fastapi.Response "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">fastapi.Response</span> \(<code>starlette.responses.Response</code>\)")]` **DEFAULT:** `Default([JSONResponse](../responses/#fastapi.responses.JSONResponse "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">fastapi.responses.JSONResponse</span> \(<code>starlette.responses.JSONResponse</code>\)"))`  
`name` |  Name for this _path operation_. Only used internally. **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`callbacks` |  List of _path operations_ that will be used as OpenAPI callbacks. This is only for OpenAPI documentation, the callbacks won't be used directly. It will be added to the generated OpenAPI (e.g. visible at `/docs`). Read more about it in the [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/). **TYPE:** `Optional[list[BaseRoute]]` **DEFAULT:** `None`  
`openapi_extra` |  Extra metadata to be included in the OpenAPI schema for this _path operation_. Read more about it in the [FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema). **TYPE:** `Optional[dict[str, Any]]` **DEFAULT:** `None`  
`generate_unique_id_function` |  Customize the function used to generate unique IDs for the _path operations_ shown in the generated OpenAPI. This is particularly useful when automatically generating clients or SDKs for your API. Read more about it in the [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function). **TYPE:** `Callable[[APIRoute], str]` **DEFAULT:** `Default(generate_unique_id)`  
Source code in `fastapi/routing.py`
    
    
    2194
    2195
    2196
    2197
    2198
    2199
    2200
    2201
    2202
    2203
    2204
    2205
    2206
    2207
    2208
    2209
    2210
    2211
    2212
    2213
    2214
    2215
    2216
    2217
    2218
    2219
    2220
    2221
    2222
    2223
    2224
    2225
    2226
    2227
    2228
    2229
    2230
    2231
    2232
    2233
    2234
    2235
    2236
    2237
    2238
    2239
    2240
    2241
    2242
    2243
    2244
    2245
    2246
    2247
    2248
    2249
    2250
    2251
    2252
    2253
    2254
    2255
    2256
    2257
    2258
    2259
    2260
    2261
    2262
    2263
    2264
    2265
    2266
    2267
    2268
    2269
    2270
    2271
    2272
    2273
    2274
    2275
    2276
    2277
    2278
    2279
    2280
    2281
    2282
    2283
    2284
    2285
    2286
    2287
    2288
    2289
    2290
    2291
    2292
    2293
    2294
    2295
    2296
    2297
    2298
    2299
    2300
    2301
    2302
    2303
    2304
    2305
    2306
    2307
    2308
    2309
    2310
    2311
    2312
    2313
    2314
    2315
    2316
    2317
    2318
    2319
    2320
    2321
    2322
    2323
    2324
    2325
    2326
    2327
    2328
    2329
    2330
    2331
    2332
    2333
    2334
    2335
    2336
    2337
    2338
    2339
    2340
    2341
    2342
    2343
    2344
    2345
    2346
    2347
    2348
    2349
    2350
    2351
    2352
    2353
    2354
    2355
    2356
    2357
    2358
    2359
    2360
    2361
    2362
    2363
    2364
    2365
    2366
    2367
    2368
    2369
    2370
    2371
    2372
    2373
    2374
    2375
    2376
    2377
    2378
    2379
    2380
    2381
    2382
    2383
    2384
    2385
    2386
    2387
    2388
    2389
    2390
    2391
    2392
    2393
    2394
    2395
    2396
    2397
    2398
    2399
    2400
    2401
    2402
    2403
    2404
    2405
    2406
    2407
    2408
    2409
    2410
    2411
    2412
    2413
    2414
    2415
    2416
    2417
    2418
    2419
    2420
    2421
    2422
    2423
    2424
    2425
    2426
    2427
    2428
    2429
    2430
    2431
    2432
    2433
    2434
    2435
    2436
    2437
    2438
    2439
    2440
    2441
    2442
    2443
    2444
    2445
    2446
    2447
    2448
    2449
    2450
    2451
    2452
    2453
    2454
    2455
    2456
    2457
    2458
    2459
    2460
    2461
    2462
    2463
    2464
    2465
    2466
    2467
    2468
    2469
    2470
    2471
    2472
    2473
    2474
    2475
    2476
    2477
    2478
    2479
    2480
    2481
    2482
    2483
    2484
    2485
    2486
    2487
    2488
    2489
    2490
    2491
    2492
    2493
    2494
    2495
    2496
    2497
    2498
    2499
    2500
    2501
    2502
    2503
    2504
    2505
    2506
    2507
    2508
    2509
    2510
    2511
    2512
    2513
    2514
    2515
    2516
    2517
    2518
    2519
    2520
    2521
    2522
    2523
    2524
    2525
    2526
    2527
    2528
    2529
    2530
    2531
    2532
    2533
    2534
    2535
    2536
    2537
    2538
    2539
    2540
    2541
    2542
    2543
    2544
    2545
    2546
    2547
    2548
    2549
    2550
    2551
    2552
    2553
    2554
    2555
    2556
    2557
    2558
    2559
    2560
    2561
    2562
    2563
    2564
    2565
    2566
    2567
    2568
    2569
    2570
    2571
    2572
    2573
    2574

| 
    
    
    def post(
        self,
        path: Annotated[
            str,
            Doc(
                """
                The URL path to be used for this *path operation*.
    
                For example, in `http://example.com/items`, the path is `/items`.
                """
            ),
        ],
        *,
        response_model: Annotated[
            Any,
            Doc(
                """
                The type to use for the response.
    
                It could be any valid Pydantic *field* type. So, it doesn't have to
                be a Pydantic model, it could be other things, like a `list`, `dict`,
                etc.
    
                It will be used for:
    
                * Documentation: the generated OpenAPI (and the UI at `/docs`) will
                    show it as the response (JSON Schema).
                * Serialization: you could return an arbitrary object and the
                    `response_model` would be used to serialize that object into the
                    corresponding JSON.
                * Filtering: the JSON sent to the client will only contain the data
                    (fields) defined in the `response_model`. If you returned an object
                    that contains an attribute `password` but the `response_model` does
                    not include that field, the JSON sent to the client would not have
                    that `password`.
                * Validation: whatever you return will be serialized with the
                    `response_model`, converting any data as necessary to generate the
                    corresponding JSON. But if the data in the object returned is not
                    valid, that would mean a violation of the contract with the client,
                    so it's an error from the API developer. So, FastAPI will raise an
                    error and return a 500 error code (Internal Server Error).
    
                Read more about it in the
                [FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).
                """
            ),
        ] = Default(None),
        status_code: Annotated[
            Optional[int],
            Doc(
                """
                The default status code to be used for the response.
    
                You could override the status code by returning a response directly.
    
                Read more about it in the
                [FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).
                """
            ),
        ] = None,
        tags: Annotated[
            Optional[list[Union[str, Enum]]],
            Doc(
                """
                A list of tags to be applied to the *path operation*.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
    
                Read more about it in the
                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).
                """
            ),
        ] = None,
        dependencies: Annotated[
            Optional[Sequence[params.Depends]],
            Doc(
                """
                A list of dependencies (using `Depends()`) to be applied to the
                *path operation*.
    
                Read more about it in the
                [FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).
                """
            ),
        ] = None,
        summary: Annotated[
            Optional[str],
            Doc(
                """
                A summary for the *path operation*.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
    
                Read more about it in the
                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
                """
            ),
        ] = None,
        description: Annotated[
            Optional[str],
            Doc(
                """
                A description for the *path operation*.
    
                If not provided, it will be extracted automatically from the docstring
                of the *path operation function*.
    
                It can contain Markdown.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
    
                Read more about it in the
                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
                """
            ),
        ] = None,
        response_description: Annotated[
            str,
            Doc(
                """
                The description for the default response.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
                """
            ),
        ] = "Successful Response",
        responses: Annotated[
            Optional[dict[Union[int, str], dict[str, Any]]],
            Doc(
                """
                Additional responses that could be returned by this *path operation*.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
                """
            ),
        ] = None,
        deprecated: Annotated[
            Optional[bool],
            Doc(
                """
                Mark this *path operation* as deprecated.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
                """
            ),
        ] = None,
        operation_id: Annotated[
            Optional[str],
            Doc(
                """
                Custom operation ID to be used by this *path operation*.
    
                By default, it is generated automatically.
    
                If you provide a custom operation ID, you need to make sure it is
                unique for the whole API.
    
                You can customize the
                operation ID generation with the parameter
                `generate_unique_id_function` in the `FastAPI` class.
    
                Read more about it in the
                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
                """
            ),
        ] = None,
        response_model_include: Annotated[
            Optional[IncEx],
            Doc(
                """
                Configuration passed to Pydantic to include only certain fields in the
                response data.
    
                Read more about it in the
                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
                """
            ),
        ] = None,
        response_model_exclude: Annotated[
            Optional[IncEx],
            Doc(
                """
                Configuration passed to Pydantic to exclude certain fields in the
                response data.
    
                Read more about it in the
                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
                """
            ),
        ] = None,
        response_model_by_alias: Annotated[
            bool,
            Doc(
                """
                Configuration passed to Pydantic to define if the response model
                should be serialized by alias when an alias is used.
    
                Read more about it in the
                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
                """
            ),
        ] = True,
        response_model_exclude_unset: Annotated[
            bool,
            Doc(
                """
                Configuration passed to Pydantic to define if the response data
                should have all the fields, including the ones that were not set and
                have their default values. This is different from
                `response_model_exclude_defaults` in that if the fields are set,
                they will be included in the response, even if the value is the same
                as the default.
    
                When `True`, default values are omitted from the response.
    
                Read more about it in the
                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).
                """
            ),
        ] = False,
        response_model_exclude_defaults: Annotated[
            bool,
            Doc(
                """
                Configuration passed to Pydantic to define if the response data
                should have all the fields, including the ones that have the same value
                as the default. This is different from `response_model_exclude_unset`
                in that if the fields are set but contain the same default values,
                they will be excluded from the response.
    
                When `True`, default values are omitted from the response.
    
                Read more about it in the
                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).
                """
            ),
        ] = False,
        response_model_exclude_none: Annotated[
            bool,
            Doc(
                """
                Configuration passed to Pydantic to define if the response data should
                exclude fields set to `None`.
    
                This is much simpler (less smart) than `response_model_exclude_unset`
                and `response_model_exclude_defaults`. You probably want to use one of
                those two instead of this one, as those allow returning `None` values
                when it makes sense.
    
                Read more about it in the
                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).
                """
            ),
        ] = False,
        include_in_schema: Annotated[
            bool,
            Doc(
                """
                Include this *path operation* in the generated OpenAPI schema.
    
                This affects the generated OpenAPI (e.g. visible at `/docs`).
    
                Read more about it in the
                [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-parameters-from-openapi).
                """
            ),
        ] = True,
        response_class: Annotated[
            type[Response],
            Doc(
                """
                Response class to be used for this *path operation*.
    
                This will not be used if you return a response directly.
    
                Read more about it in the
                [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).
                """
            ),
        ] = Default(JSONResponse),
        name: Annotated[
            Optional[str],
            Doc(
                """
                Name for this *path operation*. Only used internally.
                """
            ),
        ] = None,
        callbacks: Annotated[
            Optional[list[BaseRoute]],
            Doc(
                """
                List of *path operations* that will be used as OpenAPI callbacks.
    
                This is only for OpenAPI documentation, the callbacks won't be used
                directly.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
    
                Read more about it in the
                [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).
                """
            ),
        ] = None,
        openapi_extra: Annotated[
            Optional[dict[str, Any]],
            Doc(
                """
                Extra metadata to be included in the OpenAPI schema for this *path
                operation*.
    
                Read more about it in the
                [FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).
                """
            ),
        ] = None,
        generate_unique_id_function: Annotated[
            Callable[[APIRoute], str],
            Doc(
                """
                Customize the function used to generate unique IDs for the *path
                operations* shown in the generated OpenAPI.
    
                This is particularly useful when automatically generating clients or
                SDKs for your API.
    
                Read more about it in the
                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
                """
            ),
        ] = Default(generate_unique_id),
    ) -> Callable[[DecoratedCallable], DecoratedCallable]:
        """
        Add a *path operation* using an HTTP POST operation.
    
        ## Example
    
        ```python
        from fastapi import APIRouter, FastAPI
        from pydantic import BaseModel
    
        class Item(BaseModel):
            name: str
            description: str | None = None
    
        app = FastAPI()
        router = APIRouter()
    
        @router.post("/items/")
        def create_item(item: Item):
            return {"message": "Item created"}
    
        app.include_router(router)
        ```
        """
        return self.api_route(
            path=path,
            response_model=response_model,
            status_code=status_code,
            tags=tags,
            dependencies=dependencies,
            summary=summary,
            description=description,
            response_description=response_description,
            responses=responses,
            deprecated=deprecated,
            methods=["POST"],
            operation_id=operation_id,
            response_model_include=response_model_include,
            response_model_exclude=response_model_exclude,
            response_model_by_alias=response_model_by_alias,
            response_model_exclude_unset=response_model_exclude_unset,
            response_model_exclude_defaults=response_model_exclude_defaults,
            response_model_exclude_none=response_model_exclude_none,
            include_in_schema=include_in_schema,
            response_class=response_class,
            name=name,
            callbacks=callbacks,
            openapi_extra=openapi_extra,
            generate_unique_id_function=generate_unique_id_function,
        )
      
  
---|---  
  
###  `` delete [¶](#fastapi.APIRouter.delete "Permanent link")
    
    
    delete(
        path,
        *,
        response_model=Default(None),
        status_code=None,
        tags=None,
        dependencies=None,
        summary=None,
        description=None,
        response_description="Successful Response",
        responses=None,
        deprecated=None,
        operation_id=None,
        response_model_include=None,
        response_model_exclude=None,
        response_model_by_alias=True,
        response_model_exclude_unset=False,
        response_model_exclude_defaults=False,
        response_model_exclude_none=False,
        include_in_schema=True,
        response_class=Default([JSONResponse](../responses/#fastapi.responses.JSONResponse "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">fastapi.responses.JSONResponse</span> \(<code>starlette.responses.JSONResponse</code>\)")),
        name=None,
        callbacks=None,
        openapi_extra=None,
        generate_unique_id_function=Default(generate_unique_id)
    )
    

Add a _path operation_ using an HTTP DELETE operation.

##### Example[¶](#fastapi.APIRouter.delete--example "Permanent link")
    
    
    from fastapi import APIRouter, FastAPI
    
    app = FastAPI()
    router = APIRouter()
    
    @router.delete("/items/{item_id}")
    def delete_item(item_id: str):
        return {"message": "Item deleted"}
    
    app.include_router(router)
    

PARAMETER | DESCRIPTION  
---|---  
`path` |  The URL path to be used for this _path operation_. For example, in `http://example.com/items`, the path is `/items`. **TYPE:** `str`  
`response_model` |  The type to use for the response. It could be any valid Pydantic _field_ type. So, it doesn't have to be a Pydantic model, it could be other things, like a `list`, `dict`, etc. It will be used for:

  * Documentation: the generated OpenAPI (and the UI at `/docs`) will show it as the response (JSON Schema).
  * Serialization: you could return an arbitrary object and the `response_model` would be used to serialize that object into the corresponding JSON.
  * Filtering: the JSON sent to the client will only contain the data (fields) defined in the `response_model`. If you returned an object that contains an attribute `password` but the `response_model` does not include that field, the JSON sent to the client would not have that `password`.
  * Validation: whatever you return will be serialized with the `response_model`, converting any data as necessary to generate the corresponding JSON. But if the data in the object returned is not valid, that would mean a violation of the contract with the client, so it's an error from the API developer. So, FastAPI will raise an error and return a 500 error code (Internal Server Error).

Read more about it in the [FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/). **TYPE:** `Any` **DEFAULT:** `Default(None)`  
`status_code` |  The default status code to be used for the response. You could override the status code by returning a response directly. Read more about it in the [FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/). **TYPE:** `Optional[int]` **DEFAULT:** `None`  
`tags` |  A list of tags to be applied to the _path operation_. It will be added to the generated OpenAPI (e.g. visible at `/docs`). Read more about it in the [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags). **TYPE:** `Optional[list[Union[str, Enum]]]` **DEFAULT:** `None`  
`dependencies` |  A list of dependencies (using `Depends()`) to be applied to the _path operation_. Read more about it in the [FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/). **TYPE:** `Optional[Sequence[Depends]]` **DEFAULT:** `None`  
`summary` |  A summary for the _path operation_. It will be added to the generated OpenAPI (e.g. visible at `/docs`). Read more about it in the [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/). **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`description` |  A description for the _path operation_. If not provided, it will be extracted automatically from the docstring of the _path operation function_. It can contain Markdown. It will be added to the generated OpenAPI (e.g. visible at `/docs`). Read more about it in the [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/). **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`response_description` |  The description for the default response. It will be added to the generated OpenAPI (e.g. visible at `/docs`). **TYPE:** `str` **DEFAULT:** `'Successful Response'`  
`responses` |  Additional responses that could be returned by this _path operation_. It will be added to the generated OpenAPI (e.g. visible at `/docs`). **TYPE:** `Optional[dict[Union[int, str], dict[str, Any]]]` **DEFAULT:** `None`  
`deprecated` |  Mark this _path operation_ as deprecated. It will be added to the generated OpenAPI (e.g. visible at `/docs`). **TYPE:** `Optional[bool]` **DEFAULT:** `None`  
`operation_id` |  Custom operation ID to be used by this _path operation_. By default, it is generated automatically. If you provide a custom operation ID, you need to make sure it is unique for the whole API. You can customize the operation ID generation with the parameter `generate_unique_id_function` in the `FastAPI` class. Read more about it in the [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function). **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`response_model_include` |  Configuration passed to Pydantic to include only certain fields in the response data. Read more about it in the [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude). **TYPE:** `Optional[IncEx]` **DEFAULT:** `None`  
`response_model_exclude` |  Configuration passed to Pydantic to exclude certain fields in the response data. Read more about it in the [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude). **TYPE:** `Optional[IncEx]` **DEFAULT:** `None`  
`response_model_by_alias` |  Configuration passed to Pydantic to define if the response model should be serialized by alias when an alias is used. Read more about it in the [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude). **TYPE:** `bool` **DEFAULT:** `True`  
`response_model_exclude_unset` |  Configuration passed to Pydantic to define if the response data should have all the fields, including the ones that were not set and have their default values. This is different from `response_model_exclude_defaults` in that if the fields are set, they will be included in the response, even if the value is the same as the default. When `True`, default values are omitted from the response. Read more about it in the [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter). **TYPE:** `bool` **DEFAULT:** `False`  
`response_model_exclude_defaults` |  Configuration passed to Pydantic to define if the response data should have all the fields, including the ones that have the same value as the default. This is different from `response_model_exclude_unset` in that if the fields are set but contain the same default values, they will be excluded from the response. When `True`, default values are omitted from the response. Read more about it in the [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter). **TYPE:** `bool` **DEFAULT:** `False`  
`response_model_exclude_none` |  Configuration passed to Pydantic to define if the response data should exclude fields set to `None`. This is much simpler (less smart) than `response_model_exclude_unset` and `response_model_exclude_defaults`. You probably want to use one of those two instead of this one, as those allow returning `None` values when it makes sense. Read more about it in the [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none). **TYPE:** `bool` **DEFAULT:** `False`  
`include_in_schema` |  Include this _path operation_ in the generated OpenAPI schema. This affects the generated OpenAPI (e.g. visible at `/docs`). Read more about it in the [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-parameters-from-openapi). **TYPE:** `bool` **DEFAULT:** `True`  
`response_class` |  Response class to be used for this _path operation_. This will not be used if you return a response directly. Read more about it in the [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse). **TYPE:** `type[[Response](../response/#fastapi.Response "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">fastapi.Response</span> \(<code>starlette.responses.Response</code>\)")]` **DEFAULT:** `Default([JSONResponse](../responses/#fastapi.responses.JSONResponse "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">fastapi.responses.JSONResponse</span> \(<code>starlette.responses.JSONResponse</code>\)"))`  
`name` |  Name for this _path operation_. Only used internally. **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`callbacks` |  List of _path operations_ that will be used as OpenAPI callbacks. This is only for OpenAPI documentation, the callbacks won't be used directly. It will be added to the generated OpenAPI (e.g. visible at `/docs`). Read more about it in the [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/). **TYPE:** `Optional[list[BaseRoute]]` **DEFAULT:** `None`  
`openapi_extra` |  Extra metadata to be included in the OpenAPI schema for this _path operation_. Read more about it in the [FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema). **TYPE:** `Optional[dict[str, Any]]` **DEFAULT:** `None`  
`generate_unique_id_function` |  Customize the function used to generate unique IDs for the _path operations_ shown in the generated OpenAPI. This is particularly useful when automatically generating clients or SDKs for your API. Read more about it in the [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function). **TYPE:** `Callable[[APIRoute], str]` **DEFAULT:** `Default(generate_unique_id)`  
Source code in `fastapi/routing.py`
    
    
    2576
    2577
    2578
    2579
    2580
    2581
    2582
    2583
    2584
    2585
    2586
    2587
    2588
    2589
    2590
    2591
    2592
    2593
    2594
    2595
    2596
    2597
    2598
    2599
    2600
    2601
    2602
    2603
    2604
    2605
    2606
    2607
    2608
    2609
    2610
    2611
    2612
    2613
    2614
    2615
    2616
    2617
    2618
    2619
    2620
    2621
    2622
    2623
    2624
    2625
    2626
    2627
    2628
    2629
    2630
    2631
    2632
    2633
    2634
    2635
    2636
    2637
    2638
    2639
    2640
    2641
    2642
    2643
    2644
    2645
    2646
    2647
    2648
    2649
    2650
    2651
    2652
    2653
    2654
    2655
    2656
    2657
    2658
    2659
    2660
    2661
    2662
    2663
    2664
    2665
    2666
    2667
    2668
    2669
    2670
    2671
    2672
    2673
    2674
    2675
    2676
    2677
    2678
    2679
    2680
    2681
    2682
    2683
    2684
    2685
    2686
    2687
    2688
    2689
    2690
    2691
    2692
    2693
    2694
    2695
    2696
    2697
    2698
    2699
    2700
    2701
    2702
    2703
    2704
    2705
    2706
    2707
    2708
    2709
    2710
    2711
    2712
    2713
    2714
    2715
    2716
    2717
    2718
    2719
    2720
    2721
    2722
    2723
    2724
    2725
    2726
    2727
    2728
    2729
    2730
    2731
    2732
    2733
    2734
    2735
    2736
    2737
    2738
    2739
    2740
    2741
    2742
    2743
    2744
    2745
    2746
    2747
    2748
    2749
    2750
    2751
    2752
    2753
    2754
    2755
    2756
    2757
    2758
    2759
    2760
    2761
    2762
    2763
    2764
    2765
    2766
    2767
    2768
    2769
    2770
    2771
    2772
    2773
    2774
    2775
    2776
    2777
    2778
    2779
    2780
    2781
    2782
    2783
    2784
    2785
    2786
    2787
    2788
    2789
    2790
    2791
    2792
    2793
    2794
    2795
    2796
    2797
    2798
    2799
    2800
    2801
    2802
    2803
    2804
    2805
    2806
    2807
    2808
    2809
    2810
    2811
    2812
    2813
    2814
    2815
    2816
    2817
    2818
    2819
    2820
    2821
    2822
    2823
    2824
    2825
    2826
    2827
    2828
    2829
    2830
    2831
    2832
    2833
    2834
    2835
    2836
    2837
    2838
    2839
    2840
    2841
    2842
    2843
    2844
    2845
    2846
    2847
    2848
    2849
    2850
    2851
    2852
    2853
    2854
    2855
    2856
    2857
    2858
    2859
    2860
    2861
    2862
    2863
    2864
    2865
    2866
    2867
    2868
    2869
    2870
    2871
    2872
    2873
    2874
    2875
    2876
    2877
    2878
    2879
    2880
    2881
    2882
    2883
    2884
    2885
    2886
    2887
    2888
    2889
    2890
    2891
    2892
    2893
    2894
    2895
    2896
    2897
    2898
    2899
    2900
    2901
    2902
    2903
    2904
    2905
    2906
    2907
    2908
    2909
    2910
    2911
    2912
    2913
    2914
    2915
    2916
    2917
    2918
    2919
    2920
    2921
    2922
    2923
    2924
    2925
    2926
    2927
    2928
    2929
    2930
    2931
    2932
    2933
    2934
    2935
    2936
    2937
    2938
    2939
    2940
    2941
    2942
    2943
    2944
    2945
    2946
    2947
    2948
    2949
    2950
    2951

| 
    
    
    def delete(
        self,
        path: Annotated[
            str,
            Doc(
                """
                The URL path to be used for this *path operation*.
    
                For example, in `http://example.com/items`, the path is `/items`.
                """
            ),
        ],
        *,
        response_model: Annotated[
            Any,
            Doc(
                """
                The type to use for the response.
    
                It could be any valid Pydantic *field* type. So, it doesn't have to
                be a Pydantic model, it could be other things, like a `list`, `dict`,
                etc.
    
                It will be used for:
    
                * Documentation: the generated OpenAPI (and the UI at `/docs`) will
                    show it as the response (JSON Schema).
                * Serialization: you could return an arbitrary object and the
                    `response_model` would be used to serialize that object into the
                    corresponding JSON.
                * Filtering: the JSON sent to the client will only contain the data
                    (fields) defined in the `response_model`. If you returned an object
                    that contains an attribute `password` but the `response_model` does
                    not include that field, the JSON sent to the client would not have
                    that `password`.
                * Validation: whatever you return will be serialized with the
                    `response_model`, converting any data as necessary to generate the
                    corresponding JSON. But if the data in the object returned is not
                    valid, that would mean a violation of the contract with the client,
                    so it's an error from the API developer. So, FastAPI will raise an
                    error and return a 500 error code (Internal Server Error).
    
                Read more about it in the
                [FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).
                """
            ),
        ] = Default(None),
        status_code: Annotated[
            Optional[int],
            Doc(
                """
                The default status code to be used for the response.
    
                You could override the status code by returning a response directly.
    
                Read more about it in the
                [FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).
                """
            ),
        ] = None,
        tags: Annotated[
            Optional[list[Union[str, Enum]]],
            Doc(
                """
                A list of tags to be applied to the *path operation*.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
    
                Read more about it in the
                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).
                """
            ),
        ] = None,
        dependencies: Annotated[
            Optional[Sequence[params.Depends]],
            Doc(
                """
                A list of dependencies (using `Depends()`) to be applied to the
                *path operation*.
    
                Read more about it in the
                [FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).
                """
            ),
        ] = None,
        summary: Annotated[
            Optional[str],
            Doc(
                """
                A summary for the *path operation*.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
    
                Read more about it in the
                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
                """
            ),
        ] = None,
        description: Annotated[
            Optional[str],
            Doc(
                """
                A description for the *path operation*.
    
                If not provided, it will be extracted automatically from the docstring
                of the *path operation function*.
    
                It can contain Markdown.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
    
                Read more about it in the
                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
                """
            ),
        ] = None,
        response_description: Annotated[
            str,
            Doc(
                """
                The description for the default response.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
                """
            ),
        ] = "Successful Response",
        responses: Annotated[
            Optional[dict[Union[int, str], dict[str, Any]]],
            Doc(
                """
                Additional responses that could be returned by this *path operation*.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
                """
            ),
        ] = None,
        deprecated: Annotated[
            Optional[bool],
            Doc(
                """
                Mark this *path operation* as deprecated.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
                """
            ),
        ] = None,
        operation_id: Annotated[
            Optional[str],
            Doc(
                """
                Custom operation ID to be used by this *path operation*.
    
                By default, it is generated automatically.
    
                If you provide a custom operation ID, you need to make sure it is
                unique for the whole API.
    
                You can customize the
                operation ID generation with the parameter
                `generate_unique_id_function` in the `FastAPI` class.
    
                Read more about it in the
                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
                """
            ),
        ] = None,
        response_model_include: Annotated[
            Optional[IncEx],
            Doc(
                """
                Configuration passed to Pydantic to include only certain fields in the
                response data.
    
                Read more about it in the
                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
                """
            ),
        ] = None,
        response_model_exclude: Annotated[
            Optional[IncEx],
            Doc(
                """
                Configuration passed to Pydantic to exclude certain fields in the
                response data.
    
                Read more about it in the
                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
                """
            ),
        ] = None,
        response_model_by_alias: Annotated[
            bool,
            Doc(
                """
                Configuration passed to Pydantic to define if the response model
                should be serialized by alias when an alias is used.
    
                Read more about it in the
                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
                """
            ),
        ] = True,
        response_model_exclude_unset: Annotated[
            bool,
            Doc(
                """
                Configuration passed to Pydantic to define if the response data
                should have all the fields, including the ones that were not set and
                have their default values. This is different from
                `response_model_exclude_defaults` in that if the fields are set,
                they will be included in the response, even if the value is the same
                as the default.
    
                When `True`, default values are omitted from the response.
    
                Read more about it in the
                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).
                """
            ),
        ] = False,
        response_model_exclude_defaults: Annotated[
            bool,
            Doc(
                """
                Configuration passed to Pydantic to define if the response data
                should have all the fields, including the ones that have the same value
                as the default. This is different from `response_model_exclude_unset`
                in that if the fields are set but contain the same default values,
                they will be excluded from the response.
    
                When `True`, default values are omitted from the response.
    
                Read more about it in the
                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).
                """
            ),
        ] = False,
        response_model_exclude_none: Annotated[
            bool,
            Doc(
                """
                Configuration passed to Pydantic to define if the response data should
                exclude fields set to `None`.
    
                This is much simpler (less smart) than `response_model_exclude_unset`
                and `response_model_exclude_defaults`. You probably want to use one of
                those two instead of this one, as those allow returning `None` values
                when it makes sense.
    
                Read more about it in the
                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).
                """
            ),
        ] = False,
        include_in_schema: Annotated[
            bool,
            Doc(
                """
                Include this *path operation* in the generated OpenAPI schema.
    
                This affects the generated OpenAPI (e.g. visible at `/docs`).
    
                Read more about it in the
                [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-parameters-from-openapi).
                """
            ),
        ] = True,
        response_class: Annotated[
            type[Response],
            Doc(
                """
                Response class to be used for this *path operation*.
    
                This will not be used if you return a response directly.
    
                Read more about it in the
                [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).
                """
            ),
        ] = Default(JSONResponse),
        name: Annotated[
            Optional[str],
            Doc(
                """
                Name for this *path operation*. Only used internally.
                """
            ),
        ] = None,
        callbacks: Annotated[
            Optional[list[BaseRoute]],
            Doc(
                """
                List of *path operations* that will be used as OpenAPI callbacks.
    
                This is only for OpenAPI documentation, the callbacks won't be used
                directly.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
    
                Read more about it in the
                [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).
                """
            ),
        ] = None,
        openapi_extra: Annotated[
            Optional[dict[str, Any]],
            Doc(
                """
                Extra metadata to be included in the OpenAPI schema for this *path
                operation*.
    
                Read more about it in the
                [FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).
                """
            ),
        ] = None,
        generate_unique_id_function: Annotated[
            Callable[[APIRoute], str],
            Doc(
                """
                Customize the function used to generate unique IDs for the *path
                operations* shown in the generated OpenAPI.
    
                This is particularly useful when automatically generating clients or
                SDKs for your API.
    
                Read more about it in the
                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
                """
            ),
        ] = Default(generate_unique_id),
    ) -> Callable[[DecoratedCallable], DecoratedCallable]:
        """
        Add a *path operation* using an HTTP DELETE operation.
    
        ## Example
    
        ```python
        from fastapi import APIRouter, FastAPI
    
        app = FastAPI()
        router = APIRouter()
    
        @router.delete("/items/{item_id}")
        def delete_item(item_id: str):
            return {"message": "Item deleted"}
    
        app.include_router(router)
        ```
        """
        return self.api_route(
            path=path,
            response_model=response_model,
            status_code=status_code,
            tags=tags,
            dependencies=dependencies,
            summary=summary,
            description=description,
            response_description=response_description,
            responses=responses,
            deprecated=deprecated,
            methods=["DELETE"],
            operation_id=operation_id,
            response_model_include=response_model_include,
            response_model_exclude=response_model_exclude,
            response_model_by_alias=response_model_by_alias,
            response_model_exclude_unset=response_model_exclude_unset,
            response_model_exclude_defaults=response_model_exclude_defaults,
            response_model_exclude_none=response_model_exclude_none,
            include_in_schema=include_in_schema,
            response_class=response_class,
            name=name,
            callbacks=callbacks,
            openapi_extra=openapi_extra,
            generate_unique_id_function=generate_unique_id_function,
        )
      
  
---|---  
  
###  `` options [¶](#fastapi.APIRouter.options "Permanent link")
    
    
    options(
        path,
        *,
        response_model=Default(None),
        status_code=None,
        tags=None,
        dependencies=None,
        summary=None,
        description=None,
        response_description="Successful Response",
        responses=None,
        deprecated=None,
        operation_id=None,
        response_model_include=None,
        response_model_exclude=None,
        response_model_by_alias=True,
        response_model_exclude_unset=False,
        response_model_exclude_defaults=False,
        response_model_exclude_none=False,
        include_in_schema=True,
        response_class=Default([JSONResponse](../responses/#fastapi.responses.JSONResponse "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">fastapi.responses.JSONResponse</span> \(<code>starlette.responses.JSONResponse</code>\)")),
        name=None,
        callbacks=None,
        openapi_extra=None,
        generate_unique_id_function=Default(generate_unique_id)
    )
    

Add a _path operation_ using an HTTP OPTIONS operation.

##### Example[¶](#fastapi.APIRouter.options--example "Permanent link")
    
    
    from fastapi import APIRouter, FastAPI
    
    app = FastAPI()
    router = APIRouter()
    
    @router.options("/items/")
    def get_item_options():
        return {"additions": ["Aji", "Guacamole"]}
    
    app.include_router(router)
    

PARAMETER | DESCRIPTION  
---|---  
`path` |  The URL path to be used for this _path operation_. For example, in `http://example.com/items`, the path is `/items`. **TYPE:** `str`  
`response_model` |  The type to use for the response. It could be any valid Pydantic _field_ type. So, it doesn't have to be a Pydantic model, it could be other things, like a `list`, `dict`, etc. It will be used for:

  * Documentation: the generated OpenAPI (and the UI at `/docs`) will show it as the response (JSON Schema).
  * Serialization: you could return an arbitrary object and the `response_model` would be used to serialize that object into the corresponding JSON.
  * Filtering: the JSON sent to the client will only contain the data (fields) defined in the `response_model`. If you returned an object that contains an attribute `password` but the `response_model` does not include that field, the JSON sent to the client would not have that `password`.
  * Validation: whatever you return will be serialized with the `response_model`, converting any data as necessary to generate the corresponding JSON. But if the data in the object returned is not valid, that would mean a violation of the contract with the client, so it's an error from the API developer. So, FastAPI will raise an error and return a 500 error code (Internal Server Error).

Read more about it in the [FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/). **TYPE:** `Any` **DEFAULT:** `Default(None)`  
`status_code` |  The default status code to be used for the response. You could override the status code by returning a response directly. Read more about it in the [FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/). **TYPE:** `Optional[int]` **DEFAULT:** `None`  
`tags` |  A list of tags to be applied to the _path operation_. It will be added to the generated OpenAPI (e.g. visible at `/docs`). Read more about it in the [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags). **TYPE:** `Optional[list[Union[str, Enum]]]` **DEFAULT:** `None`  
`dependencies` |  A list of dependencies (using `Depends()`) to be applied to the _path operation_. Read more about it in the [FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/). **TYPE:** `Optional[Sequence[Depends]]` **DEFAULT:** `None`  
`summary` |  A summary for the _path operation_. It will be added to the generated OpenAPI (e.g. visible at `/docs`). Read more about it in the [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/). **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`description` |  A description for the _path operation_. If not provided, it will be extracted automatically from the docstring of the _path operation function_. It can contain Markdown. It will be added to the generated OpenAPI (e.g. visible at `/docs`). Read more about it in the [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/). **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`response_description` |  The description for the default response. It will be added to the generated OpenAPI (e.g. visible at `/docs`). **TYPE:** `str` **DEFAULT:** `'Successful Response'`  
`responses` |  Additional responses that could be returned by this _path operation_. It will be added to the generated OpenAPI (e.g. visible at `/docs`). **TYPE:** `Optional[dict[Union[int, str], dict[str, Any]]]` **DEFAULT:** `None`  
`deprecated` |  Mark this _path operation_ as deprecated. It will be added to the generated OpenAPI (e.g. visible at `/docs`). **TYPE:** `Optional[bool]` **DEFAULT:** `None`  
`operation_id` |  Custom operation ID to be used by this _path operation_. By default, it is generated automatically. If you provide a custom operation ID, you need to make sure it is unique for the whole API. You can customize the operation ID generation with the parameter `generate_unique_id_function` in the `FastAPI` class. Read more about it in the [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function). **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`response_model_include` |  Configuration passed to Pydantic to include only certain fields in the response data. Read more about it in the [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude). **TYPE:** `Optional[IncEx]` **DEFAULT:** `None`  
`response_model_exclude` |  Configuration passed to Pydantic to exclude certain fields in the response data. Read more about it in the [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude). **TYPE:** `Optional[IncEx]` **DEFAULT:** `None`  
`response_model_by_alias` |  Configuration passed to Pydantic to define if the response model should be serialized by alias when an alias is used. Read more about it in the [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude). **TYPE:** `bool` **DEFAULT:** `True`  
`response_model_exclude_unset` |  Configuration passed to Pydantic to define if the response data should have all the fields, including the ones that were not set and have their default values. This is different from `response_model_exclude_defaults` in that if the fields are set, they will be included in the response, even if the value is the same as the default. When `True`, default values are omitted from the response. Read more about it in the [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter). **TYPE:** `bool` **DEFAULT:** `False`  
`response_model_exclude_defaults` |  Configuration passed to Pydantic to define if the response data should have all the fields, including the ones that have the same value as the default. This is different from `response_model_exclude_unset` in that if the fields are set but contain the same default values, they will be excluded from the response. When `True`, default values are omitted from the response. Read more about it in the [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter). **TYPE:** `bool` **DEFAULT:** `False`  
`response_model_exclude_none` |  Configuration passed to Pydantic to define if the response data should exclude fields set to `None`. This is much simpler (less smart) than `response_model_exclude_unset` and `response_model_exclude_defaults`. You probably want to use one of those two instead of this one, as those allow returning `None` values when it makes sense. Read more about it in the [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none). **TYPE:** `bool` **DEFAULT:** `False`  
`include_in_schema` |  Include this _path operation_ in the generated OpenAPI schema. This affects the generated OpenAPI (e.g. visible at `/docs`). Read more about it in the [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-parameters-from-openapi). **TYPE:** `bool` **DEFAULT:** `True`  
`response_class` |  Response class to be used for this _path operation_. This will not be used if you return a response directly. Read more about it in the [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse). **TYPE:** `type[[Response](../response/#fastapi.Response "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">fastapi.Response</span> \(<code>starlette.responses.Response</code>\)")]` **DEFAULT:** `Default([JSONResponse](../responses/#fastapi.responses.JSONResponse "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">fastapi.responses.JSONResponse</span> \(<code>starlette.responses.JSONResponse</code>\)"))`  
`name` |  Name for this _path operation_. Only used internally. **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`callbacks` |  List of _path operations_ that will be used as OpenAPI callbacks. This is only for OpenAPI documentation, the callbacks won't be used directly. It will be added to the generated OpenAPI (e.g. visible at `/docs`). Read more about it in the [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/). **TYPE:** `Optional[list[BaseRoute]]` **DEFAULT:** `None`  
`openapi_extra` |  Extra metadata to be included in the OpenAPI schema for this _path operation_. Read more about it in the [FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema). **TYPE:** `Optional[dict[str, Any]]` **DEFAULT:** `None`  
`generate_unique_id_function` |  Customize the function used to generate unique IDs for the _path operations_ shown in the generated OpenAPI. This is particularly useful when automatically generating clients or SDKs for your API. Read more about it in the [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function). **TYPE:** `Callable[[APIRoute], str]` **DEFAULT:** `Default(generate_unique_id)`  
Source code in `fastapi/routing.py`
    
    
    2953
    2954
    2955
    2956
    2957
    2958
    2959
    2960
    2961
    2962
    2963
    2964
    2965
    2966
    2967
    2968
    2969
    2970
    2971
    2972
    2973
    2974
    2975
    2976
    2977
    2978
    2979
    2980
    2981
    2982
    2983
    2984
    2985
    2986
    2987
    2988
    2989
    2990
    2991
    2992
    2993
    2994
    2995
    2996
    2997
    2998
    2999
    3000
    3001
    3002
    3003
    3004
    3005
    3006
    3007
    3008
    3009
    3010
    3011
    3012
    3013
    3014
    3015
    3016
    3017
    3018
    3019
    3020
    3021
    3022
    3023
    3024
    3025
    3026
    3027
    3028
    3029
    3030
    3031
    3032
    3033
    3034
    3035
    3036
    3037
    3038
    3039
    3040
    3041
    3042
    3043
    3044
    3045
    3046
    3047
    3048
    3049
    3050
    3051
    3052
    3053
    3054
    3055
    3056
    3057
    3058
    3059
    3060
    3061
    3062
    3063
    3064
    3065
    3066
    3067
    3068
    3069
    3070
    3071
    3072
    3073
    3074
    3075
    3076
    3077
    3078
    3079
    3080
    3081
    3082
    3083
    3084
    3085
    3086
    3087
    3088
    3089
    3090
    3091
    3092
    3093
    3094
    3095
    3096
    3097
    3098
    3099
    3100
    3101
    3102
    3103
    3104
    3105
    3106
    3107
    3108
    3109
    3110
    3111
    3112
    3113
    3114
    3115
    3116
    3117
    3118
    3119
    3120
    3121
    3122
    3123
    3124
    3125
    3126
    3127
    3128
    3129
    3130
    3131
    3132
    3133
    3134
    3135
    3136
    3137
    3138
    3139
    3140
    3141
    3142
    3143
    3144
    3145
    3146
    3147
    3148
    3149
    3150
    3151
    3152
    3153
    3154
    3155
    3156
    3157
    3158
    3159
    3160
    3161
    3162
    3163
    3164
    3165
    3166
    3167
    3168
    3169
    3170
    3171
    3172
    3173
    3174
    3175
    3176
    3177
    3178
    3179
    3180
    3181
    3182
    3183
    3184
    3185
    3186
    3187
    3188
    3189
    3190
    3191
    3192
    3193
    3194
    3195
    3196
    3197
    3198
    3199
    3200
    3201
    3202
    3203
    3204
    3205
    3206
    3207
    3208
    3209
    3210
    3211
    3212
    3213
    3214
    3215
    3216
    3217
    3218
    3219
    3220
    3221
    3222
    3223
    3224
    3225
    3226
    3227
    3228
    3229
    3230
    3231
    3232
    3233
    3234
    3235
    3236
    3237
    3238
    3239
    3240
    3241
    3242
    3243
    3244
    3245
    3246
    3247
    3248
    3249
    3250
    3251
    3252
    3253
    3254
    3255
    3256
    3257
    3258
    3259
    3260
    3261
    3262
    3263
    3264
    3265
    3266
    3267
    3268
    3269
    3270
    3271
    3272
    3273
    3274
    3275
    3276
    3277
    3278
    3279
    3280
    3281
    3282
    3283
    3284
    3285
    3286
    3287
    3288
    3289
    3290
    3291
    3292
    3293
    3294
    3295
    3296
    3297
    3298
    3299
    3300
    3301
    3302
    3303
    3304
    3305
    3306
    3307
    3308
    3309
    3310
    3311
    3312
    3313
    3314
    3315
    3316
    3317
    3318
    3319
    3320
    3321
    3322
    3323
    3324
    3325
    3326
    3327
    3328

| 
    
    
    def options(
        self,
        path: Annotated[
            str,
            Doc(
                """
                The URL path to be used for this *path operation*.
    
                For example, in `http://example.com/items`, the path is `/items`.
                """
            ),
        ],
        *,
        response_model: Annotated[
            Any,
            Doc(
                """
                The type to use for the response.
    
                It could be any valid Pydantic *field* type. So, it doesn't have to
                be a Pydantic model, it could be other things, like a `list`, `dict`,
                etc.
    
                It will be used for:
    
                * Documentation: the generated OpenAPI (and the UI at `/docs`) will
                    show it as the response (JSON Schema).
                * Serialization: you could return an arbitrary object and the
                    `response_model` would be used to serialize that object into the
                    corresponding JSON.
                * Filtering: the JSON sent to the client will only contain the data
                    (fields) defined in the `response_model`. If you returned an object
                    that contains an attribute `password` but the `response_model` does
                    not include that field, the JSON sent to the client would not have
                    that `password`.
                * Validation: whatever you return will be serialized with the
                    `response_model`, converting any data as necessary to generate the
                    corresponding JSON. But if the data in the object returned is not
                    valid, that would mean a violation of the contract with the client,
                    so it's an error from the API developer. So, FastAPI will raise an
                    error and return a 500 error code (Internal Server Error).
    
                Read more about it in the
                [FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).
                """
            ),
        ] = Default(None),
        status_code: Annotated[
            Optional[int],
            Doc(
                """
                The default status code to be used for the response.
    
                You could override the status code by returning a response directly.
    
                Read more about it in the
                [FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).
                """
            ),
        ] = None,
        tags: Annotated[
            Optional[list[Union[str, Enum]]],
            Doc(
                """
                A list of tags to be applied to the *path operation*.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
    
                Read more about it in the
                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).
                """
            ),
        ] = None,
        dependencies: Annotated[
            Optional[Sequence[params.Depends]],
            Doc(
                """
                A list of dependencies (using `Depends()`) to be applied to the
                *path operation*.
    
                Read more about it in the
                [FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).
                """
            ),
        ] = None,
        summary: Annotated[
            Optional[str],
            Doc(
                """
                A summary for the *path operation*.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
    
                Read more about it in the
                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
                """
            ),
        ] = None,
        description: Annotated[
            Optional[str],
            Doc(
                """
                A description for the *path operation*.
    
                If not provided, it will be extracted automatically from the docstring
                of the *path operation function*.
    
                It can contain Markdown.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
    
                Read more about it in the
                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
                """
            ),
        ] = None,
        response_description: Annotated[
            str,
            Doc(
                """
                The description for the default response.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
                """
            ),
        ] = "Successful Response",
        responses: Annotated[
            Optional[dict[Union[int, str], dict[str, Any]]],
            Doc(
                """
                Additional responses that could be returned by this *path operation*.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
                """
            ),
        ] = None,
        deprecated: Annotated[
            Optional[bool],
            Doc(
                """
                Mark this *path operation* as deprecated.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
                """
            ),
        ] = None,
        operation_id: Annotated[
            Optional[str],
            Doc(
                """
                Custom operation ID to be used by this *path operation*.
    
                By default, it is generated automatically.
    
                If you provide a custom operation ID, you need to make sure it is
                unique for the whole API.
    
                You can customize the
                operation ID generation with the parameter
                `generate_unique_id_function` in the `FastAPI` class.
    
                Read more about it in the
                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
                """
            ),
        ] = None,
        response_model_include: Annotated[
            Optional[IncEx],
            Doc(
                """
                Configuration passed to Pydantic to include only certain fields in the
                response data.
    
                Read more about it in the
                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
                """
            ),
        ] = None,
        response_model_exclude: Annotated[
            Optional[IncEx],
            Doc(
                """
                Configuration passed to Pydantic to exclude certain fields in the
                response data.
    
                Read more about it in the
                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
                """
            ),
        ] = None,
        response_model_by_alias: Annotated[
            bool,
            Doc(
                """
                Configuration passed to Pydantic to define if the response model
                should be serialized by alias when an alias is used.
    
                Read more about it in the
                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
                """
            ),
        ] = True,
        response_model_exclude_unset: Annotated[
            bool,
            Doc(
                """
                Configuration passed to Pydantic to define if the response data
                should have all the fields, including the ones that were not set and
                have their default values. This is different from
                `response_model_exclude_defaults` in that if the fields are set,
                they will be included in the response, even if the value is the same
                as the default.
    
                When `True`, default values are omitted from the response.
    
                Read more about it in the
                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).
                """
            ),
        ] = False,
        response_model_exclude_defaults: Annotated[
            bool,
            Doc(
                """
                Configuration passed to Pydantic to define if the response data
                should have all the fields, including the ones that have the same value
                as the default. This is different from `response_model_exclude_unset`
                in that if the fields are set but contain the same default values,
                they will be excluded from the response.
    
                When `True`, default values are omitted from the response.
    
                Read more about it in the
                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).
                """
            ),
        ] = False,
        response_model_exclude_none: Annotated[
            bool,
            Doc(
                """
                Configuration passed to Pydantic to define if the response data should
                exclude fields set to `None`.
    
                This is much simpler (less smart) than `response_model_exclude_unset`
                and `response_model_exclude_defaults`. You probably want to use one of
                those two instead of this one, as those allow returning `None` values
                when it makes sense.
    
                Read more about it in the
                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).
                """
            ),
        ] = False,
        include_in_schema: Annotated[
            bool,
            Doc(
                """
                Include this *path operation* in the generated OpenAPI schema.
    
                This affects the generated OpenAPI (e.g. visible at `/docs`).
    
                Read more about it in the
                [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-parameters-from-openapi).
                """
            ),
        ] = True,
        response_class: Annotated[
            type[Response],
            Doc(
                """
                Response class to be used for this *path operation*.
    
                This will not be used if you return a response directly.
    
                Read more about it in the
                [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).
                """
            ),
        ] = Default(JSONResponse),
        name: Annotated[
            Optional[str],
            Doc(
                """
                Name for this *path operation*. Only used internally.
                """
            ),
        ] = None,
        callbacks: Annotated[
            Optional[list[BaseRoute]],
            Doc(
                """
                List of *path operations* that will be used as OpenAPI callbacks.
    
                This is only for OpenAPI documentation, the callbacks won't be used
                directly.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
    
                Read more about it in the
                [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).
                """
            ),
        ] = None,
        openapi_extra: Annotated[
            Optional[dict[str, Any]],
            Doc(
                """
                Extra metadata to be included in the OpenAPI schema for this *path
                operation*.
    
                Read more about it in the
                [FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).
                """
            ),
        ] = None,
        generate_unique_id_function: Annotated[
            Callable[[APIRoute], str],
            Doc(
                """
                Customize the function used to generate unique IDs for the *path
                operations* shown in the generated OpenAPI.
    
                This is particularly useful when automatically generating clients or
                SDKs for your API.
    
                Read more about it in the
                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
                """
            ),
        ] = Default(generate_unique_id),
    ) -> Callable[[DecoratedCallable], DecoratedCallable]:
        """
        Add a *path operation* using an HTTP OPTIONS operation.
    
        ## Example
    
        ```python
        from fastapi import APIRouter, FastAPI
    
        app = FastAPI()
        router = APIRouter()
    
        @router.options("/items/")
        def get_item_options():
            return {"additions": ["Aji", "Guacamole"]}
    
        app.include_router(router)
        ```
        """
        return self.api_route(
            path=path,
            response_model=response_model,
            status_code=status_code,
            tags=tags,
            dependencies=dependencies,
            summary=summary,
            description=description,
            response_description=response_description,
            responses=responses,
            deprecated=deprecated,
            methods=["OPTIONS"],
            operation_id=operation_id,
            response_model_include=response_model_include,
            response_model_exclude=response_model_exclude,
            response_model_by_alias=response_model_by_alias,
            response_model_exclude_unset=response_model_exclude_unset,
            response_model_exclude_defaults=response_model_exclude_defaults,
            response_model_exclude_none=response_model_exclude_none,
            include_in_schema=include_in_schema,
            response_class=response_class,
            name=name,
            callbacks=callbacks,
            openapi_extra=openapi_extra,
            generate_unique_id_function=generate_unique_id_function,
        )
      
  
---|---  
  
###  `` head [¶](#fastapi.APIRouter.head "Permanent link")
    
    
    head(
        path,
        *,
        response_model=Default(None),
        status_code=None,
        tags=None,
        dependencies=None,
        summary=None,
        description=None,
        response_description="Successful Response",
        responses=None,
        deprecated=None,
        operation_id=None,
        response_model_include=None,
        response_model_exclude=None,
        response_model_by_alias=True,
        response_model_exclude_unset=False,
        response_model_exclude_defaults=False,
        response_model_exclude_none=False,
        include_in_schema=True,
        response_class=Default([JSONResponse](../responses/#fastapi.responses.JSONResponse "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">fastapi.responses.JSONResponse</span> \(<code>starlette.responses.JSONResponse</code>\)")),
        name=None,
        callbacks=None,
        openapi_extra=None,
        generate_unique_id_function=Default(generate_unique_id)
    )
    

Add a _path operation_ using an HTTP HEAD operation.

##### Example[¶](#fastapi.APIRouter.head--example "Permanent link")
    
    
    from fastapi import APIRouter, FastAPI
    from pydantic import BaseModel
    
    class Item(BaseModel):
        name: str
        description: str | None = None
    
    app = FastAPI()
    router = APIRouter()
    
    @router.head("/items/", status_code=204)
    def get_items_headers(response: Response):
        response.headers["X-Cat-Dog"] = "Alone in the world"
    
    app.include_router(router)
    

PARAMETER | DESCRIPTION  
---|---  
`path` |  The URL path to be used for this _path operation_. For example, in `http://example.com/items`, the path is `/items`. **TYPE:** `str`  
`response_model` |  The type to use for the response. It could be any valid Pydantic _field_ type. So, it doesn't have to be a Pydantic model, it could be other things, like a `list`, `dict`, etc. It will be used for:

  * Documentation: the generated OpenAPI (and the UI at `/docs`) will show it as the response (JSON Schema).
  * Serialization: you could return an arbitrary object and the `response_model` would be used to serialize that object into the corresponding JSON.
  * Filtering: the JSON sent to the client will only contain the data (fields) defined in the `response_model`. If you returned an object that contains an attribute `password` but the `response_model` does not include that field, the JSON sent to the client would not have that `password`.
  * Validation: whatever you return will be serialized with the `response_model`, converting any data as necessary to generate the corresponding JSON. But if the data in the object returned is not valid, that would mean a violation of the contract with the client, so it's an error from the API developer. So, FastAPI will raise an error and return a 500 error code (Internal Server Error).

Read more about it in the [FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/). **TYPE:** `Any` **DEFAULT:** `Default(None)`  
`status_code` |  The default status code to be used for the response. You could override the status code by returning a response directly. Read more about it in the [FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/). **TYPE:** `Optional[int]` **DEFAULT:** `None`  
`tags` |  A list of tags to be applied to the _path operation_. It will be added to the generated OpenAPI (e.g. visible at `/docs`). Read more about it in the [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags). **TYPE:** `Optional[list[Union[str, Enum]]]` **DEFAULT:** `None`  
`dependencies` |  A list of dependencies (using `Depends()`) to be applied to the _path operation_. Read more about it in the [FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/). **TYPE:** `Optional[Sequence[Depends]]` **DEFAULT:** `None`  
`summary` |  A summary for the _path operation_. It will be added to the generated OpenAPI (e.g. visible at `/docs`). Read more about it in the [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/). **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`description` |  A description for the _path operation_. If not provided, it will be extracted automatically from the docstring of the _path operation function_. It can contain Markdown. It will be added to the generated OpenAPI (e.g. visible at `/docs`). Read more about it in the [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/). **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`response_description` |  The description for the default response. It will be added to the generated OpenAPI (e.g. visible at `/docs`). **TYPE:** `str` **DEFAULT:** `'Successful Response'`  
`responses` |  Additional responses that could be returned by this _path operation_. It will be added to the generated OpenAPI (e.g. visible at `/docs`). **TYPE:** `Optional[dict[Union[int, str], dict[str, Any]]]` **DEFAULT:** `None`  
`deprecated` |  Mark this _path operation_ as deprecated. It will be added to the generated OpenAPI (e.g. visible at `/docs`). **TYPE:** `Optional[bool]` **DEFAULT:** `None`  
`operation_id` |  Custom operation ID to be used by this _path operation_. By default, it is generated automatically. If you provide a custom operation ID, you need to make sure it is unique for the whole API. You can customize the operation ID generation with the parameter `generate_unique_id_function` in the `FastAPI` class. Read more about it in the [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function). **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`response_model_include` |  Configuration passed to Pydantic to include only certain fields in the response data. Read more about it in the [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude). **TYPE:** `Optional[IncEx]` **DEFAULT:** `None`  
`response_model_exclude` |  Configuration passed to Pydantic to exclude certain fields in the response data. Read more about it in the [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude). **TYPE:** `Optional[IncEx]` **DEFAULT:** `None`  
`response_model_by_alias` |  Configuration passed to Pydantic to define if the response model should be serialized by alias when an alias is used. Read more about it in the [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude). **TYPE:** `bool` **DEFAULT:** `True`  
`response_model_exclude_unset` |  Configuration passed to Pydantic to define if the response data should have all the fields, including the ones that were not set and have their default values. This is different from `response_model_exclude_defaults` in that if the fields are set, they will be included in the response, even if the value is the same as the default. When `True`, default values are omitted from the response. Read more about it in the [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter). **TYPE:** `bool` **DEFAULT:** `False`  
`response_model_exclude_defaults` |  Configuration passed to Pydantic to define if the response data should have all the fields, including the ones that have the same value as the default. This is different from `response_model_exclude_unset` in that if the fields are set but contain the same default values, they will be excluded from the response. When `True`, default values are omitted from the response. Read more about it in the [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter). **TYPE:** `bool` **DEFAULT:** `False`  
`response_model_exclude_none` |  Configuration passed to Pydantic to define if the response data should exclude fields set to `None`. This is much simpler (less smart) than `response_model_exclude_unset` and `response_model_exclude_defaults`. You probably want to use one of those two instead of this one, as those allow returning `None` values when it makes sense. Read more about it in the [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none). **TYPE:** `bool` **DEFAULT:** `False`  
`include_in_schema` |  Include this _path operation_ in the generated OpenAPI schema. This affects the generated OpenAPI (e.g. visible at `/docs`). Read more about it in the [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-parameters-from-openapi). **TYPE:** `bool` **DEFAULT:** `True`  
`response_class` |  Response class to be used for this _path operation_. This will not be used if you return a response directly. Read more about it in the [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse). **TYPE:** `type[[Response](../response/#fastapi.Response "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">fastapi.Response</span> \(<code>starlette.responses.Response</code>\)")]` **DEFAULT:** `Default([JSONResponse](../responses/#fastapi.responses.JSONResponse "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">fastapi.responses.JSONResponse</span> \(<code>starlette.responses.JSONResponse</code>\)"))`  
`name` |  Name for this _path operation_. Only used internally. **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`callbacks` |  List of _path operations_ that will be used as OpenAPI callbacks. This is only for OpenAPI documentation, the callbacks won't be used directly. It will be added to the generated OpenAPI (e.g. visible at `/docs`). Read more about it in the [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/). **TYPE:** `Optional[list[BaseRoute]]` **DEFAULT:** `None`  
`openapi_extra` |  Extra metadata to be included in the OpenAPI schema for this _path operation_. Read more about it in the [FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema). **TYPE:** `Optional[dict[str, Any]]` **DEFAULT:** `None`  
`generate_unique_id_function` |  Customize the function used to generate unique IDs for the _path operations_ shown in the generated OpenAPI. This is particularly useful when automatically generating clients or SDKs for your API. Read more about it in the [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function). **TYPE:** `Callable[[APIRoute], str]` **DEFAULT:** `Default(generate_unique_id)`  
Source code in `fastapi/routing.py`
    
    
    3330
    3331
    3332
    3333
    3334
    3335
    3336
    3337
    3338
    3339
    3340
    3341
    3342
    3343
    3344
    3345
    3346
    3347
    3348
    3349
    3350
    3351
    3352
    3353
    3354
    3355
    3356
    3357
    3358
    3359
    3360
    3361
    3362
    3363
    3364
    3365
    3366
    3367
    3368
    3369
    3370
    3371
    3372
    3373
    3374
    3375
    3376
    3377
    3378
    3379
    3380
    3381
    3382
    3383
    3384
    3385
    3386
    3387
    3388
    3389
    3390
    3391
    3392
    3393
    3394
    3395
    3396
    3397
    3398
    3399
    3400
    3401
    3402
    3403
    3404
    3405
    3406
    3407
    3408
    3409
    3410
    3411
    3412
    3413
    3414
    3415
    3416
    3417
    3418
    3419
    3420
    3421
    3422
    3423
    3424
    3425
    3426
    3427
    3428
    3429
    3430
    3431
    3432
    3433
    3434
    3435
    3436
    3437
    3438
    3439
    3440
    3441
    3442
    3443
    3444
    3445
    3446
    3447
    3448
    3449
    3450
    3451
    3452
    3453
    3454
    3455
    3456
    3457
    3458
    3459
    3460
    3461
    3462
    3463
    3464
    3465
    3466
    3467
    3468
    3469
    3470
    3471
    3472
    3473
    3474
    3475
    3476
    3477
    3478
    3479
    3480
    3481
    3482
    3483
    3484
    3485
    3486
    3487
    3488
    3489
    3490
    3491
    3492
    3493
    3494
    3495
    3496
    3497
    3498
    3499
    3500
    3501
    3502
    3503
    3504
    3505
    3506
    3507
    3508
    3509
    3510
    3511
    3512
    3513
    3514
    3515
    3516
    3517
    3518
    3519
    3520
    3521
    3522
    3523
    3524
    3525
    3526
    3527
    3528
    3529
    3530
    3531
    3532
    3533
    3534
    3535
    3536
    3537
    3538
    3539
    3540
    3541
    3542
    3543
    3544
    3545
    3546
    3547
    3548
    3549
    3550
    3551
    3552
    3553
    3554
    3555
    3556
    3557
    3558
    3559
    3560
    3561
    3562
    3563
    3564
    3565
    3566
    3567
    3568
    3569
    3570
    3571
    3572
    3573
    3574
    3575
    3576
    3577
    3578
    3579
    3580
    3581
    3582
    3583
    3584
    3585
    3586
    3587
    3588
    3589
    3590
    3591
    3592
    3593
    3594
    3595
    3596
    3597
    3598
    3599
    3600
    3601
    3602
    3603
    3604
    3605
    3606
    3607
    3608
    3609
    3610
    3611
    3612
    3613
    3614
    3615
    3616
    3617
    3618
    3619
    3620
    3621
    3622
    3623
    3624
    3625
    3626
    3627
    3628
    3629
    3630
    3631
    3632
    3633
    3634
    3635
    3636
    3637
    3638
    3639
    3640
    3641
    3642
    3643
    3644
    3645
    3646
    3647
    3648
    3649
    3650
    3651
    3652
    3653
    3654
    3655
    3656
    3657
    3658
    3659
    3660
    3661
    3662
    3663
    3664
    3665
    3666
    3667
    3668
    3669
    3670
    3671
    3672
    3673
    3674
    3675
    3676
    3677
    3678
    3679
    3680
    3681
    3682
    3683
    3684
    3685
    3686
    3687
    3688
    3689
    3690
    3691
    3692
    3693
    3694
    3695
    3696
    3697
    3698
    3699
    3700
    3701
    3702
    3703
    3704
    3705
    3706
    3707
    3708
    3709
    3710

| 
    
    
    def head(
        self,
        path: Annotated[
            str,
            Doc(
                """
                The URL path to be used for this *path operation*.
    
                For example, in `http://example.com/items`, the path is `/items`.
                """
            ),
        ],
        *,
        response_model: Annotated[
            Any,
            Doc(
                """
                The type to use for the response.
    
                It could be any valid Pydantic *field* type. So, it doesn't have to
                be a Pydantic model, it could be other things, like a `list`, `dict`,
                etc.
    
                It will be used for:
    
                * Documentation: the generated OpenAPI (and the UI at `/docs`) will
                    show it as the response (JSON Schema).
                * Serialization: you could return an arbitrary object and the
                    `response_model` would be used to serialize that object into the
                    corresponding JSON.
                * Filtering: the JSON sent to the client will only contain the data
                    (fields) defined in the `response_model`. If you returned an object
                    that contains an attribute `password` but the `response_model` does
                    not include that field, the JSON sent to the client would not have
                    that `password`.
                * Validation: whatever you return will be serialized with the
                    `response_model`, converting any data as necessary to generate the
                    corresponding JSON. But if the data in the object returned is not
                    valid, that would mean a violation of the contract with the client,
                    so it's an error from the API developer. So, FastAPI will raise an
                    error and return a 500 error code (Internal Server Error).
    
                Read more about it in the
                [FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).
                """
            ),
        ] = Default(None),
        status_code: Annotated[
            Optional[int],
            Doc(
                """
                The default status code to be used for the response.
    
                You could override the status code by returning a response directly.
    
                Read more about it in the
                [FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).
                """
            ),
        ] = None,
        tags: Annotated[
            Optional[list[Union[str, Enum]]],
            Doc(
                """
                A list of tags to be applied to the *path operation*.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
    
                Read more about it in the
                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).
                """
            ),
        ] = None,
        dependencies: Annotated[
            Optional[Sequence[params.Depends]],
            Doc(
                """
                A list of dependencies (using `Depends()`) to be applied to the
                *path operation*.
    
                Read more about it in the
                [FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).
                """
            ),
        ] = None,
        summary: Annotated[
            Optional[str],
            Doc(
                """
                A summary for the *path operation*.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
    
                Read more about it in the
                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
                """
            ),
        ] = None,
        description: Annotated[
            Optional[str],
            Doc(
                """
                A description for the *path operation*.
    
                If not provided, it will be extracted automatically from the docstring
                of the *path operation function*.
    
                It can contain Markdown.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
    
                Read more about it in the
                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
                """
            ),
        ] = None,
        response_description: Annotated[
            str,
            Doc(
                """
                The description for the default response.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
                """
            ),
        ] = "Successful Response",
        responses: Annotated[
            Optional[dict[Union[int, str], dict[str, Any]]],
            Doc(
                """
                Additional responses that could be returned by this *path operation*.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
                """
            ),
        ] = None,
        deprecated: Annotated[
            Optional[bool],
            Doc(
                """
                Mark this *path operation* as deprecated.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
                """
            ),
        ] = None,
        operation_id: Annotated[
            Optional[str],
            Doc(
                """
                Custom operation ID to be used by this *path operation*.
    
                By default, it is generated automatically.
    
                If you provide a custom operation ID, you need to make sure it is
                unique for the whole API.
    
                You can customize the
                operation ID generation with the parameter
                `generate_unique_id_function` in the `FastAPI` class.
    
                Read more about it in the
                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
                """
            ),
        ] = None,
        response_model_include: Annotated[
            Optional[IncEx],
            Doc(
                """
                Configuration passed to Pydantic to include only certain fields in the
                response data.
    
                Read more about it in the
                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
                """
            ),
        ] = None,
        response_model_exclude: Annotated[
            Optional[IncEx],
            Doc(
                """
                Configuration passed to Pydantic to exclude certain fields in the
                response data.
    
                Read more about it in the
                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
                """
            ),
        ] = None,
        response_model_by_alias: Annotated[
            bool,
            Doc(
                """
                Configuration passed to Pydantic to define if the response model
                should be serialized by alias when an alias is used.
    
                Read more about it in the
                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
                """
            ),
        ] = True,
        response_model_exclude_unset: Annotated[
            bool,
            Doc(
                """
                Configuration passed to Pydantic to define if the response data
                should have all the fields, including the ones that were not set and
                have their default values. This is different from
                `response_model_exclude_defaults` in that if the fields are set,
                they will be included in the response, even if the value is the same
                as the default.
    
                When `True`, default values are omitted from the response.
    
                Read more about it in the
                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).
                """
            ),
        ] = False,
        response_model_exclude_defaults: Annotated[
            bool,
            Doc(
                """
                Configuration passed to Pydantic to define if the response data
                should have all the fields, including the ones that have the same value
                as the default. This is different from `response_model_exclude_unset`
                in that if the fields are set but contain the same default values,
                they will be excluded from the response.
    
                When `True`, default values are omitted from the response.
    
                Read more about it in the
                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).
                """
            ),
        ] = False,
        response_model_exclude_none: Annotated[
            bool,
            Doc(
                """
                Configuration passed to Pydantic to define if the response data should
                exclude fields set to `None`.
    
                This is much simpler (less smart) than `response_model_exclude_unset`
                and `response_model_exclude_defaults`. You probably want to use one of
                those two instead of this one, as those allow returning `None` values
                when it makes sense.
    
                Read more about it in the
                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).
                """
            ),
        ] = False,
        include_in_schema: Annotated[
            bool,
            Doc(
                """
                Include this *path operation* in the generated OpenAPI schema.
    
                This affects the generated OpenAPI (e.g. visible at `/docs`).
    
                Read more about it in the
                [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-parameters-from-openapi).
                """
            ),
        ] = True,
        response_class: Annotated[
            type[Response],
            Doc(
                """
                Response class to be used for this *path operation*.
    
                This will not be used if you return a response directly.
    
                Read more about it in the
                [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).
                """
            ),
        ] = Default(JSONResponse),
        name: Annotated[
            Optional[str],
            Doc(
                """
                Name for this *path operation*. Only used internally.
                """
            ),
        ] = None,
        callbacks: Annotated[
            Optional[list[BaseRoute]],
            Doc(
                """
                List of *path operations* that will be used as OpenAPI callbacks.
    
                This is only for OpenAPI documentation, the callbacks won't be used
                directly.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
    
                Read more about it in the
                [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).
                """
            ),
        ] = None,
        openapi_extra: Annotated[
            Optional[dict[str, Any]],
            Doc(
                """
                Extra metadata to be included in the OpenAPI schema for this *path
                operation*.
    
                Read more about it in the
                [FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).
                """
            ),
        ] = None,
        generate_unique_id_function: Annotated[
            Callable[[APIRoute], str],
            Doc(
                """
                Customize the function used to generate unique IDs for the *path
                operations* shown in the generated OpenAPI.
    
                This is particularly useful when automatically generating clients or
                SDKs for your API.
    
                Read more about it in the
                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
                """
            ),
        ] = Default(generate_unique_id),
    ) -> Callable[[DecoratedCallable], DecoratedCallable]:
        """
        Add a *path operation* using an HTTP HEAD operation.
    
        ## Example
    
        ```python
        from fastapi import APIRouter, FastAPI
        from pydantic import BaseModel
    
        class Item(BaseModel):
            name: str
            description: str | None = None
    
        app = FastAPI()
        router = APIRouter()
    
        @router.head("/items/", status_code=204)
        def get_items_headers(response: Response):
            response.headers["X-Cat-Dog"] = "Alone in the world"
    
        app.include_router(router)
        ```
        """
        return self.api_route(
            path=path,
            response_model=response_model,
            status_code=status_code,
            tags=tags,
            dependencies=dependencies,
            summary=summary,
            description=description,
            response_description=response_description,
            responses=responses,
            deprecated=deprecated,
            methods=["HEAD"],
            operation_id=operation_id,
            response_model_include=response_model_include,
            response_model_exclude=response_model_exclude,
            response_model_by_alias=response_model_by_alias,
            response_model_exclude_unset=response_model_exclude_unset,
            response_model_exclude_defaults=response_model_exclude_defaults,
            response_model_exclude_none=response_model_exclude_none,
            include_in_schema=include_in_schema,
            response_class=response_class,
            name=name,
            callbacks=callbacks,
            openapi_extra=openapi_extra,
            generate_unique_id_function=generate_unique_id_function,
        )
      
  
---|---  
  
###  `` patch [¶](#fastapi.APIRouter.patch "Permanent link")
    
    
    patch(
        path,
        *,
        response_model=Default(None),
        status_code=None,
        tags=None,
        dependencies=None,
        summary=None,
        description=None,
        response_description="Successful Response",
        responses=None,
        deprecated=None,
        operation_id=None,
        response_model_include=None,
        response_model_exclude=None,
        response_model_by_alias=True,
        response_model_exclude_unset=False,
        response_model_exclude_defaults=False,
        response_model_exclude_none=False,
        include_in_schema=True,
        response_class=Default([JSONResponse](../responses/#fastapi.responses.JSONResponse "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">fastapi.responses.JSONResponse</span> \(<code>starlette.responses.JSONResponse</code>\)")),
        name=None,
        callbacks=None,
        openapi_extra=None,
        generate_unique_id_function=Default(generate_unique_id)
    )
    

Add a _path operation_ using an HTTP PATCH operation.

##### Example[¶](#fastapi.APIRouter.patch--example "Permanent link")
    
    
    from fastapi import APIRouter, FastAPI
    from pydantic import BaseModel
    
    class Item(BaseModel):
        name: str
        description: str | None = None
    
    app = FastAPI()
    router = APIRouter()
    
    @router.patch("/items/")
    def update_item(item: Item):
        return {"message": "Item updated in place"}
    
    app.include_router(router)
    

PARAMETER | DESCRIPTION  
---|---  
`path` |  The URL path to be used for this _path operation_. For example, in `http://example.com/items`, the path is `/items`. **TYPE:** `str`  
`response_model` |  The type to use for the response. It could be any valid Pydantic _field_ type. So, it doesn't have to be a Pydantic model, it could be other things, like a `list`, `dict`, etc. It will be used for:

  * Documentation: the generated OpenAPI (and the UI at `/docs`) will show it as the response (JSON Schema).
  * Serialization: you could return an arbitrary object and the `response_model` would be used to serialize that object into the corresponding JSON.
  * Filtering: the JSON sent to the client will only contain the data (fields) defined in the `response_model`. If you returned an object that contains an attribute `password` but the `response_model` does not include that field, the JSON sent to the client would not have that `password`.
  * Validation: whatever you return will be serialized with the `response_model`, converting any data as necessary to generate the corresponding JSON. But if the data in the object returned is not valid, that would mean a violation of the contract with the client, so it's an error from the API developer. So, FastAPI will raise an error and return a 500 error code (Internal Server Error).

Read more about it in the [FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/). **TYPE:** `Any` **DEFAULT:** `Default(None)`  
`status_code` |  The default status code to be used for the response. You could override the status code by returning a response directly. Read more about it in the [FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/). **TYPE:** `Optional[int]` **DEFAULT:** `None`  
`tags` |  A list of tags to be applied to the _path operation_. It will be added to the generated OpenAPI (e.g. visible at `/docs`). Read more about it in the [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags). **TYPE:** `Optional[list[Union[str, Enum]]]` **DEFAULT:** `None`  
`dependencies` |  A list of dependencies (using `Depends()`) to be applied to the _path operation_. Read more about it in the [FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/). **TYPE:** `Optional[Sequence[Depends]]` **DEFAULT:** `None`  
`summary` |  A summary for the _path operation_. It will be added to the generated OpenAPI (e.g. visible at `/docs`). Read more about it in the [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/). **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`description` |  A description for the _path operation_. If not provided, it will be extracted automatically from the docstring of the _path operation function_. It can contain Markdown. It will be added to the generated OpenAPI (e.g. visible at `/docs`). Read more about it in the [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/). **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`response_description` |  The description for the default response. It will be added to the generated OpenAPI (e.g. visible at `/docs`). **TYPE:** `str` **DEFAULT:** `'Successful Response'`  
`responses` |  Additional responses that could be returned by this _path operation_. It will be added to the generated OpenAPI (e.g. visible at `/docs`). **TYPE:** `Optional[dict[Union[int, str], dict[str, Any]]]` **DEFAULT:** `None`  
`deprecated` |  Mark this _path operation_ as deprecated. It will be added to the generated OpenAPI (e.g. visible at `/docs`). **TYPE:** `Optional[bool]` **DEFAULT:** `None`  
`operation_id` |  Custom operation ID to be used by this _path operation_. By default, it is generated automatically. If you provide a custom operation ID, you need to make sure it is unique for the whole API. You can customize the operation ID generation with the parameter `generate_unique_id_function` in the `FastAPI` class. Read more about it in the [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function). **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`response_model_include` |  Configuration passed to Pydantic to include only certain fields in the response data. Read more about it in the [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude). **TYPE:** `Optional[IncEx]` **DEFAULT:** `None`  
`response_model_exclude` |  Configuration passed to Pydantic to exclude certain fields in the response data. Read more about it in the [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude). **TYPE:** `Optional[IncEx]` **DEFAULT:** `None`  
`response_model_by_alias` |  Configuration passed to Pydantic to define if the response model should be serialized by alias when an alias is used. Read more about it in the [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude). **TYPE:** `bool` **DEFAULT:** `True`  
`response_model_exclude_unset` |  Configuration passed to Pydantic to define if the response data should have all the fields, including the ones that were not set and have their default values. This is different from `response_model_exclude_defaults` in that if the fields are set, they will be included in the response, even if the value is the same as the default. When `True`, default values are omitted from the response. Read more about it in the [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter). **TYPE:** `bool` **DEFAULT:** `False`  
`response_model_exclude_defaults` |  Configuration passed to Pydantic to define if the response data should have all the fields, including the ones that have the same value as the default. This is different from `response_model_exclude_unset` in that if the fields are set but contain the same default values, they will be excluded from the response. When `True`, default values are omitted from the response. Read more about it in the [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter). **TYPE:** `bool` **DEFAULT:** `False`  
`response_model_exclude_none` |  Configuration passed to Pydantic to define if the response data should exclude fields set to `None`. This is much simpler (less smart) than `response_model_exclude_unset` and `response_model_exclude_defaults`. You probably want to use one of those two instead of this one, as those allow returning `None` values when it makes sense. Read more about it in the [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none). **TYPE:** `bool` **DEFAULT:** `False`  
`include_in_schema` |  Include this _path operation_ in the generated OpenAPI schema. This affects the generated OpenAPI (e.g. visible at `/docs`). Read more about it in the [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-parameters-from-openapi). **TYPE:** `bool` **DEFAULT:** `True`  
`response_class` |  Response class to be used for this _path operation_. This will not be used if you return a response directly. Read more about it in the [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse). **TYPE:** `type[[Response](../response/#fastapi.Response "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">fastapi.Response</span> \(<code>starlette.responses.Response</code>\)")]` **DEFAULT:** `Default([JSONResponse](../responses/#fastapi.responses.JSONResponse "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">fastapi.responses.JSONResponse</span> \(<code>starlette.responses.JSONResponse</code>\)"))`  
`name` |  Name for this _path operation_. Only used internally. **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`callbacks` |  List of _path operations_ that will be used as OpenAPI callbacks. This is only for OpenAPI documentation, the callbacks won't be used directly. It will be added to the generated OpenAPI (e.g. visible at `/docs`). Read more about it in the [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/). **TYPE:** `Optional[list[BaseRoute]]` **DEFAULT:** `None`  
`openapi_extra` |  Extra metadata to be included in the OpenAPI schema for this _path operation_. Read more about it in the [FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema). **TYPE:** `Optional[dict[str, Any]]` **DEFAULT:** `None`  
`generate_unique_id_function` |  Customize the function used to generate unique IDs for the _path operations_ shown in the generated OpenAPI. This is particularly useful when automatically generating clients or SDKs for your API. Read more about it in the [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function). **TYPE:** `Callable[[APIRoute], str]` **DEFAULT:** `Default(generate_unique_id)`  
Source code in `fastapi/routing.py`
    
    
    3712
    3713
    3714
    3715
    3716
    3717
    3718
    3719
    3720
    3721
    3722
    3723
    3724
    3725
    3726
    3727
    3728
    3729
    3730
    3731
    3732
    3733
    3734
    3735
    3736
    3737
    3738
    3739
    3740
    3741
    3742
    3743
    3744
    3745
    3746
    3747
    3748
    3749
    3750
    3751
    3752
    3753
    3754
    3755
    3756
    3757
    3758
    3759
    3760
    3761
    3762
    3763
    3764
    3765
    3766
    3767
    3768
    3769
    3770
    3771
    3772
    3773
    3774
    3775
    3776
    3777
    3778
    3779
    3780
    3781
    3782
    3783
    3784
    3785
    3786
    3787
    3788
    3789
    3790
    3791
    3792
    3793
    3794
    3795
    3796
    3797
    3798
    3799
    3800
    3801
    3802
    3803
    3804
    3805
    3806
    3807
    3808
    3809
    3810
    3811
    3812
    3813
    3814
    3815
    3816
    3817
    3818
    3819
    3820
    3821
    3822
    3823
    3824
    3825
    3826
    3827
    3828
    3829
    3830
    3831
    3832
    3833
    3834
    3835
    3836
    3837
    3838
    3839
    3840
    3841
    3842
    3843
    3844
    3845
    3846
    3847
    3848
    3849
    3850
    3851
    3852
    3853
    3854
    3855
    3856
    3857
    3858
    3859
    3860
    3861
    3862
    3863
    3864
    3865
    3866
    3867
    3868
    3869
    3870
    3871
    3872
    3873
    3874
    3875
    3876
    3877
    3878
    3879
    3880
    3881
    3882
    3883
    3884
    3885
    3886
    3887
    3888
    3889
    3890
    3891
    3892
    3893
    3894
    3895
    3896
    3897
    3898
    3899
    3900
    3901
    3902
    3903
    3904
    3905
    3906
    3907
    3908
    3909
    3910
    3911
    3912
    3913
    3914
    3915
    3916
    3917
    3918
    3919
    3920
    3921
    3922
    3923
    3924
    3925
    3926
    3927
    3928
    3929
    3930
    3931
    3932
    3933
    3934
    3935
    3936
    3937
    3938
    3939
    3940
    3941
    3942
    3943
    3944
    3945
    3946
    3947
    3948
    3949
    3950
    3951
    3952
    3953
    3954
    3955
    3956
    3957
    3958
    3959
    3960
    3961
    3962
    3963
    3964
    3965
    3966
    3967
    3968
    3969
    3970
    3971
    3972
    3973
    3974
    3975
    3976
    3977
    3978
    3979
    3980
    3981
    3982
    3983
    3984
    3985
    3986
    3987
    3988
    3989
    3990
    3991
    3992
    3993
    3994
    3995
    3996
    3997
    3998
    3999
    4000
    4001
    4002
    4003
    4004
    4005
    4006
    4007
    4008
    4009
    4010
    4011
    4012
    4013
    4014
    4015
    4016
    4017
    4018
    4019
    4020
    4021
    4022
    4023
    4024
    4025
    4026
    4027
    4028
    4029
    4030
    4031
    4032
    4033
    4034
    4035
    4036
    4037
    4038
    4039
    4040
    4041
    4042
    4043
    4044
    4045
    4046
    4047
    4048
    4049
    4050
    4051
    4052
    4053
    4054
    4055
    4056
    4057
    4058
    4059
    4060
    4061
    4062
    4063
    4064
    4065
    4066
    4067
    4068
    4069
    4070
    4071
    4072
    4073
    4074
    4075
    4076
    4077
    4078
    4079
    4080
    4081
    4082
    4083
    4084
    4085
    4086
    4087
    4088
    4089
    4090
    4091
    4092

| 
    
    
    def patch(
        self,
        path: Annotated[
            str,
            Doc(
                """
                The URL path to be used for this *path operation*.
    
                For example, in `http://example.com/items`, the path is `/items`.
                """
            ),
        ],
        *,
        response_model: Annotated[
            Any,
            Doc(
                """
                The type to use for the response.
    
                It could be any valid Pydantic *field* type. So, it doesn't have to
                be a Pydantic model, it could be other things, like a `list`, `dict`,
                etc.
    
                It will be used for:
    
                * Documentation: the generated OpenAPI (and the UI at `/docs`) will
                    show it as the response (JSON Schema).
                * Serialization: you could return an arbitrary object and the
                    `response_model` would be used to serialize that object into the
                    corresponding JSON.
                * Filtering: the JSON sent to the client will only contain the data
                    (fields) defined in the `response_model`. If you returned an object
                    that contains an attribute `password` but the `response_model` does
                    not include that field, the JSON sent to the client would not have
                    that `password`.
                * Validation: whatever you return will be serialized with the
                    `response_model`, converting any data as necessary to generate the
                    corresponding JSON. But if the data in the object returned is not
                    valid, that would mean a violation of the contract with the client,
                    so it's an error from the API developer. So, FastAPI will raise an
                    error and return a 500 error code (Internal Server Error).
    
                Read more about it in the
                [FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).
                """
            ),
        ] = Default(None),
        status_code: Annotated[
            Optional[int],
            Doc(
                """
                The default status code to be used for the response.
    
                You could override the status code by returning a response directly.
    
                Read more about it in the
                [FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).
                """
            ),
        ] = None,
        tags: Annotated[
            Optional[list[Union[str, Enum]]],
            Doc(
                """
                A list of tags to be applied to the *path operation*.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
    
                Read more about it in the
                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).
                """
            ),
        ] = None,
        dependencies: Annotated[
            Optional[Sequence[params.Depends]],
            Doc(
                """
                A list of dependencies (using `Depends()`) to be applied to the
                *path operation*.
    
                Read more about it in the
                [FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).
                """
            ),
        ] = None,
        summary: Annotated[
            Optional[str],
            Doc(
                """
                A summary for the *path operation*.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
    
                Read more about it in the
                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
                """
            ),
        ] = None,
        description: Annotated[
            Optional[str],
            Doc(
                """
                A description for the *path operation*.
    
                If not provided, it will be extracted automatically from the docstring
                of the *path operation function*.
    
                It can contain Markdown.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
    
                Read more about it in the
                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
                """
            ),
        ] = None,
        response_description: Annotated[
            str,
            Doc(
                """
                The description for the default response.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
                """
            ),
        ] = "Successful Response",
        responses: Annotated[
            Optional[dict[Union[int, str], dict[str, Any]]],
            Doc(
                """
                Additional responses that could be returned by this *path operation*.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
                """
            ),
        ] = None,
        deprecated: Annotated[
            Optional[bool],
            Doc(
                """
                Mark this *path operation* as deprecated.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
                """
            ),
        ] = None,
        operation_id: Annotated[
            Optional[str],
            Doc(
                """
                Custom operation ID to be used by this *path operation*.
    
                By default, it is generated automatically.
    
                If you provide a custom operation ID, you need to make sure it is
                unique for the whole API.
    
                You can customize the
                operation ID generation with the parameter
                `generate_unique_id_function` in the `FastAPI` class.
    
                Read more about it in the
                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
                """
            ),
        ] = None,
        response_model_include: Annotated[
            Optional[IncEx],
            Doc(
                """
                Configuration passed to Pydantic to include only certain fields in the
                response data.
    
                Read more about it in the
                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
                """
            ),
        ] = None,
        response_model_exclude: Annotated[
            Optional[IncEx],
            Doc(
                """
                Configuration passed to Pydantic to exclude certain fields in the
                response data.
    
                Read more about it in the
                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
                """
            ),
        ] = None,
        response_model_by_alias: Annotated[
            bool,
            Doc(
                """
                Configuration passed to Pydantic to define if the response model
                should be serialized by alias when an alias is used.
    
                Read more about it in the
                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
                """
            ),
        ] = True,
        response_model_exclude_unset: Annotated[
            bool,
            Doc(
                """
                Configuration passed to Pydantic to define if the response data
                should have all the fields, including the ones that were not set and
                have their default values. This is different from
                `response_model_exclude_defaults` in that if the fields are set,
                they will be included in the response, even if the value is the same
                as the default.
    
                When `True`, default values are omitted from the response.
    
                Read more about it in the
                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).
                """
            ),
        ] = False,
        response_model_exclude_defaults: Annotated[
            bool,
            Doc(
                """
                Configuration passed to Pydantic to define if the response data
                should have all the fields, including the ones that have the same value
                as the default. This is different from `response_model_exclude_unset`
                in that if the fields are set but contain the same default values,
                they will be excluded from the response.
    
                When `True`, default values are omitted from the response.
    
                Read more about it in the
                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).
                """
            ),
        ] = False,
        response_model_exclude_none: Annotated[
            bool,
            Doc(
                """
                Configuration passed to Pydantic to define if the response data should
                exclude fields set to `None`.
    
                This is much simpler (less smart) than `response_model_exclude_unset`
                and `response_model_exclude_defaults`. You probably want to use one of
                those two instead of this one, as those allow returning `None` values
                when it makes sense.
    
                Read more about it in the
                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).
                """
            ),
        ] = False,
        include_in_schema: Annotated[
            bool,
            Doc(
                """
                Include this *path operation* in the generated OpenAPI schema.
    
                This affects the generated OpenAPI (e.g. visible at `/docs`).
    
                Read more about it in the
                [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-parameters-from-openapi).
                """
            ),
        ] = True,
        response_class: Annotated[
            type[Response],
            Doc(
                """
                Response class to be used for this *path operation*.
    
                This will not be used if you return a response directly.
    
                Read more about it in the
                [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).
                """
            ),
        ] = Default(JSONResponse),
        name: Annotated[
            Optional[str],
            Doc(
                """
                Name for this *path operation*. Only used internally.
                """
            ),
        ] = None,
        callbacks: Annotated[
            Optional[list[BaseRoute]],
            Doc(
                """
                List of *path operations* that will be used as OpenAPI callbacks.
    
                This is only for OpenAPI documentation, the callbacks won't be used
                directly.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
    
                Read more about it in the
                [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).
                """
            ),
        ] = None,
        openapi_extra: Annotated[
            Optional[dict[str, Any]],
            Doc(
                """
                Extra metadata to be included in the OpenAPI schema for this *path
                operation*.
    
                Read more about it in the
                [FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).
                """
            ),
        ] = None,
        generate_unique_id_function: Annotated[
            Callable[[APIRoute], str],
            Doc(
                """
                Customize the function used to generate unique IDs for the *path
                operations* shown in the generated OpenAPI.
    
                This is particularly useful when automatically generating clients or
                SDKs for your API.
    
                Read more about it in the
                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
                """
            ),
        ] = Default(generate_unique_id),
    ) -> Callable[[DecoratedCallable], DecoratedCallable]:
        """
        Add a *path operation* using an HTTP PATCH operation.
    
        ## Example
    
        ```python
        from fastapi import APIRouter, FastAPI
        from pydantic import BaseModel
    
        class Item(BaseModel):
            name: str
            description: str | None = None
    
        app = FastAPI()
        router = APIRouter()
    
        @router.patch("/items/")
        def update_item(item: Item):
            return {"message": "Item updated in place"}
    
        app.include_router(router)
        ```
        """
        return self.api_route(
            path=path,
            response_model=response_model,
            status_code=status_code,
            tags=tags,
            dependencies=dependencies,
            summary=summary,
            description=description,
            response_description=response_description,
            responses=responses,
            deprecated=deprecated,
            methods=["PATCH"],
            operation_id=operation_id,
            response_model_include=response_model_include,
            response_model_exclude=response_model_exclude,
            response_model_by_alias=response_model_by_alias,
            response_model_exclude_unset=response_model_exclude_unset,
            response_model_exclude_defaults=response_model_exclude_defaults,
            response_model_exclude_none=response_model_exclude_none,
            include_in_schema=include_in_schema,
            response_class=response_class,
            name=name,
            callbacks=callbacks,
            openapi_extra=openapi_extra,
            generate_unique_id_function=generate_unique_id_function,
        )
      
  
---|---  
  
###  `` trace [¶](#fastapi.APIRouter.trace "Permanent link")
    
    
    trace(
        path,
        *,
        response_model=Default(None),
        status_code=None,
        tags=None,
        dependencies=None,
        summary=None,
        description=None,
        response_description="Successful Response",
        responses=None,
        deprecated=None,
        operation_id=None,
        response_model_include=None,
        response_model_exclude=None,
        response_model_by_alias=True,
        response_model_exclude_unset=False,
        response_model_exclude_defaults=False,
        response_model_exclude_none=False,
        include_in_schema=True,
        response_class=Default([JSONResponse](../responses/#fastapi.responses.JSONResponse "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">fastapi.responses.JSONResponse</span> \(<code>starlette.responses.JSONResponse</code>\)")),
        name=None,
        callbacks=None,
        openapi_extra=None,
        generate_unique_id_function=Default(generate_unique_id)
    )
    

Add a _path operation_ using an HTTP TRACE operation.

##### Example[¶](#fastapi.APIRouter.trace--example "Permanent link")
    
    
    from fastapi import APIRouter, FastAPI
    from pydantic import BaseModel
    
    class Item(BaseModel):
        name: str
        description: str | None = None
    
    app = FastAPI()
    router = APIRouter()
    
    @router.trace("/items/{item_id}")
    def trace_item(item_id: str):
        return None
    
    app.include_router(router)
    

PARAMETER | DESCRIPTION  
---|---  
`path` |  The URL path to be used for this _path operation_. For example, in `http://example.com/items`, the path is `/items`. **TYPE:** `str`  
`response_model` |  The type to use for the response. It could be any valid Pydantic _field_ type. So, it doesn't have to be a Pydantic model, it could be other things, like a `list`, `dict`, etc. It will be used for:

  * Documentation: the generated OpenAPI (and the UI at `/docs`) will show it as the response (JSON Schema).
  * Serialization: you could return an arbitrary object and the `response_model` would be used to serialize that object into the corresponding JSON.
  * Filtering: the JSON sent to the client will only contain the data (fields) defined in the `response_model`. If you returned an object that contains an attribute `password` but the `response_model` does not include that field, the JSON sent to the client would not have that `password`.
  * Validation: whatever you return will be serialized with the `response_model`, converting any data as necessary to generate the corresponding JSON. But if the data in the object returned is not valid, that would mean a violation of the contract with the client, so it's an error from the API developer. So, FastAPI will raise an error and return a 500 error code (Internal Server Error).

Read more about it in the [FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/). **TYPE:** `Any` **DEFAULT:** `Default(None)`  
`status_code` |  The default status code to be used for the response. You could override the status code by returning a response directly. Read more about it in the [FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/). **TYPE:** `Optional[int]` **DEFAULT:** `None`  
`tags` |  A list of tags to be applied to the _path operation_. It will be added to the generated OpenAPI (e.g. visible at `/docs`). Read more about it in the [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags). **TYPE:** `Optional[list[Union[str, Enum]]]` **DEFAULT:** `None`  
`dependencies` |  A list of dependencies (using `Depends()`) to be applied to the _path operation_. Read more about it in the [FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/). **TYPE:** `Optional[Sequence[Depends]]` **DEFAULT:** `None`  
`summary` |  A summary for the _path operation_. It will be added to the generated OpenAPI (e.g. visible at `/docs`). Read more about it in the [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/). **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`description` |  A description for the _path operation_. If not provided, it will be extracted automatically from the docstring of the _path operation function_. It can contain Markdown. It will be added to the generated OpenAPI (e.g. visible at `/docs`). Read more about it in the [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/). **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`response_description` |  The description for the default response. It will be added to the generated OpenAPI (e.g. visible at `/docs`). **TYPE:** `str` **DEFAULT:** `'Successful Response'`  
`responses` |  Additional responses that could be returned by this _path operation_. It will be added to the generated OpenAPI (e.g. visible at `/docs`). **TYPE:** `Optional[dict[Union[int, str], dict[str, Any]]]` **DEFAULT:** `None`  
`deprecated` |  Mark this _path operation_ as deprecated. It will be added to the generated OpenAPI (e.g. visible at `/docs`). **TYPE:** `Optional[bool]` **DEFAULT:** `None`  
`operation_id` |  Custom operation ID to be used by this _path operation_. By default, it is generated automatically. If you provide a custom operation ID, you need to make sure it is unique for the whole API. You can customize the operation ID generation with the parameter `generate_unique_id_function` in the `FastAPI` class. Read more about it in the [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function). **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`response_model_include` |  Configuration passed to Pydantic to include only certain fields in the response data. Read more about it in the [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude). **TYPE:** `Optional[IncEx]` **DEFAULT:** `None`  
`response_model_exclude` |  Configuration passed to Pydantic to exclude certain fields in the response data. Read more about it in the [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude). **TYPE:** `Optional[IncEx]` **DEFAULT:** `None`  
`response_model_by_alias` |  Configuration passed to Pydantic to define if the response model should be serialized by alias when an alias is used. Read more about it in the [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude). **TYPE:** `bool` **DEFAULT:** `True`  
`response_model_exclude_unset` |  Configuration passed to Pydantic to define if the response data should have all the fields, including the ones that were not set and have their default values. This is different from `response_model_exclude_defaults` in that if the fields are set, they will be included in the response, even if the value is the same as the default. When `True`, default values are omitted from the response. Read more about it in the [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter). **TYPE:** `bool` **DEFAULT:** `False`  
`response_model_exclude_defaults` |  Configuration passed to Pydantic to define if the response data should have all the fields, including the ones that have the same value as the default. This is different from `response_model_exclude_unset` in that if the fields are set but contain the same default values, they will be excluded from the response. When `True`, default values are omitted from the response. Read more about it in the [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter). **TYPE:** `bool` **DEFAULT:** `False`  
`response_model_exclude_none` |  Configuration passed to Pydantic to define if the response data should exclude fields set to `None`. This is much simpler (less smart) than `response_model_exclude_unset` and `response_model_exclude_defaults`. You probably want to use one of those two instead of this one, as those allow returning `None` values when it makes sense. Read more about it in the [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none). **TYPE:** `bool` **DEFAULT:** `False`  
`include_in_schema` |  Include this _path operation_ in the generated OpenAPI schema. This affects the generated OpenAPI (e.g. visible at `/docs`). Read more about it in the [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-parameters-from-openapi). **TYPE:** `bool` **DEFAULT:** `True`  
`response_class` |  Response class to be used for this _path operation_. This will not be used if you return a response directly. Read more about it in the [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse). **TYPE:** `type[[Response](../response/#fastapi.Response "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">fastapi.Response</span> \(<code>starlette.responses.Response</code>\)")]` **DEFAULT:** `Default([JSONResponse](../responses/#fastapi.responses.JSONResponse "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">fastapi.responses.JSONResponse</span> \(<code>starlette.responses.JSONResponse</code>\)"))`  
`name` |  Name for this _path operation_. Only used internally. **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`callbacks` |  List of _path operations_ that will be used as OpenAPI callbacks. This is only for OpenAPI documentation, the callbacks won't be used directly. It will be added to the generated OpenAPI (e.g. visible at `/docs`). Read more about it in the [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/). **TYPE:** `Optional[list[BaseRoute]]` **DEFAULT:** `None`  
`openapi_extra` |  Extra metadata to be included in the OpenAPI schema for this _path operation_. Read more about it in the [FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema). **TYPE:** `Optional[dict[str, Any]]` **DEFAULT:** `None`  
`generate_unique_id_function` |  Customize the function used to generate unique IDs for the _path operations_ shown in the generated OpenAPI. This is particularly useful when automatically generating clients or SDKs for your API. Read more about it in the [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function). **TYPE:** `Callable[[APIRoute], str]` **DEFAULT:** `Default(generate_unique_id)`  
Source code in `fastapi/routing.py`
    
    
    4094
    4095
    4096
    4097
    4098
    4099
    4100
    4101
    4102
    4103
    4104
    4105
    4106
    4107
    4108
    4109
    4110
    4111
    4112
    4113
    4114
    4115
    4116
    4117
    4118
    4119
    4120
    4121
    4122
    4123
    4124
    4125
    4126
    4127
    4128
    4129
    4130
    4131
    4132
    4133
    4134
    4135
    4136
    4137
    4138
    4139
    4140
    4141
    4142
    4143
    4144
    4145
    4146
    4147
    4148
    4149
    4150
    4151
    4152
    4153
    4154
    4155
    4156
    4157
    4158
    4159
    4160
    4161
    4162
    4163
    4164
    4165
    4166
    4167
    4168
    4169
    4170
    4171
    4172
    4173
    4174
    4175
    4176
    4177
    4178
    4179
    4180
    4181
    4182
    4183
    4184
    4185
    4186
    4187
    4188
    4189
    4190
    4191
    4192
    4193
    4194
    4195
    4196
    4197
    4198
    4199
    4200
    4201
    4202
    4203
    4204
    4205
    4206
    4207
    4208
    4209
    4210
    4211
    4212
    4213
    4214
    4215
    4216
    4217
    4218
    4219
    4220
    4221
    4222
    4223
    4224
    4225
    4226
    4227
    4228
    4229
    4230
    4231
    4232
    4233
    4234
    4235
    4236
    4237
    4238
    4239
    4240
    4241
    4242
    4243
    4244
    4245
    4246
    4247
    4248
    4249
    4250
    4251
    4252
    4253
    4254
    4255
    4256
    4257
    4258
    4259
    4260
    4261
    4262
    4263
    4264
    4265
    4266
    4267
    4268
    4269
    4270
    4271
    4272
    4273
    4274
    4275
    4276
    4277
    4278
    4279
    4280
    4281
    4282
    4283
    4284
    4285
    4286
    4287
    4288
    4289
    4290
    4291
    4292
    4293
    4294
    4295
    4296
    4297
    4298
    4299
    4300
    4301
    4302
    4303
    4304
    4305
    4306
    4307
    4308
    4309
    4310
    4311
    4312
    4313
    4314
    4315
    4316
    4317
    4318
    4319
    4320
    4321
    4322
    4323
    4324
    4325
    4326
    4327
    4328
    4329
    4330
    4331
    4332
    4333
    4334
    4335
    4336
    4337
    4338
    4339
    4340
    4341
    4342
    4343
    4344
    4345
    4346
    4347
    4348
    4349
    4350
    4351
    4352
    4353
    4354
    4355
    4356
    4357
    4358
    4359
    4360
    4361
    4362
    4363
    4364
    4365
    4366
    4367
    4368
    4369
    4370
    4371
    4372
    4373
    4374
    4375
    4376
    4377
    4378
    4379
    4380
    4381
    4382
    4383
    4384
    4385
    4386
    4387
    4388
    4389
    4390
    4391
    4392
    4393
    4394
    4395
    4396
    4397
    4398
    4399
    4400
    4401
    4402
    4403
    4404
    4405
    4406
    4407
    4408
    4409
    4410
    4411
    4412
    4413
    4414
    4415
    4416
    4417
    4418
    4419
    4420
    4421
    4422
    4423
    4424
    4425
    4426
    4427
    4428
    4429
    4430
    4431
    4432
    4433
    4434
    4435
    4436
    4437
    4438
    4439
    4440
    4441
    4442
    4443
    4444
    4445
    4446
    4447
    4448
    4449
    4450
    4451
    4452
    4453
    4454
    4455
    4456
    4457
    4458
    4459
    4460
    4461
    4462
    4463
    4464
    4465
    4466
    4467
    4468
    4469
    4470
    4471
    4472
    4473
    4474

| 
    
    
    def trace(
        self,
        path: Annotated[
            str,
            Doc(
                """
                The URL path to be used for this *path operation*.
    
                For example, in `http://example.com/items`, the path is `/items`.
                """
            ),
        ],
        *,
        response_model: Annotated[
            Any,
            Doc(
                """
                The type to use for the response.
    
                It could be any valid Pydantic *field* type. So, it doesn't have to
                be a Pydantic model, it could be other things, like a `list`, `dict`,
                etc.
    
                It will be used for:
    
                * Documentation: the generated OpenAPI (and the UI at `/docs`) will
                    show it as the response (JSON Schema).
                * Serialization: you could return an arbitrary object and the
                    `response_model` would be used to serialize that object into the
                    corresponding JSON.
                * Filtering: the JSON sent to the client will only contain the data
                    (fields) defined in the `response_model`. If you returned an object
                    that contains an attribute `password` but the `response_model` does
                    not include that field, the JSON sent to the client would not have
                    that `password`.
                * Validation: whatever you return will be serialized with the
                    `response_model`, converting any data as necessary to generate the
                    corresponding JSON. But if the data in the object returned is not
                    valid, that would mean a violation of the contract with the client,
                    so it's an error from the API developer. So, FastAPI will raise an
                    error and return a 500 error code (Internal Server Error).
    
                Read more about it in the
                [FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).
                """
            ),
        ] = Default(None),
        status_code: Annotated[
            Optional[int],
            Doc(
                """
                The default status code to be used for the response.
    
                You could override the status code by returning a response directly.
    
                Read more about it in the
                [FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).
                """
            ),
        ] = None,
        tags: Annotated[
            Optional[list[Union[str, Enum]]],
            Doc(
                """
                A list of tags to be applied to the *path operation*.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
    
                Read more about it in the
                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).
                """
            ),
        ] = None,
        dependencies: Annotated[
            Optional[Sequence[params.Depends]],
            Doc(
                """
                A list of dependencies (using `Depends()`) to be applied to the
                *path operation*.
    
                Read more about it in the
                [FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).
                """
            ),
        ] = None,
        summary: Annotated[
            Optional[str],
            Doc(
                """
                A summary for the *path operation*.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
    
                Read more about it in the
                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
                """
            ),
        ] = None,
        description: Annotated[
            Optional[str],
            Doc(
                """
                A description for the *path operation*.
    
                If not provided, it will be extracted automatically from the docstring
                of the *path operation function*.
    
                It can contain Markdown.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
    
                Read more about it in the
                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
                """
            ),
        ] = None,
        response_description: Annotated[
            str,
            Doc(
                """
                The description for the default response.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
                """
            ),
        ] = "Successful Response",
        responses: Annotated[
            Optional[dict[Union[int, str], dict[str, Any]]],
            Doc(
                """
                Additional responses that could be returned by this *path operation*.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
                """
            ),
        ] = None,
        deprecated: Annotated[
            Optional[bool],
            Doc(
                """
                Mark this *path operation* as deprecated.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
                """
            ),
        ] = None,
        operation_id: Annotated[
            Optional[str],
            Doc(
                """
                Custom operation ID to be used by this *path operation*.
    
                By default, it is generated automatically.
    
                If you provide a custom operation ID, you need to make sure it is
                unique for the whole API.
    
                You can customize the
                operation ID generation with the parameter
                `generate_unique_id_function` in the `FastAPI` class.
    
                Read more about it in the
                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
                """
            ),
        ] = None,
        response_model_include: Annotated[
            Optional[IncEx],
            Doc(
                """
                Configuration passed to Pydantic to include only certain fields in the
                response data.
    
                Read more about it in the
                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
                """
            ),
        ] = None,
        response_model_exclude: Annotated[
            Optional[IncEx],
            Doc(
                """
                Configuration passed to Pydantic to exclude certain fields in the
                response data.
    
                Read more about it in the
                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
                """
            ),
        ] = None,
        response_model_by_alias: Annotated[
            bool,
            Doc(
                """
                Configuration passed to Pydantic to define if the response model
                should be serialized by alias when an alias is used.
    
                Read more about it in the
                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
                """
            ),
        ] = True,
        response_model_exclude_unset: Annotated[
            bool,
            Doc(
                """
                Configuration passed to Pydantic to define if the response data
                should have all the fields, including the ones that were not set and
                have their default values. This is different from
                `response_model_exclude_defaults` in that if the fields are set,
                they will be included in the response, even if the value is the same
                as the default.
    
                When `True`, default values are omitted from the response.
    
                Read more about it in the
                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).
                """
            ),
        ] = False,
        response_model_exclude_defaults: Annotated[
            bool,
            Doc(
                """
                Configuration passed to Pydantic to define if the response data
                should have all the fields, including the ones that have the same value
                as the default. This is different from `response_model_exclude_unset`
                in that if the fields are set but contain the same default values,
                they will be excluded from the response.
    
                When `True`, default values are omitted from the response.
    
                Read more about it in the
                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).
                """
            ),
        ] = False,
        response_model_exclude_none: Annotated[
            bool,
            Doc(
                """
                Configuration passed to Pydantic to define if the response data should
                exclude fields set to `None`.
    
                This is much simpler (less smart) than `response_model_exclude_unset`
                and `response_model_exclude_defaults`. You probably want to use one of
                those two instead of this one, as those allow returning `None` values
                when it makes sense.
    
                Read more about it in the
                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).
                """
            ),
        ] = False,
        include_in_schema: Annotated[
            bool,
            Doc(
                """
                Include this *path operation* in the generated OpenAPI schema.
    
                This affects the generated OpenAPI (e.g. visible at `/docs`).
    
                Read more about it in the
                [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-parameters-from-openapi).
                """
            ),
        ] = True,
        response_class: Annotated[
            type[Response],
            Doc(
                """
                Response class to be used for this *path operation*.
    
                This will not be used if you return a response directly.
    
                Read more about it in the
                [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).
                """
            ),
        ] = Default(JSONResponse),
        name: Annotated[
            Optional[str],
            Doc(
                """
                Name for this *path operation*. Only used internally.
                """
            ),
        ] = None,
        callbacks: Annotated[
            Optional[list[BaseRoute]],
            Doc(
                """
                List of *path operations* that will be used as OpenAPI callbacks.
    
                This is only for OpenAPI documentation, the callbacks won't be used
                directly.
    
                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
    
                Read more about it in the
                [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).
                """
            ),
        ] = None,
        openapi_extra: Annotated[
            Optional[dict[str, Any]],
            Doc(
                """
                Extra metadata to be included in the OpenAPI schema for this *path
                operation*.
    
                Read more about it in the
                [FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).
                """
            ),
        ] = None,
        generate_unique_id_function: Annotated[
            Callable[[APIRoute], str],
            Doc(
                """
                Customize the function used to generate unique IDs for the *path
                operations* shown in the generated OpenAPI.
    
                This is particularly useful when automatically generating clients or
                SDKs for your API.
    
                Read more about it in the
                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
                """
            ),
        ] = Default(generate_unique_id),
    ) -> Callable[[DecoratedCallable], DecoratedCallable]:
        """
        Add a *path operation* using an HTTP TRACE operation.
    
        ## Example
    
        ```python
        from fastapi import APIRouter, FastAPI
        from pydantic import BaseModel
    
        class Item(BaseModel):
            name: str
            description: str | None = None
    
        app = FastAPI()
        router = APIRouter()
    
        @router.trace("/items/{item_id}")
        def trace_item(item_id: str):
            return None
    
        app.include_router(router)
        ```
        """
        return self.api_route(
            path=path,
            response_model=response_model,
            status_code=status_code,
            tags=tags,
            dependencies=dependencies,
            summary=summary,
            description=description,
            response_description=response_description,
            responses=responses,
            deprecated=deprecated,
            methods=["TRACE"],
            operation_id=operation_id,
            response_model_include=response_model_include,
            response_model_exclude=response_model_exclude,
            response_model_by_alias=response_model_by_alias,
            response_model_exclude_unset=response_model_exclude_unset,
            response_model_exclude_defaults=response_model_exclude_defaults,
            response_model_exclude_none=response_model_exclude_none,
            include_in_schema=include_in_schema,
            response_class=response_class,
            name=name,
            callbacks=callbacks,
            openapi_extra=openapi_extra,
            generate_unique_id_function=generate_unique_id_function,
        )
      
  
---|---  
  
###  `` on_event [¶](#fastapi.APIRouter.on_event "Permanent link")
    
    
    on_event(event_type)
    

Add an event handler for the router.

`on_event` is deprecated, use `lifespan` event handlers instead.

Read more about it in the [FastAPI docs for Lifespan Events](https://fastapi.tiangolo.com/advanced/events/#alternative-events-deprecated).

PARAMETER | DESCRIPTION  
---|---  
`event_type` |  The type of event. `startup` or `shutdown`. **TYPE:** `str`  
Source code in `fastapi/routing.py`
    
    
    4476
    4477
    4478
    4479
    4480
    4481
    4482
    4483
    4484
    4485
    4486
    4487
    4488
    4489
    4490
    4491
    4492
    4493
    4494
    4495
    4496
    4497
    4498
    4499
    4500
    4501
    4502
    4503
    4504
    4505
    4506
    4507
    4508

| 
    
    
    @deprecated(
        """
        on_event is deprecated, use lifespan event handlers instead.
    
        Read more about it in the
        [FastAPI docs for Lifespan Events](https://fastapi.tiangolo.com/advanced/events/).
        """
    )
    def on_event(
        self,
        event_type: Annotated[
            str,
            Doc(
                """
                The type of event. `startup` or `shutdown`.
                """
            ),
        ],
    ) -> Callable[[DecoratedCallable], DecoratedCallable]:
        """
        Add an event handler for the router.
    
        `on_event` is deprecated, use `lifespan` event handlers instead.
    
        Read more about it in the
        [FastAPI docs for Lifespan Events](https://fastapi.tiangolo.com/advanced/events/#alternative-events-deprecated).
        """
    
        def decorator(func: DecoratedCallable) -> DecoratedCallable:
            self.add_event_handler(event_type, func)
            return func
    
        return decorator
      
  
---|---

---

###### Background Tasks -BackgroundTasks¶

# Background Tasks - `BackgroundTasks`[¶](#background-tasks-backgroundtasks "Permanent link")

You can declare a parameter in a _path operation function_ or dependency function with the type `BackgroundTasks`, and then you can use it to schedule the execution of background tasks after the response is sent.

You can import it directly from `fastapi`:
    
    
    from fastapi import BackgroundTasks
    

##  `` fastapi.BackgroundTasks [¶](#fastapi.BackgroundTasks "Permanent link")
    
    
    BackgroundTasks(tasks=None)
    

Bases: `BackgroundTasks`

A collection of background tasks that will be called after a response has been sent to the client.

Read more about it in the [FastAPI docs for Background Tasks](https://fastapi.tiangolo.com/tutorial/background-tasks/).

#### Example[¶](#fastapi.BackgroundTasks--example "Permanent link")
    
    
    from fastapi import BackgroundTasks, FastAPI
    
    app = FastAPI()
    
    
    def write_notification(email: str, message=""):
        with open("log.txt", mode="w") as email_file:
            content = f"notification for {email}: {message}"
            email_file.write(content)
    
    
    @app.post("/send-notification/{email}")
    async def send_notification(email: str, background_tasks: BackgroundTasks):
        background_tasks.add_task(write_notification, email, message="some notification")
        return {"message": "Notification sent in the background"}
    

Source code in `starlette/background.py`
    
    
    27
    28

| 
    
    
    def __init__(self, tasks: Sequence[BackgroundTask] | None = None):
        self.tasks = list(tasks) if tasks else []
      
  
---|---  
  
###  `` func `instance-attribute` [¶](#fastapi.BackgroundTasks.func "Permanent link")
    
    
    func = func
    

###  `` args `instance-attribute` [¶](#fastapi.BackgroundTasks.args "Permanent link")
    
    
    args = args
    

###  `` kwargs `instance-attribute` [¶](#fastapi.BackgroundTasks.kwargs "Permanent link")
    
    
    kwargs = kwargs
    

###  `` is_async `instance-attribute` [¶](#fastapi.BackgroundTasks.is_async "Permanent link")
    
    
    is_async = is_async_callable(func)
    

###  `` tasks `instance-attribute` [¶](#fastapi.BackgroundTasks.tasks "Permanent link")
    
    
    tasks = list(tasks) if tasks else []
    

###  `` add_task [¶](#fastapi.BackgroundTasks.add_task "Permanent link")
    
    
    add_task(func, *args, **kwargs)
    

Add a function to be called in the background after the response is sent.

Read more about it in the [FastAPI docs for Background Tasks](https://fastapi.tiangolo.com/tutorial/background-tasks/).

PARAMETER | DESCRIPTION  
---|---  
`func` |  The function to call after the response is sent. It can be a regular `def` function or an `async def` function. **TYPE:** `Callable[P, Any]`  
Source code in `fastapi/background.py`
    
    
    39
    40
    41
    42
    43
    44
    45
    46
    47
    48
    49
    50
    51
    52
    53
    54
    55
    56
    57
    58
    59
    60

| 
    
    
    def add_task(
        self,
        func: Annotated[
            Callable[P, Any],
            Doc(
                """
                The function to call after the response is sent.
    
                It can be a regular `def` function or an `async def` function.
                """
            ),
        ],
        *args: P.args,
        **kwargs: P.kwargs,
    ) -> None:
        """
        Add a function to be called in the background after the response is sent.
    
        Read more about it in the
        [FastAPI docs for Background Tasks](https://fastapi.tiangolo.com/tutorial/background-tasks/).
        """
        return super().add_task(func, *args, **kwargs)
      
  
---|---

---

###### Requestclass¶

# `Request` class[¶](#request-class "Permanent link")

You can declare a parameter in a _path operation function_ or dependency to be of type `Request` and then you can access the raw request object directly, without any validation, etc.

Read more about it in the [FastAPI docs about using Request directly](https://fastapi.tiangolo.com/advanced/using-request-directly/)

You can import it directly from `fastapi`:
    
    
    from fastapi import Request
    

Tip

When you want to define dependencies that should be compatible with both HTTP and WebSockets, you can define a parameter that takes an `HTTPConnection` instead of a `Request` or a `WebSocket`.

##  `` fastapi.Request [¶](#fastapi.Request "Permanent link")
    
    
    Request(scope, receive=empty_receive, send=empty_send)
    

Bases: `[HTTPConnection](../httpconnection/#fastapi.requests.HTTPConnection "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">fastapi.requests.HTTPConnection</span> \(<code>starlette.requests.HTTPConnection</code>\)")`

Source code in `starlette/requests.py`
    
    
    203
    204
    205
    206
    207
    208
    209
    210

| 
    
    
    def __init__(self, scope: Scope, receive: Receive = empty_receive, send: Send = empty_send):
        super().__init__(scope)
        assert scope["type"] == "http"
        self._receive = receive
        self._send = send
        self._stream_consumed = False
        self._is_disconnected = False
        self._form = None
      
  
---|---  
  
###  `` scope `instance-attribute` [¶](#fastapi.Request.scope "Permanent link")
    
    
    scope = scope
    

###  `` app `property` [¶](#fastapi.Request.app "Permanent link")
    
    
    app
    

###  `` url `property` [¶](#fastapi.Request.url "Permanent link")
    
    
    url
    

###  `` base_url `property` [¶](#fastapi.Request.base_url "Permanent link")
    
    
    base_url
    

###  `` headers `property` [¶](#fastapi.Request.headers "Permanent link")
    
    
    headers
    

###  `` query_params `property` [¶](#fastapi.Request.query_params "Permanent link")
    
    
    query_params
    

###  `` path_params `property` [¶](#fastapi.Request.path_params "Permanent link")
    
    
    path_params
    

###  `` cookies `property` [¶](#fastapi.Request.cookies "Permanent link")
    
    
    cookies
    

###  `` client `property` [¶](#fastapi.Request.client "Permanent link")
    
    
    client
    

###  `` session `property` [¶](#fastapi.Request.session "Permanent link")
    
    
    session
    

###  `` auth `property` [¶](#fastapi.Request.auth "Permanent link")
    
    
    auth
    

###  `` user `property` [¶](#fastapi.Request.user "Permanent link")
    
    
    user
    

###  `` state `property` [¶](#fastapi.Request.state "Permanent link")
    
    
    state
    

###  `` method `property` [¶](#fastapi.Request.method "Permanent link")
    
    
    method
    

###  `` receive `property` [¶](#fastapi.Request.receive "Permanent link")
    
    
    receive
    

###  `` url_for [¶](#fastapi.Request.url_for "Permanent link")
    
    
    url_for(name, /, **path_params)
    

Source code in `starlette/requests.py`
    
    
    184
    185
    186
    187
    188
    189

| 
    
    
    def url_for(self, name: str, /, **path_params: Any) -> URL:
        url_path_provider: Router | Starlette | None = self.scope.get("router") or self.scope.get("app")
        if url_path_provider is None:
            raise RuntimeError("The `url_for` method can only be used inside a Starlette application or with a router.")
        url_path = url_path_provider.url_path_for(name, **path_params)
        return url_path.make_absolute_url(base_url=self.base_url)
      
  
---|---  
  
###  `` stream `async` [¶](#fastapi.Request.stream "Permanent link")
    
    
    stream()
    

Source code in `starlette/requests.py`
    
    
    220
    221
    222
    223
    224
    225
    226
    227
    228
    229
    230
    231
    232
    233
    234
    235
    236
    237
    238

| 
    
    
    async def stream(self) -> AsyncGenerator[bytes, None]:
        if hasattr(self, "_body"):
            yield self._body
            yield b""
            return
        if self._stream_consumed:
            raise RuntimeError("Stream consumed")
        while not self._stream_consumed:
            message = await self._receive()
            if message["type"] == "http.request":
                body = message.get("body", b"")
                if not message.get("more_body", False):
                    self._stream_consumed = True
                if body:
                    yield body
            elif message["type"] == "http.disconnect":  # pragma: no branch
                self._is_disconnected = True
                raise ClientDisconnect()
        yield b""
      
  
---|---  
  
###  `` body `async` [¶](#fastapi.Request.body "Permanent link")
    
    
    body()
    

Source code in `starlette/requests.py`
    
    
    240
    241
    242
    243
    244
    245
    246

| 
    
    
    async def body(self) -> bytes:
        if not hasattr(self, "_body"):
            chunks: list[bytes] = []
            async for chunk in self.stream():
                chunks.append(chunk)
            self._body = b"".join(chunks)
        return self._body
      
  
---|---  
  
###  `` json `async` [¶](#fastapi.Request.json "Permanent link")
    
    
    json()
    

Source code in `starlette/requests.py`
    
    
    248
    249
    250
    251
    252

| 
    
    
    async def json(self) -> Any:
        if not hasattr(self, "_json"):  # pragma: no branch
            body = await self.body()
            self._json = json.loads(body)
        return self._json
      
  
---|---  
  
###  `` form [¶](#fastapi.Request.form "Permanent link")
    
    
    form(
        *,
        max_files=1000,
        max_fields=1000,
        max_part_size=1024 * 1024
    )
    

Source code in `starlette/requests.py`
    
    
    289
    290
    291
    292
    293
    294
    295
    296
    297
    298

| 
    
    
    def form(
        self,
        *,
        max_files: int | float = 1000,
        max_fields: int | float = 1000,
        max_part_size: int = 1024 * 1024,
    ) -> AwaitableOrContextManager[FormData]:
        return AwaitableOrContextManagerWrapper(
            self._get_form(max_files=max_files, max_fields=max_fields, max_part_size=max_part_size)
        )
      
  
---|---  
  
###  `` close `async` [¶](#fastapi.Request.close "Permanent link")
    
    
    close()
    

Source code in `starlette/requests.py`
    
    
    300
    301
    302

| 
    
    
    async def close(self) -> None:
        if self._form is not None:  # pragma: no branch
            await self._form.close()
      
  
---|---  
  
###  `` is_disconnected `async` [¶](#fastapi.Request.is_disconnected "Permanent link")
    
    
    is_disconnected()
    

Source code in `starlette/requests.py`
    
    
    304
    305
    306
    307
    308
    309
    310
    311
    312
    313
    314
    315
    316

| 
    
    
    async def is_disconnected(self) -> bool:
        if not self._is_disconnected:
            message: Message = {}
    
            # If message isn't immediately available, move on
            with anyio.CancelScope() as cs:
                cs.cancel()
                message = await self._receive()
    
            if message.get("type") == "http.disconnect":
                self._is_disconnected = True
    
        return self._is_disconnected
      
  
---|---  
  
###  `` send_push_promise `async` [¶](#fastapi.Request.send_push_promise "Permanent link")
    
    
    send_push_promise(path)
    

Source code in `starlette/requests.py`
    
    
    318
    319
    320
    321
    322
    323
    324

| 
    
    
    async def send_push_promise(self, path: str) -> None:
        if "http.response.push" in self.scope.get("extensions", {}):
            raw_headers: list[tuple[bytes, bytes]] = []
            for name in SERVER_PUSH_HEADERS_TO_COPY:
                for value in self.headers.getlist(name):
                    raw_headers.append((name.encode("latin-1"), value.encode("latin-1")))
            await self._send({"type": "http.response.push", "path": path, "headers": raw_headers})
      
  
---|---

---

###### WebSockets¶

# WebSockets[¶](#websockets "Permanent link")

When defining WebSockets, you normally declare a parameter of type `WebSocket` and with it you can read data from the client and send data to it.

Read more about it in the [FastAPI docs for WebSockets](https://fastapi.tiangolo.com/advanced/websockets/)

It is provided directly by Starlette, but you can import it from `fastapi`:
    
    
    from fastapi import WebSocket
    

Tip

When you want to define dependencies that should be compatible with both HTTP and WebSockets, you can define a parameter that takes an `HTTPConnection` instead of a `Request` or a `WebSocket`.

##  `` fastapi.WebSocket [¶](#fastapi.WebSocket "Permanent link")
    
    
    WebSocket(scope, receive, send)
    

Bases: `[HTTPConnection](../httpconnection/#fastapi.requests.HTTPConnection "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">fastapi.requests.HTTPConnection</span> \(<code>starlette.requests.HTTPConnection</code>\)")`

Source code in `starlette/websockets.py`
    
    
    27
    28
    29
    30
    31
    32
    33

| 
    
    
    def __init__(self, scope: Scope, receive: Receive, send: Send) -> None:
        super().__init__(scope)
        assert scope["type"] == "websocket"
        self._receive = receive
        self._send = send
        self.client_state = WebSocketState.CONNECTING
        self.application_state = WebSocketState.CONNECTING
      
  
---|---  
  
###  `` scope `instance-attribute` [¶](#fastapi.WebSocket.scope "Permanent link")
    
    
    scope = scope
    

###  `` app `property` [¶](#fastapi.WebSocket.app "Permanent link")
    
    
    app
    

###  `` url `property` [¶](#fastapi.WebSocket.url "Permanent link")
    
    
    url
    

###  `` base_url `property` [¶](#fastapi.WebSocket.base_url "Permanent link")
    
    
    base_url
    

###  `` headers `property` [¶](#fastapi.WebSocket.headers "Permanent link")
    
    
    headers
    

###  `` query_params `property` [¶](#fastapi.WebSocket.query_params "Permanent link")
    
    
    query_params
    

###  `` path_params `property` [¶](#fastapi.WebSocket.path_params "Permanent link")
    
    
    path_params
    

###  `` cookies `property` [¶](#fastapi.WebSocket.cookies "Permanent link")
    
    
    cookies
    

###  `` client `property` [¶](#fastapi.WebSocket.client "Permanent link")
    
    
    client
    

###  `` state `property` [¶](#fastapi.WebSocket.state "Permanent link")
    
    
    state
    

###  `` client_state `instance-attribute` [¶](#fastapi.WebSocket.client_state "Permanent link")
    
    
    client_state = [CONNECTING](#fastapi.websockets.WebSocketState.CONNECTING "<code class="doc-symbol doc-symbol-heading doc-symbol-attribute"></code>            <span class="doc doc-object-name doc-attribute-name">CONNECTING</span>
    
    
      <span class="doc doc-labels">
          <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
          <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
      </span> \(<code>starlette.websockets.WebSocketState.CONNECTING</code>\)")
    

###  `` application_state `instance-attribute` [¶](#fastapi.WebSocket.application_state "Permanent link")
    
    
    application_state = [CONNECTING](#fastapi.websockets.WebSocketState.CONNECTING "<code class="doc-symbol doc-symbol-heading doc-symbol-attribute"></code>            <span class="doc doc-object-name doc-attribute-name">CONNECTING</span>
    
    
      <span class="doc doc-labels">
          <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
          <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
      </span> \(<code>starlette.websockets.WebSocketState.CONNECTING</code>\)")
    

###  `` url_for [¶](#fastapi.WebSocket.url_for "Permanent link")
    
    
    url_for(name, /, **path_params)
    

Source code in `starlette/requests.py`
    
    
    184
    185
    186
    187
    188
    189

| 
    
    
    def url_for(self, name: str, /, **path_params: Any) -> URL:
        url_path_provider: Router | Starlette | None = self.scope.get("router") or self.scope.get("app")
        if url_path_provider is None:
            raise RuntimeError("The `url_for` method can only be used inside a Starlette application or with a router.")
        url_path = url_path_provider.url_path_for(name, **path_params)
        return url_path.make_absolute_url(base_url=self.base_url)
      
  
---|---  
  
###  `` receive `async` [¶](#fastapi.WebSocket.receive "Permanent link")
    
    
    receive()
    

Receive ASGI websocket messages, ensuring valid state transitions.

Source code in `starlette/websockets.py`
    
    
    35
    36
    37
    38
    39
    40
    41
    42
    43
    44
    45
    46
    47
    48
    49
    50
    51
    52
    53
    54
    55
    56
    57

| 
    
    
    async def receive(self) -> Message:
        """
        Receive ASGI websocket messages, ensuring valid state transitions.
        """
        if self.client_state == WebSocketState.CONNECTING:
            message = await self._receive()
            message_type = message["type"]
            if message_type != "websocket.connect":
                raise RuntimeError(f'Expected ASGI message "websocket.connect", but got {message_type!r}')
            self.client_state = WebSocketState.CONNECTED
            return message
        elif self.client_state == WebSocketState.CONNECTED:
            message = await self._receive()
            message_type = message["type"]
            if message_type not in {"websocket.receive", "websocket.disconnect"}:
                raise RuntimeError(
                    f'Expected ASGI message "websocket.receive" or "websocket.disconnect", but got {message_type!r}'
                )
            if message_type == "websocket.disconnect":
                self.client_state = WebSocketState.DISCONNECTED
            return message
        else:
            raise RuntimeError('Cannot call "receive" once a disconnect message has been received.')
      
  
---|---  
  
###  `` send `async` [¶](#fastapi.WebSocket.send "Permanent link")
    
    
    send(message)
    

Send ASGI websocket messages, ensuring valid state transitions.

Source code in `starlette/websockets.py`
    
    
    59
    60
    61
    62
    63
    64
    65
    66
    67
    68
    69
    70
    71
    72
    73
    74
    75
    76
    77
    78
    79
    80
    81
    82
    83
    84
    85
    86
    87
    88
    89
    90
    91
    92
    93
    94
    95
    96
    97
    98

| 
    
    
    async def send(self, message: Message) -> None:
        """
        Send ASGI websocket messages, ensuring valid state transitions.
        """
        if self.application_state == WebSocketState.CONNECTING:
            message_type = message["type"]
            if message_type not in {"websocket.accept", "websocket.close", "websocket.http.response.start"}:
                raise RuntimeError(
                    'Expected ASGI message "websocket.accept", "websocket.close" or "websocket.http.response.start", '
                    f"but got {message_type!r}"
                )
            if message_type == "websocket.close":
                self.application_state = WebSocketState.DISCONNECTED
            elif message_type == "websocket.http.response.start":
                self.application_state = WebSocketState.RESPONSE
            else:
                self.application_state = WebSocketState.CONNECTED
            await self._send(message)
        elif self.application_state == WebSocketState.CONNECTED:
            message_type = message["type"]
            if message_type not in {"websocket.send", "websocket.close"}:
                raise RuntimeError(
                    f'Expected ASGI message "websocket.send" or "websocket.close", but got {message_type!r}'
                )
            if message_type == "websocket.close":
                self.application_state = WebSocketState.DISCONNECTED
            try:
                await self._send(message)
            except OSError:
                self.application_state = WebSocketState.DISCONNECTED
                raise WebSocketDisconnect(code=1006)
        elif self.application_state == WebSocketState.RESPONSE:
            message_type = message["type"]
            if message_type != "websocket.http.response.body":
                raise RuntimeError(f'Expected ASGI message "websocket.http.response.body", but got {message_type!r}')
            if not message.get("more_body", False):
                self.application_state = WebSocketState.DISCONNECTED
            await self._send(message)
        else:
            raise RuntimeError('Cannot call "send" once a close message has been sent.')
      
  
---|---  
  
###  `` accept `async` [¶](#fastapi.WebSocket.accept "Permanent link")
    
    
    accept(subprotocol=None, headers=None)
    

Source code in `starlette/websockets.py`
    
    
    100
    101
    102
    103
    104
    105
    106
    107
    108
    109
    110

| 
    
    
    async def accept(
        self,
        subprotocol: str | None = None,
        headers: Iterable[tuple[bytes, bytes]] | None = None,
    ) -> None:
        headers = headers or []
    
        if self.client_state == WebSocketState.CONNECTING:  # pragma: no branch
            # If we haven't yet seen the 'connect' message, then wait for it first.
            await self.receive()
        await self.send({"type": "websocket.accept", "subprotocol": subprotocol, "headers": headers})
      
  
---|---  
  
###  `` receive_text `async` [¶](#fastapi.WebSocket.receive_text "Permanent link")
    
    
    receive_text()
    

Source code in `starlette/websockets.py`
    
    
    116
    117
    118
    119
    120
    121

| 
    
    
    async def receive_text(self) -> str:
        if self.application_state != WebSocketState.CONNECTED:
            raise RuntimeError('WebSocket is not connected. Need to call "accept" first.')
        message = await self.receive()
        self._raise_on_disconnect(message)
        return cast(str, message["text"])
      
  
---|---  
  
###  `` receive_bytes `async` [¶](#fastapi.WebSocket.receive_bytes "Permanent link")
    
    
    receive_bytes()
    

Source code in `starlette/websockets.py`
    
    
    123
    124
    125
    126
    127
    128

| 
    
    
    async def receive_bytes(self) -> bytes:
        if self.application_state != WebSocketState.CONNECTED:
            raise RuntimeError('WebSocket is not connected. Need to call "accept" first.')
        message = await self.receive()
        self._raise_on_disconnect(message)
        return cast(bytes, message["bytes"])
      
  
---|---  
  
###  `` receive_json `async` [¶](#fastapi.WebSocket.receive_json "Permanent link")
    
    
    receive_json(mode='text')
    

Source code in `starlette/websockets.py`
    
    
    130
    131
    132
    133
    134
    135
    136
    137
    138
    139
    140
    141
    142

| 
    
    
    async def receive_json(self, mode: str = "text") -> Any:
        if mode not in {"text", "binary"}:
            raise RuntimeError('The "mode" argument should be "text" or "binary".')
        if self.application_state != WebSocketState.CONNECTED:
            raise RuntimeError('WebSocket is not connected. Need to call "accept" first.')
        message = await self.receive()
        self._raise_on_disconnect(message)
    
        if mode == "text":
            text = message["text"]
        else:
            text = message["bytes"].decode("utf-8")
        return json.loads(text)
      
  
---|---  
  
###  `` iter_text `async` [¶](#fastapi.WebSocket.iter_text "Permanent link")
    
    
    iter_text()
    

Source code in `starlette/websockets.py`
    
    
    144
    145
    146
    147
    148
    149

| 
    
    
    async def iter_text(self) -> AsyncIterator[str]:
        try:
            while True:
                yield await self.receive_text()
        except WebSocketDisconnect:
            pass
      
  
---|---  
  
###  `` iter_bytes `async` [¶](#fastapi.WebSocket.iter_bytes "Permanent link")
    
    
    iter_bytes()
    

Source code in `starlette/websockets.py`
    
    
    151
    152
    153
    154
    155
    156

| 
    
    
    async def iter_bytes(self) -> AsyncIterator[bytes]:
        try:
            while True:
                yield await self.receive_bytes()
        except WebSocketDisconnect:
            pass
      
  
---|---  
  
###  `` iter_json `async` [¶](#fastapi.WebSocket.iter_json "Permanent link")
    
    
    iter_json()
    

Source code in `starlette/websockets.py`
    
    
    158
    159
    160
    161
    162
    163

| 
    
    
    async def iter_json(self) -> AsyncIterator[Any]:
        try:
            while True:
                yield await self.receive_json()
        except WebSocketDisconnect:
            pass
      
  
---|---  
  
###  `` send_text `async` [¶](#fastapi.WebSocket.send_text "Permanent link")
    
    
    send_text(data)
    

Source code in `starlette/websockets.py`
    
    
    165
    166

| 
    
    
    async def send_text(self, data: str) -> None:
        await self.send({"type": "websocket.send", "text": data})
      
  
---|---  
  
###  `` send_bytes `async` [¶](#fastapi.WebSocket.send_bytes "Permanent link")
    
    
    send_bytes(data)
    

Source code in `starlette/websockets.py`
    
    
    168
    169

| 
    
    
    async def send_bytes(self, data: bytes) -> None:
        await self.send({"type": "websocket.send", "bytes": data})
      
  
---|---  
  
###  `` send_json `async` [¶](#fastapi.WebSocket.send_json "Permanent link")
    
    
    send_json(data, mode='text')
    

Source code in `starlette/websockets.py`
    
    
    171
    172
    173
    174
    175
    176
    177
    178

| 
    
    
    async def send_json(self, data: Any, mode: str = "text") -> None:
        if mode not in {"text", "binary"}:
            raise RuntimeError('The "mode" argument should be "text" or "binary".')
        text = json.dumps(data, separators=(",", ":"), ensure_ascii=False)
        if mode == "text":
            await self.send({"type": "websocket.send", "text": text})
        else:
            await self.send({"type": "websocket.send", "bytes": text.encode("utf-8")})
      
  
---|---  
  
###  `` close `async` [¶](#fastapi.WebSocket.close "Permanent link")
    
    
    close(code=1000, reason=None)
    

Source code in `starlette/websockets.py`
    
    
    180
    181

| 
    
    
    async def close(self, code: int = 1000, reason: str | None = None) -> None:
        await self.send({"type": "websocket.close", "code": code, "reason": reason or ""})
      
  
---|---  
  
## WebSockets - additional classes[¶](#websockets-additional-classes "Permanent link")

Additional classes for handling WebSockets.

Provided directly by Starlette, but you can import it from `fastapi`:
    
    
    from fastapi.websockets import WebSocketDisconnect, WebSocketState
    

##  `` fastapi.websockets.WebSocketDisconnect [¶](#fastapi.websockets.WebSocketDisconnect "Permanent link")
    
    
    WebSocketDisconnect(code=1000, reason=None)
    

Bases: `Exception`

Source code in `starlette/websockets.py`
    
    
    21
    22
    23

| 
    
    
    def __init__(self, code: int = 1000, reason: str | None = None) -> None:
        self.code = code
        self.reason = reason or ""
      
  
---|---  
  
###  `` code `instance-attribute` [¶](#fastapi.websockets.WebSocketDisconnect.code "Permanent link")
    
    
    code = code
    

###  `` reason `instance-attribute` [¶](#fastapi.websockets.WebSocketDisconnect.reason "Permanent link")
    
    
    reason = reason or ''
    

When a client disconnects, a `WebSocketDisconnect` exception is raised, you can catch it.

You can import it directly form `fastapi`:
    
    
    from fastapi import WebSocketDisconnect
    

Read more about it in the [FastAPI docs for WebSockets](https://fastapi.tiangolo.com/advanced/websockets/#handling-disconnections-and-multiple-clients)

##  `` fastapi.websockets.WebSocketState [¶](#fastapi.websockets.WebSocketState "Permanent link")

Bases: `Enum`

###  `` CONNECTING `class-attribute` `instance-attribute` [¶](#fastapi.websockets.WebSocketState.CONNECTING "Permanent link")
    
    
    CONNECTING = 0
    

###  `` CONNECTED `class-attribute` `instance-attribute` [¶](#fastapi.websockets.WebSocketState.CONNECTED "Permanent link")
    
    
    CONNECTED = 1
    

###  `` DISCONNECTED `class-attribute` `instance-attribute` [¶](#fastapi.websockets.WebSocketState.DISCONNECTED "Permanent link")
    
    
    DISCONNECTED = 2
    

###  `` RESPONSE `class-attribute` `instance-attribute` [¶](#fastapi.websockets.WebSocketState.RESPONSE "Permanent link")
    
    
    RESPONSE = 3
    

`WebSocketState` is an enumeration of the possible states of a WebSocket connection.

---

###### HTTPConnectionclass¶

# `HTTPConnection` class[¶](#httpconnection-class "Permanent link")

When you want to define dependencies that should be compatible with both HTTP and WebSockets, you can define a parameter that takes an `HTTPConnection` instead of a `Request` or a `WebSocket`.

You can import it from `fastapi.requests`:
    
    
    from fastapi.requests import HTTPConnection
    

##  `` fastapi.requests.HTTPConnection [¶](#fastapi.requests.HTTPConnection "Permanent link")
    
    
    HTTPConnection(scope, receive=None)
    

Bases: `Mapping[str, Any]`

A base class for incoming HTTP connections, that is used to provide any functionality that is common to both `Request` and `WebSocket`.

Source code in `starlette/requests.py`
    
    
    77
    78
    79

| 
    
    
    def __init__(self, scope: Scope, receive: Receive | None = None) -> None:
        assert scope["type"] in ("http", "websocket")
        self.scope = scope
      
  
---|---  
  
###  `` scope `instance-attribute` [¶](#fastapi.requests.HTTPConnection.scope "Permanent link")
    
    
    scope = scope
    

###  `` app `property` [¶](#fastapi.requests.HTTPConnection.app "Permanent link")
    
    
    app
    

###  `` url `property` [¶](#fastapi.requests.HTTPConnection.url "Permanent link")
    
    
    url
    

###  `` base_url `property` [¶](#fastapi.requests.HTTPConnection.base_url "Permanent link")
    
    
    base_url
    

###  `` headers `property` [¶](#fastapi.requests.HTTPConnection.headers "Permanent link")
    
    
    headers
    

###  `` query_params `property` [¶](#fastapi.requests.HTTPConnection.query_params "Permanent link")
    
    
    query_params
    

###  `` path_params `property` [¶](#fastapi.requests.HTTPConnection.path_params "Permanent link")
    
    
    path_params
    

###  `` cookies `property` [¶](#fastapi.requests.HTTPConnection.cookies "Permanent link")
    
    
    cookies
    

###  `` client `property` [¶](#fastapi.requests.HTTPConnection.client "Permanent link")
    
    
    client
    

###  `` session `property` [¶](#fastapi.requests.HTTPConnection.session "Permanent link")
    
    
    session
    

###  `` auth `property` [¶](#fastapi.requests.HTTPConnection.auth "Permanent link")
    
    
    auth
    

###  `` user `property` [¶](#fastapi.requests.HTTPConnection.user "Permanent link")
    
    
    user
    

###  `` state `property` [¶](#fastapi.requests.HTTPConnection.state "Permanent link")
    
    
    state
    

###  `` url_for [¶](#fastapi.requests.HTTPConnection.url_for "Permanent link")
    
    
    url_for(name, /, **path_params)
    

Source code in `starlette/requests.py`
    
    
    184
    185
    186
    187
    188
    189

| 
    
    
    def url_for(self, name: str, /, **path_params: Any) -> URL:
        url_path_provider: Router | Starlette | None = self.scope.get("router") or self.scope.get("app")
        if url_path_provider is None:
            raise RuntimeError("The `url_for` method can only be used inside a Starlette application or with a router.")
        url_path = url_path_provider.url_path_for(name, **path_params)
        return url_path.make_absolute_url(base_url=self.base_url)
      
  
---|---

---

###### Responseclass¶

# `Response` class[¶](#response-class "Permanent link")

You can declare a parameter in a _path operation function_ or dependency to be of type `Response` and then you can set data for the response like headers or cookies.

You can also use it directly to create an instance of it and return it from your _path operations_.

Read more about it in the [FastAPI docs about returning a custom Response](https://fastapi.tiangolo.com/advanced/response-directly/#returning-a-custom-response)

You can import it directly from `fastapi`:
    
    
    from fastapi import Response
    

##  `` fastapi.Response [¶](#fastapi.Response "Permanent link")
    
    
    Response(
        content=None,
        status_code=200,
        headers=None,
        media_type=None,
        background=None,
    )
    

Source code in `starlette/responses.py`
    
    
    34
    35
    36
    37
    38
    39
    40
    41
    42
    43
    44
    45
    46
    47

| 
    
    
    def __init__(
        self,
        content: Any = None,
        status_code: int = 200,
        headers: Mapping[str, str] | None = None,
        media_type: str | None = None,
        background: BackgroundTask | None = None,
    ) -> None:
        self.status_code = status_code
        if media_type is not None:
            self.media_type = media_type
        self.background = background
        self.body = self.render(content)
        self.init_headers(headers)
      
  
---|---  
  
###  `` media_type `class-attribute` `instance-attribute` [¶](#fastapi.Response.media_type "Permanent link")
    
    
    media_type = None
    

###  `` charset `class-attribute` `instance-attribute` [¶](#fastapi.Response.charset "Permanent link")
    
    
    charset = 'utf-8'
    

###  `` status_code `instance-attribute` [¶](#fastapi.Response.status_code "Permanent link")
    
    
    status_code = status_code
    

###  `` background `instance-attribute` [¶](#fastapi.Response.background "Permanent link")
    
    
    background = background
    

###  `` body `instance-attribute` [¶](#fastapi.Response.body "Permanent link")
    
    
    body = render(content)
    

###  `` headers `property` [¶](#fastapi.Response.headers "Permanent link")
    
    
    headers
    

###  `` render [¶](#fastapi.Response.render "Permanent link")
    
    
    render(content)
    

Source code in `starlette/responses.py`
    
    
    49
    50
    51
    52
    53
    54

| 
    
    
    def render(self, content: Any) -> bytes | memoryview:
        if content is None:
            return b""
        if isinstance(content, bytes | memoryview):
            return content
        return content.encode(self.charset)  # type: ignore
      
  
---|---  
  
###  `` init_headers [¶](#fastapi.Response.init_headers "Permanent link")
    
    
    init_headers(headers=None)
    

Source code in `starlette/responses.py`
    
    
    56
    57
    58
    59
    60
    61
    62
    63
    64
    65
    66
    67
    68
    69
    70
    71
    72
    73
    74
    75
    76
    77
    78
    79
    80
    81
    82

| 
    
    
    def init_headers(self, headers: Mapping[str, str] | None = None) -> None:
        if headers is None:
            raw_headers: list[tuple[bytes, bytes]] = []
            populate_content_length = True
            populate_content_type = True
        else:
            raw_headers = [(k.lower().encode("latin-1"), v.encode("latin-1")) for k, v in headers.items()]
            keys = [h[0] for h in raw_headers]
            populate_content_length = b"content-length" not in keys
            populate_content_type = b"content-type" not in keys
    
        body = getattr(self, "body", None)
        if (
            body is not None
            and populate_content_length
            and not (self.status_code < 200 or self.status_code in (204, 304))
        ):
            content_length = str(len(body))
            raw_headers.append((b"content-length", content_length.encode("latin-1")))
    
        content_type = self.media_type
        if content_type is not None and populate_content_type:
            if content_type.startswith("text/") and "charset=" not in content_type.lower():
                content_type += "; charset=" + self.charset
            raw_headers.append((b"content-type", content_type.encode("latin-1")))
    
        self.raw_headers = raw_headers
      
  
---|---  
  
###  `` set_cookie [¶](#fastapi.Response.set_cookie "Permanent link")
    
    
    set_cookie(
        key,
        value="",
        max_age=None,
        expires=None,
        path="/",
        domain=None,
        secure=False,
        httponly=False,
        samesite="lax",
        partitioned=False,
    )
    

Source code in `starlette/responses.py`
    
    
     90
     91
     92
     93
     94
     95
     96
     97
     98
     99
    100
    101
    102
    103
    104
    105
    106
    107
    108
    109
    110
    111
    112
    113
    114
    115
    116
    117
    118
    119
    120
    121
    122
    123
    124
    125
    126
    127
    128
    129
    130
    131
    132
    133

| 
    
    
    def set_cookie(
        self,
        key: str,
        value: str = "",
        max_age: int | None = None,
        expires: datetime | str | int | None = None,
        path: str | None = "/",
        domain: str | None = None,
        secure: bool = False,
        httponly: bool = False,
        samesite: Literal["lax", "strict", "none"] | None = "lax",
        partitioned: bool = False,
    ) -> None:
        cookie: http.cookies.BaseCookie[str] = http.cookies.SimpleCookie()
        cookie[key] = value
        if max_age is not None:
            cookie[key]["max-age"] = max_age
        if expires is not None:
            if isinstance(expires, datetime):
                cookie[key]["expires"] = format_datetime(expires, usegmt=True)
            else:
                cookie[key]["expires"] = expires
        if path is not None:
            cookie[key]["path"] = path
        if domain is not None:
            cookie[key]["domain"] = domain
        if secure:
            cookie[key]["secure"] = True
        if httponly:
            cookie[key]["httponly"] = True
        if samesite is not None:
            assert samesite.lower() in [
                "strict",
                "lax",
                "none",
            ], "samesite must be either 'strict', 'lax' or 'none'"
            cookie[key]["samesite"] = samesite
        if partitioned:
            if sys.version_info < (3, 14):
                raise ValueError("Partitioned cookies are only supported in Python 3.14 and above.")  # pragma: no cover
            cookie[key]["partitioned"] = True  # pragma: no cover
    
        cookie_val = cookie.output(header="").strip()
        self.raw_headers.append((b"set-cookie", cookie_val.encode("latin-1")))
      
  
---|---  
  
###  `` delete_cookie [¶](#fastapi.Response.delete_cookie "Permanent link")
    
    
    delete_cookie(
        key,
        path="/",
        domain=None,
        secure=False,
        httponly=False,
        samesite="lax",
    )
    

Source code in `starlette/responses.py`
    
    
    135
    136
    137
    138
    139
    140
    141
    142
    143
    144
    145
    146
    147
    148
    149
    150
    151
    152
    153

| 
    
    
    def delete_cookie(
        self,
        key: str,
        path: str = "/",
        domain: str | None = None,
        secure: bool = False,
        httponly: bool = False,
        samesite: Literal["lax", "strict", "none"] | None = "lax",
    ) -> None:
        self.set_cookie(
            key,
            max_age=0,
            expires=0,
            path=path,
            domain=domain,
            secure=secure,
            httponly=httponly,
            samesite=samesite,
        )
      
  
---|---

---

###### Custom Response Classes - File, HTML, Redirect, Streaming, etc.¶

# Custom Response Classes - File, HTML, Redirect, Streaming, etc.[¶](#custom-response-classes-file-html-redirect-streaming-etc "Permanent link")

There are several custom response classes you can use to create an instance and return them directly from your _path operations_.

Read more about it in the [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/).

You can import them directly from `fastapi.responses`:
    
    
    from fastapi.responses import (
        FileResponse,
        HTMLResponse,
        JSONResponse,
        ORJSONResponse,
        PlainTextResponse,
        RedirectResponse,
        Response,
        StreamingResponse,
        UJSONResponse,
    )
    

## FastAPI Responses[¶](#fastapi-responses "Permanent link")

There are a couple of custom FastAPI response classes, you can use them to optimize JSON performance.

##  `` fastapi.responses.UJSONResponse [¶](#fastapi.responses.UJSONResponse "Permanent link")
    
    
    UJSONResponse(
        content,
        status_code=200,
        headers=None,
        media_type=None,
        background=None,
    )
    

Bases: `[JSONResponse](#fastapi.responses.JSONResponse "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">fastapi.responses.JSONResponse</span> \(<code>starlette.responses.JSONResponse</code>\)")`

JSON response using the high-performance ujson library to serialize data to JSON.

Read more about it in the [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/).

Source code in `starlette/responses.py`
    
    
    181
    182
    183
    184
    185
    186
    187
    188
    189

| 
    
    
    def __init__(
        self,
        content: Any,
        status_code: int = 200,
        headers: Mapping[str, str] | None = None,
        media_type: str | None = None,
        background: BackgroundTask | None = None,
    ) -> None:
        super().__init__(content, status_code, headers, media_type, background)
      
  
---|---  
  
###  `` charset `class-attribute` `instance-attribute` [¶](#fastapi.responses.UJSONResponse.charset "Permanent link")
    
    
    charset = 'utf-8'
    

###  `` status_code `instance-attribute` [¶](#fastapi.responses.UJSONResponse.status_code "Permanent link")
    
    
    status_code = status_code
    

###  `` media_type `class-attribute` `instance-attribute` [¶](#fastapi.responses.UJSONResponse.media_type "Permanent link")
    
    
    media_type = 'application/json'
    

###  `` body `instance-attribute` [¶](#fastapi.responses.UJSONResponse.body "Permanent link")
    
    
    body = render(content)
    

###  `` background `instance-attribute` [¶](#fastapi.responses.UJSONResponse.background "Permanent link")
    
    
    background = background
    

###  `` headers `property` [¶](#fastapi.responses.UJSONResponse.headers "Permanent link")
    
    
    headers
    

###  `` render [¶](#fastapi.responses.UJSONResponse.render "Permanent link")
    
    
    render(content)
    

Source code in `fastapi/responses.py`
    
    
    31
    32
    33

| 
    
    
    def render(self, content: Any) -> bytes:
        assert ujson is not None, "ujson must be installed to use UJSONResponse"
        return ujson.dumps(content, ensure_ascii=False).encode("utf-8")
      
  
---|---  
  
###  `` init_headers [¶](#fastapi.responses.UJSONResponse.init_headers "Permanent link")
    
    
    init_headers(headers=None)
    

Source code in `starlette/responses.py`
    
    
    56
    57
    58
    59
    60
    61
    62
    63
    64
    65
    66
    67
    68
    69
    70
    71
    72
    73
    74
    75
    76
    77
    78
    79
    80
    81
    82

| 
    
    
    def init_headers(self, headers: Mapping[str, str] | None = None) -> None:
        if headers is None:
            raw_headers: list[tuple[bytes, bytes]] = []
            populate_content_length = True
            populate_content_type = True
        else:
            raw_headers = [(k.lower().encode("latin-1"), v.encode("latin-1")) for k, v in headers.items()]
            keys = [h[0] for h in raw_headers]
            populate_content_length = b"content-length" not in keys
            populate_content_type = b"content-type" not in keys
    
        body = getattr(self, "body", None)
        if (
            body is not None
            and populate_content_length
            and not (self.status_code < 200 or self.status_code in (204, 304))
        ):
            content_length = str(len(body))
            raw_headers.append((b"content-length", content_length.encode("latin-1")))
    
        content_type = self.media_type
        if content_type is not None and populate_content_type:
            if content_type.startswith("text/") and "charset=" not in content_type.lower():
                content_type += "; charset=" + self.charset
            raw_headers.append((b"content-type", content_type.encode("latin-1")))
    
        self.raw_headers = raw_headers
      
  
---|---  
  
###  `` set_cookie [¶](#fastapi.responses.UJSONResponse.set_cookie "Permanent link")
    
    
    set_cookie(
        key,
        value="",
        max_age=None,
        expires=None,
        path="/",
        domain=None,
        secure=False,
        httponly=False,
        samesite="lax",
        partitioned=False,
    )
    

Source code in `starlette/responses.py`
    
    
     90
     91
     92
     93
     94
     95
     96
     97
     98
     99
    100
    101
    102
    103
    104
    105
    106
    107
    108
    109
    110
    111
    112
    113
    114
    115
    116
    117
    118
    119
    120
    121
    122
    123
    124
    125
    126
    127
    128
    129
    130
    131
    132
    133

| 
    
    
    def set_cookie(
        self,
        key: str,
        value: str = "",
        max_age: int | None = None,
        expires: datetime | str | int | None = None,
        path: str | None = "/",
        domain: str | None = None,
        secure: bool = False,
        httponly: bool = False,
        samesite: Literal["lax", "strict", "none"] | None = "lax",
        partitioned: bool = False,
    ) -> None:
        cookie: http.cookies.BaseCookie[str] = http.cookies.SimpleCookie()
        cookie[key] = value
        if max_age is not None:
            cookie[key]["max-age"] = max_age
        if expires is not None:
            if isinstance(expires, datetime):
                cookie[key]["expires"] = format_datetime(expires, usegmt=True)
            else:
                cookie[key]["expires"] = expires
        if path is not None:
            cookie[key]["path"] = path
        if domain is not None:
            cookie[key]["domain"] = domain
        if secure:
            cookie[key]["secure"] = True
        if httponly:
            cookie[key]["httponly"] = True
        if samesite is not None:
            assert samesite.lower() in [
                "strict",
                "lax",
                "none",
            ], "samesite must be either 'strict', 'lax' or 'none'"
            cookie[key]["samesite"] = samesite
        if partitioned:
            if sys.version_info < (3, 14):
                raise ValueError("Partitioned cookies are only supported in Python 3.14 and above.")  # pragma: no cover
            cookie[key]["partitioned"] = True  # pragma: no cover
    
        cookie_val = cookie.output(header="").strip()
        self.raw_headers.append((b"set-cookie", cookie_val.encode("latin-1")))
      
  
---|---  
  
###  `` delete_cookie [¶](#fastapi.responses.UJSONResponse.delete_cookie "Permanent link")
    
    
    delete_cookie(
        key,
        path="/",
        domain=None,
        secure=False,
        httponly=False,
        samesite="lax",
    )
    

Source code in `starlette/responses.py`
    
    
    135
    136
    137
    138
    139
    140
    141
    142
    143
    144
    145
    146
    147
    148
    149
    150
    151
    152
    153

| 
    
    
    def delete_cookie(
        self,
        key: str,
        path: str = "/",
        domain: str | None = None,
        secure: bool = False,
        httponly: bool = False,
        samesite: Literal["lax", "strict", "none"] | None = "lax",
    ) -> None:
        self.set_cookie(
            key,
            max_age=0,
            expires=0,
            path=path,
            domain=domain,
            secure=secure,
            httponly=httponly,
            samesite=samesite,
        )
      
  
---|---  
  
##  `` fastapi.responses.ORJSONResponse [¶](#fastapi.responses.ORJSONResponse "Permanent link")
    
    
    ORJSONResponse(
        content,
        status_code=200,
        headers=None,
        media_type=None,
        background=None,
    )
    

Bases: `[JSONResponse](#fastapi.responses.JSONResponse "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">fastapi.responses.JSONResponse</span> \(<code>starlette.responses.JSONResponse</code>\)")`

JSON response using the high-performance orjson library to serialize data to JSON.

Read more about it in the [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/).

Source code in `starlette/responses.py`
    
    
    181
    182
    183
    184
    185
    186
    187
    188
    189

| 
    
    
    def __init__(
        self,
        content: Any,
        status_code: int = 200,
        headers: Mapping[str, str] | None = None,
        media_type: str | None = None,
        background: BackgroundTask | None = None,
    ) -> None:
        super().__init__(content, status_code, headers, media_type, background)
      
  
---|---  
  
###  `` charset `class-attribute` `instance-attribute` [¶](#fastapi.responses.ORJSONResponse.charset "Permanent link")
    
    
    charset = 'utf-8'
    

###  `` status_code `instance-attribute` [¶](#fastapi.responses.ORJSONResponse.status_code "Permanent link")
    
    
    status_code = status_code
    

###  `` media_type `class-attribute` `instance-attribute` [¶](#fastapi.responses.ORJSONResponse.media_type "Permanent link")
    
    
    media_type = 'application/json'
    

###  `` body `instance-attribute` [¶](#fastapi.responses.ORJSONResponse.body "Permanent link")
    
    
    body = render(content)
    

###  `` background `instance-attribute` [¶](#fastapi.responses.ORJSONResponse.background "Permanent link")
    
    
    background = background
    

###  `` headers `property` [¶](#fastapi.responses.ORJSONResponse.headers "Permanent link")
    
    
    headers
    

###  `` render [¶](#fastapi.responses.ORJSONResponse.render "Permanent link")
    
    
    render(content)
    

Source code in `fastapi/responses.py`
    
    
    44
    45
    46
    47
    48

| 
    
    
    def render(self, content: Any) -> bytes:
        assert orjson is not None, "orjson must be installed to use ORJSONResponse"
        return orjson.dumps(
            content, option=orjson.OPT_NON_STR_KEYS | orjson.OPT_SERIALIZE_NUMPY
        )
      
  
---|---  
  
###  `` init_headers [¶](#fastapi.responses.ORJSONResponse.init_headers "Permanent link")
    
    
    init_headers(headers=None)
    

Source code in `starlette/responses.py`
    
    
    56
    57
    58
    59
    60
    61
    62
    63
    64
    65
    66
    67
    68
    69
    70
    71
    72
    73
    74
    75
    76
    77
    78
    79
    80
    81
    82

| 
    
    
    def init_headers(self, headers: Mapping[str, str] | None = None) -> None:
        if headers is None:
            raw_headers: list[tuple[bytes, bytes]] = []
            populate_content_length = True
            populate_content_type = True
        else:
            raw_headers = [(k.lower().encode("latin-1"), v.encode("latin-1")) for k, v in headers.items()]
            keys = [h[0] for h in raw_headers]
            populate_content_length = b"content-length" not in keys
            populate_content_type = b"content-type" not in keys
    
        body = getattr(self, "body", None)
        if (
            body is not None
            and populate_content_length
            and not (self.status_code < 200 or self.status_code in (204, 304))
        ):
            content_length = str(len(body))
            raw_headers.append((b"content-length", content_length.encode("latin-1")))
    
        content_type = self.media_type
        if content_type is not None and populate_content_type:
            if content_type.startswith("text/") and "charset=" not in content_type.lower():
                content_type += "; charset=" + self.charset
            raw_headers.append((b"content-type", content_type.encode("latin-1")))
    
        self.raw_headers = raw_headers
      
  
---|---  
  
###  `` set_cookie [¶](#fastapi.responses.ORJSONResponse.set_cookie "Permanent link")
    
    
    set_cookie(
        key,
        value="",
        max_age=None,
        expires=None,
        path="/",
        domain=None,
        secure=False,
        httponly=False,
        samesite="lax",
        partitioned=False,
    )
    

Source code in `starlette/responses.py`
    
    
     90
     91
     92
     93
     94
     95
     96
     97
     98
     99
    100
    101
    102
    103
    104
    105
    106
    107
    108
    109
    110
    111
    112
    113
    114
    115
    116
    117
    118
    119
    120
    121
    122
    123
    124
    125
    126
    127
    128
    129
    130
    131
    132
    133

| 
    
    
    def set_cookie(
        self,
        key: str,
        value: str = "",
        max_age: int | None = None,
        expires: datetime | str | int | None = None,
        path: str | None = "/",
        domain: str | None = None,
        secure: bool = False,
        httponly: bool = False,
        samesite: Literal["lax", "strict", "none"] | None = "lax",
        partitioned: bool = False,
    ) -> None:
        cookie: http.cookies.BaseCookie[str] = http.cookies.SimpleCookie()
        cookie[key] = value
        if max_age is not None:
            cookie[key]["max-age"] = max_age
        if expires is not None:
            if isinstance(expires, datetime):
                cookie[key]["expires"] = format_datetime(expires, usegmt=True)
            else:
                cookie[key]["expires"] = expires
        if path is not None:
            cookie[key]["path"] = path
        if domain is not None:
            cookie[key]["domain"] = domain
        if secure:
            cookie[key]["secure"] = True
        if httponly:
            cookie[key]["httponly"] = True
        if samesite is not None:
            assert samesite.lower() in [
                "strict",
                "lax",
                "none",
            ], "samesite must be either 'strict', 'lax' or 'none'"
            cookie[key]["samesite"] = samesite
        if partitioned:
            if sys.version_info < (3, 14):
                raise ValueError("Partitioned cookies are only supported in Python 3.14 and above.")  # pragma: no cover
            cookie[key]["partitioned"] = True  # pragma: no cover
    
        cookie_val = cookie.output(header="").strip()
        self.raw_headers.append((b"set-cookie", cookie_val.encode("latin-1")))
      
  
---|---  
  
###  `` delete_cookie [¶](#fastapi.responses.ORJSONResponse.delete_cookie "Permanent link")
    
    
    delete_cookie(
        key,
        path="/",
        domain=None,
        secure=False,
        httponly=False,
        samesite="lax",
    )
    

Source code in `starlette/responses.py`
    
    
    135
    136
    137
    138
    139
    140
    141
    142
    143
    144
    145
    146
    147
    148
    149
    150
    151
    152
    153

| 
    
    
    def delete_cookie(
        self,
        key: str,
        path: str = "/",
        domain: str | None = None,
        secure: bool = False,
        httponly: bool = False,
        samesite: Literal["lax", "strict", "none"] | None = "lax",
    ) -> None:
        self.set_cookie(
            key,
            max_age=0,
            expires=0,
            path=path,
            domain=domain,
            secure=secure,
            httponly=httponly,
            samesite=samesite,
        )
      
  
---|---  
  
## Starlette Responses[¶](#starlette-responses "Permanent link")

You can read more about all of them in the [FastAPI docs for Custom Response](https://fastapi.tiangolo.com/advanced/custom-response/) and in the [Starlette docs about Responses](https://starlette.dev/responses/).

##  `` fastapi.responses.FileResponse [¶](#fastapi.responses.FileResponse "Permanent link")
    
    
    FileResponse(
        path,
        status_code=200,
        headers=None,
        media_type=None,
        background=None,
        filename=None,
        stat_result=None,
        method=None,
        content_disposition_type="attachment",
    )
    

Bases: `[Response](#fastapi.responses.Response "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">fastapi.responses.Response</span> \(<code>starlette.responses.Response</code>\)")`

Source code in `starlette/responses.py`
    
    
    296
    297
    298
    299
    300
    301
    302
    303
    304
    305
    306
    307
    308
    309
    310
    311
    312
    313
    314
    315
    316
    317
    318
    319
    320
    321
    322
    323
    324
    325
    326
    327
    328
    329
    330
    331

| 
    
    
    def __init__(
        self,
        path: str | os.PathLike[str],
        status_code: int = 200,
        headers: Mapping[str, str] | None = None,
        media_type: str | None = None,
        background: BackgroundTask | None = None,
        filename: str | None = None,
        stat_result: os.stat_result | None = None,
        method: str | None = None,
        content_disposition_type: str = "attachment",
    ) -> None:
        self.path = path
        self.status_code = status_code
        self.filename = filename
        if method is not None:
            warnings.warn(
                "The 'method' parameter is not used, and it will be removed.",
                DeprecationWarning,
            )
        if media_type is None:
            media_type = guess_type(filename or path)[0] or "text/plain"
        self.media_type = media_type
        self.background = background
        self.init_headers(headers)
        self.headers.setdefault("accept-ranges", "bytes")
        if self.filename is not None:
            content_disposition_filename = quote(self.filename)
            if content_disposition_filename != self.filename:
                content_disposition = f"{content_disposition_type}; filename*=utf-8''{content_disposition_filename}"
            else:
                content_disposition = f'{content_disposition_type}; filename="{self.filename}"'
            self.headers.setdefault("content-disposition", content_disposition)
        self.stat_result = stat_result
        if stat_result is not None:
            self.set_stat_headers(stat_result)
      
  
---|---  
  
###  `` chunk_size `class-attribute` `instance-attribute` [¶](#fastapi.responses.FileResponse.chunk_size "Permanent link")
    
    
    chunk_size = 64 * 1024
    

###  `` charset `class-attribute` `instance-attribute` [¶](#fastapi.responses.FileResponse.charset "Permanent link")
    
    
    charset = 'utf-8'
    

###  `` status_code `instance-attribute` [¶](#fastapi.responses.FileResponse.status_code "Permanent link")
    
    
    status_code = status_code
    

###  `` media_type `instance-attribute` [¶](#fastapi.responses.FileResponse.media_type "Permanent link")
    
    
    media_type = media_type
    

###  `` body `instance-attribute` [¶](#fastapi.responses.FileResponse.body "Permanent link")
    
    
    body = render(content)
    

###  `` background `instance-attribute` [¶](#fastapi.responses.FileResponse.background "Permanent link")
    
    
    background = background
    

###  `` headers `property` [¶](#fastapi.responses.FileResponse.headers "Permanent link")
    
    
    headers
    

###  `` render [¶](#fastapi.responses.FileResponse.render "Permanent link")
    
    
    render(content)
    

Source code in `starlette/responses.py`
    
    
    49
    50
    51
    52
    53
    54

| 
    
    
    def render(self, content: Any) -> bytes | memoryview:
        if content is None:
            return b""
        if isinstance(content, bytes | memoryview):
            return content
        return content.encode(self.charset)  # type: ignore
      
  
---|---  
  
###  `` init_headers [¶](#fastapi.responses.FileResponse.init_headers "Permanent link")
    
    
    init_headers(headers=None)
    

Source code in `starlette/responses.py`
    
    
    56
    57
    58
    59
    60
    61
    62
    63
    64
    65
    66
    67
    68
    69
    70
    71
    72
    73
    74
    75
    76
    77
    78
    79
    80
    81
    82

| 
    
    
    def init_headers(self, headers: Mapping[str, str] | None = None) -> None:
        if headers is None:
            raw_headers: list[tuple[bytes, bytes]] = []
            populate_content_length = True
            populate_content_type = True
        else:
            raw_headers = [(k.lower().encode("latin-1"), v.encode("latin-1")) for k, v in headers.items()]
            keys = [h[0] for h in raw_headers]
            populate_content_length = b"content-length" not in keys
            populate_content_type = b"content-type" not in keys
    
        body = getattr(self, "body", None)
        if (
            body is not None
            and populate_content_length
            and not (self.status_code < 200 or self.status_code in (204, 304))
        ):
            content_length = str(len(body))
            raw_headers.append((b"content-length", content_length.encode("latin-1")))
    
        content_type = self.media_type
        if content_type is not None and populate_content_type:
            if content_type.startswith("text/") and "charset=" not in content_type.lower():
                content_type += "; charset=" + self.charset
            raw_headers.append((b"content-type", content_type.encode("latin-1")))
    
        self.raw_headers = raw_headers
      
  
---|---  
  
###  `` set_cookie [¶](#fastapi.responses.FileResponse.set_cookie "Permanent link")
    
    
    set_cookie(
        key,
        value="",
        max_age=None,
        expires=None,
        path="/",
        domain=None,
        secure=False,
        httponly=False,
        samesite="lax",
        partitioned=False,
    )
    

Source code in `starlette/responses.py`
    
    
     90
     91
     92
     93
     94
     95
     96
     97
     98
     99
    100
    101
    102
    103
    104
    105
    106
    107
    108
    109
    110
    111
    112
    113
    114
    115
    116
    117
    118
    119
    120
    121
    122
    123
    124
    125
    126
    127
    128
    129
    130
    131
    132
    133

| 
    
    
    def set_cookie(
        self,
        key: str,
        value: str = "",
        max_age: int | None = None,
        expires: datetime | str | int | None = None,
        path: str | None = "/",
        domain: str | None = None,
        secure: bool = False,
        httponly: bool = False,
        samesite: Literal["lax", "strict", "none"] | None = "lax",
        partitioned: bool = False,
    ) -> None:
        cookie: http.cookies.BaseCookie[str] = http.cookies.SimpleCookie()
        cookie[key] = value
        if max_age is not None:
            cookie[key]["max-age"] = max_age
        if expires is not None:
            if isinstance(expires, datetime):
                cookie[key]["expires"] = format_datetime(expires, usegmt=True)
            else:
                cookie[key]["expires"] = expires
        if path is not None:
            cookie[key]["path"] = path
        if domain is not None:
            cookie[key]["domain"] = domain
        if secure:
            cookie[key]["secure"] = True
        if httponly:
            cookie[key]["httponly"] = True
        if samesite is not None:
            assert samesite.lower() in [
                "strict",
                "lax",
                "none",
            ], "samesite must be either 'strict', 'lax' or 'none'"
            cookie[key]["samesite"] = samesite
        if partitioned:
            if sys.version_info < (3, 14):
                raise ValueError("Partitioned cookies are only supported in Python 3.14 and above.")  # pragma: no cover
            cookie[key]["partitioned"] = True  # pragma: no cover
    
        cookie_val = cookie.output(header="").strip()
        self.raw_headers.append((b"set-cookie", cookie_val.encode("latin-1")))
      
  
---|---  
  
###  `` delete_cookie [¶](#fastapi.responses.FileResponse.delete_cookie "Permanent link")
    
    
    delete_cookie(
        key,
        path="/",
        domain=None,
        secure=False,
        httponly=False,
        samesite="lax",
    )
    

Source code in `starlette/responses.py`
    
    
    135
    136
    137
    138
    139
    140
    141
    142
    143
    144
    145
    146
    147
    148
    149
    150
    151
    152
    153

| 
    
    
    def delete_cookie(
        self,
        key: str,
        path: str = "/",
        domain: str | None = None,
        secure: bool = False,
        httponly: bool = False,
        samesite: Literal["lax", "strict", "none"] | None = "lax",
    ) -> None:
        self.set_cookie(
            key,
            max_age=0,
            expires=0,
            path=path,
            domain=domain,
            secure=secure,
            httponly=httponly,
            samesite=samesite,
        )
      
  
---|---  
  
##  `` fastapi.responses.HTMLResponse [¶](#fastapi.responses.HTMLResponse "Permanent link")
    
    
    HTMLResponse(
        content=None,
        status_code=200,
        headers=None,
        media_type=None,
        background=None,
    )
    

Bases: `[Response](#fastapi.responses.Response "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">fastapi.responses.Response</span> \(<code>starlette.responses.Response</code>\)")`

Source code in `starlette/responses.py`
    
    
    34
    35
    36
    37
    38
    39
    40
    41
    42
    43
    44
    45
    46
    47

| 
    
    
    def __init__(
        self,
        content: Any = None,
        status_code: int = 200,
        headers: Mapping[str, str] | None = None,
        media_type: str | None = None,
        background: BackgroundTask | None = None,
    ) -> None:
        self.status_code = status_code
        if media_type is not None:
            self.media_type = media_type
        self.background = background
        self.body = self.render(content)
        self.init_headers(headers)
      
  
---|---  
  
###  `` charset `class-attribute` `instance-attribute` [¶](#fastapi.responses.HTMLResponse.charset "Permanent link")
    
    
    charset = 'utf-8'
    

###  `` status_code `instance-attribute` [¶](#fastapi.responses.HTMLResponse.status_code "Permanent link")
    
    
    status_code = status_code
    

###  `` media_type `class-attribute` `instance-attribute` [¶](#fastapi.responses.HTMLResponse.media_type "Permanent link")
    
    
    media_type = 'text/html'
    

###  `` body `instance-attribute` [¶](#fastapi.responses.HTMLResponse.body "Permanent link")
    
    
    body = render(content)
    

###  `` background `instance-attribute` [¶](#fastapi.responses.HTMLResponse.background "Permanent link")
    
    
    background = background
    

###  `` headers `property` [¶](#fastapi.responses.HTMLResponse.headers "Permanent link")
    
    
    headers
    

###  `` render [¶](#fastapi.responses.HTMLResponse.render "Permanent link")
    
    
    render(content)
    

Source code in `starlette/responses.py`
    
    
    49
    50
    51
    52
    53
    54

| 
    
    
    def render(self, content: Any) -> bytes | memoryview:
        if content is None:
            return b""
        if isinstance(content, bytes | memoryview):
            return content
        return content.encode(self.charset)  # type: ignore
      
  
---|---  
  
###  `` init_headers [¶](#fastapi.responses.HTMLResponse.init_headers "Permanent link")
    
    
    init_headers(headers=None)
    

Source code in `starlette/responses.py`
    
    
    56
    57
    58
    59
    60
    61
    62
    63
    64
    65
    66
    67
    68
    69
    70
    71
    72
    73
    74
    75
    76
    77
    78
    79
    80
    81
    82

| 
    
    
    def init_headers(self, headers: Mapping[str, str] | None = None) -> None:
        if headers is None:
            raw_headers: list[tuple[bytes, bytes]] = []
            populate_content_length = True
            populate_content_type = True
        else:
            raw_headers = [(k.lower().encode("latin-1"), v.encode("latin-1")) for k, v in headers.items()]
            keys = [h[0] for h in raw_headers]
            populate_content_length = b"content-length" not in keys
            populate_content_type = b"content-type" not in keys
    
        body = getattr(self, "body", None)
        if (
            body is not None
            and populate_content_length
            and not (self.status_code < 200 or self.status_code in (204, 304))
        ):
            content_length = str(len(body))
            raw_headers.append((b"content-length", content_length.encode("latin-1")))
    
        content_type = self.media_type
        if content_type is not None and populate_content_type:
            if content_type.startswith("text/") and "charset=" not in content_type.lower():
                content_type += "; charset=" + self.charset
            raw_headers.append((b"content-type", content_type.encode("latin-1")))
    
        self.raw_headers = raw_headers
      
  
---|---  
  
###  `` set_cookie [¶](#fastapi.responses.HTMLResponse.set_cookie "Permanent link")
    
    
    set_cookie(
        key,
        value="",
        max_age=None,
        expires=None,
        path="/",
        domain=None,
        secure=False,
        httponly=False,
        samesite="lax",
        partitioned=False,
    )
    

Source code in `starlette/responses.py`
    
    
     90
     91
     92
     93
     94
     95
     96
     97
     98
     99
    100
    101
    102
    103
    104
    105
    106
    107
    108
    109
    110
    111
    112
    113
    114
    115
    116
    117
    118
    119
    120
    121
    122
    123
    124
    125
    126
    127
    128
    129
    130
    131
    132
    133

| 
    
    
    def set_cookie(
        self,
        key: str,
        value: str = "",
        max_age: int | None = None,
        expires: datetime | str | int | None = None,
        path: str | None = "/",
        domain: str | None = None,
        secure: bool = False,
        httponly: bool = False,
        samesite: Literal["lax", "strict", "none"] | None = "lax",
        partitioned: bool = False,
    ) -> None:
        cookie: http.cookies.BaseCookie[str] = http.cookies.SimpleCookie()
        cookie[key] = value
        if max_age is not None:
            cookie[key]["max-age"] = max_age
        if expires is not None:
            if isinstance(expires, datetime):
                cookie[key]["expires"] = format_datetime(expires, usegmt=True)
            else:
                cookie[key]["expires"] = expires
        if path is not None:
            cookie[key]["path"] = path
        if domain is not None:
            cookie[key]["domain"] = domain
        if secure:
            cookie[key]["secure"] = True
        if httponly:
            cookie[key]["httponly"] = True
        if samesite is not None:
            assert samesite.lower() in [
                "strict",
                "lax",
                "none",
            ], "samesite must be either 'strict', 'lax' or 'none'"
            cookie[key]["samesite"] = samesite
        if partitioned:
            if sys.version_info < (3, 14):
                raise ValueError("Partitioned cookies are only supported in Python 3.14 and above.")  # pragma: no cover
            cookie[key]["partitioned"] = True  # pragma: no cover
    
        cookie_val = cookie.output(header="").strip()
        self.raw_headers.append((b"set-cookie", cookie_val.encode("latin-1")))
      
  
---|---  
  
###  `` delete_cookie [¶](#fastapi.responses.HTMLResponse.delete_cookie "Permanent link")
    
    
    delete_cookie(
        key,
        path="/",
        domain=None,
        secure=False,
        httponly=False,
        samesite="lax",
    )
    

Source code in `starlette/responses.py`
    
    
    135
    136
    137
    138
    139
    140
    141
    142
    143
    144
    145
    146
    147
    148
    149
    150
    151
    152
    153

| 
    
    
    def delete_cookie(
        self,
        key: str,
        path: str = "/",
        domain: str | None = None,
        secure: bool = False,
        httponly: bool = False,
        samesite: Literal["lax", "strict", "none"] | None = "lax",
    ) -> None:
        self.set_cookie(
            key,
            max_age=0,
            expires=0,
            path=path,
            domain=domain,
            secure=secure,
            httponly=httponly,
            samesite=samesite,
        )
      
  
---|---  
  
##  `` fastapi.responses.JSONResponse [¶](#fastapi.responses.JSONResponse "Permanent link")
    
    
    JSONResponse(
        content,
        status_code=200,
        headers=None,
        media_type=None,
        background=None,
    )
    

Bases: `[Response](#fastapi.responses.Response "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">fastapi.responses.Response</span> \(<code>starlette.responses.Response</code>\)")`

Source code in `starlette/responses.py`
    
    
    181
    182
    183
    184
    185
    186
    187
    188
    189

| 
    
    
    def __init__(
        self,
        content: Any,
        status_code: int = 200,
        headers: Mapping[str, str] | None = None,
        media_type: str | None = None,
        background: BackgroundTask | None = None,
    ) -> None:
        super().__init__(content, status_code, headers, media_type, background)
      
  
---|---  
  
###  `` charset `class-attribute` `instance-attribute` [¶](#fastapi.responses.JSONResponse.charset "Permanent link")
    
    
    charset = 'utf-8'
    

###  `` status_code `instance-attribute` [¶](#fastapi.responses.JSONResponse.status_code "Permanent link")
    
    
    status_code = status_code
    

###  `` media_type `class-attribute` `instance-attribute` [¶](#fastapi.responses.JSONResponse.media_type "Permanent link")
    
    
    media_type = 'application/json'
    

###  `` body `instance-attribute` [¶](#fastapi.responses.JSONResponse.body "Permanent link")
    
    
    body = render(content)
    

###  `` background `instance-attribute` [¶](#fastapi.responses.JSONResponse.background "Permanent link")
    
    
    background = background
    

###  `` headers `property` [¶](#fastapi.responses.JSONResponse.headers "Permanent link")
    
    
    headers
    

###  `` render [¶](#fastapi.responses.JSONResponse.render "Permanent link")
    
    
    render(content)
    

Source code in `starlette/responses.py`
    
    
    191
    192
    193
    194
    195
    196
    197
    198

| 
    
    
    def render(self, content: Any) -> bytes:
        return json.dumps(
            content,
            ensure_ascii=False,
            allow_nan=False,
            indent=None,
            separators=(",", ":"),
        ).encode("utf-8")
      
  
---|---  
  
###  `` init_headers [¶](#fastapi.responses.JSONResponse.init_headers "Permanent link")
    
    
    init_headers(headers=None)
    

Source code in `starlette/responses.py`
    
    
    56
    57
    58
    59
    60
    61
    62
    63
    64
    65
    66
    67
    68
    69
    70
    71
    72
    73
    74
    75
    76
    77
    78
    79
    80
    81
    82

| 
    
    
    def init_headers(self, headers: Mapping[str, str] | None = None) -> None:
        if headers is None:
            raw_headers: list[tuple[bytes, bytes]] = []
            populate_content_length = True
            populate_content_type = True
        else:
            raw_headers = [(k.lower().encode("latin-1"), v.encode("latin-1")) for k, v in headers.items()]
            keys = [h[0] for h in raw_headers]
            populate_content_length = b"content-length" not in keys
            populate_content_type = b"content-type" not in keys
    
        body = getattr(self, "body", None)
        if (
            body is not None
            and populate_content_length
            and not (self.status_code < 200 or self.status_code in (204, 304))
        ):
            content_length = str(len(body))
            raw_headers.append((b"content-length", content_length.encode("latin-1")))
    
        content_type = self.media_type
        if content_type is not None and populate_content_type:
            if content_type.startswith("text/") and "charset=" not in content_type.lower():
                content_type += "; charset=" + self.charset
            raw_headers.append((b"content-type", content_type.encode("latin-1")))
    
        self.raw_headers = raw_headers
      
  
---|---  
  
###  `` set_cookie [¶](#fastapi.responses.JSONResponse.set_cookie "Permanent link")
    
    
    set_cookie(
        key,
        value="",
        max_age=None,
        expires=None,
        path="/",
        domain=None,
        secure=False,
        httponly=False,
        samesite="lax",
        partitioned=False,
    )
    

Source code in `starlette/responses.py`
    
    
     90
     91
     92
     93
     94
     95
     96
     97
     98
     99
    100
    101
    102
    103
    104
    105
    106
    107
    108
    109
    110
    111
    112
    113
    114
    115
    116
    117
    118
    119
    120
    121
    122
    123
    124
    125
    126
    127
    128
    129
    130
    131
    132
    133

| 
    
    
    def set_cookie(
        self,
        key: str,
        value: str = "",
        max_age: int | None = None,
        expires: datetime | str | int | None = None,
        path: str | None = "/",
        domain: str | None = None,
        secure: bool = False,
        httponly: bool = False,
        samesite: Literal["lax", "strict", "none"] | None = "lax",
        partitioned: bool = False,
    ) -> None:
        cookie: http.cookies.BaseCookie[str] = http.cookies.SimpleCookie()
        cookie[key] = value
        if max_age is not None:
            cookie[key]["max-age"] = max_age
        if expires is not None:
            if isinstance(expires, datetime):
                cookie[key]["expires"] = format_datetime(expires, usegmt=True)
            else:
                cookie[key]["expires"] = expires
        if path is not None:
            cookie[key]["path"] = path
        if domain is not None:
            cookie[key]["domain"] = domain
        if secure:
            cookie[key]["secure"] = True
        if httponly:
            cookie[key]["httponly"] = True
        if samesite is not None:
            assert samesite.lower() in [
                "strict",
                "lax",
                "none",
            ], "samesite must be either 'strict', 'lax' or 'none'"
            cookie[key]["samesite"] = samesite
        if partitioned:
            if sys.version_info < (3, 14):
                raise ValueError("Partitioned cookies are only supported in Python 3.14 and above.")  # pragma: no cover
            cookie[key]["partitioned"] = True  # pragma: no cover
    
        cookie_val = cookie.output(header="").strip()
        self.raw_headers.append((b"set-cookie", cookie_val.encode("latin-1")))
      
  
---|---  
  
###  `` delete_cookie [¶](#fastapi.responses.JSONResponse.delete_cookie "Permanent link")
    
    
    delete_cookie(
        key,
        path="/",
        domain=None,
        secure=False,
        httponly=False,
        samesite="lax",
    )
    

Source code in `starlette/responses.py`
    
    
    135
    136
    137
    138
    139
    140
    141
    142
    143
    144
    145
    146
    147
    148
    149
    150
    151
    152
    153

| 
    
    
    def delete_cookie(
        self,
        key: str,
        path: str = "/",
        domain: str | None = None,
        secure: bool = False,
        httponly: bool = False,
        samesite: Literal["lax", "strict", "none"] | None = "lax",
    ) -> None:
        self.set_cookie(
            key,
            max_age=0,
            expires=0,
            path=path,
            domain=domain,
            secure=secure,
            httponly=httponly,
            samesite=samesite,
        )
      
  
---|---  
  
##  `` fastapi.responses.PlainTextResponse [¶](#fastapi.responses.PlainTextResponse "Permanent link")
    
    
    PlainTextResponse(
        content=None,
        status_code=200,
        headers=None,
        media_type=None,
        background=None,
    )
    

Bases: `[Response](#fastapi.responses.Response "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">fastapi.responses.Response</span> \(<code>starlette.responses.Response</code>\)")`

Source code in `starlette/responses.py`
    
    
    34
    35
    36
    37
    38
    39
    40
    41
    42
    43
    44
    45
    46
    47

| 
    
    
    def __init__(
        self,
        content: Any = None,
        status_code: int = 200,
        headers: Mapping[str, str] | None = None,
        media_type: str | None = None,
        background: BackgroundTask | None = None,
    ) -> None:
        self.status_code = status_code
        if media_type is not None:
            self.media_type = media_type
        self.background = background
        self.body = self.render(content)
        self.init_headers(headers)
      
  
---|---  
  
###  `` charset `class-attribute` `instance-attribute` [¶](#fastapi.responses.PlainTextResponse.charset "Permanent link")
    
    
    charset = 'utf-8'
    

###  `` status_code `instance-attribute` [¶](#fastapi.responses.PlainTextResponse.status_code "Permanent link")
    
    
    status_code = status_code
    

###  `` media_type `class-attribute` `instance-attribute` [¶](#fastapi.responses.PlainTextResponse.media_type "Permanent link")
    
    
    media_type = 'text/plain'
    

###  `` body `instance-attribute` [¶](#fastapi.responses.PlainTextResponse.body "Permanent link")
    
    
    body = render(content)
    

###  `` background `instance-attribute` [¶](#fastapi.responses.PlainTextResponse.background "Permanent link")
    
    
    background = background
    

###  `` headers `property` [¶](#fastapi.responses.PlainTextResponse.headers "Permanent link")
    
    
    headers
    

###  `` render [¶](#fastapi.responses.PlainTextResponse.render "Permanent link")
    
    
    render(content)
    

Source code in `starlette/responses.py`
    
    
    49
    50
    51
    52
    53
    54

| 
    
    
    def render(self, content: Any) -> bytes | memoryview:
        if content is None:
            return b""
        if isinstance(content, bytes | memoryview):
            return content
        return content.encode(self.charset)  # type: ignore
      
  
---|---  
  
###  `` init_headers [¶](#fastapi.responses.PlainTextResponse.init_headers "Permanent link")
    
    
    init_headers(headers=None)
    

Source code in `starlette/responses.py`
    
    
    56
    57
    58
    59
    60
    61
    62
    63
    64
    65
    66
    67
    68
    69
    70
    71
    72
    73
    74
    75
    76
    77
    78
    79
    80
    81
    82

| 
    
    
    def init_headers(self, headers: Mapping[str, str] | None = None) -> None:
        if headers is None:
            raw_headers: list[tuple[bytes, bytes]] = []
            populate_content_length = True
            populate_content_type = True
        else:
            raw_headers = [(k.lower().encode("latin-1"), v.encode("latin-1")) for k, v in headers.items()]
            keys = [h[0] for h in raw_headers]
            populate_content_length = b"content-length" not in keys
            populate_content_type = b"content-type" not in keys
    
        body = getattr(self, "body", None)
        if (
            body is not None
            and populate_content_length
            and not (self.status_code < 200 or self.status_code in (204, 304))
        ):
            content_length = str(len(body))
            raw_headers.append((b"content-length", content_length.encode("latin-1")))
    
        content_type = self.media_type
        if content_type is not None and populate_content_type:
            if content_type.startswith("text/") and "charset=" not in content_type.lower():
                content_type += "; charset=" + self.charset
            raw_headers.append((b"content-type", content_type.encode("latin-1")))
    
        self.raw_headers = raw_headers
      
  
---|---  
  
###  `` set_cookie [¶](#fastapi.responses.PlainTextResponse.set_cookie "Permanent link")
    
    
    set_cookie(
        key,
        value="",
        max_age=None,
        expires=None,
        path="/",
        domain=None,
        secure=False,
        httponly=False,
        samesite="lax",
        partitioned=False,
    )
    

Source code in `starlette/responses.py`
    
    
     90
     91
     92
     93
     94
     95
     96
     97
     98
     99
    100
    101
    102
    103
    104
    105
    106
    107
    108
    109
    110
    111
    112
    113
    114
    115
    116
    117
    118
    119
    120
    121
    122
    123
    124
    125
    126
    127
    128
    129
    130
    131
    132
    133

| 
    
    
    def set_cookie(
        self,
        key: str,
        value: str = "",
        max_age: int | None = None,
        expires: datetime | str | int | None = None,
        path: str | None = "/",
        domain: str | None = None,
        secure: bool = False,
        httponly: bool = False,
        samesite: Literal["lax", "strict", "none"] | None = "lax",
        partitioned: bool = False,
    ) -> None:
        cookie: http.cookies.BaseCookie[str] = http.cookies.SimpleCookie()
        cookie[key] = value
        if max_age is not None:
            cookie[key]["max-age"] = max_age
        if expires is not None:
            if isinstance(expires, datetime):
                cookie[key]["expires"] = format_datetime(expires, usegmt=True)
            else:
                cookie[key]["expires"] = expires
        if path is not None:
            cookie[key]["path"] = path
        if domain is not None:
            cookie[key]["domain"] = domain
        if secure:
            cookie[key]["secure"] = True
        if httponly:
            cookie[key]["httponly"] = True
        if samesite is not None:
            assert samesite.lower() in [
                "strict",
                "lax",
                "none",
            ], "samesite must be either 'strict', 'lax' or 'none'"
            cookie[key]["samesite"] = samesite
        if partitioned:
            if sys.version_info < (3, 14):
                raise ValueError("Partitioned cookies are only supported in Python 3.14 and above.")  # pragma: no cover
            cookie[key]["partitioned"] = True  # pragma: no cover
    
        cookie_val = cookie.output(header="").strip()
        self.raw_headers.append((b"set-cookie", cookie_val.encode("latin-1")))
      
  
---|---  
  
###  `` delete_cookie [¶](#fastapi.responses.PlainTextResponse.delete_cookie "Permanent link")
    
    
    delete_cookie(
        key,
        path="/",
        domain=None,
        secure=False,
        httponly=False,
        samesite="lax",
    )
    

Source code in `starlette/responses.py`
    
    
    135
    136
    137
    138
    139
    140
    141
    142
    143
    144
    145
    146
    147
    148
    149
    150
    151
    152
    153

| 
    
    
    def delete_cookie(
        self,
        key: str,
        path: str = "/",
        domain: str | None = None,
        secure: bool = False,
        httponly: bool = False,
        samesite: Literal["lax", "strict", "none"] | None = "lax",
    ) -> None:
        self.set_cookie(
            key,
            max_age=0,
            expires=0,
            path=path,
            domain=domain,
            secure=secure,
            httponly=httponly,
            samesite=samesite,
        )
      
  
---|---  
  
##  `` fastapi.responses.RedirectResponse [¶](#fastapi.responses.RedirectResponse "Permanent link")
    
    
    RedirectResponse(
        url, status_code=307, headers=None, background=None
    )
    

Bases: `[Response](#fastapi.responses.Response "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">fastapi.responses.Response</span> \(<code>starlette.responses.Response</code>\)")`

Source code in `starlette/responses.py`
    
    
    202
    203
    204
    205
    206
    207
    208
    209
    210

| 
    
    
    def __init__(
        self,
        url: str | URL,
        status_code: int = 307,
        headers: Mapping[str, str] | None = None,
        background: BackgroundTask | None = None,
    ) -> None:
        super().__init__(content=b"", status_code=status_code, headers=headers, background=background)
        self.headers["location"] = quote(str(url), safe=":/%#?=@[]!$&'()*+,;")
      
  
---|---  
  
###  `` charset `class-attribute` `instance-attribute` [¶](#fastapi.responses.RedirectResponse.charset "Permanent link")
    
    
    charset = 'utf-8'
    

###  `` status_code `instance-attribute` [¶](#fastapi.responses.RedirectResponse.status_code "Permanent link")
    
    
    status_code = status_code
    

###  `` media_type `class-attribute` `instance-attribute` [¶](#fastapi.responses.RedirectResponse.media_type "Permanent link")
    
    
    media_type = None
    

###  `` body `instance-attribute` [¶](#fastapi.responses.RedirectResponse.body "Permanent link")
    
    
    body = render(content)
    

###  `` background `instance-attribute` [¶](#fastapi.responses.RedirectResponse.background "Permanent link")
    
    
    background = background
    

###  `` headers `property` [¶](#fastapi.responses.RedirectResponse.headers "Permanent link")
    
    
    headers
    

###  `` render [¶](#fastapi.responses.RedirectResponse.render "Permanent link")
    
    
    render(content)
    

Source code in `starlette/responses.py`
    
    
    49
    50
    51
    52
    53
    54

| 
    
    
    def render(self, content: Any) -> bytes | memoryview:
        if content is None:
            return b""
        if isinstance(content, bytes | memoryview):
            return content
        return content.encode(self.charset)  # type: ignore
      
  
---|---  
  
###  `` init_headers [¶](#fastapi.responses.RedirectResponse.init_headers "Permanent link")
    
    
    init_headers(headers=None)
    

Source code in `starlette/responses.py`
    
    
    56
    57
    58
    59
    60
    61
    62
    63
    64
    65
    66
    67
    68
    69
    70
    71
    72
    73
    74
    75
    76
    77
    78
    79
    80
    81
    82

| 
    
    
    def init_headers(self, headers: Mapping[str, str] | None = None) -> None:
        if headers is None:
            raw_headers: list[tuple[bytes, bytes]] = []
            populate_content_length = True
            populate_content_type = True
        else:
            raw_headers = [(k.lower().encode("latin-1"), v.encode("latin-1")) for k, v in headers.items()]
            keys = [h[0] for h in raw_headers]
            populate_content_length = b"content-length" not in keys
            populate_content_type = b"content-type" not in keys
    
        body = getattr(self, "body", None)
        if (
            body is not None
            and populate_content_length
            and not (self.status_code < 200 or self.status_code in (204, 304))
        ):
            content_length = str(len(body))
            raw_headers.append((b"content-length", content_length.encode("latin-1")))
    
        content_type = self.media_type
        if content_type is not None and populate_content_type:
            if content_type.startswith("text/") and "charset=" not in content_type.lower():
                content_type += "; charset=" + self.charset
            raw_headers.append((b"content-type", content_type.encode("latin-1")))
    
        self.raw_headers = raw_headers
      
  
---|---  
  
###  `` set_cookie [¶](#fastapi.responses.RedirectResponse.set_cookie "Permanent link")
    
    
    set_cookie(
        key,
        value="",
        max_age=None,
        expires=None,
        path="/",
        domain=None,
        secure=False,
        httponly=False,
        samesite="lax",
        partitioned=False,
    )
    

Source code in `starlette/responses.py`
    
    
     90
     91
     92
     93
     94
     95
     96
     97
     98
     99
    100
    101
    102
    103
    104
    105
    106
    107
    108
    109
    110
    111
    112
    113
    114
    115
    116
    117
    118
    119
    120
    121
    122
    123
    124
    125
    126
    127
    128
    129
    130
    131
    132
    133

| 
    
    
    def set_cookie(
        self,
        key: str,
        value: str = "",
        max_age: int | None = None,
        expires: datetime | str | int | None = None,
        path: str | None = "/",
        domain: str | None = None,
        secure: bool = False,
        httponly: bool = False,
        samesite: Literal["lax", "strict", "none"] | None = "lax",
        partitioned: bool = False,
    ) -> None:
        cookie: http.cookies.BaseCookie[str] = http.cookies.SimpleCookie()
        cookie[key] = value
        if max_age is not None:
            cookie[key]["max-age"] = max_age
        if expires is not None:
            if isinstance(expires, datetime):
                cookie[key]["expires"] = format_datetime(expires, usegmt=True)
            else:
                cookie[key]["expires"] = expires
        if path is not None:
            cookie[key]["path"] = path
        if domain is not None:
            cookie[key]["domain"] = domain
        if secure:
            cookie[key]["secure"] = True
        if httponly:
            cookie[key]["httponly"] = True
        if samesite is not None:
            assert samesite.lower() in [
                "strict",
                "lax",
                "none",
            ], "samesite must be either 'strict', 'lax' or 'none'"
            cookie[key]["samesite"] = samesite
        if partitioned:
            if sys.version_info < (3, 14):
                raise ValueError("Partitioned cookies are only supported in Python 3.14 and above.")  # pragma: no cover
            cookie[key]["partitioned"] = True  # pragma: no cover
    
        cookie_val = cookie.output(header="").strip()
        self.raw_headers.append((b"set-cookie", cookie_val.encode("latin-1")))
      
  
---|---  
  
###  `` delete_cookie [¶](#fastapi.responses.RedirectResponse.delete_cookie "Permanent link")
    
    
    delete_cookie(
        key,
        path="/",
        domain=None,
        secure=False,
        httponly=False,
        samesite="lax",
    )
    

Source code in `starlette/responses.py`
    
    
    135
    136
    137
    138
    139
    140
    141
    142
    143
    144
    145
    146
    147
    148
    149
    150
    151
    152
    153

| 
    
    
    def delete_cookie(
        self,
        key: str,
        path: str = "/",
        domain: str | None = None,
        secure: bool = False,
        httponly: bool = False,
        samesite: Literal["lax", "strict", "none"] | None = "lax",
    ) -> None:
        self.set_cookie(
            key,
            max_age=0,
            expires=0,
            path=path,
            domain=domain,
            secure=secure,
            httponly=httponly,
            samesite=samesite,
        )
      
  
---|---  
  
##  `` fastapi.responses.Response [¶](#fastapi.responses.Response "Permanent link")
    
    
    Response(
        content=None,
        status_code=200,
        headers=None,
        media_type=None,
        background=None,
    )
    

Source code in `starlette/responses.py`
    
    
    34
    35
    36
    37
    38
    39
    40
    41
    42
    43
    44
    45
    46
    47

| 
    
    
    def __init__(
        self,
        content: Any = None,
        status_code: int = 200,
        headers: Mapping[str, str] | None = None,
        media_type: str | None = None,
        background: BackgroundTask | None = None,
    ) -> None:
        self.status_code = status_code
        if media_type is not None:
            self.media_type = media_type
        self.background = background
        self.body = self.render(content)
        self.init_headers(headers)
      
  
---|---  
  
###  `` charset `class-attribute` `instance-attribute` [¶](#fastapi.responses.Response.charset "Permanent link")
    
    
    charset = 'utf-8'
    

###  `` status_code `instance-attribute` [¶](#fastapi.responses.Response.status_code "Permanent link")
    
    
    status_code = status_code
    

###  `` media_type `class-attribute` `instance-attribute` [¶](#fastapi.responses.Response.media_type "Permanent link")
    
    
    media_type = None
    

###  `` body `instance-attribute` [¶](#fastapi.responses.Response.body "Permanent link")
    
    
    body = render(content)
    

###  `` background `instance-attribute` [¶](#fastapi.responses.Response.background "Permanent link")
    
    
    background = background
    

###  `` headers `property` [¶](#fastapi.responses.Response.headers "Permanent link")
    
    
    headers
    

###  `` render [¶](#fastapi.responses.Response.render "Permanent link")
    
    
    render(content)
    

Source code in `starlette/responses.py`
    
    
    49
    50
    51
    52
    53
    54

| 
    
    
    def render(self, content: Any) -> bytes | memoryview:
        if content is None:
            return b""
        if isinstance(content, bytes | memoryview):
            return content
        return content.encode(self.charset)  # type: ignore
      
  
---|---  
  
###  `` init_headers [¶](#fastapi.responses.Response.init_headers "Permanent link")
    
    
    init_headers(headers=None)
    

Source code in `starlette/responses.py`
    
    
    56
    57
    58
    59
    60
    61
    62
    63
    64
    65
    66
    67
    68
    69
    70
    71
    72
    73
    74
    75
    76
    77
    78
    79
    80
    81
    82

| 
    
    
    def init_headers(self, headers: Mapping[str, str] | None = None) -> None:
        if headers is None:
            raw_headers: list[tuple[bytes, bytes]] = []
            populate_content_length = True
            populate_content_type = True
        else:
            raw_headers = [(k.lower().encode("latin-1"), v.encode("latin-1")) for k, v in headers.items()]
            keys = [h[0] for h in raw_headers]
            populate_content_length = b"content-length" not in keys
            populate_content_type = b"content-type" not in keys
    
        body = getattr(self, "body", None)
        if (
            body is not None
            and populate_content_length
            and not (self.status_code < 200 or self.status_code in (204, 304))
        ):
            content_length = str(len(body))
            raw_headers.append((b"content-length", content_length.encode("latin-1")))
    
        content_type = self.media_type
        if content_type is not None and populate_content_type:
            if content_type.startswith("text/") and "charset=" not in content_type.lower():
                content_type += "; charset=" + self.charset
            raw_headers.append((b"content-type", content_type.encode("latin-1")))
    
        self.raw_headers = raw_headers
      
  
---|---  
  
###  `` set_cookie [¶](#fastapi.responses.Response.set_cookie "Permanent link")
    
    
    set_cookie(
        key,
        value="",
        max_age=None,
        expires=None,
        path="/",
        domain=None,
        secure=False,
        httponly=False,
        samesite="lax",
        partitioned=False,
    )
    

Source code in `starlette/responses.py`
    
    
     90
     91
     92
     93
     94
     95
     96
     97
     98
     99
    100
    101
    102
    103
    104
    105
    106
    107
    108
    109
    110
    111
    112
    113
    114
    115
    116
    117
    118
    119
    120
    121
    122
    123
    124
    125
    126
    127
    128
    129
    130
    131
    132
    133

| 
    
    
    def set_cookie(
        self,
        key: str,
        value: str = "",
        max_age: int | None = None,
        expires: datetime | str | int | None = None,
        path: str | None = "/",
        domain: str | None = None,
        secure: bool = False,
        httponly: bool = False,
        samesite: Literal["lax", "strict", "none"] | None = "lax",
        partitioned: bool = False,
    ) -> None:
        cookie: http.cookies.BaseCookie[str] = http.cookies.SimpleCookie()
        cookie[key] = value
        if max_age is not None:
            cookie[key]["max-age"] = max_age
        if expires is not None:
            if isinstance(expires, datetime):
                cookie[key]["expires"] = format_datetime(expires, usegmt=True)
            else:
                cookie[key]["expires"] = expires
        if path is not None:
            cookie[key]["path"] = path
        if domain is not None:
            cookie[key]["domain"] = domain
        if secure:
            cookie[key]["secure"] = True
        if httponly:
            cookie[key]["httponly"] = True
        if samesite is not None:
            assert samesite.lower() in [
                "strict",
                "lax",
                "none",
            ], "samesite must be either 'strict', 'lax' or 'none'"
            cookie[key]["samesite"] = samesite
        if partitioned:
            if sys.version_info < (3, 14):
                raise ValueError("Partitioned cookies are only supported in Python 3.14 and above.")  # pragma: no cover
            cookie[key]["partitioned"] = True  # pragma: no cover
    
        cookie_val = cookie.output(header="").strip()
        self.raw_headers.append((b"set-cookie", cookie_val.encode("latin-1")))
      
  
---|---  
  
###  `` delete_cookie [¶](#fastapi.responses.Response.delete_cookie "Permanent link")
    
    
    delete_cookie(
        key,
        path="/",
        domain=None,
        secure=False,
        httponly=False,
        samesite="lax",
    )
    

Source code in `starlette/responses.py`
    
    
    135
    136
    137
    138
    139
    140
    141
    142
    143
    144
    145
    146
    147
    148
    149
    150
    151
    152
    153

| 
    
    
    def delete_cookie(
        self,
        key: str,
        path: str = "/",
        domain: str | None = None,
        secure: bool = False,
        httponly: bool = False,
        samesite: Literal["lax", "strict", "none"] | None = "lax",
    ) -> None:
        self.set_cookie(
            key,
            max_age=0,
            expires=0,
            path=path,
            domain=domain,
            secure=secure,
            httponly=httponly,
            samesite=samesite,
        )
      
  
---|---  
  
##  `` fastapi.responses.StreamingResponse [¶](#fastapi.responses.StreamingResponse "Permanent link")
    
    
    StreamingResponse(
        content,
        status_code=200,
        headers=None,
        media_type=None,
        background=None,
    )
    

Bases: `[Response](#fastapi.responses.Response "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">fastapi.responses.Response</span> \(<code>starlette.responses.Response</code>\)")`

Source code in `starlette/responses.py`
    
    
    222
    223
    224
    225
    226
    227
    228
    229
    230
    231
    232
    233
    234
    235
    236
    237

| 
    
    
    def __init__(
        self,
        content: ContentStream,
        status_code: int = 200,
        headers: Mapping[str, str] | None = None,
        media_type: str | None = None,
        background: BackgroundTask | None = None,
    ) -> None:
        if isinstance(content, AsyncIterable):
            self.body_iterator = content
        else:
            self.body_iterator = iterate_in_threadpool(content)
        self.status_code = status_code
        self.media_type = self.media_type if media_type is None else media_type
        self.background = background
        self.init_headers(headers)
      
  
---|---  
  
###  `` body_iterator `instance-attribute` [¶](#fastapi.responses.StreamingResponse.body_iterator "Permanent link")
    
    
    body_iterator
    

###  `` charset `class-attribute` `instance-attribute` [¶](#fastapi.responses.StreamingResponse.charset "Permanent link")
    
    
    charset = 'utf-8'
    

###  `` status_code `instance-attribute` [¶](#fastapi.responses.StreamingResponse.status_code "Permanent link")
    
    
    status_code = status_code
    

###  `` media_type `instance-attribute` [¶](#fastapi.responses.StreamingResponse.media_type "Permanent link")
    
    
    media_type = (
        media_type if media_type is None else media_type
    )
    

###  `` body `instance-attribute` [¶](#fastapi.responses.StreamingResponse.body "Permanent link")
    
    
    body = render(content)
    

###  `` background `instance-attribute` [¶](#fastapi.responses.StreamingResponse.background "Permanent link")
    
    
    background = background
    

###  `` headers `property` [¶](#fastapi.responses.StreamingResponse.headers "Permanent link")
    
    
    headers
    

###  `` render [¶](#fastapi.responses.StreamingResponse.render "Permanent link")
    
    
    render(content)
    

Source code in `starlette/responses.py`
    
    
    49
    50
    51
    52
    53
    54

| 
    
    
    def render(self, content: Any) -> bytes | memoryview:
        if content is None:
            return b""
        if isinstance(content, bytes | memoryview):
            return content
        return content.encode(self.charset)  # type: ignore
      
  
---|---  
  
###  `` init_headers [¶](#fastapi.responses.StreamingResponse.init_headers "Permanent link")
    
    
    init_headers(headers=None)
    

Source code in `starlette/responses.py`
    
    
    56
    57
    58
    59
    60
    61
    62
    63
    64
    65
    66
    67
    68
    69
    70
    71
    72
    73
    74
    75
    76
    77
    78
    79
    80
    81
    82

| 
    
    
    def init_headers(self, headers: Mapping[str, str] | None = None) -> None:
        if headers is None:
            raw_headers: list[tuple[bytes, bytes]] = []
            populate_content_length = True
            populate_content_type = True
        else:
            raw_headers = [(k.lower().encode("latin-1"), v.encode("latin-1")) for k, v in headers.items()]
            keys = [h[0] for h in raw_headers]
            populate_content_length = b"content-length" not in keys
            populate_content_type = b"content-type" not in keys
    
        body = getattr(self, "body", None)
        if (
            body is not None
            and populate_content_length
            and not (self.status_code < 200 or self.status_code in (204, 304))
        ):
            content_length = str(len(body))
            raw_headers.append((b"content-length", content_length.encode("latin-1")))
    
        content_type = self.media_type
        if content_type is not None and populate_content_type:
            if content_type.startswith("text/") and "charset=" not in content_type.lower():
                content_type += "; charset=" + self.charset
            raw_headers.append((b"content-type", content_type.encode("latin-1")))
    
        self.raw_headers = raw_headers
      
  
---|---  
  
###  `` set_cookie [¶](#fastapi.responses.StreamingResponse.set_cookie "Permanent link")
    
    
    set_cookie(
        key,
        value="",
        max_age=None,
        expires=None,
        path="/",
        domain=None,
        secure=False,
        httponly=False,
        samesite="lax",
        partitioned=False,
    )
    

Source code in `starlette/responses.py`
    
    
     90
     91
     92
     93
     94
     95
     96
     97
     98
     99
    100
    101
    102
    103
    104
    105
    106
    107
    108
    109
    110
    111
    112
    113
    114
    115
    116
    117
    118
    119
    120
    121
    122
    123
    124
    125
    126
    127
    128
    129
    130
    131
    132
    133

| 
    
    
    def set_cookie(
        self,
        key: str,
        value: str = "",
        max_age: int | None = None,
        expires: datetime | str | int | None = None,
        path: str | None = "/",
        domain: str | None = None,
        secure: bool = False,
        httponly: bool = False,
        samesite: Literal["lax", "strict", "none"] | None = "lax",
        partitioned: bool = False,
    ) -> None:
        cookie: http.cookies.BaseCookie[str] = http.cookies.SimpleCookie()
        cookie[key] = value
        if max_age is not None:
            cookie[key]["max-age"] = max_age
        if expires is not None:
            if isinstance(expires, datetime):
                cookie[key]["expires"] = format_datetime(expires, usegmt=True)
            else:
                cookie[key]["expires"] = expires
        if path is not None:
            cookie[key]["path"] = path
        if domain is not None:
            cookie[key]["domain"] = domain
        if secure:
            cookie[key]["secure"] = True
        if httponly:
            cookie[key]["httponly"] = True
        if samesite is not None:
            assert samesite.lower() in [
                "strict",
                "lax",
                "none",
            ], "samesite must be either 'strict', 'lax' or 'none'"
            cookie[key]["samesite"] = samesite
        if partitioned:
            if sys.version_info < (3, 14):
                raise ValueError("Partitioned cookies are only supported in Python 3.14 and above.")  # pragma: no cover
            cookie[key]["partitioned"] = True  # pragma: no cover
    
        cookie_val = cookie.output(header="").strip()
        self.raw_headers.append((b"set-cookie", cookie_val.encode("latin-1")))
      
  
---|---  
  
###  `` delete_cookie [¶](#fastapi.responses.StreamingResponse.delete_cookie "Permanent link")
    
    
    delete_cookie(
        key,
        path="/",
        domain=None,
        secure=False,
        httponly=False,
        samesite="lax",
    )
    

Source code in `starlette/responses.py`
    
    
    135
    136
    137
    138
    139
    140
    141
    142
    143
    144
    145
    146
    147
    148
    149
    150
    151
    152
    153

| 
    
    
    def delete_cookie(
        self,
        key: str,
        path: str = "/",
        domain: str | None = None,
        secure: bool = False,
        httponly: bool = False,
        samesite: Literal["lax", "strict", "none"] | None = "lax",
    ) -> None:
        self.set_cookie(
            key,
            max_age=0,
            expires=0,
            path=path,
            domain=domain,
            secure=secure,
            httponly=httponly,
            samesite=samesite,
        )
      
  
---|---

---

###### Middleware¶

# Middleware[¶](#middleware "Permanent link")

There are several middlewares available provided by Starlette directly.

Read more about them in the [FastAPI docs for Middleware](https://fastapi.tiangolo.com/advanced/middleware/).

##  `` fastapi.middleware.cors.CORSMiddleware [¶](#fastapi.middleware.cors.CORSMiddleware "Permanent link")
    
    
    CORSMiddleware(
        app,
        allow_origins=(),
        allow_methods=("GET",),
        allow_headers=(),
        allow_credentials=False,
        allow_origin_regex=None,
        expose_headers=(),
        max_age=600,
    )
    

Source code in `starlette/middleware/cors.py`
    
    
    16
    17
    18
    19
    20
    21
    22
    23
    24
    25
    26
    27
    28
    29
    30
    31
    32
    33
    34
    35
    36
    37
    38
    39
    40
    41
    42
    43
    44
    45
    46
    47
    48
    49
    50
    51
    52
    53
    54
    55
    56
    57
    58
    59
    60
    61
    62
    63
    64
    65
    66
    67
    68
    69
    70
    71
    72
    73

| 
    
    
    def __init__(
        self,
        app: ASGIApp,
        allow_origins: Sequence[str] = (),
        allow_methods: Sequence[str] = ("GET",),
        allow_headers: Sequence[str] = (),
        allow_credentials: bool = False,
        allow_origin_regex: str | None = None,
        expose_headers: Sequence[str] = (),
        max_age: int = 600,
    ) -> None:
        if "*" in allow_methods:
            allow_methods = ALL_METHODS
    
        compiled_allow_origin_regex = None
        if allow_origin_regex is not None:
            compiled_allow_origin_regex = re.compile(allow_origin_regex)
    
        allow_all_origins = "*" in allow_origins
        allow_all_headers = "*" in allow_headers
        preflight_explicit_allow_origin = not allow_all_origins or allow_credentials
    
        simple_headers = {}
        if allow_all_origins:
            simple_headers["Access-Control-Allow-Origin"] = "*"
        if allow_credentials:
            simple_headers["Access-Control-Allow-Credentials"] = "true"
        if expose_headers:
            simple_headers["Access-Control-Expose-Headers"] = ", ".join(expose_headers)
    
        preflight_headers = {}
        if preflight_explicit_allow_origin:
            # The origin value will be set in preflight_response() if it is allowed.
            preflight_headers["Vary"] = "Origin"
        else:
            preflight_headers["Access-Control-Allow-Origin"] = "*"
        preflight_headers.update(
            {
                "Access-Control-Allow-Methods": ", ".join(allow_methods),
                "Access-Control-Max-Age": str(max_age),
            }
        )
        allow_headers = sorted(SAFELISTED_HEADERS | set(allow_headers))
        if allow_headers and not allow_all_headers:
            preflight_headers["Access-Control-Allow-Headers"] = ", ".join(allow_headers)
        if allow_credentials:
            preflight_headers["Access-Control-Allow-Credentials"] = "true"
    
        self.app = app
        self.allow_origins = allow_origins
        self.allow_methods = allow_methods
        self.allow_headers = [h.lower() for h in allow_headers]
        self.allow_all_origins = allow_all_origins
        self.allow_all_headers = allow_all_headers
        self.preflight_explicit_allow_origin = preflight_explicit_allow_origin
        self.allow_origin_regex = compiled_allow_origin_regex
        self.simple_headers = simple_headers
        self.preflight_headers = preflight_headers
      
  
---|---  
  
###  `` app `instance-attribute` [¶](#fastapi.middleware.cors.CORSMiddleware.app "Permanent link")
    
    
    app = app
    

###  `` allow_origins `instance-attribute` [¶](#fastapi.middleware.cors.CORSMiddleware.allow_origins "Permanent link")
    
    
    allow_origins = allow_origins
    

###  `` allow_methods `instance-attribute` [¶](#fastapi.middleware.cors.CORSMiddleware.allow_methods "Permanent link")
    
    
    allow_methods = allow_methods
    

###  `` allow_headers `instance-attribute` [¶](#fastapi.middleware.cors.CORSMiddleware.allow_headers "Permanent link")
    
    
    allow_headers = [(lower()) for h in allow_headers]
    

###  `` allow_all_origins `instance-attribute` [¶](#fastapi.middleware.cors.CORSMiddleware.allow_all_origins "Permanent link")
    
    
    allow_all_origins = allow_all_origins
    

###  `` allow_all_headers `instance-attribute` [¶](#fastapi.middleware.cors.CORSMiddleware.allow_all_headers "Permanent link")
    
    
    allow_all_headers = allow_all_headers
    

###  `` preflight_explicit_allow_origin `instance-attribute` [¶](#fastapi.middleware.cors.CORSMiddleware.preflight_explicit_allow_origin "Permanent link")
    
    
    preflight_explicit_allow_origin = (
        preflight_explicit_allow_origin
    )
    

###  `` allow_origin_regex `instance-attribute` [¶](#fastapi.middleware.cors.CORSMiddleware.allow_origin_regex "Permanent link")
    
    
    allow_origin_regex = compiled_allow_origin_regex
    

###  `` simple_headers `instance-attribute` [¶](#fastapi.middleware.cors.CORSMiddleware.simple_headers "Permanent link")
    
    
    simple_headers = simple_headers
    

###  `` preflight_headers `instance-attribute` [¶](#fastapi.middleware.cors.CORSMiddleware.preflight_headers "Permanent link")
    
    
    preflight_headers = preflight_headers
    

###  `` is_allowed_origin [¶](#fastapi.middleware.cors.CORSMiddleware.is_allowed_origin "Permanent link")
    
    
    is_allowed_origin(origin)
    

Source code in `starlette/middleware/cors.py`
    
    
     95
     96
     97
     98
     99
    100
    101
    102

| 
    
    
    def is_allowed_origin(self, origin: str) -> bool:
        if self.allow_all_origins:
            return True
    
        if self.allow_origin_regex is not None and self.allow_origin_regex.fullmatch(origin):
            return True
    
        return origin in self.allow_origins
      
  
---|---  
  
###  `` preflight_response [¶](#fastapi.middleware.cors.CORSMiddleware.preflight_response "Permanent link")
    
    
    preflight_response(request_headers)
    

Source code in `starlette/middleware/cors.py`
    
    
    104
    105
    106
    107
    108
    109
    110
    111
    112
    113
    114
    115
    116
    117
    118
    119
    120
    121
    122
    123
    124
    125
    126
    127
    128
    129
    130
    131
    132
    133
    134
    135
    136
    137
    138
    139
    140

| 
    
    
    def preflight_response(self, request_headers: Headers) -> Response:
        requested_origin = request_headers["origin"]
        requested_method = request_headers["access-control-request-method"]
        requested_headers = request_headers.get("access-control-request-headers")
    
        headers = dict(self.preflight_headers)
        failures = []
    
        if self.is_allowed_origin(origin=requested_origin):
            if self.preflight_explicit_allow_origin:
                # The "else" case is already accounted for in self.preflight_headers
                # and the value would be "*".
                headers["Access-Control-Allow-Origin"] = requested_origin
        else:
            failures.append("origin")
    
        if requested_method not in self.allow_methods:
            failures.append("method")
    
        # If we allow all headers, then we have to mirror back any requested
        # headers in the response.
        if self.allow_all_headers and requested_headers is not None:
            headers["Access-Control-Allow-Headers"] = requested_headers
        elif requested_headers is not None:
            for header in [h.lower() for h in requested_headers.split(",")]:
                if header.strip() not in self.allow_headers:
                    failures.append("headers")
                    break
    
        # We don't strictly need to use 400 responses here, since its up to
        # the browser to enforce the CORS policy, but its more informative
        # if we do.
        if failures:
            failure_text = "Disallowed CORS " + ", ".join(failures)
            return PlainTextResponse(failure_text, status_code=400, headers=headers)
    
        return PlainTextResponse("OK", status_code=200, headers=headers)
      
  
---|---  
  
###  `` simple_response `async` [¶](#fastapi.middleware.cors.CORSMiddleware.simple_response "Permanent link")
    
    
    simple_response(scope, receive, send, request_headers)
    

Source code in `starlette/middleware/cors.py`
    
    
    142
    143
    144

| 
    
    
    async def simple_response(self, scope: Scope, receive: Receive, send: Send, request_headers: Headers) -> None:
        send = functools.partial(self.send, send=send, request_headers=request_headers)
        await self.app(scope, receive, send)
      
  
---|---  
  
###  `` send `async` [¶](#fastapi.middleware.cors.CORSMiddleware.send "Permanent link")
    
    
    send(message, send, request_headers)
    

Source code in `starlette/middleware/cors.py`
    
    
    146
    147
    148
    149
    150
    151
    152
    153
    154
    155
    156
    157
    158
    159
    160
    161
    162
    163
    164
    165
    166
    167

| 
    
    
    async def send(self, message: Message, send: Send, request_headers: Headers) -> None:
        if message["type"] != "http.response.start":
            await send(message)
            return
    
        message.setdefault("headers", [])
        headers = MutableHeaders(scope=message)
        headers.update(self.simple_headers)
        origin = request_headers["Origin"]
        has_cookie = "cookie" in request_headers
    
        # If request includes any cookie headers, then we must respond
        # with the specific origin instead of '*'.
        if self.allow_all_origins and has_cookie:
            self.allow_explicit_origin(headers, origin)
    
        # If we only allow specific origins, then we have to mirror back
        # the Origin header in the response.
        elif not self.allow_all_origins and self.is_allowed_origin(origin=origin):
            self.allow_explicit_origin(headers, origin)
    
        await send(message)
      
  
---|---  
  
###  `` allow_explicit_origin `staticmethod` [¶](#fastapi.middleware.cors.CORSMiddleware.allow_explicit_origin "Permanent link")
    
    
    allow_explicit_origin(headers, origin)
    

Source code in `starlette/middleware/cors.py`
    
    
    169
    170
    171
    172

| 
    
    
    @staticmethod
    def allow_explicit_origin(headers: MutableHeaders, origin: str) -> None:
        headers["Access-Control-Allow-Origin"] = origin
        headers.add_vary_header("Origin")
      
  
---|---  
  
It can be imported from `fastapi`:
    
    
    from fastapi.middleware.cors import CORSMiddleware
    

##  `` fastapi.middleware.gzip.GZipMiddleware [¶](#fastapi.middleware.gzip.GZipMiddleware "Permanent link")
    
    
    GZipMiddleware(app, minimum_size=500, compresslevel=9)
    

Source code in `starlette/middleware/gzip.py`
    
    
    12
    13
    14
    15

| 
    
    
    def __init__(self, app: ASGIApp, minimum_size: int = 500, compresslevel: int = 9) -> None:
        self.app = app
        self.minimum_size = minimum_size
        self.compresslevel = compresslevel
      
  
---|---  
  
###  `` app `instance-attribute` [¶](#fastapi.middleware.gzip.GZipMiddleware.app "Permanent link")
    
    
    app = app
    

###  `` minimum_size `instance-attribute` [¶](#fastapi.middleware.gzip.GZipMiddleware.minimum_size "Permanent link")
    
    
    minimum_size = minimum_size
    

###  `` compresslevel `instance-attribute` [¶](#fastapi.middleware.gzip.GZipMiddleware.compresslevel "Permanent link")
    
    
    compresslevel = compresslevel
    

It can be imported from `fastapi`:
    
    
    from fastapi.middleware.gzip import GZipMiddleware
    

##  `` fastapi.middleware.httpsredirect.HTTPSRedirectMiddleware [¶](#fastapi.middleware.httpsredirect.HTTPSRedirectMiddleware "Permanent link")
    
    
    HTTPSRedirectMiddleware(app)
    

Source code in `starlette/middleware/httpsredirect.py`
    
    
    7
    8

| 
    
    
    def __init__(self, app: ASGIApp) -> None:
        self.app = app
      
  
---|---  
  
###  `` app `instance-attribute` [¶](#fastapi.middleware.httpsredirect.HTTPSRedirectMiddleware.app "Permanent link")
    
    
    app = app
    

It can be imported from `fastapi`:
    
    
    from fastapi.middleware.httpsredirect import HTTPSRedirectMiddleware
    

##  `` fastapi.middleware.trustedhost.TrustedHostMiddleware [¶](#fastapi.middleware.trustedhost.TrustedHostMiddleware "Permanent link")
    
    
    TrustedHostMiddleware(
        app, allowed_hosts=None, www_redirect=True
    )
    

Source code in `starlette/middleware/trustedhost.py`
    
    
    13
    14
    15
    16
    17
    18
    19
    20
    21
    22
    23
    24
    25
    26
    27
    28
    29

| 
    
    
    def __init__(
        self,
        app: ASGIApp,
        allowed_hosts: Sequence[str] | None = None,
        www_redirect: bool = True,
    ) -> None:
        if allowed_hosts is None:
            allowed_hosts = ["*"]
    
        for pattern in allowed_hosts:
            assert "*" not in pattern[1:], ENFORCE_DOMAIN_WILDCARD
            if pattern.startswith("*") and pattern != "*":
                assert pattern.startswith("*."), ENFORCE_DOMAIN_WILDCARD
        self.app = app
        self.allowed_hosts = list(allowed_hosts)
        self.allow_any = "*" in allowed_hosts
        self.www_redirect = www_redirect
      
  
---|---  
  
###  `` app `instance-attribute` [¶](#fastapi.middleware.trustedhost.TrustedHostMiddleware.app "Permanent link")
    
    
    app = app
    

###  `` allowed_hosts `instance-attribute` [¶](#fastapi.middleware.trustedhost.TrustedHostMiddleware.allowed_hosts "Permanent link")
    
    
    allowed_hosts = list(allowed_hosts)
    

###  `` allow_any `instance-attribute` [¶](#fastapi.middleware.trustedhost.TrustedHostMiddleware.allow_any "Permanent link")
    
    
    allow_any = '*' in allowed_hosts
    

###  `` www_redirect `instance-attribute` [¶](#fastapi.middleware.trustedhost.TrustedHostMiddleware.www_redirect "Permanent link")
    
    
    www_redirect = www_redirect
    

It can be imported from `fastapi`:
    
    
    from fastapi.middleware.trustedhost import TrustedHostMiddleware

---

###### OpenAPI¶

# OpenAPI[¶](#openapi "Permanent link")

There are several utilities to handle OpenAPI.

You normally don't need to use them unless you have a specific advanced use case that requires it.

---

###### OpenAPIdocs¶

# OpenAPI `docs`[¶](#openapi-docs "Permanent link")

Utilities to handle OpenAPI automatic UI documentation, including Swagger UI (by default at `/docs`) and ReDoc (by default at `/redoc`).

##  `` fastapi.openapi.docs.get_swagger_ui_html [¶](#fastapi.openapi.docs.get_swagger_ui_html "Permanent link")
    
    
    get_swagger_ui_html(
        *,
        openapi_url,
        title,
        swagger_js_url="https://cdn.jsdelivr.net/npm/swagger-ui-dist@5/swagger-ui-bundle.js",
        swagger_css_url="https://cdn.jsdelivr.net/npm/swagger-ui-dist@5/swagger-ui.css",
        swagger_favicon_url="https://fastapi.tiangolo.com/img/favicon.png",
        oauth2_redirect_url=None,
        init_oauth=None,
        swagger_ui_parameters=None
    )
    

Generate and return the HTML that loads Swagger UI for the interactive API docs (normally served at `/docs`).

You would only call this function yourself if you needed to override some parts, for example the URLs to use to load Swagger UI's JavaScript and CSS.

Read more about it in the [FastAPI docs for Configure Swagger UI](https://fastapi.tiangolo.com/how-to/configure-swagger-ui/) and the [FastAPI docs for Custom Docs UI Static Assets (Self-Hosting)](https://fastapi.tiangolo.com/how-to/custom-docs-ui-assets/).

PARAMETER | DESCRIPTION  
---|---  
`openapi_url` |  The OpenAPI URL that Swagger UI should load and use. This is normally done automatically by FastAPI using the default URL `/openapi.json`. Read more about it in the [FastAPI docs for Conditional OpenAPI](https://fastapi.tiangolo.com/how-to/conditional-openapi/#conditional-openapi-from-settings-and-env-vars) **TYPE:** `str`  
`title` |  The HTML `<title>` content, normally shown in the browser tab. Read more about it in the [FastAPI docs for Custom Docs UI Static Assets](https://fastapi.tiangolo.com/how-to/custom-docs-ui-assets/) **TYPE:** `str`  
`swagger_js_url` |  The URL to use to load the Swagger UI JavaScript. It is normally set to a CDN URL. Read more about it in the [FastAPI docs for Custom Docs UI Static Assets](https://fastapi.tiangolo.com/how-to/custom-docs-ui-assets/) **TYPE:** `str` **DEFAULT:** `'https://cdn.jsdelivr.net/npm/swagger-ui-dist@5/swagger-ui-bundle.js'`  
`swagger_css_url` |  The URL to use to load the Swagger UI CSS. It is normally set to a CDN URL. Read more about it in the [FastAPI docs for Custom Docs UI Static Assets](https://fastapi.tiangolo.com/how-to/custom-docs-ui-assets/) **TYPE:** `str` **DEFAULT:** `'https://cdn.jsdelivr.net/npm/swagger-ui-dist@5/swagger-ui.css'`  
`swagger_favicon_url` |  The URL of the favicon to use. It is normally shown in the browser tab. **TYPE:** `str` **DEFAULT:** `'https://fastapi.tiangolo.com/img/favicon.png'`  
`oauth2_redirect_url` |  The OAuth2 redirect URL, it is normally automatically handled by FastAPI. Read more about it in the [FastAPI docs for Custom Docs UI Static Assets](https://fastapi.tiangolo.com/how-to/custom-docs-ui-assets/) **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`init_oauth` |  A dictionary with Swagger UI OAuth2 initialization configurations. Read more about the available configuration options in the [Swagger UI docs](https://swagger.io/docs/open-source-tools/swagger-ui/usage/oauth2/). **TYPE:** `Optional[dict[str, Any]]` **DEFAULT:** `None`  
`swagger_ui_parameters` |  Configuration parameters for Swagger UI. It defaults to [swagger_ui_default_parameters](#fastapi.openapi.docs.swagger_ui_default_parameters "<code class="doc-symbol doc-symbol-heading doc-symbol-attribute"></code>            <span class="doc doc-object-name doc-attribute-name">fastapi.openapi.docs.swagger_ui_default_parameters</span>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-module-attribute"><code>module-attribute</code></small>
  </span>"). Read more about it in the [FastAPI docs about how to Configure Swagger UI](https://fastapi.tiangolo.com/how-to/configure-swagger-ui/). **TYPE:** `Optional[dict[str, Any]]` **DEFAULT:** `None`  
Source code in `fastapi/openapi/docs.py`
    
    
     26
     27
     28
     29
     30
     31
     32
     33
     34
     35
     36
     37
     38
     39
     40
     41
     42
     43
     44
     45
     46
     47
     48
     49
     50
     51
     52
     53
     54
     55
     56
     57
     58
     59
     60
     61
     62
     63
     64
     65
     66
     67
     68
     69
     70
     71
     72
     73
     74
     75
     76
     77
     78
     79
     80
     81
     82
     83
     84
     85
     86
     87
     88
     89
     90
     91
     92
     93
     94
     95
     96
     97
     98
     99
    100
    101
    102
    103
    104
    105
    106
    107
    108
    109
    110
    111
    112
    113
    114
    115
    116
    117
    118
    119
    120
    121
    122
    123
    124
    125
    126
    127
    128
    129
    130
    131
    132
    133
    134
    135
    136
    137
    138
    139
    140
    141
    142
    143
    144
    145
    146
    147
    148
    149
    150
    151
    152
    153
    154
    155
    156
    157
    158
    159
    160
    161
    162
    163
    164
    165
    166
    167
    168
    169
    170
    171
    172
    173
    174
    175
    176
    177
    178
    179
    180

| 
    
    
    def get_swagger_ui_html(
        *,
        openapi_url: Annotated[
            str,
            Doc(
                """
                The OpenAPI URL that Swagger UI should load and use.
    
                This is normally done automatically by FastAPI using the default URL
                `/openapi.json`.
    
                Read more about it in the
                [FastAPI docs for Conditional OpenAPI](https://fastapi.tiangolo.com/how-to/conditional-openapi/#conditional-openapi-from-settings-and-env-vars)
                """
            ),
        ],
        title: Annotated[
            str,
            Doc(
                """
                The HTML `<title>` content, normally shown in the browser tab.
    
                Read more about it in the
                [FastAPI docs for Custom Docs UI Static Assets](https://fastapi.tiangolo.com/how-to/custom-docs-ui-assets/)
                """
            ),
        ],
        swagger_js_url: Annotated[
            str,
            Doc(
                """
                The URL to use to load the Swagger UI JavaScript.
    
                It is normally set to a CDN URL.
    
                Read more about it in the
                [FastAPI docs for Custom Docs UI Static Assets](https://fastapi.tiangolo.com/how-to/custom-docs-ui-assets/)
                """
            ),
        ] = "https://cdn.jsdelivr.net/npm/swagger-ui-dist@5/swagger-ui-bundle.js",
        swagger_css_url: Annotated[
            str,
            Doc(
                """
                The URL to use to load the Swagger UI CSS.
    
                It is normally set to a CDN URL.
    
                Read more about it in the
                [FastAPI docs for Custom Docs UI Static Assets](https://fastapi.tiangolo.com/how-to/custom-docs-ui-assets/)
                """
            ),
        ] = "https://cdn.jsdelivr.net/npm/swagger-ui-dist@5/swagger-ui.css",
        swagger_favicon_url: Annotated[
            str,
            Doc(
                """
                The URL of the favicon to use. It is normally shown in the browser tab.
                """
            ),
        ] = "https://fastapi.tiangolo.com/img/favicon.png",
        oauth2_redirect_url: Annotated[
            Optional[str],
            Doc(
                """
                The OAuth2 redirect URL, it is normally automatically handled by FastAPI.
    
                Read more about it in the
                [FastAPI docs for Custom Docs UI Static Assets](https://fastapi.tiangolo.com/how-to/custom-docs-ui-assets/)
                """
            ),
        ] = None,
        init_oauth: Annotated[
            Optional[dict[str, Any]],
            Doc(
                """
                A dictionary with Swagger UI OAuth2 initialization configurations.
    
                Read more about the available configuration options in the
                [Swagger UI docs](https://swagger.io/docs/open-source-tools/swagger-ui/usage/oauth2/).
                """
            ),
        ] = None,
        swagger_ui_parameters: Annotated[
            Optional[dict[str, Any]],
            Doc(
                """
                Configuration parameters for Swagger UI.
    
                It defaults to [swagger_ui_default_parameters][fastapi.openapi.docs.swagger_ui_default_parameters].
    
                Read more about it in the
                [FastAPI docs about how to Configure Swagger UI](https://fastapi.tiangolo.com/how-to/configure-swagger-ui/).
                """
            ),
        ] = None,
    ) -> HTMLResponse:
        """
        Generate and return the HTML  that loads Swagger UI for the interactive
        API docs (normally served at `/docs`).
    
        You would only call this function yourself if you needed to override some parts,
        for example the URLs to use to load Swagger UI's JavaScript and CSS.
    
        Read more about it in the
        [FastAPI docs for Configure Swagger UI](https://fastapi.tiangolo.com/how-to/configure-swagger-ui/)
        and the [FastAPI docs for Custom Docs UI Static Assets (Self-Hosting)](https://fastapi.tiangolo.com/how-to/custom-docs-ui-assets/).
        """
        current_swagger_ui_parameters = swagger_ui_default_parameters.copy()
        if swagger_ui_parameters:
            current_swagger_ui_parameters.update(swagger_ui_parameters)
    
        html = f"""
        <!DOCTYPE html>
        <html>
        <head>
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link type="text/css" rel="stylesheet" href="{swagger_css_url}">
        <link rel="shortcut icon" href="{swagger_favicon_url}">
        <title>{title}</title>
        </head>
        <body>
        <div id="swagger-ui">
        </div>
        <script src="{swagger_js_url}"></script>
        <!-- `SwaggerUIBundle` is now available on the page -->
        <script>
        const ui = SwaggerUIBundle({{
            url: '{openapi_url}',
        """
    
        for key, value in current_swagger_ui_parameters.items():
            html += f"{json.dumps(key)}: {json.dumps(jsonable_encoder(value))},\n"
    
        if oauth2_redirect_url:
            html += f"oauth2RedirectUrl: window.location.origin + '{oauth2_redirect_url}',"
    
        html += """
        presets: [
            SwaggerUIBundle.presets.apis,
            SwaggerUIBundle.SwaggerUIStandalonePreset
            ],
        })"""
    
        if init_oauth:
            html += f"""
            ui.initOAuth({json.dumps(jsonable_encoder(init_oauth))})
            """
    
        html += """
        </script>
        </body>
        </html>
        """
        return HTMLResponse(html)
      
  
---|---  
  
##  `` fastapi.openapi.docs.get_redoc_html [¶](#fastapi.openapi.docs.get_redoc_html "Permanent link")
    
    
    get_redoc_html(
        *,
        openapi_url,
        title,
        redoc_js_url="https://cdn.jsdelivr.net/npm/redoc@2/bundles/redoc.standalone.js",
        redoc_favicon_url="https://fastapi.tiangolo.com/img/favicon.png",
        with_google_fonts=True
    )
    

Generate and return the HTML response that loads ReDoc for the alternative API docs (normally served at `/redoc`).

You would only call this function yourself if you needed to override some parts, for example the URLs to use to load ReDoc's JavaScript and CSS.

Read more about it in the [FastAPI docs for Custom Docs UI Static Assets (Self-Hosting)](https://fastapi.tiangolo.com/how-to/custom-docs-ui-assets/).

PARAMETER | DESCRIPTION  
---|---  
`openapi_url` |  The OpenAPI URL that ReDoc should load and use. This is normally done automatically by FastAPI using the default URL `/openapi.json`. Read more about it in the [FastAPI docs for Conditional OpenAPI](https://fastapi.tiangolo.com/how-to/conditional-openapi/#conditional-openapi-from-settings-and-env-vars) **TYPE:** `str`  
`title` |  The HTML `<title>` content, normally shown in the browser tab. Read more about it in the [FastAPI docs for Custom Docs UI Static Assets](https://fastapi.tiangolo.com/how-to/custom-docs-ui-assets/) **TYPE:** `str`  
`redoc_js_url` |  The URL to use to load the ReDoc JavaScript. It is normally set to a CDN URL. Read more about it in the [FastAPI docs for Custom Docs UI Static Assets](https://fastapi.tiangolo.com/how-to/custom-docs-ui-assets/) **TYPE:** `str` **DEFAULT:** `'https://cdn.jsdelivr.net/npm/redoc@2/bundles/redoc.standalone.js'`  
`redoc_favicon_url` |  The URL of the favicon to use. It is normally shown in the browser tab. **TYPE:** `str` **DEFAULT:** `'https://fastapi.tiangolo.com/img/favicon.png'`  
`with_google_fonts` |  Load and use Google Fonts. **TYPE:** `bool` **DEFAULT:** `True`  
Source code in `fastapi/openapi/docs.py`
    
    
    183
    184
    185
    186
    187
    188
    189
    190
    191
    192
    193
    194
    195
    196
    197
    198
    199
    200
    201
    202
    203
    204
    205
    206
    207
    208
    209
    210
    211
    212
    213
    214
    215
    216
    217
    218
    219
    220
    221
    222
    223
    224
    225
    226
    227
    228
    229
    230
    231
    232
    233
    234
    235
    236
    237
    238
    239
    240
    241
    242
    243
    244
    245
    246
    247
    248
    249
    250
    251
    252
    253
    254
    255
    256
    257
    258
    259
    260
    261
    262
    263
    264
    265
    266
    267
    268
    269
    270
    271
    272
    273
    274
    275
    276
    277
    278
    279
    280
    281
    282
    283
    284

| 
    
    
    def get_redoc_html(
        *,
        openapi_url: Annotated[
            str,
            Doc(
                """
                The OpenAPI URL that ReDoc should load and use.
    
                This is normally done automatically by FastAPI using the default URL
                `/openapi.json`.
    
                Read more about it in the
                [FastAPI docs for Conditional OpenAPI](https://fastapi.tiangolo.com/how-to/conditional-openapi/#conditional-openapi-from-settings-and-env-vars)
                """
            ),
        ],
        title: Annotated[
            str,
            Doc(
                """
                The HTML `<title>` content, normally shown in the browser tab.
    
                Read more about it in the
                [FastAPI docs for Custom Docs UI Static Assets](https://fastapi.tiangolo.com/how-to/custom-docs-ui-assets/)
                """
            ),
        ],
        redoc_js_url: Annotated[
            str,
            Doc(
                """
                The URL to use to load the ReDoc JavaScript.
    
                It is normally set to a CDN URL.
    
                Read more about it in the
                [FastAPI docs for Custom Docs UI Static Assets](https://fastapi.tiangolo.com/how-to/custom-docs-ui-assets/)
                """
            ),
        ] = "https://cdn.jsdelivr.net/npm/redoc@2/bundles/redoc.standalone.js",
        redoc_favicon_url: Annotated[
            str,
            Doc(
                """
                The URL of the favicon to use. It is normally shown in the browser tab.
                """
            ),
        ] = "https://fastapi.tiangolo.com/img/favicon.png",
        with_google_fonts: Annotated[
            bool,
            Doc(
                """
                Load and use Google Fonts.
                """
            ),
        ] = True,
    ) -> HTMLResponse:
        """
        Generate and return the HTML response that loads ReDoc for the alternative
        API docs (normally served at `/redoc`).
    
        You would only call this function yourself if you needed to override some parts,
        for example the URLs to use to load ReDoc's JavaScript and CSS.
    
        Read more about it in the
        [FastAPI docs for Custom Docs UI Static Assets (Self-Hosting)](https://fastapi.tiangolo.com/how-to/custom-docs-ui-assets/).
        """
        html = f"""
        <!DOCTYPE html>
        <html>
        <head>
        <title>{title}</title>
        <!-- needed for adaptive design -->
        <meta charset="utf-8"/>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        """
        if with_google_fonts:
            html += """
        <link href="https://fonts.googleapis.com/css?family=Montserrat:300,400,700|Roboto:300,400,700" rel="stylesheet">
        """
        html += f"""
        <link rel="shortcut icon" href="{redoc_favicon_url}">
        <!--
        ReDoc doesn't change outer page styles
        -->
        <style>
          body {{
            margin: 0;
            padding: 0;
          }}
        </style>
        </head>
        <body>
        <noscript>
            ReDoc requires Javascript to function. Please enable it to browse the documentation.
        </noscript>
        <redoc spec-url="{openapi_url}"></redoc>
        <script src="{redoc_js_url}"> </script>
        </body>
        </html>
        """
        return HTMLResponse(html)
      
  
---|---  
  
##  `` fastapi.openapi.docs.get_swagger_ui_oauth2_redirect_html [¶](#fastapi.openapi.docs.get_swagger_ui_oauth2_redirect_html "Permanent link")
    
    
    get_swagger_ui_oauth2_redirect_html()
    

Generate the HTML response with the OAuth2 redirection for Swagger UI.

You normally don't need to use or change this.

Source code in `fastapi/openapi/docs.py`
    
    
    287
    288
    289
    290
    291
    292
    293
    294
    295
    296
    297
    298
    299
    300
    301
    302
    303
    304
    305
    306
    307
    308
    309
    310
    311
    312
    313
    314
    315
    316
    317
    318
    319
    320
    321
    322
    323
    324
    325
    326
    327
    328
    329
    330
    331
    332
    333
    334
    335
    336
    337
    338
    339
    340
    341
    342
    343
    344
    345
    346
    347
    348
    349
    350
    351
    352
    353
    354
    355
    356
    357
    358
    359
    360
    361
    362
    363
    364
    365
    366
    367
    368
    369
    370
    371
    372
    373
    374
    375

| 
    
    
    def get_swagger_ui_oauth2_redirect_html() -> HTMLResponse:
        """
        Generate the HTML response with the OAuth2 redirection for Swagger UI.
    
        You normally don't need to use or change this.
        """
        # copied from https://github.com/swagger-api/swagger-ui/blob/v4.14.0/dist/oauth2-redirect.html
        html = """
        <!doctype html>
        <html lang="en-US">
        <head>
            <title>Swagger UI: OAuth2 Redirect</title>
        </head>
        <body>
        <script>
            'use strict';
            function run () {
                var oauth2 = window.opener.swaggerUIRedirectOauth2;
                var sentState = oauth2.state;
                var redirectUrl = oauth2.redirectUrl;
                var isValid, qp, arr;
    
                if (/code|token|error/.test(window.location.hash)) {
                    qp = window.location.hash.substring(1).replace('?', '&');
                } else {
                    qp = location.search.substring(1);
                }
    
                arr = qp.split("&");
                arr.forEach(function (v,i,_arr) { _arr[i] = '"' + v.replace('=', '":"') + '"';});
                qp = qp ? JSON.parse('{' + arr.join() + '}',
                        function (key, value) {
                            return key === "" ? value : decodeURIComponent(value);
                        }
                ) : {};
    
                isValid = qp.state === sentState;
    
                if ((
                  oauth2.auth.schema.get("flow") === "accessCode" ||
                  oauth2.auth.schema.get("flow") === "authorizationCode" ||
                  oauth2.auth.schema.get("flow") === "authorization_code"
                ) && !oauth2.auth.code) {
                    if (!isValid) {
                        oauth2.errCb({
                            authId: oauth2.auth.name,
                            source: "auth",
                            level: "warning",
                            message: "Authorization may be unsafe, passed state was changed in server. The passed state wasn't returned from auth server."
                        });
                    }
    
                    if (qp.code) {
                        delete oauth2.state;
                        oauth2.auth.code = qp.code;
                        oauth2.callback({auth: oauth2.auth, redirectUrl: redirectUrl});
                    } else {
                        let oauthErrorMsg;
                        if (qp.error) {
                            oauthErrorMsg = "["+qp.error+"]: " +
                                (qp.error_description ? qp.error_description+ ". " : "no accessCode received from the server. ") +
                                (qp.error_uri ? "More info: "+qp.error_uri : "");
                        }
    
                        oauth2.errCb({
                            authId: oauth2.auth.name,
                            source: "auth",
                            level: "error",
                            message: oauthErrorMsg || "[Authorization failed]: no accessCode received from the server."
                        });
                    }
                } else {
                    oauth2.callback({auth: oauth2.auth, token: qp, isValid: isValid, redirectUrl: redirectUrl});
                }
                window.close();
            }
    
            if (document.readyState !== 'loading') {
                run();
            } else {
                document.addEventListener('DOMContentLoaded', function () {
                    run();
                });
            }
        </script>
        </body>
        </html>
            """
        return HTMLResponse(content=html)
      
  
---|---  
  
##  `` fastapi.openapi.docs.swagger_ui_default_parameters `module-attribute` [¶](#fastapi.openapi.docs.swagger_ui_default_parameters "Permanent link")
    
    
    swagger_ui_default_parameters = {
        "dom_id": "#swagger-ui",
        "layout": "BaseLayout",
        "deepLinking": True,
        "showExtensions": True,
        "showCommonExtensions": True,
    }
    

Default configurations for Swagger UI.

You can use it as a template to add any other configurations needed.

---

###### OpenAPImodels¶

# OpenAPI `models`[¶](#openapi-models "Permanent link")

OpenAPI Pydantic models used to generate and validate the generated OpenAPI.

##  `` fastapi.openapi.models [¶](#fastapi.openapi.models "Permanent link")

###  `` SchemaType `module-attribute` [¶](#fastapi.openapi.models.SchemaType "Permanent link")
    
    
    SchemaType = Literal[
        "array",
        "boolean",
        "integer",
        "null",
        "number",
        "object",
        "string",
    ]
    

###  `` SchemaOrBool `module-attribute` [¶](#fastapi.openapi.models.SchemaOrBool "Permanent link")
    
    
    SchemaOrBool = Union[[Schema](#fastapi.openapi.models.Schema "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">Schema</span> \(<code>fastapi.openapi.models.Schema</code>\)"), bool]
    

###  `` SecurityScheme `module-attribute` [¶](#fastapi.openapi.models.SecurityScheme "Permanent link")
    
    
    SecurityScheme = Union[
        [APIKey](#fastapi.openapi.models.APIKey "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">APIKey</span> \(<code>fastapi.openapi.models.APIKey</code>\)"), [HTTPBase](#fastapi.openapi.models.HTTPBase "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">HTTPBase</span> \(<code>fastapi.openapi.models.HTTPBase</code>\)"), [OAuth2](#fastapi.openapi.models.OAuth2 "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">OAuth2</span> \(<code>fastapi.openapi.models.OAuth2</code>\)"), [OpenIdConnect](#fastapi.openapi.models.OpenIdConnect "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">OpenIdConnect</span> \(<code>fastapi.openapi.models.OpenIdConnect</code>\)"), [HTTPBearer](#fastapi.openapi.models.HTTPBearer "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">HTTPBearer</span> \(<code>fastapi.openapi.models.HTTPBearer</code>\)")
    ]
    

###  `` BaseModelWithConfig [¶](#fastapi.openapi.models.BaseModelWithConfig "Permanent link")

Bases: `BaseModel`

####  `` model_config `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.BaseModelWithConfig.model_config "Permanent link")
    
    
    model_config = {'extra': 'allow'}
    

###  `` Contact [¶](#fastapi.openapi.models.Contact "Permanent link")

Bases: `[BaseModelWithConfig](#fastapi.openapi.models.BaseModelWithConfig "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">BaseModelWithConfig</span> \(<code>fastapi.openapi.models.BaseModelWithConfig</code>\)")`

####  `` name `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Contact.name "Permanent link")
    
    
    name = None
    

####  `` url `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Contact.url "Permanent link")
    
    
    url = None
    

####  `` email `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Contact.email "Permanent link")
    
    
    email = None
    

####  `` model_config `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Contact.model_config "Permanent link")
    
    
    model_config = {'extra': 'allow'}
    

###  `` License [¶](#fastapi.openapi.models.License "Permanent link")

Bases: `[BaseModelWithConfig](#fastapi.openapi.models.BaseModelWithConfig "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">BaseModelWithConfig</span> \(<code>fastapi.openapi.models.BaseModelWithConfig</code>\)")`

####  `` name `instance-attribute` [¶](#fastapi.openapi.models.License.name "Permanent link")
    
    
    name
    

####  `` identifier `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.License.identifier "Permanent link")
    
    
    identifier = None
    

####  `` url `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.License.url "Permanent link")
    
    
    url = None
    

####  `` model_config `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.License.model_config "Permanent link")
    
    
    model_config = {'extra': 'allow'}
    

###  `` Info [¶](#fastapi.openapi.models.Info "Permanent link")

Bases: `[BaseModelWithConfig](#fastapi.openapi.models.BaseModelWithConfig "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">BaseModelWithConfig</span> \(<code>fastapi.openapi.models.BaseModelWithConfig</code>\)")`

####  `` title `instance-attribute` [¶](#fastapi.openapi.models.Info.title "Permanent link")
    
    
    title
    

####  `` summary `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Info.summary "Permanent link")
    
    
    summary = None
    

####  `` description `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Info.description "Permanent link")
    
    
    description = None
    

####  `` termsOfService `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Info.termsOfService "Permanent link")
    
    
    termsOfService = None
    

####  `` contact `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Info.contact "Permanent link")
    
    
    contact = None
    

####  `` license `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Info.license "Permanent link")
    
    
    license = None
    

####  `` version `instance-attribute` [¶](#fastapi.openapi.models.Info.version "Permanent link")
    
    
    version
    

####  `` model_config `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Info.model_config "Permanent link")
    
    
    model_config = {'extra': 'allow'}
    

###  `` ServerVariable [¶](#fastapi.openapi.models.ServerVariable "Permanent link")

Bases: `[BaseModelWithConfig](#fastapi.openapi.models.BaseModelWithConfig "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">BaseModelWithConfig</span> \(<code>fastapi.openapi.models.BaseModelWithConfig</code>\)")`

####  `` enum `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.ServerVariable.enum "Permanent link")
    
    
    enum = None
    

####  `` default `instance-attribute` [¶](#fastapi.openapi.models.ServerVariable.default "Permanent link")
    
    
    default
    

####  `` description `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.ServerVariable.description "Permanent link")
    
    
    description = None
    

####  `` model_config `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.ServerVariable.model_config "Permanent link")
    
    
    model_config = {'extra': 'allow'}
    

###  `` Server [¶](#fastapi.openapi.models.Server "Permanent link")

Bases: `[BaseModelWithConfig](#fastapi.openapi.models.BaseModelWithConfig "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">BaseModelWithConfig</span> \(<code>fastapi.openapi.models.BaseModelWithConfig</code>\)")`

####  `` url `instance-attribute` [¶](#fastapi.openapi.models.Server.url "Permanent link")
    
    
    url
    

####  `` description `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Server.description "Permanent link")
    
    
    description = None
    

####  `` variables `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Server.variables "Permanent link")
    
    
    variables = None
    

####  `` model_config `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Server.model_config "Permanent link")
    
    
    model_config = {'extra': 'allow'}
    

###  `` Reference [¶](#fastapi.openapi.models.Reference "Permanent link")

Bases: `BaseModel`

####  `` ref `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Reference.ref "Permanent link")
    
    
    ref = Field(alias='$ref')
    

###  `` Discriminator [¶](#fastapi.openapi.models.Discriminator "Permanent link")

Bases: `BaseModel`

####  `` propertyName `instance-attribute` [¶](#fastapi.openapi.models.Discriminator.propertyName "Permanent link")
    
    
    propertyName
    

####  `` mapping `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Discriminator.mapping "Permanent link")
    
    
    mapping = None
    

###  `` XML [¶](#fastapi.openapi.models.XML "Permanent link")

Bases: `[BaseModelWithConfig](#fastapi.openapi.models.BaseModelWithConfig "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">BaseModelWithConfig</span> \(<code>fastapi.openapi.models.BaseModelWithConfig</code>\)")`

####  `` name `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.XML.name "Permanent link")
    
    
    name = None
    

####  `` namespace `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.XML.namespace "Permanent link")
    
    
    namespace = None
    

####  `` prefix `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.XML.prefix "Permanent link")
    
    
    prefix = None
    

####  `` attribute `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.XML.attribute "Permanent link")
    
    
    attribute = None
    

####  `` wrapped `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.XML.wrapped "Permanent link")
    
    
    wrapped = None
    

####  `` model_config `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.XML.model_config "Permanent link")
    
    
    model_config = {'extra': 'allow'}
    

###  `` ExternalDocumentation [¶](#fastapi.openapi.models.ExternalDocumentation "Permanent link")

Bases: `[BaseModelWithConfig](#fastapi.openapi.models.BaseModelWithConfig "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">BaseModelWithConfig</span> \(<code>fastapi.openapi.models.BaseModelWithConfig</code>\)")`

####  `` description `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.ExternalDocumentation.description "Permanent link")
    
    
    description = None
    

####  `` url `instance-attribute` [¶](#fastapi.openapi.models.ExternalDocumentation.url "Permanent link")
    
    
    url
    

####  `` model_config `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.ExternalDocumentation.model_config "Permanent link")
    
    
    model_config = {'extra': 'allow'}
    

###  `` Schema [¶](#fastapi.openapi.models.Schema "Permanent link")

Bases: `[BaseModelWithConfig](#fastapi.openapi.models.BaseModelWithConfig "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">BaseModelWithConfig</span> \(<code>fastapi.openapi.models.BaseModelWithConfig</code>\)")`

####  `` schema_ `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Schema.schema_ "Permanent link")
    
    
    schema_ = Field(default=None, alias='$schema')
    

####  `` vocabulary `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Schema.vocabulary "Permanent link")
    
    
    vocabulary = Field(default=None, alias='$vocabulary')
    

####  `` id `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Schema.id "Permanent link")
    
    
    id = Field(default=None, alias='$id')
    

####  `` anchor `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Schema.anchor "Permanent link")
    
    
    anchor = Field(default=None, alias='$anchor')
    

####  `` dynamicAnchor `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Schema.dynamicAnchor "Permanent link")
    
    
    dynamicAnchor = Field(default=None, alias='$dynamicAnchor')
    

####  `` ref `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Schema.ref "Permanent link")
    
    
    ref = Field(default=None, alias='$ref')
    

####  `` dynamicRef `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Schema.dynamicRef "Permanent link")
    
    
    dynamicRef = Field(default=None, alias='$dynamicRef')
    

####  `` defs `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Schema.defs "Permanent link")
    
    
    defs = Field(default=None, alias='$defs')
    

####  `` comment `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Schema.comment "Permanent link")
    
    
    comment = Field(default=None, alias='$comment')
    

####  `` allOf `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Schema.allOf "Permanent link")
    
    
    allOf = None
    

####  `` anyOf `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Schema.anyOf "Permanent link")
    
    
    anyOf = None
    

####  `` oneOf `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Schema.oneOf "Permanent link")
    
    
    oneOf = None
    

####  `` not_ `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Schema.not_ "Permanent link")
    
    
    not_ = Field(default=None, alias='not')
    

####  `` if_ `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Schema.if_ "Permanent link")
    
    
    if_ = Field(default=None, alias='if')
    

####  `` then `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Schema.then "Permanent link")
    
    
    then = None
    

####  `` else_ `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Schema.else_ "Permanent link")
    
    
    else_ = Field(default=None, alias='else')
    

####  `` dependentSchemas `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Schema.dependentSchemas "Permanent link")
    
    
    dependentSchemas = None
    

####  `` prefixItems `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Schema.prefixItems "Permanent link")
    
    
    prefixItems = None
    

####  `` items `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Schema.items "Permanent link")
    
    
    items = None
    

####  `` contains `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Schema.contains "Permanent link")
    
    
    contains = None
    

####  `` properties `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Schema.properties "Permanent link")
    
    
    properties = None
    

####  `` patternProperties `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Schema.patternProperties "Permanent link")
    
    
    patternProperties = None
    

####  `` additionalProperties `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Schema.additionalProperties "Permanent link")
    
    
    additionalProperties = None
    

####  `` propertyNames `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Schema.propertyNames "Permanent link")
    
    
    propertyNames = None
    

####  `` unevaluatedItems `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Schema.unevaluatedItems "Permanent link")
    
    
    unevaluatedItems = None
    

####  `` unevaluatedProperties `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Schema.unevaluatedProperties "Permanent link")
    
    
    unevaluatedProperties = None
    

####  `` type `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Schema.type "Permanent link")
    
    
    type = None
    

####  `` enum `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Schema.enum "Permanent link")
    
    
    enum = None
    

####  `` const `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Schema.const "Permanent link")
    
    
    const = None
    

####  `` multipleOf `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Schema.multipleOf "Permanent link")
    
    
    multipleOf = Field(default=None, gt=0)
    

####  `` maximum `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Schema.maximum "Permanent link")
    
    
    maximum = None
    

####  `` exclusiveMaximum `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Schema.exclusiveMaximum "Permanent link")
    
    
    exclusiveMaximum = None
    

####  `` minimum `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Schema.minimum "Permanent link")
    
    
    minimum = None
    

####  `` exclusiveMinimum `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Schema.exclusiveMinimum "Permanent link")
    
    
    exclusiveMinimum = None
    

####  `` maxLength `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Schema.maxLength "Permanent link")
    
    
    maxLength = Field(default=None, ge=0)
    

####  `` minLength `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Schema.minLength "Permanent link")
    
    
    minLength = Field(default=None, ge=0)
    

####  `` pattern `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Schema.pattern "Permanent link")
    
    
    pattern = None
    

####  `` maxItems `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Schema.maxItems "Permanent link")
    
    
    maxItems = Field(default=None, ge=0)
    

####  `` minItems `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Schema.minItems "Permanent link")
    
    
    minItems = Field(default=None, ge=0)
    

####  `` uniqueItems `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Schema.uniqueItems "Permanent link")
    
    
    uniqueItems = None
    

####  `` maxContains `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Schema.maxContains "Permanent link")
    
    
    maxContains = Field(default=None, ge=0)
    

####  `` minContains `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Schema.minContains "Permanent link")
    
    
    minContains = Field(default=None, ge=0)
    

####  `` maxProperties `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Schema.maxProperties "Permanent link")
    
    
    maxProperties = Field(default=None, ge=0)
    

####  `` minProperties `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Schema.minProperties "Permanent link")
    
    
    minProperties = Field(default=None, ge=0)
    

####  `` required `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Schema.required "Permanent link")
    
    
    required = None
    

####  `` dependentRequired `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Schema.dependentRequired "Permanent link")
    
    
    dependentRequired = None
    

####  `` format `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Schema.format "Permanent link")
    
    
    format = None
    

####  `` contentEncoding `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Schema.contentEncoding "Permanent link")
    
    
    contentEncoding = None
    

####  `` contentMediaType `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Schema.contentMediaType "Permanent link")
    
    
    contentMediaType = None
    

####  `` contentSchema `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Schema.contentSchema "Permanent link")
    
    
    contentSchema = None
    

####  `` title `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Schema.title "Permanent link")
    
    
    title = None
    

####  `` description `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Schema.description "Permanent link")
    
    
    description = None
    

####  `` default `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Schema.default "Permanent link")
    
    
    default = None
    

####  `` deprecated `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Schema.deprecated "Permanent link")
    
    
    deprecated = None
    

####  `` readOnly `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Schema.readOnly "Permanent link")
    
    
    readOnly = None
    

####  `` writeOnly `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Schema.writeOnly "Permanent link")
    
    
    writeOnly = None
    

####  `` examples `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Schema.examples "Permanent link")
    
    
    examples = None
    

####  `` discriminator `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Schema.discriminator "Permanent link")
    
    
    discriminator = None
    

####  `` xml `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Schema.xml "Permanent link")
    
    
    xml = None
    

####  `` externalDocs `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Schema.externalDocs "Permanent link")
    
    
    externalDocs = None
    

####  `` example `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Schema.example "Permanent link")
    
    
    example = None
    

Deprecated in OpenAPI 3.1.0 that now uses JSON Schema 2020-12, although still supported. Use examples instead.

####  `` model_config `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Schema.model_config "Permanent link")
    
    
    model_config = {'extra': 'allow'}
    

###  `` Example [¶](#fastapi.openapi.models.Example "Permanent link")

Bases: `TypedDict`

####  `` summary `instance-attribute` [¶](#fastapi.openapi.models.Example.summary "Permanent link")
    
    
    summary
    

####  `` description `instance-attribute` [¶](#fastapi.openapi.models.Example.description "Permanent link")
    
    
    description
    

####  `` value `instance-attribute` [¶](#fastapi.openapi.models.Example.value "Permanent link")
    
    
    value
    

####  `` externalValue `instance-attribute` [¶](#fastapi.openapi.models.Example.externalValue "Permanent link")
    
    
    externalValue
    

###  `` ParameterInType [¶](#fastapi.openapi.models.ParameterInType "Permanent link")

Bases: `Enum`

####  `` query `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.ParameterInType.query "Permanent link")
    
    
    query = 'query'
    

####  `` header `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.ParameterInType.header "Permanent link")
    
    
    header = 'header'
    

####  `` path `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.ParameterInType.path "Permanent link")
    
    
    path = 'path'
    

####  `` cookie `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.ParameterInType.cookie "Permanent link")
    
    
    cookie = 'cookie'
    

###  `` Encoding [¶](#fastapi.openapi.models.Encoding "Permanent link")

Bases: `[BaseModelWithConfig](#fastapi.openapi.models.BaseModelWithConfig "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">BaseModelWithConfig</span> \(<code>fastapi.openapi.models.BaseModelWithConfig</code>\)")`

####  `` contentType `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Encoding.contentType "Permanent link")
    
    
    contentType = None
    

####  `` headers `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Encoding.headers "Permanent link")
    
    
    headers = None
    

####  `` style `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Encoding.style "Permanent link")
    
    
    style = None
    

####  `` explode `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Encoding.explode "Permanent link")
    
    
    explode = None
    

####  `` allowReserved `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Encoding.allowReserved "Permanent link")
    
    
    allowReserved = None
    

####  `` model_config `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Encoding.model_config "Permanent link")
    
    
    model_config = {'extra': 'allow'}
    

###  `` MediaType [¶](#fastapi.openapi.models.MediaType "Permanent link")

Bases: `[BaseModelWithConfig](#fastapi.openapi.models.BaseModelWithConfig "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">BaseModelWithConfig</span> \(<code>fastapi.openapi.models.BaseModelWithConfig</code>\)")`

####  `` schema_ `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.MediaType.schema_ "Permanent link")
    
    
    schema_ = Field(default=None, alias='schema')
    

####  `` example `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.MediaType.example "Permanent link")
    
    
    example = None
    

####  `` examples `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.MediaType.examples "Permanent link")
    
    
    examples = None
    

####  `` encoding `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.MediaType.encoding "Permanent link")
    
    
    encoding = None
    

####  `` model_config `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.MediaType.model_config "Permanent link")
    
    
    model_config = {'extra': 'allow'}
    

###  `` ParameterBase [¶](#fastapi.openapi.models.ParameterBase "Permanent link")

Bases: `[BaseModelWithConfig](#fastapi.openapi.models.BaseModelWithConfig "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">BaseModelWithConfig</span> \(<code>fastapi.openapi.models.BaseModelWithConfig</code>\)")`

####  `` description `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.ParameterBase.description "Permanent link")
    
    
    description = None
    

####  `` required `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.ParameterBase.required "Permanent link")
    
    
    required = None
    

####  `` deprecated `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.ParameterBase.deprecated "Permanent link")
    
    
    deprecated = None
    

####  `` style `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.ParameterBase.style "Permanent link")
    
    
    style = None
    

####  `` explode `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.ParameterBase.explode "Permanent link")
    
    
    explode = None
    

####  `` allowReserved `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.ParameterBase.allowReserved "Permanent link")
    
    
    allowReserved = None
    

####  `` schema_ `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.ParameterBase.schema_ "Permanent link")
    
    
    schema_ = Field(default=None, alias='schema')
    

####  `` example `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.ParameterBase.example "Permanent link")
    
    
    example = None
    

####  `` examples `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.ParameterBase.examples "Permanent link")
    
    
    examples = None
    

####  `` content `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.ParameterBase.content "Permanent link")
    
    
    content = None
    

####  `` model_config `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.ParameterBase.model_config "Permanent link")
    
    
    model_config = {'extra': 'allow'}
    

###  `` Parameter [¶](#fastapi.openapi.models.Parameter "Permanent link")

Bases: `[ParameterBase](#fastapi.openapi.models.ParameterBase "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">ParameterBase</span> \(<code>fastapi.openapi.models.ParameterBase</code>\)")`

####  `` name `instance-attribute` [¶](#fastapi.openapi.models.Parameter.name "Permanent link")
    
    
    name
    

####  `` in_ `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Parameter.in_ "Permanent link")
    
    
    in_ = Field(alias='in')
    

####  `` model_config `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Parameter.model_config "Permanent link")
    
    
    model_config = {'extra': 'allow'}
    

####  `` description `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Parameter.description "Permanent link")
    
    
    description = None
    

####  `` required `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Parameter.required "Permanent link")
    
    
    required = None
    

####  `` deprecated `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Parameter.deprecated "Permanent link")
    
    
    deprecated = None
    

####  `` style `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Parameter.style "Permanent link")
    
    
    style = None
    

####  `` explode `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Parameter.explode "Permanent link")
    
    
    explode = None
    

####  `` allowReserved `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Parameter.allowReserved "Permanent link")
    
    
    allowReserved = None
    

####  `` schema_ `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Parameter.schema_ "Permanent link")
    
    
    schema_ = Field(default=None, alias='schema')
    

####  `` example `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Parameter.example "Permanent link")
    
    
    example = None
    

####  `` examples `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Parameter.examples "Permanent link")
    
    
    examples = None
    

####  `` content `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Parameter.content "Permanent link")
    
    
    content = None
    

###  `` Header [¶](#fastapi.openapi.models.Header "Permanent link")

Bases: `[ParameterBase](#fastapi.openapi.models.ParameterBase "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">ParameterBase</span> \(<code>fastapi.openapi.models.ParameterBase</code>\)")`

####  `` model_config `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Header.model_config "Permanent link")
    
    
    model_config = {'extra': 'allow'}
    

####  `` description `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Header.description "Permanent link")
    
    
    description = None
    

####  `` required `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Header.required "Permanent link")
    
    
    required = None
    

####  `` deprecated `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Header.deprecated "Permanent link")
    
    
    deprecated = None
    

####  `` style `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Header.style "Permanent link")
    
    
    style = None
    

####  `` explode `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Header.explode "Permanent link")
    
    
    explode = None
    

####  `` allowReserved `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Header.allowReserved "Permanent link")
    
    
    allowReserved = None
    

####  `` schema_ `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Header.schema_ "Permanent link")
    
    
    schema_ = Field(default=None, alias='schema')
    

####  `` example `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Header.example "Permanent link")
    
    
    example = None
    

####  `` examples `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Header.examples "Permanent link")
    
    
    examples = None
    

####  `` content `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Header.content "Permanent link")
    
    
    content = None
    

###  `` RequestBody [¶](#fastapi.openapi.models.RequestBody "Permanent link")

Bases: `[BaseModelWithConfig](#fastapi.openapi.models.BaseModelWithConfig "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">BaseModelWithConfig</span> \(<code>fastapi.openapi.models.BaseModelWithConfig</code>\)")`

####  `` description `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.RequestBody.description "Permanent link")
    
    
    description = None
    

####  `` content `instance-attribute` [¶](#fastapi.openapi.models.RequestBody.content "Permanent link")
    
    
    content
    

####  `` required `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.RequestBody.required "Permanent link")
    
    
    required = None
    

####  `` model_config `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.RequestBody.model_config "Permanent link")
    
    
    model_config = {'extra': 'allow'}
    

###  `` Link [¶](#fastapi.openapi.models.Link "Permanent link")

Bases: `[BaseModelWithConfig](#fastapi.openapi.models.BaseModelWithConfig "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">BaseModelWithConfig</span> \(<code>fastapi.openapi.models.BaseModelWithConfig</code>\)")`

####  `` operationRef `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Link.operationRef "Permanent link")
    
    
    operationRef = None
    

####  `` operationId `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Link.operationId "Permanent link")
    
    
    operationId = None
    

####  `` parameters `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Link.parameters "Permanent link")
    
    
    parameters = None
    

####  `` requestBody `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Link.requestBody "Permanent link")
    
    
    requestBody = None
    

####  `` description `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Link.description "Permanent link")
    
    
    description = None
    

####  `` server `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Link.server "Permanent link")
    
    
    server = None
    

####  `` model_config `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Link.model_config "Permanent link")
    
    
    model_config = {'extra': 'allow'}
    

###  `` Response [¶](#fastapi.openapi.models.Response "Permanent link")

Bases: `[BaseModelWithConfig](#fastapi.openapi.models.BaseModelWithConfig "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">BaseModelWithConfig</span> \(<code>fastapi.openapi.models.BaseModelWithConfig</code>\)")`

####  `` description `instance-attribute` [¶](#fastapi.openapi.models.Response.description "Permanent link")
    
    
    description
    

####  `` headers `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Response.headers "Permanent link")
    
    
    headers = None
    

####  `` content `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Response.content "Permanent link")
    
    
    content = None
    

####  `` links `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Response.links "Permanent link")
    
    
    links = None
    

####  `` model_config `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Response.model_config "Permanent link")
    
    
    model_config = {'extra': 'allow'}
    

###  `` Operation [¶](#fastapi.openapi.models.Operation "Permanent link")

Bases: `[BaseModelWithConfig](#fastapi.openapi.models.BaseModelWithConfig "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">BaseModelWithConfig</span> \(<code>fastapi.openapi.models.BaseModelWithConfig</code>\)")`

####  `` tags `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Operation.tags "Permanent link")
    
    
    tags = None
    

####  `` summary `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Operation.summary "Permanent link")
    
    
    summary = None
    

####  `` description `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Operation.description "Permanent link")
    
    
    description = None
    

####  `` externalDocs `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Operation.externalDocs "Permanent link")
    
    
    externalDocs = None
    

####  `` operationId `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Operation.operationId "Permanent link")
    
    
    operationId = None
    

####  `` parameters `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Operation.parameters "Permanent link")
    
    
    parameters = None
    

####  `` requestBody `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Operation.requestBody "Permanent link")
    
    
    requestBody = None
    

####  `` responses `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Operation.responses "Permanent link")
    
    
    responses = None
    

####  `` callbacks `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Operation.callbacks "Permanent link")
    
    
    callbacks = None
    

####  `` deprecated `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Operation.deprecated "Permanent link")
    
    
    deprecated = None
    

####  `` security `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Operation.security "Permanent link")
    
    
    security = None
    

####  `` servers `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Operation.servers "Permanent link")
    
    
    servers = None
    

####  `` model_config `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Operation.model_config "Permanent link")
    
    
    model_config = {'extra': 'allow'}
    

###  `` PathItem [¶](#fastapi.openapi.models.PathItem "Permanent link")

Bases: `[BaseModelWithConfig](#fastapi.openapi.models.BaseModelWithConfig "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">BaseModelWithConfig</span> \(<code>fastapi.openapi.models.BaseModelWithConfig</code>\)")`

####  `` ref `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.PathItem.ref "Permanent link")
    
    
    ref = Field(default=None, alias='$ref')
    

####  `` summary `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.PathItem.summary "Permanent link")
    
    
    summary = None
    

####  `` description `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.PathItem.description "Permanent link")
    
    
    description = None
    

####  `` get `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.PathItem.get "Permanent link")
    
    
    get = None
    

####  `` put `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.PathItem.put "Permanent link")
    
    
    put = None
    

####  `` post `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.PathItem.post "Permanent link")
    
    
    post = None
    

####  `` delete `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.PathItem.delete "Permanent link")
    
    
    delete = None
    

####  `` options `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.PathItem.options "Permanent link")
    
    
    options = None
    

####  `` head `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.PathItem.head "Permanent link")
    
    
    head = None
    

####  `` patch `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.PathItem.patch "Permanent link")
    
    
    patch = None
    

####  `` trace `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.PathItem.trace "Permanent link")
    
    
    trace = None
    

####  `` servers `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.PathItem.servers "Permanent link")
    
    
    servers = None
    

####  `` parameters `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.PathItem.parameters "Permanent link")
    
    
    parameters = None
    

####  `` model_config `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.PathItem.model_config "Permanent link")
    
    
    model_config = {'extra': 'allow'}
    

###  `` SecuritySchemeType [¶](#fastapi.openapi.models.SecuritySchemeType "Permanent link")

Bases: `Enum`

####  `` apiKey `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.SecuritySchemeType.apiKey "Permanent link")
    
    
    apiKey = 'apiKey'
    

####  `` http `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.SecuritySchemeType.http "Permanent link")
    
    
    http = 'http'
    

####  `` oauth2 `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.SecuritySchemeType.oauth2 "Permanent link")
    
    
    oauth2 = 'oauth2'
    

####  `` openIdConnect `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.SecuritySchemeType.openIdConnect "Permanent link")
    
    
    openIdConnect = 'openIdConnect'
    

###  `` SecurityBase [¶](#fastapi.openapi.models.SecurityBase "Permanent link")

Bases: `[BaseModelWithConfig](#fastapi.openapi.models.BaseModelWithConfig "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">BaseModelWithConfig</span> \(<code>fastapi.openapi.models.BaseModelWithConfig</code>\)")`

####  `` type_ `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.SecurityBase.type_ "Permanent link")
    
    
    type_ = Field(alias='type')
    

####  `` description `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.SecurityBase.description "Permanent link")
    
    
    description = None
    

####  `` model_config `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.SecurityBase.model_config "Permanent link")
    
    
    model_config = {'extra': 'allow'}
    

###  `` APIKeyIn [¶](#fastapi.openapi.models.APIKeyIn "Permanent link")

Bases: `Enum`

####  `` query `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.APIKeyIn.query "Permanent link")
    
    
    query = 'query'
    

####  `` header `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.APIKeyIn.header "Permanent link")
    
    
    header = 'header'
    

####  `` cookie `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.APIKeyIn.cookie "Permanent link")
    
    
    cookie = 'cookie'
    

###  `` APIKey [¶](#fastapi.openapi.models.APIKey "Permanent link")

Bases: `[SecurityBase](#fastapi.openapi.models.SecurityBase "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">SecurityBase</span> \(<code>fastapi.openapi.models.SecurityBase</code>\)")`

####  `` type_ `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.APIKey.type_ "Permanent link")
    
    
    type_ = Field(default=[apiKey](#fastapi.openapi.models.SecuritySchemeType.apiKey "<code class="doc-symbol doc-symbol-heading doc-symbol-attribute"></code>            <span class="doc doc-object-name doc-attribute-name">apiKey</span>
    
    
      <span class="doc doc-labels">
          <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
          <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
      </span> \(<code>fastapi.openapi.models.SecuritySchemeType.apiKey</code>\)"), alias='type')
    

####  `` in_ `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.APIKey.in_ "Permanent link")
    
    
    in_ = Field(alias='in')
    

####  `` name `instance-attribute` [¶](#fastapi.openapi.models.APIKey.name "Permanent link")
    
    
    name
    

####  `` model_config `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.APIKey.model_config "Permanent link")
    
    
    model_config = {'extra': 'allow'}
    

####  `` description `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.APIKey.description "Permanent link")
    
    
    description = None
    

###  `` HTTPBase [¶](#fastapi.openapi.models.HTTPBase "Permanent link")

Bases: `[SecurityBase](#fastapi.openapi.models.SecurityBase "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">SecurityBase</span> \(<code>fastapi.openapi.models.SecurityBase</code>\)")`

####  `` type_ `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.HTTPBase.type_ "Permanent link")
    
    
    type_ = Field(default=[http](#fastapi.openapi.models.SecuritySchemeType.http "<code class="doc-symbol doc-symbol-heading doc-symbol-attribute"></code>            <span class="doc doc-object-name doc-attribute-name">http</span>
    
    
      <span class="doc doc-labels">
          <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
          <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
      </span> \(<code>fastapi.openapi.models.SecuritySchemeType.http</code>\)"), alias='type')
    

####  `` scheme `instance-attribute` [¶](#fastapi.openapi.models.HTTPBase.scheme "Permanent link")
    
    
    scheme
    

####  `` model_config `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.HTTPBase.model_config "Permanent link")
    
    
    model_config = {'extra': 'allow'}
    

####  `` description `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.HTTPBase.description "Permanent link")
    
    
    description = None
    

###  `` HTTPBearer [¶](#fastapi.openapi.models.HTTPBearer "Permanent link")

Bases: `[HTTPBase](#fastapi.openapi.models.HTTPBase "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">HTTPBase</span> \(<code>fastapi.openapi.models.HTTPBase</code>\)")`

####  `` scheme `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.HTTPBearer.scheme "Permanent link")
    
    
    scheme = 'bearer'
    

####  `` bearerFormat `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.HTTPBearer.bearerFormat "Permanent link")
    
    
    bearerFormat = None
    

####  `` model_config `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.HTTPBearer.model_config "Permanent link")
    
    
    model_config = {'extra': 'allow'}
    

####  `` type_ `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.HTTPBearer.type_ "Permanent link")
    
    
    type_ = Field(default=[http](#fastapi.openapi.models.SecuritySchemeType.http "<code class="doc-symbol doc-symbol-heading doc-symbol-attribute"></code>            <span class="doc doc-object-name doc-attribute-name">http</span>
    
    
      <span class="doc doc-labels">
          <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
          <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
      </span> \(<code>fastapi.openapi.models.SecuritySchemeType.http</code>\)"), alias='type')
    

####  `` description `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.HTTPBearer.description "Permanent link")
    
    
    description = None
    

###  `` OAuthFlow [¶](#fastapi.openapi.models.OAuthFlow "Permanent link")

Bases: `[BaseModelWithConfig](#fastapi.openapi.models.BaseModelWithConfig "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">BaseModelWithConfig</span> \(<code>fastapi.openapi.models.BaseModelWithConfig</code>\)")`

####  `` refreshUrl `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.OAuthFlow.refreshUrl "Permanent link")
    
    
    refreshUrl = None
    

####  `` scopes `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.OAuthFlow.scopes "Permanent link")
    
    
    scopes = {}
    

####  `` model_config `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.OAuthFlow.model_config "Permanent link")
    
    
    model_config = {'extra': 'allow'}
    

###  `` OAuthFlowImplicit [¶](#fastapi.openapi.models.OAuthFlowImplicit "Permanent link")

Bases: `[OAuthFlow](#fastapi.openapi.models.OAuthFlow "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">OAuthFlow</span> \(<code>fastapi.openapi.models.OAuthFlow</code>\)")`

####  `` authorizationUrl `instance-attribute` [¶](#fastapi.openapi.models.OAuthFlowImplicit.authorizationUrl "Permanent link")
    
    
    authorizationUrl
    

####  `` model_config `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.OAuthFlowImplicit.model_config "Permanent link")
    
    
    model_config = {'extra': 'allow'}
    

####  `` refreshUrl `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.OAuthFlowImplicit.refreshUrl "Permanent link")
    
    
    refreshUrl = None
    

####  `` scopes `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.OAuthFlowImplicit.scopes "Permanent link")
    
    
    scopes = {}
    

###  `` OAuthFlowPassword [¶](#fastapi.openapi.models.OAuthFlowPassword "Permanent link")

Bases: `[OAuthFlow](#fastapi.openapi.models.OAuthFlow "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">OAuthFlow</span> \(<code>fastapi.openapi.models.OAuthFlow</code>\)")`

####  `` tokenUrl `instance-attribute` [¶](#fastapi.openapi.models.OAuthFlowPassword.tokenUrl "Permanent link")
    
    
    tokenUrl
    

####  `` model_config `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.OAuthFlowPassword.model_config "Permanent link")
    
    
    model_config = {'extra': 'allow'}
    

####  `` refreshUrl `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.OAuthFlowPassword.refreshUrl "Permanent link")
    
    
    refreshUrl = None
    

####  `` scopes `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.OAuthFlowPassword.scopes "Permanent link")
    
    
    scopes = {}
    

###  `` OAuthFlowClientCredentials [¶](#fastapi.openapi.models.OAuthFlowClientCredentials "Permanent link")

Bases: `[OAuthFlow](#fastapi.openapi.models.OAuthFlow "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">OAuthFlow</span> \(<code>fastapi.openapi.models.OAuthFlow</code>\)")`

####  `` tokenUrl `instance-attribute` [¶](#fastapi.openapi.models.OAuthFlowClientCredentials.tokenUrl "Permanent link")
    
    
    tokenUrl
    

####  `` model_config `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.OAuthFlowClientCredentials.model_config "Permanent link")
    
    
    model_config = {'extra': 'allow'}
    

####  `` refreshUrl `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.OAuthFlowClientCredentials.refreshUrl "Permanent link")
    
    
    refreshUrl = None
    

####  `` scopes `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.OAuthFlowClientCredentials.scopes "Permanent link")
    
    
    scopes = {}
    

###  `` OAuthFlowAuthorizationCode [¶](#fastapi.openapi.models.OAuthFlowAuthorizationCode "Permanent link")

Bases: `[OAuthFlow](#fastapi.openapi.models.OAuthFlow "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">OAuthFlow</span> \(<code>fastapi.openapi.models.OAuthFlow</code>\)")`

####  `` authorizationUrl `instance-attribute` [¶](#fastapi.openapi.models.OAuthFlowAuthorizationCode.authorizationUrl "Permanent link")
    
    
    authorizationUrl
    

####  `` tokenUrl `instance-attribute` [¶](#fastapi.openapi.models.OAuthFlowAuthorizationCode.tokenUrl "Permanent link")
    
    
    tokenUrl
    

####  `` model_config `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.OAuthFlowAuthorizationCode.model_config "Permanent link")
    
    
    model_config = {'extra': 'allow'}
    

####  `` refreshUrl `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.OAuthFlowAuthorizationCode.refreshUrl "Permanent link")
    
    
    refreshUrl = None
    

####  `` scopes `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.OAuthFlowAuthorizationCode.scopes "Permanent link")
    
    
    scopes = {}
    

###  `` OAuthFlows [¶](#fastapi.openapi.models.OAuthFlows "Permanent link")

Bases: `[BaseModelWithConfig](#fastapi.openapi.models.BaseModelWithConfig "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">BaseModelWithConfig</span> \(<code>fastapi.openapi.models.BaseModelWithConfig</code>\)")`

####  `` implicit `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.OAuthFlows.implicit "Permanent link")
    
    
    implicit = None
    

####  `` password `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.OAuthFlows.password "Permanent link")
    
    
    password = None
    

####  `` clientCredentials `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.OAuthFlows.clientCredentials "Permanent link")
    
    
    clientCredentials = None
    

####  `` authorizationCode `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.OAuthFlows.authorizationCode "Permanent link")
    
    
    authorizationCode = None
    

####  `` model_config `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.OAuthFlows.model_config "Permanent link")
    
    
    model_config = {'extra': 'allow'}
    

###  `` OAuth2 [¶](#fastapi.openapi.models.OAuth2 "Permanent link")

Bases: `[SecurityBase](#fastapi.openapi.models.SecurityBase "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">SecurityBase</span> \(<code>fastapi.openapi.models.SecurityBase</code>\)")`

####  `` type_ `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.OAuth2.type_ "Permanent link")
    
    
    type_ = Field(default=[oauth2](#fastapi.openapi.models.SecuritySchemeType.oauth2 "<code class="doc-symbol doc-symbol-heading doc-symbol-attribute"></code>            <span class="doc doc-object-name doc-attribute-name">oauth2</span>
    
    
      <span class="doc doc-labels">
          <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
          <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
      </span> \(<code>fastapi.openapi.models.SecuritySchemeType.oauth2</code>\)"), alias='type')
    

####  `` flows `instance-attribute` [¶](#fastapi.openapi.models.OAuth2.flows "Permanent link")
    
    
    flows
    

####  `` model_config `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.OAuth2.model_config "Permanent link")
    
    
    model_config = {'extra': 'allow'}
    

####  `` description `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.OAuth2.description "Permanent link")
    
    
    description = None
    

###  `` OpenIdConnect [¶](#fastapi.openapi.models.OpenIdConnect "Permanent link")

Bases: `[SecurityBase](#fastapi.openapi.models.SecurityBase "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">SecurityBase</span> \(<code>fastapi.openapi.models.SecurityBase</code>\)")`

####  `` type_ `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.OpenIdConnect.type_ "Permanent link")
    
    
    type_ = Field(default=[openIdConnect](#fastapi.openapi.models.SecuritySchemeType.openIdConnect "<code class="doc-symbol doc-symbol-heading doc-symbol-attribute"></code>            <span class="doc doc-object-name doc-attribute-name">openIdConnect</span>
    
    
      <span class="doc doc-labels">
          <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
          <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
      </span> \(<code>fastapi.openapi.models.SecuritySchemeType.openIdConnect</code>\)"), alias='type')
    

####  `` openIdConnectUrl `instance-attribute` [¶](#fastapi.openapi.models.OpenIdConnect.openIdConnectUrl "Permanent link")
    
    
    openIdConnectUrl
    

####  `` model_config `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.OpenIdConnect.model_config "Permanent link")
    
    
    model_config = {'extra': 'allow'}
    

####  `` description `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.OpenIdConnect.description "Permanent link")
    
    
    description = None
    

###  `` Components [¶](#fastapi.openapi.models.Components "Permanent link")

Bases: `[BaseModelWithConfig](#fastapi.openapi.models.BaseModelWithConfig "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">BaseModelWithConfig</span> \(<code>fastapi.openapi.models.BaseModelWithConfig</code>\)")`

####  `` schemas `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Components.schemas "Permanent link")
    
    
    schemas = None
    

####  `` responses `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Components.responses "Permanent link")
    
    
    responses = None
    

####  `` parameters `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Components.parameters "Permanent link")
    
    
    parameters = None
    

####  `` examples `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Components.examples "Permanent link")
    
    
    examples = None
    

####  `` requestBodies `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Components.requestBodies "Permanent link")
    
    
    requestBodies = None
    

####  `` headers `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Components.headers "Permanent link")
    
    
    headers = None
    

####  `` securitySchemes `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Components.securitySchemes "Permanent link")
    
    
    securitySchemes = None
    

####  `` links `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Components.links "Permanent link")
    
    
    links = None
    

####  `` callbacks `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Components.callbacks "Permanent link")
    
    
    callbacks = None
    

####  `` pathItems `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Components.pathItems "Permanent link")
    
    
    pathItems = None
    

####  `` model_config `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Components.model_config "Permanent link")
    
    
    model_config = {'extra': 'allow'}
    

###  `` Tag [¶](#fastapi.openapi.models.Tag "Permanent link")

Bases: `[BaseModelWithConfig](#fastapi.openapi.models.BaseModelWithConfig "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">BaseModelWithConfig</span> \(<code>fastapi.openapi.models.BaseModelWithConfig</code>\)")`

####  `` name `instance-attribute` [¶](#fastapi.openapi.models.Tag.name "Permanent link")
    
    
    name
    

####  `` description `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Tag.description "Permanent link")
    
    
    description = None
    

####  `` externalDocs `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Tag.externalDocs "Permanent link")
    
    
    externalDocs = None
    

####  `` model_config `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.Tag.model_config "Permanent link")
    
    
    model_config = {'extra': 'allow'}
    

###  `` OpenAPI [¶](#fastapi.openapi.models.OpenAPI "Permanent link")

Bases: `[BaseModelWithConfig](#fastapi.openapi.models.BaseModelWithConfig "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">BaseModelWithConfig</span> \(<code>fastapi.openapi.models.BaseModelWithConfig</code>\)")`

####  `` openapi `instance-attribute` [¶](#fastapi.openapi.models.OpenAPI.openapi "Permanent link")
    
    
    openapi
    

####  `` info `instance-attribute` [¶](#fastapi.openapi.models.OpenAPI.info "Permanent link")
    
    
    info
    

####  `` jsonSchemaDialect `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.OpenAPI.jsonSchemaDialect "Permanent link")
    
    
    jsonSchemaDialect = None
    

####  `` servers `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.OpenAPI.servers "Permanent link")
    
    
    servers = None
    

####  `` paths `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.OpenAPI.paths "Permanent link")
    
    
    paths = None
    

####  `` webhooks `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.OpenAPI.webhooks "Permanent link")
    
    
    webhooks = None
    

####  `` components `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.OpenAPI.components "Permanent link")
    
    
    components = None
    

####  `` security `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.OpenAPI.security "Permanent link")
    
    
    security = None
    

####  `` tags `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.OpenAPI.tags "Permanent link")
    
    
    tags = None
    

####  `` externalDocs `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.OpenAPI.externalDocs "Permanent link")
    
    
    externalDocs = None
    

####  `` model_config `class-attribute` `instance-attribute` [¶](#fastapi.openapi.models.OpenAPI.model_config "Permanent link")
    
    
    model_config = {'extra': 'allow'}

---

###### Security Tools¶

# Security Tools[¶](#security-tools "Permanent link")

When you need to declare dependencies with OAuth2 scopes you use `Security()`.

But you still need to define what is the dependable, the callable that you pass as a parameter to `Depends()` or `Security()`.

There are multiple tools that you can use to create those dependables, and they get integrated into OpenAPI so they are shown in the automatic docs UI, they can be used by automatically generated clients and SDKs, etc.

You can import them from `fastapi.security`:
    
    
    from fastapi.security import (
        APIKeyCookie,
        APIKeyHeader,
        APIKeyQuery,
        HTTPAuthorizationCredentials,
        HTTPBasic,
        HTTPBasicCredentials,
        HTTPBearer,
        HTTPDigest,
        OAuth2,
        OAuth2AuthorizationCodeBearer,
        OAuth2PasswordBearer,
        OAuth2PasswordRequestForm,
        OAuth2PasswordRequestFormStrict,
        OpenIdConnect,
        SecurityScopes,
    )
    

Read more about them in the [FastAPI docs about Security](https://fastapi.tiangolo.com/tutorial/security/).

## API Key Security Schemes[¶](#api-key-security-schemes "Permanent link")

##  `` fastapi.security.APIKeyCookie [¶](#fastapi.security.APIKeyCookie "Permanent link")
    
    
    APIKeyCookie(
        *,
        name,
        scheme_name=None,
        description=None,
        auto_error=True
    )
    

Bases: `APIKeyBase`

API key authentication using a cookie.

This defines the name of the cookie that should be provided in the request with the API key and integrates that into the OpenAPI documentation. It extracts the key value sent in the cookie automatically and provides it as the dependency result. But it doesn't define how to set that cookie.

#### Usage[¶](#fastapi.security.APIKeyCookie--usage "Permanent link")

Create an instance object and use that object as the dependency in `Depends()`.

The dependency result will be a string containing the key value.

#### Example[¶](#fastapi.security.APIKeyCookie--example "Permanent link")
    
    
    from fastapi import Depends, FastAPI
    from fastapi.security import APIKeyCookie
    
    app = FastAPI()
    
    cookie_scheme = APIKeyCookie(name="session")
    
    
    @app.get("/items/")
    async def read_items(session: str = Depends(cookie_scheme)):
        return {"session": session}
    

PARAMETER | DESCRIPTION  
---|---  
`name` |  Cookie name. **TYPE:** `str`  
`scheme_name` |  Security scheme name. It will be included in the generated OpenAPI (e.g. visible at `/docs`). **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`description` |  Security scheme description. It will be included in the generated OpenAPI (e.g. visible at `/docs`). **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`auto_error` |  By default, if the cookie is not provided, `APIKeyCookie` will automatically cancel the request and send the client an error. If `auto_error` is set to `False`, when the cookie is not available, instead of erroring out, the dependency result will be `None`. This is useful when you want to have optional authentication. It is also useful when you want to have authentication that can be provided in one of multiple optional ways (for example, in a cookie or in an HTTP Bearer token). **TYPE:** `bool` **DEFAULT:** `True`  
Source code in `fastapi/security/api_key.py`
    
    
    265
    266
    267
    268
    269
    270
    271
    272
    273
    274
    275
    276
    277
    278
    279
    280
    281
    282
    283
    284
    285
    286
    287
    288
    289
    290
    291
    292
    293
    294
    295
    296
    297
    298
    299
    300
    301
    302
    303
    304
    305
    306
    307
    308
    309
    310
    311
    312
    313
    314

| 
    
    
    def __init__(
        self,
        *,
        name: Annotated[str, Doc("Cookie name.")],
        scheme_name: Annotated[
            Optional[str],
            Doc(
                """
                Security scheme name.
    
                It will be included in the generated OpenAPI (e.g. visible at `/docs`).
                """
            ),
        ] = None,
        description: Annotated[
            Optional[str],
            Doc(
                """
                Security scheme description.
    
                It will be included in the generated OpenAPI (e.g. visible at `/docs`).
                """
            ),
        ] = None,
        auto_error: Annotated[
            bool,
            Doc(
                """
                By default, if the cookie is not provided, `APIKeyCookie` will
                automatically cancel the request and send the client an error.
    
                If `auto_error` is set to `False`, when the cookie is not available,
                instead of erroring out, the dependency result will be `None`.
    
                This is useful when you want to have optional authentication.
    
                It is also useful when you want to have authentication that can be
                provided in one of multiple optional ways (for example, in a cookie or
                in an HTTP Bearer token).
                """
            ),
        ] = True,
    ):
        super().__init__(
            location=APIKeyIn.cookie,
            name=name,
            scheme_name=scheme_name,
            description=description,
            auto_error=auto_error,
        )
      
  
---|---  
  
###  `` model `instance-attribute` [¶](#fastapi.security.APIKeyCookie.model "Permanent link")
    
    
    model = [APIKey](../openapi/models/#fastapi.openapi.models.APIKey "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">APIKey</span> \(<code>fastapi.openapi.models.APIKey</code>\)")(
        **{"in": location}, name=name, description=description
    )
    

###  `` scheme_name `instance-attribute` [¶](#fastapi.security.APIKeyCookie.scheme_name "Permanent link")
    
    
    scheme_name = scheme_name or __name__
    

###  `` auto_error `instance-attribute` [¶](#fastapi.security.APIKeyCookie.auto_error "Permanent link")
    
    
    auto_error = auto_error
    

###  `` make_not_authenticated_error [¶](#fastapi.security.APIKeyCookie.make_not_authenticated_error "Permanent link")
    
    
    make_not_authenticated_error()
    

The WWW-Authenticate header is not standardized for API Key authentication but the HTTP specification requires that an error of 401 "Unauthorized" must include a WWW-Authenticate header.

Ref: https://datatracker.ietf.org/doc/html/rfc9110#name-401-unauthorized

For this, this method sends a custom challenge `APIKey`.

Source code in `fastapi/security/api_key.py`
    
    
    29
    30
    31
    32
    33
    34
    35
    36
    37
    38
    39
    40
    41
    42
    43

| 
    
    
    def make_not_authenticated_error(self) -> HTTPException:
        """
        The WWW-Authenticate header is not standardized for API Key authentication but
        the HTTP specification requires that an error of 401 "Unauthorized" must
        include a WWW-Authenticate header.
    
        Ref: https://datatracker.ietf.org/doc/html/rfc9110#name-401-unauthorized
    
        For this, this method sends a custom challenge `APIKey`.
        """
        return HTTPException(
            status_code=HTTP_401_UNAUTHORIZED,
            detail="Not authenticated",
            headers={"WWW-Authenticate": "APIKey"},
        )
      
  
---|---  
  
###  `` check_api_key [¶](#fastapi.security.APIKeyCookie.check_api_key "Permanent link")
    
    
    check_api_key(api_key)
    

Source code in `fastapi/security/api_key.py`
    
    
    45
    46
    47
    48
    49
    50

| 
    
    
    def check_api_key(self, api_key: Optional[str]) -> Optional[str]:
        if not api_key:
            if self.auto_error:
                raise self.make_not_authenticated_error()
            return None
        return api_key
      
  
---|---  
  
##  `` fastapi.security.APIKeyHeader [¶](#fastapi.security.APIKeyHeader "Permanent link")
    
    
    APIKeyHeader(
        *,
        name,
        scheme_name=None,
        description=None,
        auto_error=True
    )
    

Bases: `APIKeyBase`

API key authentication using a header.

This defines the name of the header that should be provided in the request with the API key and integrates that into the OpenAPI documentation. It extracts the key value sent in the header automatically and provides it as the dependency result. But it doesn't define how to send that key to the client.

#### Usage[¶](#fastapi.security.APIKeyHeader--usage "Permanent link")

Create an instance object and use that object as the dependency in `Depends()`.

The dependency result will be a string containing the key value.

#### Example[¶](#fastapi.security.APIKeyHeader--example "Permanent link")
    
    
    from fastapi import Depends, FastAPI
    from fastapi.security import APIKeyHeader
    
    app = FastAPI()
    
    header_scheme = APIKeyHeader(name="x-key")
    
    
    @app.get("/items/")
    async def read_items(key: str = Depends(header_scheme)):
        return {"key": key}
    

PARAMETER | DESCRIPTION  
---|---  
`name` |  Header name. **TYPE:** `str`  
`scheme_name` |  Security scheme name. It will be included in the generated OpenAPI (e.g. visible at `/docs`). **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`description` |  Security scheme description. It will be included in the generated OpenAPI (e.g. visible at `/docs`). **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`auto_error` |  By default, if the header is not provided, `APIKeyHeader` will automatically cancel the request and send the client an error. If `auto_error` is set to `False`, when the header is not available, instead of erroring out, the dependency result will be `None`. This is useful when you want to have optional authentication. It is also useful when you want to have authentication that can be provided in one of multiple optional ways (for example, in a header or in an HTTP Bearer token). **TYPE:** `bool` **DEFAULT:** `True`  
Source code in `fastapi/security/api_key.py`
    
    
    177
    178
    179
    180
    181
    182
    183
    184
    185
    186
    187
    188
    189
    190
    191
    192
    193
    194
    195
    196
    197
    198
    199
    200
    201
    202
    203
    204
    205
    206
    207
    208
    209
    210
    211
    212
    213
    214
    215
    216
    217
    218
    219
    220
    221
    222
    223
    224
    225
    226

| 
    
    
    def __init__(
        self,
        *,
        name: Annotated[str, Doc("Header name.")],
        scheme_name: Annotated[
            Optional[str],
            Doc(
                """
                Security scheme name.
    
                It will be included in the generated OpenAPI (e.g. visible at `/docs`).
                """
            ),
        ] = None,
        description: Annotated[
            Optional[str],
            Doc(
                """
                Security scheme description.
    
                It will be included in the generated OpenAPI (e.g. visible at `/docs`).
                """
            ),
        ] = None,
        auto_error: Annotated[
            bool,
            Doc(
                """
                By default, if the header is not provided, `APIKeyHeader` will
                automatically cancel the request and send the client an error.
    
                If `auto_error` is set to `False`, when the header is not available,
                instead of erroring out, the dependency result will be `None`.
    
                This is useful when you want to have optional authentication.
    
                It is also useful when you want to have authentication that can be
                provided in one of multiple optional ways (for example, in a header or
                in an HTTP Bearer token).
                """
            ),
        ] = True,
    ):
        super().__init__(
            location=APIKeyIn.header,
            name=name,
            scheme_name=scheme_name,
            description=description,
            auto_error=auto_error,
        )
      
  
---|---  
  
###  `` model `instance-attribute` [¶](#fastapi.security.APIKeyHeader.model "Permanent link")
    
    
    model = [APIKey](../openapi/models/#fastapi.openapi.models.APIKey "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">APIKey</span> \(<code>fastapi.openapi.models.APIKey</code>\)")(
        **{"in": location}, name=name, description=description
    )
    

###  `` scheme_name `instance-attribute` [¶](#fastapi.security.APIKeyHeader.scheme_name "Permanent link")
    
    
    scheme_name = scheme_name or __name__
    

###  `` auto_error `instance-attribute` [¶](#fastapi.security.APIKeyHeader.auto_error "Permanent link")
    
    
    auto_error = auto_error
    

###  `` make_not_authenticated_error [¶](#fastapi.security.APIKeyHeader.make_not_authenticated_error "Permanent link")
    
    
    make_not_authenticated_error()
    

The WWW-Authenticate header is not standardized for API Key authentication but the HTTP specification requires that an error of 401 "Unauthorized" must include a WWW-Authenticate header.

Ref: https://datatracker.ietf.org/doc/html/rfc9110#name-401-unauthorized

For this, this method sends a custom challenge `APIKey`.

Source code in `fastapi/security/api_key.py`
    
    
    29
    30
    31
    32
    33
    34
    35
    36
    37
    38
    39
    40
    41
    42
    43

| 
    
    
    def make_not_authenticated_error(self) -> HTTPException:
        """
        The WWW-Authenticate header is not standardized for API Key authentication but
        the HTTP specification requires that an error of 401 "Unauthorized" must
        include a WWW-Authenticate header.
    
        Ref: https://datatracker.ietf.org/doc/html/rfc9110#name-401-unauthorized
    
        For this, this method sends a custom challenge `APIKey`.
        """
        return HTTPException(
            status_code=HTTP_401_UNAUTHORIZED,
            detail="Not authenticated",
            headers={"WWW-Authenticate": "APIKey"},
        )
      
  
---|---  
  
###  `` check_api_key [¶](#fastapi.security.APIKeyHeader.check_api_key "Permanent link")
    
    
    check_api_key(api_key)
    

Source code in `fastapi/security/api_key.py`
    
    
    45
    46
    47
    48
    49
    50

| 
    
    
    def check_api_key(self, api_key: Optional[str]) -> Optional[str]:
        if not api_key:
            if self.auto_error:
                raise self.make_not_authenticated_error()
            return None
        return api_key
      
  
---|---  
  
##  `` fastapi.security.APIKeyQuery [¶](#fastapi.security.APIKeyQuery "Permanent link")
    
    
    APIKeyQuery(
        *,
        name,
        scheme_name=None,
        description=None,
        auto_error=True
    )
    

Bases: `APIKeyBase`

API key authentication using a query parameter.

This defines the name of the query parameter that should be provided in the request with the API key and integrates that into the OpenAPI documentation. It extracts the key value sent in the query parameter automatically and provides it as the dependency result. But it doesn't define how to send that API key to the client.

#### Usage[¶](#fastapi.security.APIKeyQuery--usage "Permanent link")

Create an instance object and use that object as the dependency in `Depends()`.

The dependency result will be a string containing the key value.

#### Example[¶](#fastapi.security.APIKeyQuery--example "Permanent link")
    
    
    from fastapi import Depends, FastAPI
    from fastapi.security import APIKeyQuery
    
    app = FastAPI()
    
    query_scheme = APIKeyQuery(name="api_key")
    
    
    @app.get("/items/")
    async def read_items(api_key: str = Depends(query_scheme)):
        return {"api_key": api_key}
    

PARAMETER | DESCRIPTION  
---|---  
`name` |  Query parameter name. **TYPE:** `str`  
`scheme_name` |  Security scheme name. It will be included in the generated OpenAPI (e.g. visible at `/docs`). **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`description` |  Security scheme description. It will be included in the generated OpenAPI (e.g. visible at `/docs`). **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`auto_error` |  By default, if the query parameter is not provided, `APIKeyQuery` will automatically cancel the request and send the client an error. If `auto_error` is set to `False`, when the query parameter is not available, instead of erroring out, the dependency result will be `None`. This is useful when you want to have optional authentication. It is also useful when you want to have authentication that can be provided in one of multiple optional ways (for example, in a query parameter or in an HTTP Bearer token). **TYPE:** `bool` **DEFAULT:** `True`  
Source code in `fastapi/security/api_key.py`
    
    
     85
     86
     87
     88
     89
     90
     91
     92
     93
     94
     95
     96
     97
     98
     99
    100
    101
    102
    103
    104
    105
    106
    107
    108
    109
    110
    111
    112
    113
    114
    115
    116
    117
    118
    119
    120
    121
    122
    123
    124
    125
    126
    127
    128
    129
    130
    131
    132
    133
    134
    135
    136
    137
    138

| 
    
    
    def __init__(
        self,
        *,
        name: Annotated[
            str,
            Doc("Query parameter name."),
        ],
        scheme_name: Annotated[
            Optional[str],
            Doc(
                """
                Security scheme name.
    
                It will be included in the generated OpenAPI (e.g. visible at `/docs`).
                """
            ),
        ] = None,
        description: Annotated[
            Optional[str],
            Doc(
                """
                Security scheme description.
    
                It will be included in the generated OpenAPI (e.g. visible at `/docs`).
                """
            ),
        ] = None,
        auto_error: Annotated[
            bool,
            Doc(
                """
                By default, if the query parameter is not provided, `APIKeyQuery` will
                automatically cancel the request and send the client an error.
    
                If `auto_error` is set to `False`, when the query parameter is not
                available, instead of erroring out, the dependency result will be
                `None`.
    
                This is useful when you want to have optional authentication.
    
                It is also useful when you want to have authentication that can be
                provided in one of multiple optional ways (for example, in a query
                parameter or in an HTTP Bearer token).
                """
            ),
        ] = True,
    ):
        super().__init__(
            location=APIKeyIn.query,
            name=name,
            scheme_name=scheme_name,
            description=description,
            auto_error=auto_error,
        )
      
  
---|---  
  
###  `` model `instance-attribute` [¶](#fastapi.security.APIKeyQuery.model "Permanent link")
    
    
    model = [APIKey](../openapi/models/#fastapi.openapi.models.APIKey "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">APIKey</span> \(<code>fastapi.openapi.models.APIKey</code>\)")(
        **{"in": location}, name=name, description=description
    )
    

###  `` scheme_name `instance-attribute` [¶](#fastapi.security.APIKeyQuery.scheme_name "Permanent link")
    
    
    scheme_name = scheme_name or __name__
    

###  `` auto_error `instance-attribute` [¶](#fastapi.security.APIKeyQuery.auto_error "Permanent link")
    
    
    auto_error = auto_error
    

###  `` make_not_authenticated_error [¶](#fastapi.security.APIKeyQuery.make_not_authenticated_error "Permanent link")
    
    
    make_not_authenticated_error()
    

The WWW-Authenticate header is not standardized for API Key authentication but the HTTP specification requires that an error of 401 "Unauthorized" must include a WWW-Authenticate header.

Ref: https://datatracker.ietf.org/doc/html/rfc9110#name-401-unauthorized

For this, this method sends a custom challenge `APIKey`.

Source code in `fastapi/security/api_key.py`
    
    
    29
    30
    31
    32
    33
    34
    35
    36
    37
    38
    39
    40
    41
    42
    43

| 
    
    
    def make_not_authenticated_error(self) -> HTTPException:
        """
        The WWW-Authenticate header is not standardized for API Key authentication but
        the HTTP specification requires that an error of 401 "Unauthorized" must
        include a WWW-Authenticate header.
    
        Ref: https://datatracker.ietf.org/doc/html/rfc9110#name-401-unauthorized
    
        For this, this method sends a custom challenge `APIKey`.
        """
        return HTTPException(
            status_code=HTTP_401_UNAUTHORIZED,
            detail="Not authenticated",
            headers={"WWW-Authenticate": "APIKey"},
        )
      
  
---|---  
  
###  `` check_api_key [¶](#fastapi.security.APIKeyQuery.check_api_key "Permanent link")
    
    
    check_api_key(api_key)
    

Source code in `fastapi/security/api_key.py`
    
    
    45
    46
    47
    48
    49
    50

| 
    
    
    def check_api_key(self, api_key: Optional[str]) -> Optional[str]:
        if not api_key:
            if self.auto_error:
                raise self.make_not_authenticated_error()
            return None
        return api_key
      
  
---|---  
  
## HTTP Authentication Schemes[¶](#http-authentication-schemes "Permanent link")

##  `` fastapi.security.HTTPBasic [¶](#fastapi.security.HTTPBasic "Permanent link")
    
    
    HTTPBasic(
        *,
        scheme_name=None,
        realm=None,
        description=None,
        auto_error=True
    )
    

Bases: `HTTPBase`

HTTP Basic authentication.

Ref: https://datatracker.ietf.org/doc/html/rfc7617

#### Usage[¶](#fastapi.security.HTTPBasic--usage "Permanent link")

Create an instance object and use that object as the dependency in `Depends()`.

The dependency result will be an `HTTPBasicCredentials` object containing the `username` and the `password`.

Read more about it in the [FastAPI docs for HTTP Basic Auth](https://fastapi.tiangolo.com/advanced/security/http-basic-auth/).

#### Example[¶](#fastapi.security.HTTPBasic--example "Permanent link")
    
    
    from typing import Annotated
    
    from fastapi import Depends, FastAPI
    from fastapi.security import HTTPBasic, HTTPBasicCredentials
    
    app = FastAPI()
    
    security = HTTPBasic()
    
    
    @app.get("/users/me")
    def read_current_user(credentials: Annotated[HTTPBasicCredentials, Depends(security)]):
        return {"username": credentials.username, "password": credentials.password}
    

PARAMETER | DESCRIPTION  
---|---  
`scheme_name` |  Security scheme name. It will be included in the generated OpenAPI (e.g. visible at `/docs`). **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`realm` |  HTTP Basic authentication realm. **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`description` |  Security scheme description. It will be included in the generated OpenAPI (e.g. visible at `/docs`). **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`auto_error` |  By default, if the HTTP Basic authentication is not provided (a header), `HTTPBasic` will automatically cancel the request and send the client an error. If `auto_error` is set to `False`, when the HTTP Basic authentication is not available, instead of erroring out, the dependency result will be `None`. This is useful when you want to have optional authentication. It is also useful when you want to have authentication that can be provided in one of multiple optional ways (for example, in HTTP Basic authentication or in an HTTP Bearer token). **TYPE:** `bool` **DEFAULT:** `True`  
Source code in `fastapi/security/http.py`
    
    
    142
    143
    144
    145
    146
    147
    148
    149
    150
    151
    152
    153
    154
    155
    156
    157
    158
    159
    160
    161
    162
    163
    164
    165
    166
    167
    168
    169
    170
    171
    172
    173
    174
    175
    176
    177
    178
    179
    180
    181
    182
    183
    184
    185
    186
    187
    188
    189
    190
    191
    192
    193
    194
    195
    196
    197

| 
    
    
    def __init__(
        self,
        *,
        scheme_name: Annotated[
            Optional[str],
            Doc(
                """
                Security scheme name.
    
                It will be included in the generated OpenAPI (e.g. visible at `/docs`).
                """
            ),
        ] = None,
        realm: Annotated[
            Optional[str],
            Doc(
                """
                HTTP Basic authentication realm.
                """
            ),
        ] = None,
        description: Annotated[
            Optional[str],
            Doc(
                """
                Security scheme description.
    
                It will be included in the generated OpenAPI (e.g. visible at `/docs`).
                """
            ),
        ] = None,
        auto_error: Annotated[
            bool,
            Doc(
                """
                By default, if the HTTP Basic authentication is not provided (a
                header), `HTTPBasic` will automatically cancel the request and send the
                client an error.
    
                If `auto_error` is set to `False`, when the HTTP Basic authentication
                is not available, instead of erroring out, the dependency result will
                be `None`.
    
                This is useful when you want to have optional authentication.
    
                It is also useful when you want to have authentication that can be
                provided in one of multiple optional ways (for example, in HTTP Basic
                authentication or in an HTTP Bearer token).
                """
            ),
        ] = True,
    ):
        self.model = HTTPBaseModel(scheme="basic", description=description)
        self.scheme_name = scheme_name or self.__class__.__name__
        self.realm = realm
        self.auto_error = auto_error
      
  
---|---  
  
###  `` model `instance-attribute` [¶](#fastapi.security.HTTPBasic.model "Permanent link")
    
    
    model = [HTTPBase](../openapi/models/#fastapi.openapi.models.HTTPBase "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">HTTPBase</span> \(<code>fastapi.openapi.models.HTTPBase</code>\)")(scheme='basic', description=description)
    

###  `` scheme_name `instance-attribute` [¶](#fastapi.security.HTTPBasic.scheme_name "Permanent link")
    
    
    scheme_name = scheme_name or __name__
    

###  `` realm `instance-attribute` [¶](#fastapi.security.HTTPBasic.realm "Permanent link")
    
    
    realm = realm
    

###  `` auto_error `instance-attribute` [¶](#fastapi.security.HTTPBasic.auto_error "Permanent link")
    
    
    auto_error = auto_error
    

###  `` make_not_authenticated_error [¶](#fastapi.security.HTTPBasic.make_not_authenticated_error "Permanent link")
    
    
    make_not_authenticated_error()
    

Source code in `fastapi/security/http.py`
    
    
    87
    88
    89
    90
    91
    92

| 
    
    
    def make_not_authenticated_error(self) -> HTTPException:
        return HTTPException(
            status_code=HTTP_401_UNAUTHORIZED,
            detail="Not authenticated",
            headers=self.make_authenticate_headers(),
        )
      
  
---|---  
  
###  `` make_authenticate_headers [¶](#fastapi.security.HTTPBasic.make_authenticate_headers "Permanent link")
    
    
    make_authenticate_headers()
    

Source code in `fastapi/security/http.py`
    
    
    199
    200
    201
    202

| 
    
    
    def make_authenticate_headers(self) -> dict[str, str]:
        if self.realm:
            return {"WWW-Authenticate": f'Basic realm="{self.realm}"'}
        return {"WWW-Authenticate": "Basic"}
      
  
---|---  
  
##  `` fastapi.security.HTTPBearer [¶](#fastapi.security.HTTPBearer "Permanent link")
    
    
    HTTPBearer(
        *,
        bearerFormat=None,
        scheme_name=None,
        description=None,
        auto_error=True
    )
    

Bases: `HTTPBase`

HTTP Bearer token authentication.

#### Usage[¶](#fastapi.security.HTTPBearer--usage "Permanent link")

Create an instance object and use that object as the dependency in `Depends()`.

The dependency result will be an `HTTPAuthorizationCredentials` object containing the `scheme` and the `credentials`.

#### Example[¶](#fastapi.security.HTTPBearer--example "Permanent link")
    
    
    from typing import Annotated
    
    from fastapi import Depends, FastAPI
    from fastapi.security import HTTPAuthorizationCredentials, HTTPBearer
    
    app = FastAPI()
    
    security = HTTPBearer()
    
    
    @app.get("/users/me")
    def read_current_user(
        credentials: Annotated[HTTPAuthorizationCredentials, Depends(security)]
    ):
        return {"scheme": credentials.scheme, "credentials": credentials.credentials}
    

PARAMETER | DESCRIPTION  
---|---  
`bearerFormat` |  Bearer token format. **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`scheme_name` |  Security scheme name. It will be included in the generated OpenAPI (e.g. visible at `/docs`). **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`description` |  Security scheme description. It will be included in the generated OpenAPI (e.g. visible at `/docs`). **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`auto_error` |  By default, if the HTTP Bearer token is not provided (in an `Authorization` header), `HTTPBearer` will automatically cancel the request and send the client an error. If `auto_error` is set to `False`, when the HTTP Bearer token is not available, instead of erroring out, the dependency result will be `None`. This is useful when you want to have optional authentication. It is also useful when you want to have authentication that can be provided in one of multiple optional ways (for example, in an HTTP Bearer token or in a cookie). **TYPE:** `bool` **DEFAULT:** `True`  
Source code in `fastapi/security/http.py`
    
    
    256
    257
    258
    259
    260
    261
    262
    263
    264
    265
    266
    267
    268
    269
    270
    271
    272
    273
    274
    275
    276
    277
    278
    279
    280
    281
    282
    283
    284
    285
    286
    287
    288
    289
    290
    291
    292
    293
    294
    295
    296
    297
    298
    299
    300
    301
    302
    303

| 
    
    
    def __init__(
        self,
        *,
        bearerFormat: Annotated[Optional[str], Doc("Bearer token format.")] = None,
        scheme_name: Annotated[
            Optional[str],
            Doc(
                """
                Security scheme name.
    
                It will be included in the generated OpenAPI (e.g. visible at `/docs`).
                """
            ),
        ] = None,
        description: Annotated[
            Optional[str],
            Doc(
                """
                Security scheme description.
    
                It will be included in the generated OpenAPI (e.g. visible at `/docs`).
                """
            ),
        ] = None,
        auto_error: Annotated[
            bool,
            Doc(
                """
                By default, if the HTTP Bearer token is not provided (in an
                `Authorization` header), `HTTPBearer` will automatically cancel the
                request and send the client an error.
    
                If `auto_error` is set to `False`, when the HTTP Bearer token
                is not available, instead of erroring out, the dependency result will
                be `None`.
    
                This is useful when you want to have optional authentication.
    
                It is also useful when you want to have authentication that can be
                provided in one of multiple optional ways (for example, in an HTTP
                Bearer token or in a cookie).
                """
            ),
        ] = True,
    ):
        self.model = HTTPBearerModel(bearerFormat=bearerFormat, description=description)
        self.scheme_name = scheme_name or self.__class__.__name__
        self.auto_error = auto_error
      
  
---|---  
  
###  `` model `instance-attribute` [¶](#fastapi.security.HTTPBearer.model "Permanent link")
    
    
    model = [HTTPBearer](../openapi/models/#fastapi.openapi.models.HTTPBearer "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">HTTPBearer</span> \(<code>fastapi.openapi.models.HTTPBearer</code>\)")(
        bearerFormat=bearerFormat, description=description
    )
    

###  `` scheme_name `instance-attribute` [¶](#fastapi.security.HTTPBearer.scheme_name "Permanent link")
    
    
    scheme_name = scheme_name or __name__
    

###  `` auto_error `instance-attribute` [¶](#fastapi.security.HTTPBearer.auto_error "Permanent link")
    
    
    auto_error = auto_error
    

###  `` make_authenticate_headers [¶](#fastapi.security.HTTPBearer.make_authenticate_headers "Permanent link")
    
    
    make_authenticate_headers()
    

Source code in `fastapi/security/http.py`
    
    
    84
    85

| 
    
    
    def make_authenticate_headers(self) -> dict[str, str]:
        return {"WWW-Authenticate": f"{self.model.scheme.title()}"}
      
  
---|---  
  
###  `` make_not_authenticated_error [¶](#fastapi.security.HTTPBearer.make_not_authenticated_error "Permanent link")
    
    
    make_not_authenticated_error()
    

Source code in `fastapi/security/http.py`
    
    
    87
    88
    89
    90
    91
    92

| 
    
    
    def make_not_authenticated_error(self) -> HTTPException:
        return HTTPException(
            status_code=HTTP_401_UNAUTHORIZED,
            detail="Not authenticated",
            headers=self.make_authenticate_headers(),
        )
      
  
---|---  
  
##  `` fastapi.security.HTTPDigest [¶](#fastapi.security.HTTPDigest "Permanent link")
    
    
    HTTPDigest(
        *, scheme_name=None, description=None, auto_error=True
    )
    

Bases: `HTTPBase`

HTTP Digest authentication.

**Warning** : this is only a stub to connect the components with OpenAPI in FastAPI, but it doesn't implement the full Digest scheme, you would need to to subclass it and implement it in your code.

Ref: https://datatracker.ietf.org/doc/html/rfc7616

#### Usage[¶](#fastapi.security.HTTPDigest--usage "Permanent link")

Create an instance object and use that object as the dependency in `Depends()`.

The dependency result will be an `HTTPAuthorizationCredentials` object containing the `scheme` and the `credentials`.

#### Example[¶](#fastapi.security.HTTPDigest--example "Permanent link")
    
    
    from typing import Annotated
    
    from fastapi import Depends, FastAPI
    from fastapi.security import HTTPAuthorizationCredentials, HTTPDigest
    
    app = FastAPI()
    
    security = HTTPDigest()
    
    
    @app.get("/users/me")
    def read_current_user(
        credentials: Annotated[HTTPAuthorizationCredentials, Depends(security)]
    ):
        return {"scheme": credentials.scheme, "credentials": credentials.credentials}
    

PARAMETER | DESCRIPTION  
---|---  
`scheme_name` |  Security scheme name. It will be included in the generated OpenAPI (e.g. visible at `/docs`). **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`description` |  Security scheme description. It will be included in the generated OpenAPI (e.g. visible at `/docs`). **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`auto_error` |  By default, if the HTTP Digest is not provided, `HTTPDigest` will automatically cancel the request and send the client an error. If `auto_error` is set to `False`, when the HTTP Digest is not available, instead of erroring out, the dependency result will be `None`. This is useful when you want to have optional authentication. It is also useful when you want to have authentication that can be provided in one of multiple optional ways (for example, in HTTP Digest or in a cookie). **TYPE:** `bool` **DEFAULT:** `True`  
Source code in `fastapi/security/http.py`
    
    
    361
    362
    363
    364
    365
    366
    367
    368
    369
    370
    371
    372
    373
    374
    375
    376
    377
    378
    379
    380
    381
    382
    383
    384
    385
    386
    387
    388
    389
    390
    391
    392
    393
    394
    395
    396
    397
    398
    399
    400
    401
    402
    403
    404
    405
    406

| 
    
    
    def __init__(
        self,
        *,
        scheme_name: Annotated[
            Optional[str],
            Doc(
                """
                Security scheme name.
    
                It will be included in the generated OpenAPI (e.g. visible at `/docs`).
                """
            ),
        ] = None,
        description: Annotated[
            Optional[str],
            Doc(
                """
                Security scheme description.
    
                It will be included in the generated OpenAPI (e.g. visible at `/docs`).
                """
            ),
        ] = None,
        auto_error: Annotated[
            bool,
            Doc(
                """
                By default, if the HTTP Digest is not provided, `HTTPDigest` will
                automatically cancel the request and send the client an error.
    
                If `auto_error` is set to `False`, when the HTTP Digest is not
                available, instead of erroring out, the dependency result will
                be `None`.
    
                This is useful when you want to have optional authentication.
    
                It is also useful when you want to have authentication that can be
                provided in one of multiple optional ways (for example, in HTTP
                Digest or in a cookie).
                """
            ),
        ] = True,
    ):
        self.model = HTTPBaseModel(scheme="digest", description=description)
        self.scheme_name = scheme_name or self.__class__.__name__
        self.auto_error = auto_error
      
  
---|---  
  
###  `` model `instance-attribute` [¶](#fastapi.security.HTTPDigest.model "Permanent link")
    
    
    model = [HTTPBase](../openapi/models/#fastapi.openapi.models.HTTPBase "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">HTTPBase</span> \(<code>fastapi.openapi.models.HTTPBase</code>\)")(scheme='digest', description=description)
    

###  `` scheme_name `instance-attribute` [¶](#fastapi.security.HTTPDigest.scheme_name "Permanent link")
    
    
    scheme_name = scheme_name or __name__
    

###  `` auto_error `instance-attribute` [¶](#fastapi.security.HTTPDigest.auto_error "Permanent link")
    
    
    auto_error = auto_error
    

###  `` make_authenticate_headers [¶](#fastapi.security.HTTPDigest.make_authenticate_headers "Permanent link")
    
    
    make_authenticate_headers()
    

Source code in `fastapi/security/http.py`
    
    
    84
    85

| 
    
    
    def make_authenticate_headers(self) -> dict[str, str]:
        return {"WWW-Authenticate": f"{self.model.scheme.title()}"}
      
  
---|---  
  
###  `` make_not_authenticated_error [¶](#fastapi.security.HTTPDigest.make_not_authenticated_error "Permanent link")
    
    
    make_not_authenticated_error()
    

Source code in `fastapi/security/http.py`
    
    
    87
    88
    89
    90
    91
    92

| 
    
    
    def make_not_authenticated_error(self) -> HTTPException:
        return HTTPException(
            status_code=HTTP_401_UNAUTHORIZED,
            detail="Not authenticated",
            headers=self.make_authenticate_headers(),
        )
      
  
---|---  
  
## HTTP Credentials[¶](#http-credentials "Permanent link")

##  `` fastapi.security.HTTPAuthorizationCredentials [¶](#fastapi.security.HTTPAuthorizationCredentials "Permanent link")

Bases: `BaseModel`

The HTTP authorization credentials in the result of using `HTTPBearer` or `HTTPDigest` in a dependency.

The HTTP authorization header value is split by the first space.

The first part is the `scheme`, the second part is the `credentials`.

For example, in an HTTP Bearer token scheme, the client will send a header like:
    
    
    Authorization: Bearer deadbeef12346
    

In this case:

  * `scheme` will have the value `"Bearer"`
  * `credentials` will have the value `"deadbeef12346"`

###  `` scheme `instance-attribute` [¶](#fastapi.security.HTTPAuthorizationCredentials.scheme "Permanent link")
    
    
    scheme
    

The HTTP authorization scheme extracted from the header value.

###  `` credentials `instance-attribute` [¶](#fastapi.security.HTTPAuthorizationCredentials.credentials "Permanent link")
    
    
    credentials
    

The HTTP authorization credentials extracted from the header value.

##  `` fastapi.security.HTTPBasicCredentials [¶](#fastapi.security.HTTPBasicCredentials "Permanent link")

Bases: `BaseModel`

The HTTP Basic credentials given as the result of using `HTTPBasic` in a dependency.

Read more about it in the [FastAPI docs for HTTP Basic Auth](https://fastapi.tiangolo.com/advanced/security/http-basic-auth/).

###  `` username `instance-attribute` [¶](#fastapi.security.HTTPBasicCredentials.username "Permanent link")
    
    
    username
    

The HTTP Basic username.

###  `` password `instance-attribute` [¶](#fastapi.security.HTTPBasicCredentials.password "Permanent link")
    
    
    password
    

The HTTP Basic password.

## OAuth2 Authentication[¶](#oauth2-authentication "Permanent link")

##  `` fastapi.security.OAuth2 [¶](#fastapi.security.OAuth2 "Permanent link")
    
    
    OAuth2(
        *,
        flows=[OAuthFlows](../openapi/models/#fastapi.openapi.models.OAuthFlows "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">OAuthFlows</span> \(<code>fastapi.openapi.models.OAuthFlows</code>\)")(),
        scheme_name=None,
        description=None,
        auto_error=True
    )
    

Bases: `SecurityBase`

This is the base class for OAuth2 authentication, an instance of it would be used as a dependency. All other OAuth2 classes inherit from it and customize it for each OAuth2 flow.

You normally would not create a new class inheriting from it but use one of the existing subclasses, and maybe compose them if you want to support multiple flows.

Read more about it in the [FastAPI docs for Security](https://fastapi.tiangolo.com/tutorial/security/).

PARAMETER | DESCRIPTION  
---|---  
`flows` |  The dictionary of OAuth2 flows. **TYPE:** `Union[[OAuthFlows](../openapi/models/#fastapi.openapi.models.OAuthFlows "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">OAuthFlows</span> \(<code>fastapi.openapi.models.OAuthFlows</code>\)"), dict[str, dict[str, Any]]]` **DEFAULT:** `[OAuthFlows](../openapi/models/#fastapi.openapi.models.OAuthFlows "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">OAuthFlows</span> \(<code>fastapi.openapi.models.OAuthFlows</code>\)")()`  
`scheme_name` |  Security scheme name. It will be included in the generated OpenAPI (e.g. visible at `/docs`). **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`description` |  Security scheme description. It will be included in the generated OpenAPI (e.g. visible at `/docs`). **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`auto_error` |  By default, if no HTTP Authorization header is provided, required for OAuth2 authentication, it will automatically cancel the request and send the client an error. If `auto_error` is set to `False`, when the HTTP Authorization header is not available, instead of erroring out, the dependency result will be `None`. This is useful when you want to have optional authentication. It is also useful when you want to have authentication that can be provided in one of multiple optional ways (for example, with OAuth2 or in a cookie). **TYPE:** `bool` **DEFAULT:** `True`  
Source code in `fastapi/security/oauth2.py`
    
    
    343
    344
    345
    346
    347
    348
    349
    350
    351
    352
    353
    354
    355
    356
    357
    358
    359
    360
    361
    362
    363
    364
    365
    366
    367
    368
    369
    370
    371
    372
    373
    374
    375
    376
    377
    378
    379
    380
    381
    382
    383
    384
    385
    386
    387
    388
    389
    390
    391
    392
    393
    394
    395
    396
    397
    398
    399

| 
    
    
    def __init__(
        self,
        *,
        flows: Annotated[
            Union[OAuthFlowsModel, dict[str, dict[str, Any]]],
            Doc(
                """
                The dictionary of OAuth2 flows.
                """
            ),
        ] = OAuthFlowsModel(),
        scheme_name: Annotated[
            Optional[str],
            Doc(
                """
                Security scheme name.
    
                It will be included in the generated OpenAPI (e.g. visible at `/docs`).
                """
            ),
        ] = None,
        description: Annotated[
            Optional[str],
            Doc(
                """
                Security scheme description.
    
                It will be included in the generated OpenAPI (e.g. visible at `/docs`).
                """
            ),
        ] = None,
        auto_error: Annotated[
            bool,
            Doc(
                """
                By default, if no HTTP Authorization header is provided, required for
                OAuth2 authentication, it will automatically cancel the request and
                send the client an error.
    
                If `auto_error` is set to `False`, when the HTTP Authorization header
                is not available, instead of erroring out, the dependency result will
                be `None`.
    
                This is useful when you want to have optional authentication.
    
                It is also useful when you want to have authentication that can be
                provided in one of multiple optional ways (for example, with OAuth2
                or in a cookie).
                """
            ),
        ] = True,
    ):
        self.model = OAuth2Model(
            flows=cast(OAuthFlowsModel, flows), description=description
        )
        self.scheme_name = scheme_name or self.__class__.__name__
        self.auto_error = auto_error
      
  
---|---  
  
###  `` model `instance-attribute` [¶](#fastapi.security.OAuth2.model "Permanent link")
    
    
    model = [OAuth2](../openapi/models/#fastapi.openapi.models.OAuth2 "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">OAuth2</span> \(<code>fastapi.openapi.models.OAuth2</code>\)")(
        flows=cast([OAuthFlows](../openapi/models/#fastapi.openapi.models.OAuthFlows "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">OAuthFlows</span> \(<code>fastapi.openapi.models.OAuthFlows</code>\)"), flows), description=description
    )
    

###  `` scheme_name `instance-attribute` [¶](#fastapi.security.OAuth2.scheme_name "Permanent link")
    
    
    scheme_name = scheme_name or __name__
    

###  `` auto_error `instance-attribute` [¶](#fastapi.security.OAuth2.auto_error "Permanent link")
    
    
    auto_error = auto_error
    

###  `` make_not_authenticated_error [¶](#fastapi.security.OAuth2.make_not_authenticated_error "Permanent link")
    
    
    make_not_authenticated_error()
    

The OAuth 2 specification doesn't define the challenge that should be used, because a `Bearer` token is not really the only option to authenticate.

But declaring any other authentication challenge would be application-specific as it's not defined in the specification.

For practical reasons, this method uses the `Bearer` challenge by default, as it's probably the most common one.

If you are implementing an OAuth2 authentication scheme other than the provided ones in FastAPI (based on bearer tokens), you might want to override this.

Ref: https://datatracker.ietf.org/doc/html/rfc6749

Source code in `fastapi/security/oauth2.py`
    
    
    401
    402
    403
    404
    405
    406
    407
    408
    409
    410
    411
    412
    413
    414
    415
    416
    417
    418
    419
    420
    421

| 
    
    
    def make_not_authenticated_error(self) -> HTTPException:
        """
        The OAuth 2 specification doesn't define the challenge that should be used,
        because a `Bearer` token is not really the only option to authenticate.
    
        But declaring any other authentication challenge would be application-specific
        as it's not defined in the specification.
    
        For practical reasons, this method uses the `Bearer` challenge by default, as
        it's probably the most common one.
    
        If you are implementing an OAuth2 authentication scheme other than the provided
        ones in FastAPI (based on bearer tokens), you might want to override this.
    
        Ref: https://datatracker.ietf.org/doc/html/rfc6749
        """
        return HTTPException(
            status_code=HTTP_401_UNAUTHORIZED,
            detail="Not authenticated",
            headers={"WWW-Authenticate": "Bearer"},
        )
      
  
---|---  
  
##  `` fastapi.security.OAuth2AuthorizationCodeBearer [¶](#fastapi.security.OAuth2AuthorizationCodeBearer "Permanent link")
    
    
    OAuth2AuthorizationCodeBearer(
        authorizationUrl,
        tokenUrl,
        refreshUrl=None,
        scheme_name=None,
        scopes=None,
        description=None,
        auto_error=True,
    )
    

Bases: `[OAuth2](#fastapi.security.OAuth2 "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">fastapi.security.OAuth2</span> \(<code>fastapi.security.oauth2.OAuth2</code>\)")`

OAuth2 flow for authentication using a bearer token obtained with an OAuth2 code flow. An instance of it would be used as a dependency.

PARAMETER | DESCRIPTION  
---|---  
`tokenUrl` |  The URL to obtain the OAuth2 token. **TYPE:** `str`  
`refreshUrl` |  The URL to refresh the token and obtain a new one. **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`scheme_name` |  Security scheme name. It will be included in the generated OpenAPI (e.g. visible at `/docs`). **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`scopes` |  The OAuth2 scopes that would be required by the _path operations_ that use this dependency. **TYPE:** `Optional[dict[str, str]]` **DEFAULT:** `None`  
`description` |  Security scheme description. It will be included in the generated OpenAPI (e.g. visible at `/docs`). **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`auto_error` |  By default, if no HTTP Authorization header is provided, required for OAuth2 authentication, it will automatically cancel the request and send the client an error. If `auto_error` is set to `False`, when the HTTP Authorization header is not available, instead of erroring out, the dependency result will be `None`. This is useful when you want to have optional authentication. It is also useful when you want to have authentication that can be provided in one of multiple optional ways (for example, with OAuth2 or in a cookie). **TYPE:** `bool` **DEFAULT:** `True`  
Source code in `fastapi/security/oauth2.py`
    
    
    553
    554
    555
    556
    557
    558
    559
    560
    561
    562
    563
    564
    565
    566
    567
    568
    569
    570
    571
    572
    573
    574
    575
    576
    577
    578
    579
    580
    581
    582
    583
    584
    585
    586
    587
    588
    589
    590
    591
    592
    593
    594
    595
    596
    597
    598
    599
    600
    601
    602
    603
    604
    605
    606
    607
    608
    609
    610
    611
    612
    613
    614
    615
    616
    617
    618
    619
    620
    621
    622
    623
    624
    625
    626
    627
    628
    629
    630
    631
    632
    633
    634
    635
    636
    637
    638
    639
    640

| 
    
    
    def __init__(
        self,
        authorizationUrl: str,
        tokenUrl: Annotated[
            str,
            Doc(
                """
                The URL to obtain the OAuth2 token.
                """
            ),
        ],
        refreshUrl: Annotated[
            Optional[str],
            Doc(
                """
                The URL to refresh the token and obtain a new one.
                """
            ),
        ] = None,
        scheme_name: Annotated[
            Optional[str],
            Doc(
                """
                Security scheme name.
    
                It will be included in the generated OpenAPI (e.g. visible at `/docs`).
                """
            ),
        ] = None,
        scopes: Annotated[
            Optional[dict[str, str]],
            Doc(
                """
                The OAuth2 scopes that would be required by the *path operations* that
                use this dependency.
                """
            ),
        ] = None,
        description: Annotated[
            Optional[str],
            Doc(
                """
                Security scheme description.
    
                It will be included in the generated OpenAPI (e.g. visible at `/docs`).
                """
            ),
        ] = None,
        auto_error: Annotated[
            bool,
            Doc(
                """
                By default, if no HTTP Authorization header is provided, required for
                OAuth2 authentication, it will automatically cancel the request and
                send the client an error.
    
                If `auto_error` is set to `False`, when the HTTP Authorization header
                is not available, instead of erroring out, the dependency result will
                be `None`.
    
                This is useful when you want to have optional authentication.
    
                It is also useful when you want to have authentication that can be
                provided in one of multiple optional ways (for example, with OAuth2
                or in a cookie).
                """
            ),
        ] = True,
    ):
        if not scopes:
            scopes = {}
        flows = OAuthFlowsModel(
            authorizationCode=cast(
                Any,
                {
                    "authorizationUrl": authorizationUrl,
                    "tokenUrl": tokenUrl,
                    "refreshUrl": refreshUrl,
                    "scopes": scopes,
                },
            )
        )
        super().__init__(
            flows=flows,
            scheme_name=scheme_name,
            description=description,
            auto_error=auto_error,
        )
      
  
---|---  
  
###  `` model `instance-attribute` [¶](#fastapi.security.OAuth2AuthorizationCodeBearer.model "Permanent link")
    
    
    model = [OAuth2](../openapi/models/#fastapi.openapi.models.OAuth2 "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">OAuth2</span> \(<code>fastapi.openapi.models.OAuth2</code>\)")(
        flows=cast([OAuthFlows](../openapi/models/#fastapi.openapi.models.OAuthFlows "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">OAuthFlows</span> \(<code>fastapi.openapi.models.OAuthFlows</code>\)"), flows), description=description
    )
    

###  `` scheme_name `instance-attribute` [¶](#fastapi.security.OAuth2AuthorizationCodeBearer.scheme_name "Permanent link")
    
    
    scheme_name = scheme_name or __name__
    

###  `` auto_error `instance-attribute` [¶](#fastapi.security.OAuth2AuthorizationCodeBearer.auto_error "Permanent link")
    
    
    auto_error = auto_error
    

###  `` make_not_authenticated_error [¶](#fastapi.security.OAuth2AuthorizationCodeBearer.make_not_authenticated_error "Permanent link")
    
    
    make_not_authenticated_error()
    

The OAuth 2 specification doesn't define the challenge that should be used, because a `Bearer` token is not really the only option to authenticate.

But declaring any other authentication challenge would be application-specific as it's not defined in the specification.

For practical reasons, this method uses the `Bearer` challenge by default, as it's probably the most common one.

If you are implementing an OAuth2 authentication scheme other than the provided ones in FastAPI (based on bearer tokens), you might want to override this.

Ref: https://datatracker.ietf.org/doc/html/rfc6749

Source code in `fastapi/security/oauth2.py`
    
    
    401
    402
    403
    404
    405
    406
    407
    408
    409
    410
    411
    412
    413
    414
    415
    416
    417
    418
    419
    420
    421

| 
    
    
    def make_not_authenticated_error(self) -> HTTPException:
        """
        The OAuth 2 specification doesn't define the challenge that should be used,
        because a `Bearer` token is not really the only option to authenticate.
    
        But declaring any other authentication challenge would be application-specific
        as it's not defined in the specification.
    
        For practical reasons, this method uses the `Bearer` challenge by default, as
        it's probably the most common one.
    
        If you are implementing an OAuth2 authentication scheme other than the provided
        ones in FastAPI (based on bearer tokens), you might want to override this.
    
        Ref: https://datatracker.ietf.org/doc/html/rfc6749
        """
        return HTTPException(
            status_code=HTTP_401_UNAUTHORIZED,
            detail="Not authenticated",
            headers={"WWW-Authenticate": "Bearer"},
        )
      
  
---|---  
  
##  `` fastapi.security.OAuth2PasswordBearer [¶](#fastapi.security.OAuth2PasswordBearer "Permanent link")
    
    
    OAuth2PasswordBearer(
        tokenUrl,
        scheme_name=None,
        scopes=None,
        description=None,
        auto_error=True,
        refreshUrl=None,
    )
    

Bases: `[OAuth2](#fastapi.security.OAuth2 "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">fastapi.security.OAuth2</span> \(<code>fastapi.security.oauth2.OAuth2</code>\)")`

OAuth2 flow for authentication using a bearer token obtained with a password. An instance of it would be used as a dependency.

Read more about it in the [FastAPI docs for Simple OAuth2 with Password and Bearer](https://fastapi.tiangolo.com/tutorial/security/simple-oauth2/).

PARAMETER | DESCRIPTION  
---|---  
`tokenUrl` |  The URL to obtain the OAuth2 token. This would be the _path operation_ that has `OAuth2PasswordRequestForm` as a dependency. Read more about it in the [FastAPI docs for Simple OAuth2 with Password and Bearer](https://fastapi.tiangolo.com/tutorial/security/simple-oauth2/). **TYPE:** `str`  
`scheme_name` |  Security scheme name. It will be included in the generated OpenAPI (e.g. visible at `/docs`). **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`scopes` |  The OAuth2 scopes that would be required by the _path operations_ that use this dependency. Read more about it in the [FastAPI docs for Simple OAuth2 with Password and Bearer](https://fastapi.tiangolo.com/tutorial/security/simple-oauth2/). **TYPE:** `Optional[dict[str, str]]` **DEFAULT:** `None`  
`description` |  Security scheme description. It will be included in the generated OpenAPI (e.g. visible at `/docs`). **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`auto_error` |  By default, if no HTTP Authorization header is provided, required for OAuth2 authentication, it will automatically cancel the request and send the client an error. If `auto_error` is set to `False`, when the HTTP Authorization header is not available, instead of erroring out, the dependency result will be `None`. This is useful when you want to have optional authentication. It is also useful when you want to have authentication that can be provided in one of multiple optional ways (for example, with OAuth2 or in a cookie). **TYPE:** `bool` **DEFAULT:** `True`  
`refreshUrl` |  The URL to refresh the token and obtain a new one. **TYPE:** `Optional[str]` **DEFAULT:** `None`  
Source code in `fastapi/security/oauth2.py`
    
    
    442
    443
    444
    445
    446
    447
    448
    449
    450
    451
    452
    453
    454
    455
    456
    457
    458
    459
    460
    461
    462
    463
    464
    465
    466
    467
    468
    469
    470
    471
    472
    473
    474
    475
    476
    477
    478
    479
    480
    481
    482
    483
    484
    485
    486
    487
    488
    489
    490
    491
    492
    493
    494
    495
    496
    497
    498
    499
    500
    501
    502
    503
    504
    505
    506
    507
    508
    509
    510
    511
    512
    513
    514
    515
    516
    517
    518
    519
    520
    521
    522
    523
    524
    525
    526
    527
    528
    529
    530
    531
    532
    533
    534

| 
    
    
    def __init__(
        self,
        tokenUrl: Annotated[
            str,
            Doc(
                """
                The URL to obtain the OAuth2 token. This would be the *path operation*
                that has `OAuth2PasswordRequestForm` as a dependency.
    
                Read more about it in the
                [FastAPI docs for Simple OAuth2 with Password and Bearer](https://fastapi.tiangolo.com/tutorial/security/simple-oauth2/).
                """
            ),
        ],
        scheme_name: Annotated[
            Optional[str],
            Doc(
                """
                Security scheme name.
    
                It will be included in the generated OpenAPI (e.g. visible at `/docs`).
                """
            ),
        ] = None,
        scopes: Annotated[
            Optional[dict[str, str]],
            Doc(
                """
                The OAuth2 scopes that would be required by the *path operations* that
                use this dependency.
    
                Read more about it in the
                [FastAPI docs for Simple OAuth2 with Password and Bearer](https://fastapi.tiangolo.com/tutorial/security/simple-oauth2/).
                """
            ),
        ] = None,
        description: Annotated[
            Optional[str],
            Doc(
                """
                Security scheme description.
    
                It will be included in the generated OpenAPI (e.g. visible at `/docs`).
                """
            ),
        ] = None,
        auto_error: Annotated[
            bool,
            Doc(
                """
                By default, if no HTTP Authorization header is provided, required for
                OAuth2 authentication, it will automatically cancel the request and
                send the client an error.
    
                If `auto_error` is set to `False`, when the HTTP Authorization header
                is not available, instead of erroring out, the dependency result will
                be `None`.
    
                This is useful when you want to have optional authentication.
    
                It is also useful when you want to have authentication that can be
                provided in one of multiple optional ways (for example, with OAuth2
                or in a cookie).
                """
            ),
        ] = True,
        refreshUrl: Annotated[
            Optional[str],
            Doc(
                """
                The URL to refresh the token and obtain a new one.
                """
            ),
        ] = None,
    ):
        if not scopes:
            scopes = {}
        flows = OAuthFlowsModel(
            password=cast(
                Any,
                {
                    "tokenUrl": tokenUrl,
                    "refreshUrl": refreshUrl,
                    "scopes": scopes,
                },
            )
        )
        super().__init__(
            flows=flows,
            scheme_name=scheme_name,
            description=description,
            auto_error=auto_error,
        )
      
  
---|---  
  
###  `` model `instance-attribute` [¶](#fastapi.security.OAuth2PasswordBearer.model "Permanent link")
    
    
    model = [OAuth2](../openapi/models/#fastapi.openapi.models.OAuth2 "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">OAuth2</span> \(<code>fastapi.openapi.models.OAuth2</code>\)")(
        flows=cast([OAuthFlows](../openapi/models/#fastapi.openapi.models.OAuthFlows "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">OAuthFlows</span> \(<code>fastapi.openapi.models.OAuthFlows</code>\)"), flows), description=description
    )
    

###  `` scheme_name `instance-attribute` [¶](#fastapi.security.OAuth2PasswordBearer.scheme_name "Permanent link")
    
    
    scheme_name = scheme_name or __name__
    

###  `` auto_error `instance-attribute` [¶](#fastapi.security.OAuth2PasswordBearer.auto_error "Permanent link")
    
    
    auto_error = auto_error
    

###  `` make_not_authenticated_error [¶](#fastapi.security.OAuth2PasswordBearer.make_not_authenticated_error "Permanent link")
    
    
    make_not_authenticated_error()
    

The OAuth 2 specification doesn't define the challenge that should be used, because a `Bearer` token is not really the only option to authenticate.

But declaring any other authentication challenge would be application-specific as it's not defined in the specification.

For practical reasons, this method uses the `Bearer` challenge by default, as it's probably the most common one.

If you are implementing an OAuth2 authentication scheme other than the provided ones in FastAPI (based on bearer tokens), you might want to override this.

Ref: https://datatracker.ietf.org/doc/html/rfc6749

Source code in `fastapi/security/oauth2.py`
    
    
    401
    402
    403
    404
    405
    406
    407
    408
    409
    410
    411
    412
    413
    414
    415
    416
    417
    418
    419
    420
    421

| 
    
    
    def make_not_authenticated_error(self) -> HTTPException:
        """
        The OAuth 2 specification doesn't define the challenge that should be used,
        because a `Bearer` token is not really the only option to authenticate.
    
        But declaring any other authentication challenge would be application-specific
        as it's not defined in the specification.
    
        For practical reasons, this method uses the `Bearer` challenge by default, as
        it's probably the most common one.
    
        If you are implementing an OAuth2 authentication scheme other than the provided
        ones in FastAPI (based on bearer tokens), you might want to override this.
    
        Ref: https://datatracker.ietf.org/doc/html/rfc6749
        """
        return HTTPException(
            status_code=HTTP_401_UNAUTHORIZED,
            detail="Not authenticated",
            headers={"WWW-Authenticate": "Bearer"},
        )
      
  
---|---  
  
## OAuth2 Password Form[¶](#oauth2-password-form "Permanent link")

##  `` fastapi.security.OAuth2PasswordRequestForm [¶](#fastapi.security.OAuth2PasswordRequestForm "Permanent link")
    
    
    OAuth2PasswordRequestForm(
        *,
        grant_type=None,
        username,
        password,
        scope="",
        client_id=None,
        client_secret=None
    )
    

This is a dependency class to collect the `username` and `password` as form data for an OAuth2 password flow.

The OAuth2 specification dictates that for a password flow the data should be collected using form data (instead of JSON) and that it should have the specific fields `username` and `password`.

All the initialization parameters are extracted from the request.

Read more about it in the [FastAPI docs for Simple OAuth2 with Password and Bearer](https://fastapi.tiangolo.com/tutorial/security/simple-oauth2/).

#### Example[¶](#fastapi.security.OAuth2PasswordRequestForm--example "Permanent link")
    
    
    from typing import Annotated
    
    from fastapi import Depends, FastAPI
    from fastapi.security import OAuth2PasswordRequestForm
    
    app = FastAPI()
    
    
    @app.post("/login")
    def login(form_data: Annotated[OAuth2PasswordRequestForm, Depends()]):
        data = {}
        data["scopes"] = []
        for scope in form_data.scopes:
            data["scopes"].append(scope)
        if form_data.client_id:
            data["client_id"] = form_data.client_id
        if form_data.client_secret:
            data["client_secret"] = form_data.client_secret
        return data
    

Note that for OAuth2 the scope `items:read` is a single scope in an opaque string. You could have custom internal logic to separate it by colon characters (`:`) or similar, and get the two parts `items` and `read`. Many applications do that to group and organize permissions, you could do it as well in your application, just know that that it is application specific, it's not part of the specification.

PARAMETER | DESCRIPTION  
---|---  
`grant_type` |  The OAuth2 spec says it is required and MUST be the fixed string "password". Nevertheless, this dependency class is permissive and allows not passing it. If you want to enforce it, use instead the `OAuth2PasswordRequestFormStrict` dependency. Read more about it in the [FastAPI docs for Simple OAuth2 with Password and Bearer](https://fastapi.tiangolo.com/tutorial/security/simple-oauth2/). **TYPE:** `Union[str, None]` **DEFAULT:** `None`  
`username` |  `username` string. The OAuth2 spec requires the exact field name `username`. Read more about it in the [FastAPI docs for Simple OAuth2 with Password and Bearer](https://fastapi.tiangolo.com/tutorial/security/simple-oauth2/). **TYPE:** `str`  
`password` |  `password` string. The OAuth2 spec requires the exact field name `password`. Read more about it in the [FastAPI docs for Simple OAuth2 with Password and Bearer](https://fastapi.tiangolo.com/tutorial/security/simple-oauth2/). **TYPE:** `str`  
`scope` |  A single string with actually several scopes separated by spaces. Each scope is also a string. For example, a single string with: ```python "items:read items:write users:read profile openid" ```` would represent the scopes:

  * `items:read`
  * `items:write`
  * `users:read`
  * `profile`
  * `openid`

Read more about it in the [FastAPI docs for Simple OAuth2 with Password and Bearer](https://fastapi.tiangolo.com/tutorial/security/simple-oauth2/). **TYPE:** `str` **DEFAULT:** `''`  
`client_id` |  If there's a `client_id`, it can be sent as part of the form fields. But the OAuth2 specification recommends sending the `client_id` and `client_secret` (if any) using HTTP Basic auth. **TYPE:** `Union[str, None]` **DEFAULT:** `None`  
`client_secret` |  If there's a `client_password` (and a `client_id`), they can be sent as part of the form fields. But the OAuth2 specification recommends sending the `client_id` and `client_secret` (if any) using HTTP Basic auth. **TYPE:** `Union[str, None]` **DEFAULT:** `None`  
Source code in `fastapi/security/oauth2.py`
    
    
     59
     60
     61
     62
     63
     64
     65
     66
     67
     68
     69
     70
     71
     72
     73
     74
     75
     76
     77
     78
     79
     80
     81
     82
     83
     84
     85
     86
     87
     88
     89
     90
     91
     92
     93
     94
     95
     96
     97
     98
     99
    100
    101
    102
    103
    104
    105
    106
    107
    108
    109
    110
    111
    112
    113
    114
    115
    116
    117
    118
    119
    120
    121
    122
    123
    124
    125
    126
    127
    128
    129
    130
    131
    132
    133
    134
    135
    136
    137
    138
    139
    140
    141
    142
    143
    144
    145
    146
    147
    148
    149
    150
    151
    152
    153
    154
    155
    156
    157
    158
    159

| 
    
    
    def __init__(
        self,
        *,
        grant_type: Annotated[
            Union[str, None],
            Form(pattern="^password$"),
            Doc(
                """
                The OAuth2 spec says it is required and MUST be the fixed string
                "password". Nevertheless, this dependency class is permissive and
                allows not passing it. If you want to enforce it, use instead the
                `OAuth2PasswordRequestFormStrict` dependency.
    
                Read more about it in the
                [FastAPI docs for Simple OAuth2 with Password and Bearer](https://fastapi.tiangolo.com/tutorial/security/simple-oauth2/).
                """
            ),
        ] = None,
        username: Annotated[
            str,
            Form(),
            Doc(
                """
                `username` string. The OAuth2 spec requires the exact field name
                `username`.
    
                Read more about it in the
                [FastAPI docs for Simple OAuth2 with Password and Bearer](https://fastapi.tiangolo.com/tutorial/security/simple-oauth2/).
                """
            ),
        ],
        password: Annotated[
            str,
            Form(json_schema_extra={"format": "password"}),
            Doc(
                """
                `password` string. The OAuth2 spec requires the exact field name
                `password`.
    
                Read more about it in the
                [FastAPI docs for Simple OAuth2 with Password and Bearer](https://fastapi.tiangolo.com/tutorial/security/simple-oauth2/).
                """
            ),
        ],
        scope: Annotated[
            str,
            Form(),
            Doc(
                """
                A single string with actually several scopes separated by spaces. Each
                scope is also a string.
    
                For example, a single string with:
    
                ```python
                "items:read items:write users:read profile openid"
                ````
    
                would represent the scopes:
    
                * `items:read`
                * `items:write`
                * `users:read`
                * `profile`
                * `openid`
    
                Read more about it in the
                [FastAPI docs for Simple OAuth2 with Password and Bearer](https://fastapi.tiangolo.com/tutorial/security/simple-oauth2/).
                """
            ),
        ] = "",
        client_id: Annotated[
            Union[str, None],
            Form(),
            Doc(
                """
                If there's a `client_id`, it can be sent as part of the form fields.
                But the OAuth2 specification recommends sending the `client_id` and
                `client_secret` (if any) using HTTP Basic auth.
                """
            ),
        ] = None,
        client_secret: Annotated[
            Union[str, None],
            Form(json_schema_extra={"format": "password"}),
            Doc(
                """
                If there's a `client_password` (and a `client_id`), they can be sent
                as part of the form fields. But the OAuth2 specification recommends
                sending the `client_id` and `client_secret` (if any) using HTTP Basic
                auth.
                """
            ),
        ] = None,
    ):
        self.grant_type = grant_type
        self.username = username
        self.password = password
        self.scopes = scope.split()
        self.client_id = client_id
        self.client_secret = client_secret
      
  
---|---  
  
###  `` grant_type `instance-attribute` [¶](#fastapi.security.OAuth2PasswordRequestForm.grant_type "Permanent link")
    
    
    grant_type = grant_type
    

###  `` username `instance-attribute` [¶](#fastapi.security.OAuth2PasswordRequestForm.username "Permanent link")
    
    
    username = username
    

###  `` password `instance-attribute` [¶](#fastapi.security.OAuth2PasswordRequestForm.password "Permanent link")
    
    
    password = password
    

###  `` scopes `instance-attribute` [¶](#fastapi.security.OAuth2PasswordRequestForm.scopes "Permanent link")
    
    
    scopes = split()
    

###  `` client_id `instance-attribute` [¶](#fastapi.security.OAuth2PasswordRequestForm.client_id "Permanent link")
    
    
    client_id = client_id
    

###  `` client_secret `instance-attribute` [¶](#fastapi.security.OAuth2PasswordRequestForm.client_secret "Permanent link")
    
    
    client_secret = client_secret
    

##  `` fastapi.security.OAuth2PasswordRequestFormStrict [¶](#fastapi.security.OAuth2PasswordRequestFormStrict "Permanent link")
    
    
    OAuth2PasswordRequestFormStrict(
        grant_type,
        username,
        password,
        scope="",
        client_id=None,
        client_secret=None,
    )
    

Bases: `[OAuth2PasswordRequestForm](#fastapi.security.OAuth2PasswordRequestForm "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">fastapi.security.OAuth2PasswordRequestForm</span> \(<code>fastapi.security.oauth2.OAuth2PasswordRequestForm</code>\)")`

This is a dependency class to collect the `username` and `password` as form data for an OAuth2 password flow.

The OAuth2 specification dictates that for a password flow the data should be collected using form data (instead of JSON) and that it should have the specific fields `username` and `password`.

All the initialization parameters are extracted from the request.

The only difference between `OAuth2PasswordRequestFormStrict` and `OAuth2PasswordRequestForm` is that `OAuth2PasswordRequestFormStrict` requires the client to send the form field `grant_type` with the value `"password"`, which is required in the OAuth2 specification (it seems that for no particular reason), while for `OAuth2PasswordRequestForm` `grant_type` is optional.

Read more about it in the [FastAPI docs for Simple OAuth2 with Password and Bearer](https://fastapi.tiangolo.com/tutorial/security/simple-oauth2/).

#### Example[¶](#fastapi.security.OAuth2PasswordRequestFormStrict--example "Permanent link")
    
    
    from typing import Annotated
    
    from fastapi import Depends, FastAPI
    from fastapi.security import OAuth2PasswordRequestForm
    
    app = FastAPI()
    
    
    @app.post("/login")
    def login(form_data: Annotated[OAuth2PasswordRequestFormStrict, Depends()]):
        data = {}
        data["scopes"] = []
        for scope in form_data.scopes:
            data["scopes"].append(scope)
        if form_data.client_id:
            data["client_id"] = form_data.client_id
        if form_data.client_secret:
            data["client_secret"] = form_data.client_secret
        return data
    

Note that for OAuth2 the scope `items:read` is a single scope in an opaque string. You could have custom internal logic to separate it by colon characters (`:`) or similar, and get the two parts `items` and `read`. Many applications do that to group and organize permissions, you could do it as well in your application, just know that that it is application specific, it's not part of the specification.

the OAuth2 spec says it is required and MUST be the fixed string "password".

This dependency is strict about it. If you want to be permissive, use instead the OAuth2PasswordRequestForm dependency class.

username: username string. The OAuth2 spec requires the exact field name "username". password: password string. The OAuth2 spec requires the exact field name "password". scope: Optional string. Several scopes (each one a string) separated by spaces. E.g. "items:read items:write users:read profile openid" client_id: optional string. OAuth2 recommends sending the client_id and client_secret (if any) using HTTP Basic auth, as: client_id:client_secret client_secret: optional string. OAuth2 recommends sending the client_id and client_secret (if any) using HTTP Basic auth, as: client_id:client_secret

PARAMETER | DESCRIPTION  
---|---  
`grant_type` |  The OAuth2 spec says it is required and MUST be the fixed string "password". This dependency is strict about it. If you want to be permissive, use instead the `OAuth2PasswordRequestForm` dependency class. Read more about it in the [FastAPI docs for Simple OAuth2 with Password and Bearer](https://fastapi.tiangolo.com/tutorial/security/simple-oauth2/). **TYPE:** `str`  
`username` |  `username` string. The OAuth2 spec requires the exact field name `username`. Read more about it in the [FastAPI docs for Simple OAuth2 with Password and Bearer](https://fastapi.tiangolo.com/tutorial/security/simple-oauth2/). **TYPE:** `str`  
`password` |  `password` string. The OAuth2 spec requires the exact field name `password`. Read more about it in the [FastAPI docs for Simple OAuth2 with Password and Bearer](https://fastapi.tiangolo.com/tutorial/security/simple-oauth2/). **TYPE:** `str`  
`scope` |  A single string with actually several scopes separated by spaces. Each scope is also a string. For example, a single string with: ```python "items:read items:write users:read profile openid" ```` would represent the scopes:

  * `items:read`
  * `items:write`
  * `users:read`
  * `profile`
  * `openid`

Read more about it in the [FastAPI docs for Simple OAuth2 with Password and Bearer](https://fastapi.tiangolo.com/tutorial/security/simple-oauth2/). **TYPE:** `str` **DEFAULT:** `''`  
`client_id` |  If there's a `client_id`, it can be sent as part of the form fields. But the OAuth2 specification recommends sending the `client_id` and `client_secret` (if any) using HTTP Basic auth. **TYPE:** `Union[str, None]` **DEFAULT:** `None`  
`client_secret` |  If there's a `client_password` (and a `client_id`), they can be sent as part of the form fields. But the OAuth2 specification recommends sending the `client_id` and `client_secret` (if any) using HTTP Basic auth. **TYPE:** `Union[str, None]` **DEFAULT:** `None`  
Source code in `fastapi/security/oauth2.py`
    
    
    226
    227
    228
    229
    230
    231
    232
    233
    234
    235
    236
    237
    238
    239
    240
    241
    242
    243
    244
    245
    246
    247
    248
    249
    250
    251
    252
    253
    254
    255
    256
    257
    258
    259
    260
    261
    262
    263
    264
    265
    266
    267
    268
    269
    270
    271
    272
    273
    274
    275
    276
    277
    278
    279
    280
    281
    282
    283
    284
    285
    286
    287
    288
    289
    290
    291
    292
    293
    294
    295
    296
    297
    298
    299
    300
    301
    302
    303
    304
    305
    306
    307
    308
    309
    310
    311
    312
    313
    314
    315
    316
    317
    318
    319
    320
    321
    322
    323
    324
    325
    326
    327

| 
    
    
    def __init__(
        self,
        grant_type: Annotated[
            str,
            Form(pattern="^password$"),
            Doc(
                """
                The OAuth2 spec says it is required and MUST be the fixed string
                "password". This dependency is strict about it. If you want to be
                permissive, use instead the `OAuth2PasswordRequestForm` dependency
                class.
    
                Read more about it in the
                [FastAPI docs for Simple OAuth2 with Password and Bearer](https://fastapi.tiangolo.com/tutorial/security/simple-oauth2/).
                """
            ),
        ],
        username: Annotated[
            str,
            Form(),
            Doc(
                """
                `username` string. The OAuth2 spec requires the exact field name
                `username`.
    
                Read more about it in the
                [FastAPI docs for Simple OAuth2 with Password and Bearer](https://fastapi.tiangolo.com/tutorial/security/simple-oauth2/).
                """
            ),
        ],
        password: Annotated[
            str,
            Form(),
            Doc(
                """
                `password` string. The OAuth2 spec requires the exact field name
                `password`.
    
                Read more about it in the
                [FastAPI docs for Simple OAuth2 with Password and Bearer](https://fastapi.tiangolo.com/tutorial/security/simple-oauth2/).
                """
            ),
        ],
        scope: Annotated[
            str,
            Form(),
            Doc(
                """
                A single string with actually several scopes separated by spaces. Each
                scope is also a string.
    
                For example, a single string with:
    
                ```python
                "items:read items:write users:read profile openid"
                ````
    
                would represent the scopes:
    
                * `items:read`
                * `items:write`
                * `users:read`
                * `profile`
                * `openid`
    
                Read more about it in the
                [FastAPI docs for Simple OAuth2 with Password and Bearer](https://fastapi.tiangolo.com/tutorial/security/simple-oauth2/).
                """
            ),
        ] = "",
        client_id: Annotated[
            Union[str, None],
            Form(),
            Doc(
                """
                If there's a `client_id`, it can be sent as part of the form fields.
                But the OAuth2 specification recommends sending the `client_id` and
                `client_secret` (if any) using HTTP Basic auth.
                """
            ),
        ] = None,
        client_secret: Annotated[
            Union[str, None],
            Form(),
            Doc(
                """
                If there's a `client_password` (and a `client_id`), they can be sent
                as part of the form fields. But the OAuth2 specification recommends
                sending the `client_id` and `client_secret` (if any) using HTTP Basic
                auth.
                """
            ),
        ] = None,
    ):
        super().__init__(
            grant_type=grant_type,
            username=username,
            password=password,
            scope=scope,
            client_id=client_id,
            client_secret=client_secret,
        )
      
  
---|---  
  
###  `` grant_type `instance-attribute` [¶](#fastapi.security.OAuth2PasswordRequestFormStrict.grant_type "Permanent link")
    
    
    grant_type = grant_type
    

###  `` username `instance-attribute` [¶](#fastapi.security.OAuth2PasswordRequestFormStrict.username "Permanent link")
    
    
    username = username
    

###  `` password `instance-attribute` [¶](#fastapi.security.OAuth2PasswordRequestFormStrict.password "Permanent link")
    
    
    password = password
    

###  `` scopes `instance-attribute` [¶](#fastapi.security.OAuth2PasswordRequestFormStrict.scopes "Permanent link")
    
    
    scopes = split()
    

###  `` client_id `instance-attribute` [¶](#fastapi.security.OAuth2PasswordRequestFormStrict.client_id "Permanent link")
    
    
    client_id = client_id
    

###  `` client_secret `instance-attribute` [¶](#fastapi.security.OAuth2PasswordRequestFormStrict.client_secret "Permanent link")
    
    
    client_secret = client_secret
    

## OAuth2 Security Scopes in Dependencies[¶](#oauth2-security-scopes-in-dependencies "Permanent link")

##  `` fastapi.security.SecurityScopes [¶](#fastapi.security.SecurityScopes "Permanent link")
    
    
    SecurityScopes(scopes=None)
    

This is a special class that you can define in a parameter in a dependency to obtain the OAuth2 scopes required by all the dependencies in the same chain.

This way, multiple dependencies can have different scopes, even when used in the same _path operation_. And with this, you can access all the scopes required in all those dependencies in a single place.

Read more about it in the [FastAPI docs for OAuth2 scopes](https://fastapi.tiangolo.com/advanced/security/oauth2-scopes/).

PARAMETER | DESCRIPTION  
---|---  
`scopes` |  This will be filled by FastAPI. **TYPE:** `Optional[list[str]]` **DEFAULT:** `None`  
Source code in `fastapi/security/oauth2.py`
    
    
    666
    667
    668
    669
    670
    671
    672
    673
    674
    675
    676
    677
    678
    679
    680
    681
    682
    683
    684
    685
    686
    687
    688
    689
    690
    691
    692
    693

| 
    
    
    def __init__(
        self,
        scopes: Annotated[
            Optional[list[str]],
            Doc(
                """
                This will be filled by FastAPI.
                """
            ),
        ] = None,
    ):
        self.scopes: Annotated[
            list[str],
            Doc(
                """
                The list of all the scopes required by dependencies.
                """
            ),
        ] = scopes or []
        self.scope_str: Annotated[
            str,
            Doc(
                """
                All the scopes required by all the dependencies in a single string
                separated by spaces, as defined in the OAuth2 specification.
                """
            ),
        ] = " ".join(self.scopes)
      
  
---|---  
  
###  `` scopes `instance-attribute` [¶](#fastapi.security.SecurityScopes.scopes "Permanent link")
    
    
    scopes = scopes or []
    

The list of all the scopes required by dependencies.

###  `` scope_str `instance-attribute` [¶](#fastapi.security.SecurityScopes.scope_str "Permanent link")
    
    
    scope_str = join(scopes)
    

All the scopes required by all the dependencies in a single string separated by spaces, as defined in the OAuth2 specification.

## OpenID Connect[¶](#openid-connect "Permanent link")

##  `` fastapi.security.OpenIdConnect [¶](#fastapi.security.OpenIdConnect "Permanent link")
    
    
    OpenIdConnect(
        *,
        openIdConnectUrl,
        scheme_name=None,
        description=None,
        auto_error=True
    )
    

Bases: `SecurityBase`

OpenID Connect authentication class. An instance of it would be used as a dependency.

**Warning** : this is only a stub to connect the components with OpenAPI in FastAPI, but it doesn't implement the full OpenIdConnect scheme, for example, it doesn't use the OpenIDConnect URL. You would need to to subclass it and implement it in your code.

PARAMETER | DESCRIPTION  
---|---  
`openIdConnectUrl` |  The OpenID Connect URL. **TYPE:** `str`  
`scheme_name` |  Security scheme name. It will be included in the generated OpenAPI (e.g. visible at `/docs`). **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`description` |  Security scheme description. It will be included in the generated OpenAPI (e.g. visible at `/docs`). **TYPE:** `Optional[str]` **DEFAULT:** `None`  
`auto_error` |  By default, if no HTTP Authorization header is provided, required for OpenID Connect authentication, it will automatically cancel the request and send the client an error. If `auto_error` is set to `False`, when the HTTP Authorization header is not available, instead of erroring out, the dependency result will be `None`. This is useful when you want to have optional authentication. It is also useful when you want to have authentication that can be provided in one of multiple optional ways (for example, with OpenID Connect or in a cookie). **TYPE:** `bool` **DEFAULT:** `True`  
Source code in `fastapi/security/open_id_connect_url.py`
    
    
    22
    23
    24
    25
    26
    27
    28
    29
    30
    31
    32
    33
    34
    35
    36
    37
    38
    39
    40
    41
    42
    43
    44
    45
    46
    47
    48
    49
    50
    51
    52
    53
    54
    55
    56
    57
    58
    59
    60
    61
    62
    63
    64
    65
    66
    67
    68
    69
    70
    71
    72
    73
    74
    75
    76
    77
    78

| 
    
    
    def __init__(
        self,
        *,
        openIdConnectUrl: Annotated[
            str,
            Doc(
                """
            The OpenID Connect URL.
            """
            ),
        ],
        scheme_name: Annotated[
            Optional[str],
            Doc(
                """
                Security scheme name.
    
                It will be included in the generated OpenAPI (e.g. visible at `/docs`).
                """
            ),
        ] = None,
        description: Annotated[
            Optional[str],
            Doc(
                """
                Security scheme description.
    
                It will be included in the generated OpenAPI (e.g. visible at `/docs`).
                """
            ),
        ] = None,
        auto_error: Annotated[
            bool,
            Doc(
                """
                By default, if no HTTP Authorization header is provided, required for
                OpenID Connect authentication, it will automatically cancel the request
                and send the client an error.
    
                If `auto_error` is set to `False`, when the HTTP Authorization header
                is not available, instead of erroring out, the dependency result will
                be `None`.
    
                This is useful when you want to have optional authentication.
    
                It is also useful when you want to have authentication that can be
                provided in one of multiple optional ways (for example, with OpenID
                Connect or in a cookie).
                """
            ),
        ] = True,
    ):
        self.model = OpenIdConnectModel(
            openIdConnectUrl=openIdConnectUrl, description=description
        )
        self.scheme_name = scheme_name or self.__class__.__name__
        self.auto_error = auto_error
      
  
---|---  
  
###  `` model `instance-attribute` [¶](#fastapi.security.OpenIdConnect.model "Permanent link")
    
    
    model = [OpenIdConnect](../openapi/models/#fastapi.openapi.models.OpenIdConnect "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">OpenIdConnect</span> \(<code>fastapi.openapi.models.OpenIdConnect</code>\)")(
        openIdConnectUrl=openIdConnectUrl,
        description=description,
    )
    

###  `` scheme_name `instance-attribute` [¶](#fastapi.security.OpenIdConnect.scheme_name "Permanent link")
    
    
    scheme_name = scheme_name or __name__
    

###  `` auto_error `instance-attribute` [¶](#fastapi.security.OpenIdConnect.auto_error "Permanent link")
    
    
    auto_error = auto_error
    

###  `` make_not_authenticated_error [¶](#fastapi.security.OpenIdConnect.make_not_authenticated_error "Permanent link")
    
    
    make_not_authenticated_error()
    

Source code in `fastapi/security/open_id_connect_url.py`
    
    
    80
    81
    82
    83
    84
    85

| 
    
    
    def make_not_authenticated_error(self) -> HTTPException:
        return HTTPException(
            status_code=HTTP_401_UNAUTHORIZED,
            detail="Not authenticated",
            headers={"WWW-Authenticate": "Bearer"},
        )
      
  
---|---

---

###### Encoders -jsonable_encoder¶

# Encoders - `jsonable_encoder`[¶](#encoders-jsonable_encoder "Permanent link")

##  `` fastapi.encoders.jsonable_encoder [¶](#fastapi.encoders.jsonable_encoder "Permanent link")
    
    
    jsonable_encoder(
        obj,
        include=None,
        exclude=None,
        by_alias=True,
        exclude_unset=False,
        exclude_defaults=False,
        exclude_none=False,
        custom_encoder=None,
        sqlalchemy_safe=True,
    )
    

Convert any object to something that can be encoded in JSON.

This is used internally by FastAPI to make sure anything you return can be encoded as JSON before it is sent to the client.

You can also use it yourself, for example to convert objects before saving them in a database that supports only JSON.

Read more about it in the [FastAPI docs for JSON Compatible Encoder](https://fastapi.tiangolo.com/tutorial/encoder/).

PARAMETER | DESCRIPTION  
---|---  
`obj` |  The input object to convert to JSON. **TYPE:** `Any`  
`include` |  Pydantic's `include` parameter, passed to Pydantic models to set the fields to include. **TYPE:** `Optional[IncEx]` **DEFAULT:** `None`  
`exclude` |  Pydantic's `exclude` parameter, passed to Pydantic models to set the fields to exclude. **TYPE:** `Optional[IncEx]` **DEFAULT:** `None`  
`by_alias` |  Pydantic's `by_alias` parameter, passed to Pydantic models to define if the output should use the alias names (when provided) or the Python attribute names. In an API, if you set an alias, it's probably because you want to use it in the result, so you probably want to leave this set to `True`. **TYPE:** `bool` **DEFAULT:** `True`  
`exclude_unset` |  Pydantic's `exclude_unset` parameter, passed to Pydantic models to define if it should exclude from the output the fields that were not explicitly set (and that only had their default values). **TYPE:** `bool` **DEFAULT:** `False`  
`exclude_defaults` |  Pydantic's `exclude_defaults` parameter, passed to Pydantic models to define if it should exclude from the output the fields that had the same default value, even when they were explicitly set. **TYPE:** `bool` **DEFAULT:** `False`  
`exclude_none` |  Pydantic's `exclude_none` parameter, passed to Pydantic models to define if it should exclude from the output any fields that have a `None` value. **TYPE:** `bool` **DEFAULT:** `False`  
`custom_encoder` |  Pydantic's `custom_encoder` parameter, passed to Pydantic models to define a custom encoder. **TYPE:** `Optional[dict[Any, Callable[[Any], Any]]]` **DEFAULT:** `None`  
`sqlalchemy_safe` |  Exclude from the output any fields that start with the name `_sa`. This is mainly a hack for compatibility with SQLAlchemy objects, they store internal SQLAlchemy-specific state in attributes named with `_sa`, and those objects can't (and shouldn't be) serialized to JSON. **TYPE:** `bool` **DEFAULT:** `True`  
Source code in `fastapi/encoders.py`
    
    
    111
    112
    113
    114
    115
    116
    117
    118
    119
    120
    121
    122
    123
    124
    125
    126
    127
    128
    129
    130
    131
    132
    133
    134
    135
    136
    137
    138
    139
    140
    141
    142
    143
    144
    145
    146
    147
    148
    149
    150
    151
    152
    153
    154
    155
    156
    157
    158
    159
    160
    161
    162
    163
    164
    165
    166
    167
    168
    169
    170
    171
    172
    173
    174
    175
    176
    177
    178
    179
    180
    181
    182
    183
    184
    185
    186
    187
    188
    189
    190
    191
    192
    193
    194
    195
    196
    197
    198
    199
    200
    201
    202
    203
    204
    205
    206
    207
    208
    209
    210
    211
    212
    213
    214
    215
    216
    217
    218
    219
    220
    221
    222
    223
    224
    225
    226
    227
    228
    229
    230
    231
    232
    233
    234
    235
    236
    237
    238
    239
    240
    241
    242
    243
    244
    245
    246
    247
    248
    249
    250
    251
    252
    253
    254
    255
    256
    257
    258
    259
    260
    261
    262
    263
    264
    265
    266
    267
    268
    269
    270
    271
    272
    273
    274
    275
    276
    277
    278
    279
    280
    281
    282
    283
    284
    285
    286
    287
    288
    289
    290
    291
    292
    293
    294
    295
    296
    297
    298
    299
    300
    301
    302
    303
    304
    305
    306
    307
    308
    309
    310
    311
    312
    313
    314
    315
    316
    317
    318
    319
    320
    321
    322
    323
    324
    325
    326
    327
    328
    329
    330
    331
    332
    333
    334
    335
    336
    337
    338
    339
    340
    341
    342
    343
    344
    345
    346

| 
    
    
    def jsonable_encoder(
        obj: Annotated[
            Any,
            Doc(
                """
                The input object to convert to JSON.
                """
            ),
        ],
        include: Annotated[
            Optional[IncEx],
            Doc(
                """
                Pydantic's `include` parameter, passed to Pydantic models to set the
                fields to include.
                """
            ),
        ] = None,
        exclude: Annotated[
            Optional[IncEx],
            Doc(
                """
                Pydantic's `exclude` parameter, passed to Pydantic models to set the
                fields to exclude.
                """
            ),
        ] = None,
        by_alias: Annotated[
            bool,
            Doc(
                """
                Pydantic's `by_alias` parameter, passed to Pydantic models to define if
                the output should use the alias names (when provided) or the Python
                attribute names. In an API, if you set an alias, it's probably because you
                want to use it in the result, so you probably want to leave this set to
                `True`.
                """
            ),
        ] = True,
        exclude_unset: Annotated[
            bool,
            Doc(
                """
                Pydantic's `exclude_unset` parameter, passed to Pydantic models to define
                if it should exclude from the output the fields that were not explicitly
                set (and that only had their default values).
                """
            ),
        ] = False,
        exclude_defaults: Annotated[
            bool,
            Doc(
                """
                Pydantic's `exclude_defaults` parameter, passed to Pydantic models to define
                if it should exclude from the output the fields that had the same default
                value, even when they were explicitly set.
                """
            ),
        ] = False,
        exclude_none: Annotated[
            bool,
            Doc(
                """
                Pydantic's `exclude_none` parameter, passed to Pydantic models to define
                if it should exclude from the output any fields that have a `None` value.
                """
            ),
        ] = False,
        custom_encoder: Annotated[
            Optional[dict[Any, Callable[[Any], Any]]],
            Doc(
                """
                Pydantic's `custom_encoder` parameter, passed to Pydantic models to define
                a custom encoder.
                """
            ),
        ] = None,
        sqlalchemy_safe: Annotated[
            bool,
            Doc(
                """
                Exclude from the output any fields that start with the name `_sa`.
    
                This is mainly a hack for compatibility with SQLAlchemy objects, they
                store internal SQLAlchemy-specific state in attributes named with `_sa`,
                and those objects can't (and shouldn't be) serialized to JSON.
                """
            ),
        ] = True,
    ) -> Any:
        """
        Convert any object to something that can be encoded in JSON.
    
        This is used internally by FastAPI to make sure anything you return can be
        encoded as JSON before it is sent to the client.
    
        You can also use it yourself, for example to convert objects before saving them
        in a database that supports only JSON.
    
        Read more about it in the
        [FastAPI docs for JSON Compatible Encoder](https://fastapi.tiangolo.com/tutorial/encoder/).
        """
        custom_encoder = custom_encoder or {}
        if custom_encoder:
            if type(obj) in custom_encoder:
                return custom_encoder[type(obj)](obj)
            else:
                for encoder_type, encoder_instance in custom_encoder.items():
                    if isinstance(obj, encoder_type):
                        return encoder_instance(obj)
        if include is not None and not isinstance(include, (set, dict)):
            include = set(include)  # type: ignore[assignment]
        if exclude is not None and not isinstance(exclude, (set, dict)):
            exclude = set(exclude)  # type: ignore[assignment]
        if isinstance(obj, BaseModel):
            obj_dict = obj.model_dump(
                mode="json",
                include=include,
                exclude=exclude,
                by_alias=by_alias,
                exclude_unset=exclude_unset,
                exclude_none=exclude_none,
                exclude_defaults=exclude_defaults,
            )
            return jsonable_encoder(
                obj_dict,
                exclude_none=exclude_none,
                exclude_defaults=exclude_defaults,
                sqlalchemy_safe=sqlalchemy_safe,
            )
        if dataclasses.is_dataclass(obj):
            assert not isinstance(obj, type)
            obj_dict = dataclasses.asdict(obj)
            return jsonable_encoder(
                obj_dict,
                include=include,
                exclude=exclude,
                by_alias=by_alias,
                exclude_unset=exclude_unset,
                exclude_defaults=exclude_defaults,
                exclude_none=exclude_none,
                custom_encoder=custom_encoder,
                sqlalchemy_safe=sqlalchemy_safe,
            )
        if isinstance(obj, Enum):
            return obj.value
        if isinstance(obj, PurePath):
            return str(obj)
        if isinstance(obj, (str, int, float, type(None))):
            return obj
        if isinstance(obj, PydanticUndefinedType):
            return None
        if isinstance(obj, dict):
            encoded_dict = {}
            allowed_keys = set(obj.keys())
            if include is not None:
                allowed_keys &= set(include)
            if exclude is not None:
                allowed_keys -= set(exclude)
            for key, value in obj.items():
                if (
                    (
                        not sqlalchemy_safe
                        or (not isinstance(key, str))
                        or (not key.startswith("_sa"))
                    )
                    and (value is not None or not exclude_none)
                    and key in allowed_keys
                ):
                    encoded_key = jsonable_encoder(
                        key,
                        by_alias=by_alias,
                        exclude_unset=exclude_unset,
                        exclude_none=exclude_none,
                        custom_encoder=custom_encoder,
                        sqlalchemy_safe=sqlalchemy_safe,
                    )
                    encoded_value = jsonable_encoder(
                        value,
                        by_alias=by_alias,
                        exclude_unset=exclude_unset,
                        exclude_none=exclude_none,
                        custom_encoder=custom_encoder,
                        sqlalchemy_safe=sqlalchemy_safe,
                    )
                    encoded_dict[encoded_key] = encoded_value
            return encoded_dict
        if isinstance(obj, (list, set, frozenset, GeneratorType, tuple, deque)):
            encoded_list = []
            for item in obj:
                encoded_list.append(
                    jsonable_encoder(
                        item,
                        include=include,
                        exclude=exclude,
                        by_alias=by_alias,
                        exclude_unset=exclude_unset,
                        exclude_defaults=exclude_defaults,
                        exclude_none=exclude_none,
                        custom_encoder=custom_encoder,
                        sqlalchemy_safe=sqlalchemy_safe,
                    )
                )
            return encoded_list
    
        if type(obj) in ENCODERS_BY_TYPE:
            return ENCODERS_BY_TYPE[type(obj)](obj)
        for encoder, classes_tuple in encoders_by_class_tuples.items():
            if isinstance(obj, classes_tuple):
                return encoder(obj)
        if is_pydantic_v1_model_instance(obj):
            raise PydanticV1NotSupportedError(
                "pydantic.v1 models are no longer supported by FastAPI."
                f" Please update the model {obj!r}."
            )
        try:
            data = dict(obj)
        except Exception as e:
            errors: list[Exception] = []
            errors.append(e)
            try:
                data = vars(obj)
            except Exception as e:
                errors.append(e)
                raise ValueError(errors) from e
        return jsonable_encoder(
            data,
            include=include,
            exclude=exclude,
            by_alias=by_alias,
            exclude_unset=exclude_unset,
            exclude_defaults=exclude_defaults,
            exclude_none=exclude_none,
            custom_encoder=custom_encoder,
            sqlalchemy_safe=sqlalchemy_safe,
        )
      
  
---|---

---

###### Static Files -StaticFiles¶

# Static Files - `StaticFiles`[¶](#static-files-staticfiles "Permanent link")

You can use the `StaticFiles` class to serve static files, like JavaScript, CSS, images, etc.

Read more about it in the [FastAPI docs for Static Files](https://fastapi.tiangolo.com/tutorial/static-files/).

You can import it directly from `fastapi.staticfiles`:
    
    
    from fastapi.staticfiles import StaticFiles
    

##  `` fastapi.staticfiles.StaticFiles [¶](#fastapi.staticfiles.StaticFiles "Permanent link")
    
    
    StaticFiles(
        *,
        directory=None,
        packages=None,
        html=False,
        check_dir=True,
        follow_symlink=False
    )
    

Source code in `starlette/staticfiles.py`
    
    
    40
    41
    42
    43
    44
    45
    46
    47
    48
    49
    50
    51
    52
    53
    54
    55
    56

| 
    
    
    def __init__(
        self,
        *,
        directory: PathLike | None = None,
        packages: list[str | tuple[str, str]] | None = None,
        html: bool = False,
        check_dir: bool = True,
        follow_symlink: bool = False,
    ) -> None:
        self.directory = directory
        self.packages = packages
        self.all_directories = self.get_directories(directory, packages)
        self.html = html
        self.config_checked = False
        self.follow_symlink = follow_symlink
        if check_dir and directory is not None and not os.path.isdir(directory):
            raise RuntimeError(f"Directory '{directory}' does not exist")
      
  
---|---  
  
###  `` directory `instance-attribute` [¶](#fastapi.staticfiles.StaticFiles.directory "Permanent link")
    
    
    directory = directory
    

###  `` packages `instance-attribute` [¶](#fastapi.staticfiles.StaticFiles.packages "Permanent link")
    
    
    packages = packages
    

###  `` all_directories `instance-attribute` [¶](#fastapi.staticfiles.StaticFiles.all_directories "Permanent link")
    
    
    all_directories = get_directories(directory, packages)
    

###  `` html `instance-attribute` [¶](#fastapi.staticfiles.StaticFiles.html "Permanent link")
    
    
    html = html
    

###  `` config_checked `instance-attribute` [¶](#fastapi.staticfiles.StaticFiles.config_checked "Permanent link")
    
    
    config_checked = False
    

###  `` follow_symlink `instance-attribute` [¶](#fastapi.staticfiles.StaticFiles.follow_symlink "Permanent link")
    
    
    follow_symlink = follow_symlink
    

###  `` get_directories [¶](#fastapi.staticfiles.StaticFiles.get_directories "Permanent link")
    
    
    get_directories(directory=None, packages=None)
    

Given `directory` and `packages` arguments, return a list of all the directories that should be used for serving static files from.

Source code in `starlette/staticfiles.py`
    
    
    58
    59
    60
    61
    62
    63
    64
    65
    66
    67
    68
    69
    70
    71
    72
    73
    74
    75
    76
    77
    78
    79
    80
    81
    82
    83
    84
    85

| 
    
    
    def get_directories(
        self,
        directory: PathLike | None = None,
        packages: list[str | tuple[str, str]] | None = None,
    ) -> list[PathLike]:
        """
        Given `directory` and `packages` arguments, return a list of all the
        directories that should be used for serving static files from.
        """
        directories = []
        if directory is not None:
            directories.append(directory)
    
        for package in packages or []:
            if isinstance(package, tuple):
                package, statics_dir = package
            else:
                statics_dir = "statics"
            spec = importlib.util.find_spec(package)
            assert spec is not None, f"Package {package!r} could not be found."
            assert spec.origin is not None, f"Package {package!r} could not be found."
            package_directory = os.path.normpath(os.path.join(spec.origin, "..", statics_dir))
            assert os.path.isdir(package_directory), (
                f"Directory '{statics_dir!r}' in package {package!r} could not be found."
            )
            directories.append(package_directory)
    
        return directories
      
  
---|---  
  
###  `` get_path [¶](#fastapi.staticfiles.StaticFiles.get_path "Permanent link")
    
    
    get_path(scope)
    

Given the ASGI scope, return the `path` string to serve up, with OS specific path separators, and any '..', '.' components removed.

Source code in `starlette/staticfiles.py`
    
    
    101
    102
    103
    104
    105
    106
    107

| 
    
    
    def get_path(self, scope: Scope) -> str:
        """
        Given the ASGI scope, return the `path` string to serve up,
        with OS specific path separators, and any '..', '.' components removed.
        """
        route_path = get_route_path(scope)
        return os.path.normpath(os.path.join(*route_path.split("/")))
      
  
---|---  
  
###  `` get_response `async` [¶](#fastapi.staticfiles.StaticFiles.get_response "Permanent link")
    
    
    get_response(path, scope)
    

Returns an HTTP response, given the incoming path, method and request headers.

Source code in `starlette/staticfiles.py`
    
    
    109
    110
    111
    112
    113
    114
    115
    116
    117
    118
    119
    120
    121
    122
    123
    124
    125
    126
    127
    128
    129
    130
    131
    132
    133
    134
    135
    136
    137
    138
    139
    140
    141
    142
    143
    144
    145
    146
    147
    148
    149

| 
    
    
    async def get_response(self, path: str, scope: Scope) -> Response:
        """
        Returns an HTTP response, given the incoming path, method and request headers.
        """
        if scope["method"] not in ("GET", "HEAD"):
            raise HTTPException(status_code=405)
    
        try:
            full_path, stat_result = await anyio.to_thread.run_sync(self.lookup_path, path)
        except PermissionError:
            raise HTTPException(status_code=401)
        except OSError as exc:
            # Filename is too long, so it can't be a valid static file.
            if exc.errno == errno.ENAMETOOLONG:
                raise HTTPException(status_code=404)
    
            raise exc
    
        if stat_result and stat.S_ISREG(stat_result.st_mode):
            # We have a static file to serve.
            return self.file_response(full_path, stat_result, scope)
    
        elif stat_result and stat.S_ISDIR(stat_result.st_mode) and self.html:
            # We're in HTML mode, and have got a directory URL.
            # Check if we have 'index.html' file to serve.
            index_path = os.path.join(path, "index.html")
            full_path, stat_result = await anyio.to_thread.run_sync(self.lookup_path, index_path)
            if stat_result is not None and stat.S_ISREG(stat_result.st_mode):
                if not scope["path"].endswith("/"):
                    # Directory URLs should redirect to always end in "/".
                    url = URL(scope=scope)
                    url = url.replace(path=url.path + "/")
                    return RedirectResponse(url=url)
                return self.file_response(full_path, stat_result, scope)
    
        if self.html:
            # Check for '404.html' if we're in HTML mode.
            full_path, stat_result = await anyio.to_thread.run_sync(self.lookup_path, "404.html")
            if stat_result and stat.S_ISREG(stat_result.st_mode):
                return FileResponse(full_path, stat_result=stat_result, status_code=404)
        raise HTTPException(status_code=404)
      
  
---|---  
  
###  `` lookup_path [¶](#fastapi.staticfiles.StaticFiles.lookup_path "Permanent link")
    
    
    lookup_path(path)
    

Source code in `starlette/staticfiles.py`
    
    
    151
    152
    153
    154
    155
    156
    157
    158
    159
    160
    161
    162
    163
    164
    165
    166
    167

| 
    
    
    def lookup_path(self, path: str) -> tuple[str, os.stat_result | None]:
        for directory in self.all_directories:
            joined_path = os.path.join(directory, path)
            if self.follow_symlink:
                full_path = os.path.abspath(joined_path)
                directory = os.path.abspath(directory)
            else:
                full_path = os.path.realpath(joined_path)
                directory = os.path.realpath(directory)
            if os.path.commonpath([full_path, directory]) != str(directory):
                # Don't allow misbehaving clients to break out of the static files directory.
                continue
            try:
                return full_path, os.stat(full_path)
            except (FileNotFoundError, NotADirectoryError):
                continue
        return "", None
      
  
---|---  
  
###  `` file_response [¶](#fastapi.staticfiles.StaticFiles.file_response "Permanent link")
    
    
    file_response(
        full_path, stat_result, scope, status_code=200
    )
    

Source code in `starlette/staticfiles.py`
    
    
    169
    170
    171
    172
    173
    174
    175
    176
    177
    178
    179
    180
    181

| 
    
    
    def file_response(
        self,
        full_path: PathLike,
        stat_result: os.stat_result,
        scope: Scope,
        status_code: int = 200,
    ) -> Response:
        request_headers = Headers(scope=scope)
    
        response = FileResponse(full_path, status_code=status_code, stat_result=stat_result)
        if self.is_not_modified(response.headers, request_headers):
            return NotModifiedResponse(response.headers)
        return response
      
  
---|---  
  
###  `` check_config `async` [¶](#fastapi.staticfiles.StaticFiles.check_config "Permanent link")
    
    
    check_config()
    

Perform a one-off configuration check that StaticFiles is actually pointed at a directory, so that we can raise loud errors rather than just returning 404 responses.

Source code in `starlette/staticfiles.py`
    
    
    183
    184
    185
    186
    187
    188
    189
    190
    191
    192
    193
    194
    195
    196
    197

| 
    
    
    async def check_config(self) -> None:
        """
        Perform a one-off configuration check that StaticFiles is actually
        pointed at a directory, so that we can raise loud errors rather than
        just returning 404 responses.
        """
        if self.directory is None:
            return
    
        try:
            stat_result = await anyio.to_thread.run_sync(os.stat, self.directory)
        except FileNotFoundError:
            raise RuntimeError(f"StaticFiles directory '{self.directory}' does not exist.")
        if not (stat.S_ISDIR(stat_result.st_mode) or stat.S_ISLNK(stat_result.st_mode)):
            raise RuntimeError(f"StaticFiles path '{self.directory}' is not a directory.")
      
  
---|---  
  
###  `` is_not_modified [¶](#fastapi.staticfiles.StaticFiles.is_not_modified "Permanent link")
    
    
    is_not_modified(response_headers, request_headers)
    

Given the request and response headers, return `True` if an HTTP "Not Modified" response could be returned instead.

Source code in `starlette/staticfiles.py`
    
    
    199
    200
    201
    202
    203
    204
    205
    206
    207
    208
    209
    210
    211
    212
    213
    214
    215
    216
    217

| 
    
    
    def is_not_modified(self, response_headers: Headers, request_headers: Headers) -> bool:
        """
        Given the request and response headers, return `True` if an HTTP
        "Not Modified" response could be returned instead.
        """
        if if_none_match := request_headers.get("if-none-match"):
            # The "etag" header is added by FileResponse, so it's always present.
            etag = response_headers["etag"]
            return etag in [tag.strip(" W/") for tag in if_none_match.split(",")]
    
        try:
            if_modified_since = parsedate(request_headers["if-modified-since"])
            last_modified = parsedate(response_headers["last-modified"])
            if if_modified_since is not None and last_modified is not None and if_modified_since >= last_modified:
                return True
        except KeyError:
            pass
    
        return False
      
  
---|---

---

###### Templating -Jinja2Templates¶

# Templating - `Jinja2Templates`[¶](#templating-jinja2templates "Permanent link")

You can use the `Jinja2Templates` class to render Jinja templates.

Read more about it in the [FastAPI docs for Templates](https://fastapi.tiangolo.com/advanced/templates/).

You can import it directly from `fastapi.templating`:
    
    
    from fastapi.templating import Jinja2Templates
    

##  `` fastapi.templating.Jinja2Templates [¶](#fastapi.templating.Jinja2Templates "Permanent link")
    
    
    Jinja2Templates(
        directory: (
            str | PathLike[str] | Sequence[str | PathLike[str]]
        ),
        *,
        context_processors: (
            list[Callable[[[Request](../request/#fastapi.Request "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">fastapi.Request</span> \(<code>starlette.requests.Request</code>\)")], dict[str, Any]]] | None
        ) = None,
        **env_options: Any
    )
    
    
    
    Jinja2Templates(
        *,
        env: Environment,
        context_processors: (
            list[Callable[[[Request](../request/#fastapi.Request "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">fastapi.Request</span> \(<code>starlette.requests.Request</code>\)")], dict[str, Any]]] | None
        ) = None
    )
    
    
    
    Jinja2Templates(
        directory=None,
        *,
        context_processors=None,
        env=None,
        **env_options
    )
    

templates = Jinja2Templates("templates")

return templates.TemplateResponse("index.html", {"request": request})

Source code in `starlette/templating.py`
    
    
     84
     85
     86
     87
     88
     89
     90
     91
     92
     93
     94
     95
     96
     97
     98
     99
    100
    101
    102
    103
    104
    105

| 
    
    
    def __init__(
        self,
        directory: str | PathLike[str] | Sequence[str | PathLike[str]] | None = None,
        *,
        context_processors: list[Callable[[Request], dict[str, Any]]] | None = None,
        env: jinja2.Environment | None = None,
        **env_options: Any,
    ) -> None:
        if env_options:
            warnings.warn(
                "Extra environment options are deprecated. Use a preconfigured jinja2.Environment instead.",
                DeprecationWarning,
            )
        assert jinja2 is not None, "jinja2 must be installed to use Jinja2Templates"
        assert bool(directory) ^ bool(env), "either 'directory' or 'env' arguments must be passed"
        self.context_processors = context_processors or []
        if directory is not None:
            self.env = self._create_env(directory, **env_options)
        elif env is not None:  # pragma: no branch
            self.env = env
    
        self._setup_env_defaults(self.env)
      
  
---|---  
  
###  `` context_processors `instance-attribute` [¶](#fastapi.templating.Jinja2Templates.context_processors "Permanent link")
    
    
    context_processors = context_processors or []
    

###  `` env `instance-attribute` [¶](#fastapi.templating.Jinja2Templates.env "Permanent link")
    
    
    env = _create_env(directory, **env_options)
    

###  `` get_template [¶](#fastapi.templating.Jinja2Templates.get_template "Permanent link")
    
    
    get_template(name)
    

Source code in `starlette/templating.py`
    
    
    131
    132

| 
    
    
    def get_template(self, name: str) -> jinja2.Template:
        return self.env.get_template(name)
      
  
---|---  
  
###  `` TemplateResponse [¶](#fastapi.templating.Jinja2Templates.TemplateResponse "Permanent link")
    
    
    TemplateResponse(
        request: [Request](../request/#fastapi.Request "<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">fastapi.Request</span> \(<code>starlette.requests.Request</code>\)"),
        name: str,
        context: dict[str, Any] | None = None,
        status_code: int = 200,
        headers: Mapping[str, str] | None = None,
        media_type: str | None = None,
        background: BackgroundTask | None = None,
    ) -> _TemplateResponse
    
    
    
    TemplateResponse(
        name: str,
        context: dict[str, Any] | None = None,
        status_code: int = 200,
        headers: Mapping[str, str] | None = None,
        media_type: str | None = None,
        background: BackgroundTask | None = None,
    ) -> _TemplateResponse
    
    
    
    TemplateResponse(*args, **kwargs)
    

Source code in `starlette/templating.py`
    
    
    159
    160
    161
    162
    163
    164
    165
    166
    167
    168
    169
    170
    171
    172
    173
    174
    175
    176
    177
    178
    179
    180
    181
    182
    183
    184
    185
    186
    187
    188
    189
    190
    191
    192
    193
    194
    195
    196
    197
    198
    199
    200
    201
    202
    203
    204
    205
    206
    207
    208
    209
    210
    211
    212
    213
    214
    215
    216
    217

| 
    
    
    def TemplateResponse(self, *args: Any, **kwargs: Any) -> _TemplateResponse:
        if args:
            if isinstance(args[0], str):  # the first argument is template name (old style)
                warnings.warn(
                    "The `name` is not the first parameter anymore. "
                    "The first parameter should be the `Request` instance.\n"
                    'Replace `TemplateResponse(name, {"request": request})` by `TemplateResponse(request, name)`.',
                    DeprecationWarning,
                )
    
                name = args[0]
                context = args[1] if len(args) > 1 else kwargs.get("context", {})
                status_code = args[2] if len(args) > 2 else kwargs.get("status_code", 200)
                headers = args[3] if len(args) > 3 else kwargs.get("headers")
                media_type = args[4] if len(args) > 4 else kwargs.get("media_type")
                background = args[5] if len(args) > 5 else kwargs.get("background")
    
                if "request" not in context:
                    raise ValueError('context must include a "request" key')
                request = context["request"]
            else:  # the first argument is a request instance (new style)
                request = args[0]
                name = args[1] if len(args) > 1 else kwargs["name"]
                context = args[2] if len(args) > 2 else kwargs.get("context", {})
                status_code = args[3] if len(args) > 3 else kwargs.get("status_code", 200)
                headers = args[4] if len(args) > 4 else kwargs.get("headers")
                media_type = args[5] if len(args) > 5 else kwargs.get("media_type")
                background = args[6] if len(args) > 6 else kwargs.get("background")
        else:  # all arguments are kwargs
            if "request" not in kwargs:
                warnings.warn(
                    "The `TemplateResponse` now requires the `request` argument.\n"
                    'Replace `TemplateResponse(name, {"context": context})` by `TemplateResponse(request, name)`.',
                    DeprecationWarning,
                )
                if "request" not in kwargs.get("context", {}):
                    raise ValueError('context must include a "request" key')
    
            context = kwargs.get("context", {})
            request = kwargs.get("request", context.get("request"))
            name = cast(str, kwargs["name"])
            status_code = kwargs.get("status_code", 200)
            headers = kwargs.get("headers")
            media_type = kwargs.get("media_type")
            background = kwargs.get("background")
    
        context.setdefault("request", request)
        for context_processor in self.context_processors:
            context.update(context_processor(request))
    
        template = self.get_template(name)
        return _TemplateResponse(
            template,
            context,
            status_code=status_code,
            headers=headers,
            media_type=media_type,
            background=background,
        )
      
  
---|---

---

###### Test Client -TestClient¶

# Test Client - `TestClient`[¶](#test-client-testclient "Permanent link")

You can use the `TestClient` class to test FastAPI applications without creating an actual HTTP and socket connection, just communicating directly with the FastAPI code.

Read more about it in the [FastAPI docs for Testing](https://fastapi.tiangolo.com/tutorial/testing/).

You can import it directly from `fastapi.testclient`:
    
    
    from fastapi.testclient import TestClient
    

##  `` fastapi.testclient.TestClient [¶](#fastapi.testclient.TestClient "Permanent link")
    
    
    TestClient(
        app,
        base_url="http://testserver",
        raise_server_exceptions=True,
        root_path="",
        backend="asyncio",
        backend_options=None,
        cookies=None,
        headers=None,
        follow_redirects=True,
        client=("testclient", 50000),
    )
    

Bases: `Client`

Source code in `starlette/testclient.py`
    
    
    373
    374
    375
    376
    377
    378
    379
    380
    381
    382
    383
    384
    385
    386
    387
    388
    389
    390
    391
    392
    393
    394
    395
    396
    397
    398
    399
    400
    401
    402
    403
    404
    405
    406
    407
    408
    409
    410
    411

| 
    
    
    def __init__(
        self,
        app: ASGIApp,
        base_url: str = "http://testserver",
        raise_server_exceptions: bool = True,
        root_path: str = "",
        backend: Literal["asyncio", "trio"] = "asyncio",
        backend_options: dict[str, Any] | None = None,
        cookies: httpx._types.CookieTypes | None = None,
        headers: dict[str, str] | None = None,
        follow_redirects: bool = True,
        client: tuple[str, int] = ("testclient", 50000),
    ) -> None:
        self.async_backend = _AsyncBackend(backend=backend, backend_options=backend_options or {})
        if _is_asgi3(app):
            asgi_app = app
        else:
            app = cast(ASGI2App, app)  # type: ignore[assignment]
            asgi_app = _WrapASGI2(app)  # type: ignore[arg-type]
        self.app = asgi_app
        self.app_state: dict[str, Any] = {}
        transport = _TestClientTransport(
            self.app,
            portal_factory=self._portal_factory,
            raise_server_exceptions=raise_server_exceptions,
            root_path=root_path,
            app_state=self.app_state,
            client=client,
        )
        if headers is None:
            headers = {}
        headers.setdefault("user-agent", "testclient")
        super().__init__(
            base_url=base_url,
            headers=headers,
            transport=transport,
            follow_redirects=follow_redirects,
            cookies=cookies,
        )
      
  
---|---  
  
###  `` headers `property` `writable` [¶](#fastapi.testclient.TestClient.headers "Permanent link")
    
    
    headers
    

HTTP headers to include when sending requests.

###  `` follow_redirects `instance-attribute` [¶](#fastapi.testclient.TestClient.follow_redirects "Permanent link")
    
    
    follow_redirects = follow_redirects
    

###  `` max_redirects `instance-attribute` [¶](#fastapi.testclient.TestClient.max_redirects "Permanent link")
    
    
    max_redirects = max_redirects
    

###  `` is_closed `property` [¶](#fastapi.testclient.TestClient.is_closed "Permanent link")
    
    
    is_closed
    

Check if the client being closed

###  `` trust_env `property` [¶](#fastapi.testclient.TestClient.trust_env "Permanent link")
    
    
    trust_env
    

###  `` timeout `property` `writable` [¶](#fastapi.testclient.TestClient.timeout "Permanent link")
    
    
    timeout
    

###  `` event_hooks `property` `writable` [¶](#fastapi.testclient.TestClient.event_hooks "Permanent link")
    
    
    event_hooks
    

###  `` auth `property` `writable` [¶](#fastapi.testclient.TestClient.auth "Permanent link")
    
    
    auth
    

Authentication class used when none is passed at the request-level.

See also [Authentication](/quickstart/#authentication).

###  `` base_url `property` `writable` [¶](#fastapi.testclient.TestClient.base_url "Permanent link")
    
    
    base_url
    

Base URL to use when sending requests with relative URLs.

###  `` cookies `property` `writable` [¶](#fastapi.testclient.TestClient.cookies "Permanent link")
    
    
    cookies
    

Cookie values to include when sending requests.

###  `` params `property` `writable` [¶](#fastapi.testclient.TestClient.params "Permanent link")
    
    
    params
    

Query parameters to include in the URL when sending requests.

###  `` task `instance-attribute` [¶](#fastapi.testclient.TestClient.task "Permanent link")
    
    
    task
    

###  `` portal `class-attribute` `instance-attribute` [¶](#fastapi.testclient.TestClient.portal "Permanent link")
    
    
    portal = None
    

###  `` async_backend `instance-attribute` [¶](#fastapi.testclient.TestClient.async_backend "Permanent link")
    
    
    async_backend = _AsyncBackend(
        backend=backend, backend_options=backend_options or {}
    )
    

###  `` app `instance-attribute` [¶](#fastapi.testclient.TestClient.app "Permanent link")
    
    
    app = asgi_app
    

###  `` app_state `instance-attribute` [¶](#fastapi.testclient.TestClient.app_state "Permanent link")
    
    
    app_state = {}
    

###  `` build_request [¶](#fastapi.testclient.TestClient.build_request "Permanent link")
    
    
    build_request(
        method,
        url,
        *,
        content=None,
        data=None,
        files=None,
        json=None,
        params=None,
        headers=None,
        cookies=None,
        timeout=USE_CLIENT_DEFAULT,
        extensions=None
    )
    

Build and return a request instance.

  * The `params`, `headers` and `cookies` arguments are merged with any values set on the client.
  * The `url` argument is merged with any `base_url` set on the client.

See also: [Request instances](/advanced/clients/#request-instances)

Source code in `httpx/_client.py`
    
    
    340
    341
    342
    343
    344
    345
    346
    347
    348
    349
    350
    351
    352
    353
    354
    355
    356
    357
    358
    359
    360
    361
    362
    363
    364
    365
    366
    367
    368
    369
    370
    371
    372
    373
    374
    375
    376
    377
    378
    379
    380
    381
    382
    383
    384
    385
    386
    387
    388
    389

| 
    
    
    def build_request(
        self,
        method: str,
        url: URL | str,
        *,
        content: RequestContent | None = None,
        data: RequestData | None = None,
        files: RequestFiles | None = None,
        json: typing.Any | None = None,
        params: QueryParamTypes | None = None,
        headers: HeaderTypes | None = None,
        cookies: CookieTypes | None = None,
        timeout: TimeoutTypes | UseClientDefault = USE_CLIENT_DEFAULT,
        extensions: RequestExtensions | None = None,
    ) -> Request:
        """
        Build and return a request instance.
    
        * The `params`, `headers` and `cookies` arguments
        are merged with any values set on the client.
        * The `url` argument is merged with any `base_url` set on the client.
    
        See also: [Request instances][0]
    
        [0]: /advanced/clients/#request-instances
        """
        url = self._merge_url(url)
        headers = self._merge_headers(headers)
        cookies = self._merge_cookies(cookies)
        params = self._merge_queryparams(params)
        extensions = {} if extensions is None else extensions
        if "timeout" not in extensions:
            timeout = (
                self.timeout
                if isinstance(timeout, UseClientDefault)
                else Timeout(timeout)
            )
            extensions = dict(**extensions, timeout=timeout.as_dict())
        return Request(
            method,
            url,
            content=content,
            data=data,
            files=files,
            json=json,
            params=params,
            headers=headers,
            cookies=cookies,
            extensions=extensions,
        )
      
  
---|---  
  
###  `` stream [¶](#fastapi.testclient.TestClient.stream "Permanent link")
    
    
    stream(
        method,
        url,
        *,
        content=None,
        data=None,
        files=None,
        json=None,
        params=None,
        headers=None,
        cookies=None,
        auth=USE_CLIENT_DEFAULT,
        follow_redirects=USE_CLIENT_DEFAULT,
        timeout=USE_CLIENT_DEFAULT,
        extensions=None
    )
    

Alternative to `httpx.request()` that streams the response body instead of loading it into memory at once.

**Parameters** : See `httpx.request`.

See also: [Streaming Responses](/quickstart#streaming-responses)

Source code in `httpx/_client.py`
    
    
    827
    828
    829
    830
    831
    832
    833
    834
    835
    836
    837
    838
    839
    840
    841
    842
    843
    844
    845
    846
    847
    848
    849
    850
    851
    852
    853
    854
    855
    856
    857
    858
    859
    860
    861
    862
    863
    864
    865
    866
    867
    868
    869
    870
    871
    872
    873
    874
    875
    876
    877

| 
    
    
    @contextmanager
    def stream(
        self,
        method: str,
        url: URL | str,
        *,
        content: RequestContent | None = None,
        data: RequestData | None = None,
        files: RequestFiles | None = None,
        json: typing.Any | None = None,
        params: QueryParamTypes | None = None,
        headers: HeaderTypes | None = None,
        cookies: CookieTypes | None = None,
        auth: AuthTypes | UseClientDefault | None = USE_CLIENT_DEFAULT,
        follow_redirects: bool | UseClientDefault = USE_CLIENT_DEFAULT,
        timeout: TimeoutTypes | UseClientDefault = USE_CLIENT_DEFAULT,
        extensions: RequestExtensions | None = None,
    ) -> typing.Iterator[Response]:
        """
        Alternative to `httpx.request()` that streams the response body
        instead of loading it into memory at once.
    
        **Parameters**: See `httpx.request`.
    
        See also: [Streaming Responses][0]
    
        [0]: /quickstart#streaming-responses
        """
        request = self.build_request(
            method=method,
            url=url,
            content=content,
            data=data,
            files=files,
            json=json,
            params=params,
            headers=headers,
            cookies=cookies,
            timeout=timeout,
            extensions=extensions,
        )
        response = self.send(
            request=request,
            auth=auth,
            follow_redirects=follow_redirects,
            stream=True,
        )
        try:
            yield response
        finally:
            response.close()
      
  
---|---  
  
###  `` send [¶](#fastapi.testclient.TestClient.send "Permanent link")
    
    
    send(
        request,
        *,
        stream=False,
        auth=USE_CLIENT_DEFAULT,
        follow_redirects=USE_CLIENT_DEFAULT
    )
    

Send a request.

The request is sent as-is, unmodified.

Typically you'll want to build one with `Client.build_request()` so that any client-level configuration is merged into the request, but passing an explicit `httpx.Request()` is supported as well.

See also: [Request instances](/advanced/clients/#request-instances)

Source code in `httpx/_client.py`
    
    
    879
    880
    881
    882
    883
    884
    885
    886
    887
    888
    889
    890
    891
    892
    893
    894
    895
    896
    897
    898
    899
    900
    901
    902
    903
    904
    905
    906
    907
    908
    909
    910
    911
    912
    913
    914
    915
    916
    917
    918
    919
    920
    921
    922
    923
    924
    925
    926
    927
    928

| 
    
    
    def send(
        self,
        request: Request,
        *,
        stream: bool = False,
        auth: AuthTypes | UseClientDefault | None = USE_CLIENT_DEFAULT,
        follow_redirects: bool | UseClientDefault = USE_CLIENT_DEFAULT,
    ) -> Response:
        """
        Send a request.
    
        The request is sent as-is, unmodified.
    
        Typically you'll want to build one with `Client.build_request()`
        so that any client-level configuration is merged into the request,
        but passing an explicit `httpx.Request()` is supported as well.
    
        See also: [Request instances][0]
    
        [0]: /advanced/clients/#request-instances
        """
        if self._state == ClientState.CLOSED:
            raise RuntimeError("Cannot send a request, as the client has been closed.")
    
        self._state = ClientState.OPENED
        follow_redirects = (
            self.follow_redirects
            if isinstance(follow_redirects, UseClientDefault)
            else follow_redirects
        )
    
        self._set_timeout(request)
    
        auth = self._build_request_auth(request, auth)
    
        response = self._send_handling_auth(
            request,
            auth=auth,
            follow_redirects=follow_redirects,
            history=[],
        )
        try:
            if not stream:
                response.read()
    
            return response
    
        except BaseException as exc:
            response.close()
            raise exc
      
  
---|---  
  
###  `` close [¶](#fastapi.testclient.TestClient.close "Permanent link")
    
    
    close()
    

Close transport and proxies.

Source code in `httpx/_client.py`
    
    
    1263
    1264
    1265
    1266
    1267
    1268
    1269
    1270
    1271
    1272
    1273

| 
    
    
    def close(self) -> None:
        """
        Close transport and proxies.
        """
        if self._state != ClientState.CLOSED:
            self._state = ClientState.CLOSED
    
            self._transport.close()
            for transport in self._mounts.values():
                if transport is not None:
                    transport.close()
      
  
---|---  
  
###  `` request [¶](#fastapi.testclient.TestClient.request "Permanent link")
    
    
    request(
        method,
        url,
        *,
        content=None,
        data=None,
        files=None,
        json=None,
        params=None,
        headers=None,
        cookies=None,
        auth=USE_CLIENT_DEFAULT,
        follow_redirects=USE_CLIENT_DEFAULT,
        timeout=USE_CLIENT_DEFAULT,
        extensions=None
    )
    

Source code in `starlette/testclient.py`
    
    
    421
    422
    423
    424
    425
    426
    427
    428
    429
    430
    431
    432
    433
    434
    435
    436
    437
    438
    439
    440
    441
    442
    443
    444
    445
    446
    447
    448
    449
    450
    451
    452
    453
    454
    455
    456
    457
    458
    459

| 
    
    
    def request(  # type: ignore[override]
        self,
        method: str,
        url: httpx._types.URLTypes,
        *,
        content: httpx._types.RequestContent | None = None,
        data: _RequestData | None = None,
        files: httpx._types.RequestFiles | None = None,
        json: Any = None,
        params: httpx._types.QueryParamTypes | None = None,
        headers: httpx._types.HeaderTypes | None = None,
        cookies: httpx._types.CookieTypes | None = None,
        auth: httpx._types.AuthTypes | httpx._client.UseClientDefault = httpx._client.USE_CLIENT_DEFAULT,
        follow_redirects: bool | httpx._client.UseClientDefault = httpx._client.USE_CLIENT_DEFAULT,
        timeout: httpx._types.TimeoutTypes | httpx._client.UseClientDefault = httpx._client.USE_CLIENT_DEFAULT,
        extensions: dict[str, Any] | None = None,
    ) -> httpx.Response:
        if timeout is not httpx.USE_CLIENT_DEFAULT:
            warnings.warn(
                "You should not use the 'timeout' argument with the TestClient. "
                "See https://github.com/Kludex/starlette/issues/1108 for more information.",
                DeprecationWarning,
            )
        url = self._merge_url(url)
        return super().request(
            method,
            url,
            content=content,
            data=data,
            files=files,
            json=json,
            params=params,
            headers=headers,
            cookies=cookies,
            auth=auth,
            follow_redirects=follow_redirects,
            timeout=timeout,
            extensions=extensions,
        )
      
  
---|---  
  
###  `` get [¶](#fastapi.testclient.TestClient.get "Permanent link")
    
    
    get(
        url,
        *,
        params=None,
        headers=None,
        cookies=None,
        auth=USE_CLIENT_DEFAULT,
        follow_redirects=USE_CLIENT_DEFAULT,
        timeout=USE_CLIENT_DEFAULT,
        extensions=None
    )
    

Source code in `starlette/testclient.py`
    
    
    461
    462
    463
    464
    465
    466
    467
    468
    469
    470
    471
    472
    473
    474
    475
    476
    477
    478
    479
    480
    481
    482

| 
    
    
    def get(  # type: ignore[override]
        self,
        url: httpx._types.URLTypes,
        *,
        params: httpx._types.QueryParamTypes | None = None,
        headers: httpx._types.HeaderTypes | None = None,
        cookies: httpx._types.CookieTypes | None = None,
        auth: httpx._types.AuthTypes | httpx._client.UseClientDefault = httpx._client.USE_CLIENT_DEFAULT,
        follow_redirects: bool | httpx._client.UseClientDefault = httpx._client.USE_CLIENT_DEFAULT,
        timeout: httpx._types.TimeoutTypes | httpx._client.UseClientDefault = httpx._client.USE_CLIENT_DEFAULT,
        extensions: dict[str, Any] | None = None,
    ) -> httpx.Response:
        return super().get(
            url,
            params=params,
            headers=headers,
            cookies=cookies,
            auth=auth,
            follow_redirects=follow_redirects,
            timeout=timeout,
            extensions=extensions,
        )
      
  
---|---  
  
###  `` options [¶](#fastapi.testclient.TestClient.options "Permanent link")
    
    
    options(
        url,
        *,
        params=None,
        headers=None,
        cookies=None,
        auth=USE_CLIENT_DEFAULT,
        follow_redirects=USE_CLIENT_DEFAULT,
        timeout=USE_CLIENT_DEFAULT,
        extensions=None
    )
    

Source code in `starlette/testclient.py`
    
    
    484
    485
    486
    487
    488
    489
    490
    491
    492
    493
    494
    495
    496
    497
    498
    499
    500
    501
    502
    503
    504
    505

| 
    
    
    def options(  # type: ignore[override]
        self,
        url: httpx._types.URLTypes,
        *,
        params: httpx._types.QueryParamTypes | None = None,
        headers: httpx._types.HeaderTypes | None = None,
        cookies: httpx._types.CookieTypes | None = None,
        auth: httpx._types.AuthTypes | httpx._client.UseClientDefault = httpx._client.USE_CLIENT_DEFAULT,
        follow_redirects: bool | httpx._client.UseClientDefault = httpx._client.USE_CLIENT_DEFAULT,
        timeout: httpx._types.TimeoutTypes | httpx._client.UseClientDefault = httpx._client.USE_CLIENT_DEFAULT,
        extensions: dict[str, Any] | None = None,
    ) -> httpx.Response:
        return super().options(
            url,
            params=params,
            headers=headers,
            cookies=cookies,
            auth=auth,
            follow_redirects=follow_redirects,
            timeout=timeout,
            extensions=extensions,
        )
      
  
---|---  
  
###  `` head [¶](#fastapi.testclient.TestClient.head "Permanent link")
    
    
    head(
        url,
        *,
        params=None,
        headers=None,
        cookies=None,
        auth=USE_CLIENT_DEFAULT,
        follow_redirects=USE_CLIENT_DEFAULT,
        timeout=USE_CLIENT_DEFAULT,
        extensions=None
    )
    

Source code in `starlette/testclient.py`
    
    
    507
    508
    509
    510
    511
    512
    513
    514
    515
    516
    517
    518
    519
    520
    521
    522
    523
    524
    525
    526
    527
    528

| 
    
    
    def head(  # type: ignore[override]
        self,
        url: httpx._types.URLTypes,
        *,
        params: httpx._types.QueryParamTypes | None = None,
        headers: httpx._types.HeaderTypes | None = None,
        cookies: httpx._types.CookieTypes | None = None,
        auth: httpx._types.AuthTypes | httpx._client.UseClientDefault = httpx._client.USE_CLIENT_DEFAULT,
        follow_redirects: bool | httpx._client.UseClientDefault = httpx._client.USE_CLIENT_DEFAULT,
        timeout: httpx._types.TimeoutTypes | httpx._client.UseClientDefault = httpx._client.USE_CLIENT_DEFAULT,
        extensions: dict[str, Any] | None = None,
    ) -> httpx.Response:
        return super().head(
            url,
            params=params,
            headers=headers,
            cookies=cookies,
            auth=auth,
            follow_redirects=follow_redirects,
            timeout=timeout,
            extensions=extensions,
        )
      
  
---|---  
  
###  `` post [¶](#fastapi.testclient.TestClient.post "Permanent link")
    
    
    post(
        url,
        *,
        content=None,
        data=None,
        files=None,
        json=None,
        params=None,
        headers=None,
        cookies=None,
        auth=USE_CLIENT_DEFAULT,
        follow_redirects=USE_CLIENT_DEFAULT,
        timeout=USE_CLIENT_DEFAULT,
        extensions=None
    )
    

Source code in `starlette/testclient.py`
    
    
    530
    531
    532
    533
    534
    535
    536
    537
    538
    539
    540
    541
    542
    543
    544
    545
    546
    547
    548
    549
    550
    551
    552
    553
    554
    555
    556
    557
    558
    559

| 
    
    
    def post(  # type: ignore[override]
        self,
        url: httpx._types.URLTypes,
        *,
        content: httpx._types.RequestContent | None = None,
        data: _RequestData | None = None,
        files: httpx._types.RequestFiles | None = None,
        json: Any = None,
        params: httpx._types.QueryParamTypes | None = None,
        headers: httpx._types.HeaderTypes | None = None,
        cookies: httpx._types.CookieTypes | None = None,
        auth: httpx._types.AuthTypes | httpx._client.UseClientDefault = httpx._client.USE_CLIENT_DEFAULT,
        follow_redirects: bool | httpx._client.UseClientDefault = httpx._client.USE_CLIENT_DEFAULT,
        timeout: httpx._types.TimeoutTypes | httpx._client.UseClientDefault = httpx._client.USE_CLIENT_DEFAULT,
        extensions: dict[str, Any] | None = None,
    ) -> httpx.Response:
        return super().post(
            url,
            content=content,
            data=data,
            files=files,
            json=json,
            params=params,
            headers=headers,
            cookies=cookies,
            auth=auth,
            follow_redirects=follow_redirects,
            timeout=timeout,
            extensions=extensions,
        )
      
  
---|---  
  
###  `` put [¶](#fastapi.testclient.TestClient.put "Permanent link")
    
    
    put(
        url,
        *,
        content=None,
        data=None,
        files=None,
        json=None,
        params=None,
        headers=None,
        cookies=None,
        auth=USE_CLIENT_DEFAULT,
        follow_redirects=USE_CLIENT_DEFAULT,
        timeout=USE_CLIENT_DEFAULT,
        extensions=None
    )
    

Source code in `starlette/testclient.py`
    
    
    561
    562
    563
    564
    565
    566
    567
    568
    569
    570
    571
    572
    573
    574
    575
    576
    577
    578
    579
    580
    581
    582
    583
    584
    585
    586
    587
    588
    589
    590

| 
    
    
    def put(  # type: ignore[override]
        self,
        url: httpx._types.URLTypes,
        *,
        content: httpx._types.RequestContent | None = None,
        data: _RequestData | None = None,
        files: httpx._types.RequestFiles | None = None,
        json: Any = None,
        params: httpx._types.QueryParamTypes | None = None,
        headers: httpx._types.HeaderTypes | None = None,
        cookies: httpx._types.CookieTypes | None = None,
        auth: httpx._types.AuthTypes | httpx._client.UseClientDefault = httpx._client.USE_CLIENT_DEFAULT,
        follow_redirects: bool | httpx._client.UseClientDefault = httpx._client.USE_CLIENT_DEFAULT,
        timeout: httpx._types.TimeoutTypes | httpx._client.UseClientDefault = httpx._client.USE_CLIENT_DEFAULT,
        extensions: dict[str, Any] | None = None,
    ) -> httpx.Response:
        return super().put(
            url,
            content=content,
            data=data,
            files=files,
            json=json,
            params=params,
            headers=headers,
            cookies=cookies,
            auth=auth,
            follow_redirects=follow_redirects,
            timeout=timeout,
            extensions=extensions,
        )
      
  
---|---  
  
###  `` patch [¶](#fastapi.testclient.TestClient.patch "Permanent link")
    
    
    patch(
        url,
        *,
        content=None,
        data=None,
        files=None,
        json=None,
        params=None,
        headers=None,
        cookies=None,
        auth=USE_CLIENT_DEFAULT,
        follow_redirects=USE_CLIENT_DEFAULT,
        timeout=USE_CLIENT_DEFAULT,
        extensions=None
    )
    

Source code in `starlette/testclient.py`
    
    
    592
    593
    594
    595
    596
    597
    598
    599
    600
    601
    602
    603
    604
    605
    606
    607
    608
    609
    610
    611
    612
    613
    614
    615
    616
    617
    618
    619
    620
    621

| 
    
    
    def patch(  # type: ignore[override]
        self,
        url: httpx._types.URLTypes,
        *,
        content: httpx._types.RequestContent | None = None,
        data: _RequestData | None = None,
        files: httpx._types.RequestFiles | None = None,
        json: Any = None,
        params: httpx._types.QueryParamTypes | None = None,
        headers: httpx._types.HeaderTypes | None = None,
        cookies: httpx._types.CookieTypes | None = None,
        auth: httpx._types.AuthTypes | httpx._client.UseClientDefault = httpx._client.USE_CLIENT_DEFAULT,
        follow_redirects: bool | httpx._client.UseClientDefault = httpx._client.USE_CLIENT_DEFAULT,
        timeout: httpx._types.TimeoutTypes | httpx._client.UseClientDefault = httpx._client.USE_CLIENT_DEFAULT,
        extensions: dict[str, Any] | None = None,
    ) -> httpx.Response:
        return super().patch(
            url,
            content=content,
            data=data,
            files=files,
            json=json,
            params=params,
            headers=headers,
            cookies=cookies,
            auth=auth,
            follow_redirects=follow_redirects,
            timeout=timeout,
            extensions=extensions,
        )
      
  
---|---  
  
###  `` delete [¶](#fastapi.testclient.TestClient.delete "Permanent link")
    
    
    delete(
        url,
        *,
        params=None,
        headers=None,
        cookies=None,
        auth=USE_CLIENT_DEFAULT,
        follow_redirects=USE_CLIENT_DEFAULT,
        timeout=USE_CLIENT_DEFAULT,
        extensions=None
    )
    

Source code in `starlette/testclient.py`
    
    
    623
    624
    625
    626
    627
    628
    629
    630
    631
    632
    633
    634
    635
    636
    637
    638
    639
    640
    641
    642
    643
    644

| 
    
    
    def delete(  # type: ignore[override]
        self,
        url: httpx._types.URLTypes,
        *,
        params: httpx._types.QueryParamTypes | None = None,
        headers: httpx._types.HeaderTypes | None = None,
        cookies: httpx._types.CookieTypes | None = None,
        auth: httpx._types.AuthTypes | httpx._client.UseClientDefault = httpx._client.USE_CLIENT_DEFAULT,
        follow_redirects: bool | httpx._client.UseClientDefault = httpx._client.USE_CLIENT_DEFAULT,
        timeout: httpx._types.TimeoutTypes | httpx._client.UseClientDefault = httpx._client.USE_CLIENT_DEFAULT,
        extensions: dict[str, Any] | None = None,
    ) -> httpx.Response:
        return super().delete(
            url,
            params=params,
            headers=headers,
            cookies=cookies,
            auth=auth,
            follow_redirects=follow_redirects,
            timeout=timeout,
            extensions=extensions,
        )
      
  
---|---  
  
###  `` websocket_connect [¶](#fastapi.testclient.TestClient.websocket_connect "Permanent link")
    
    
    websocket_connect(url, subprotocols=None, **kwargs)
    

Source code in `starlette/testclient.py`
    
    
    646
    647
    648
    649
    650
    651
    652
    653
    654
    655
    656
    657
    658
    659
    660
    661
    662
    663
    664
    665
    666
    667

| 
    
    
    def websocket_connect(
        self,
        url: str,
        subprotocols: Sequence[str] | None = None,
        **kwargs: Any,
    ) -> WebSocketTestSession:
        url = urljoin("ws://testserver", url)
        headers = kwargs.get("headers", {})
        headers.setdefault("connection", "upgrade")
        headers.setdefault("sec-websocket-key", "testserver==")
        headers.setdefault("sec-websocket-version", "13")
        if subprotocols is not None:
            headers.setdefault("sec-websocket-protocol", ", ".join(subprotocols))
        kwargs["headers"] = headers
        try:
            super().request("GET", url, **kwargs)
        except _Upgrade as exc:
            session = exc.session
        else:
            raise RuntimeError("Expected WebSocket upgrade")  # pragma: no cover
    
        return session
      
  
---|---  
  
###  `` lifespan `async` [¶](#fastapi.testclient.TestClient.lifespan "Permanent link")
    
    
    lifespan()
    

Source code in `starlette/testclient.py`
    
    
    701
    702
    703
    704
    705
    706

| 
    
    
    async def lifespan(self) -> None:
        scope = {"type": "lifespan", "state": self.app_state}
        try:
            await self.app(scope, self.stream_receive.receive, self.stream_send.send)
        finally:
            await self.stream_send.send(None)
      
  
---|---  
  
###  `` wait_startup `async` [¶](#fastapi.testclient.TestClient.wait_startup "Permanent link")
    
    
    wait_startup()
    

Source code in `starlette/testclient.py`
    
    
    708
    709
    710
    711
    712
    713
    714
    715
    716
    717
    718
    719
    720
    721
    722
    723

| 
    
    
    async def wait_startup(self) -> None:
        await self.stream_receive.send({"type": "lifespan.startup"})
    
        async def receive() -> Any:
            message = await self.stream_send.receive()
            if message is None:
                self.task.result()
            return message
    
        message = await receive()
        assert message["type"] in (
            "lifespan.startup.complete",
            "lifespan.startup.failed",
        )
        if message["type"] == "lifespan.startup.failed":
            await receive()
      
  
---|---  
  
###  `` wait_shutdown `async` [¶](#fastapi.testclient.TestClient.wait_shutdown "Permanent link")
    
    
    wait_shutdown()
    

Source code in `starlette/testclient.py`
    
    
    725
    726
    727
    728
    729
    730
    731
    732
    733
    734
    735
    736
    737
    738
    739

| 
    
    
    async def wait_shutdown(self) -> None:
        async def receive() -> Any:
            message = await self.stream_send.receive()
            if message is None:
                self.task.result()
            return message
    
        await self.stream_receive.send({"type": "lifespan.shutdown"})
        message = await receive()
        assert message["type"] in (
            "lifespan.shutdown.complete",
            "lifespan.shutdown.failed",
        )
        if message["type"] == "lifespan.shutdown.failed":
            await receive()
      
  
---|---

---

### FastAPI People¶

# FastAPI People[¶](#fastapi-people "Permanent link")

FastAPI has an amazing community that welcomes people from all backgrounds.

## Creator[¶](#creator "Permanent link")

Hey! üëã

This is me:

[![](https://avatars.githubusercontent.com/u/1326112?u=cb5d06e73a9e1998141b1641aa88e443c6717651&v=4)@tiangolo](https://github.com/tiangolo)

Answers: 1900

Pull Requests: 871

I'm the creator of **FastAPI**. You can read more about that in [Help FastAPI - Get Help - Connect with the author](../help-fastapi/#connect-with-the-author).

...But here I want to show you the community.

* * *

**FastAPI** receives a lot of support from the community. And I want to highlight their contributions.

These are the people that:

  * [Help others with questions in GitHub](../help-fastapi/#help-others-with-questions-in-github).
  * [Create Pull Requests](../help-fastapi/#create-a-pull-request).
  * Review Pull Requests, [especially important for translations](../contributing/#translations).
  * Help [manage the repository](../management-tasks/) (team members).

All these tasks help maintain the repository.

A round of applause to them. üëè üôá

## Team[¶](#team "Permanent link")

This is the current list of team members. üòé

They have different levels of involvement and permissions, they can perform [repository management tasks](../management-tasks/) and together we [manage the FastAPI repository](../management/).

[![](https://avatars.githubusercontent.com/u/1326112)@tiangolo](https://github.com/tiangolo)

[![](https://avatars.githubusercontent.com/u/7353520)@Kludex](https://github.com/Kludex)

[![](https://avatars.githubusercontent.com/u/90076947)@alejsdev](https://github.com/alejsdev)

[![](https://avatars.githubusercontent.com/u/8796347)@svlandeg](https://github.com/svlandeg)

[![](https://avatars.githubusercontent.com/u/109919500)@YuriiMotov](https://github.com/YuriiMotov)

[![](https://avatars.githubusercontent.com/u/667029)@patrick91](https://github.com/patrick91)

[![](https://avatars.githubusercontent.com/u/27291415)@luzzodev](https://github.com/luzzodev)

Although the team members have the permissions to perform privileged tasks, all the [help from others maintaining FastAPI](../help-fastapi/#help-maintain-fastapi) is very much appreciated! üôá‚Äç‚ôÇÔ∏è

## FastAPI Experts[¶](#fastapi-experts "Permanent link")

These are the users that have been [helping others the most with questions in GitHub](../help-fastapi/#help-others-with-questions-in-github). üôá

They have proven to be **FastAPI Experts** by helping many others. ‚ú®

Tip

You could become an official FastAPI Expert too!

Just [help others with questions in GitHub](../help-fastapi/#help-others-with-questions-in-github). ü§ì

You can see the **FastAPI Experts** for:

  * [Last Month](#fastapi-experts-last-month) ü§ì
  * [3 Months](#fastapi-experts-3-months) üòé
  * [6 Months](#fastapi-experts-6-months) üßê
  * [1 Year](#fastapi-experts-1-year) üßë‚Äçüî¨
  * [**All Time**](#fastapi-experts-all-time) üßô

### FastAPI Experts - Last Month[¶](#fastapi-experts-last-month "Permanent link")

These are the users that have been [helping others the most with questions in GitHub](../help-fastapi/#help-others-with-questions-in-github) during the last month. ü§ì

[![](https://avatars.githubusercontent.com/u/109919500?u=b9b13d598dddfab529a52d264df80a900bfe7060&v=4)@YuriiMotov](https://github.com/YuriiMotov)

Questions replied: 17

[![](https://avatars.githubusercontent.com/u/12831905?u=aae1ebc675c91e8fa582df4fcc4fc4128106344d&v=4)@valentinDruzhinin](https://github.com/valentinDruzhinin)

Questions replied: 5

[![](https://avatars.githubusercontent.com/u/37829370?u=da44ca53aefd5c23f346fab8e9fd2e108294c179&v=4)@yinziyan1206](https://github.com/yinziyan1206)

Questions replied: 4

[![](https://avatars.githubusercontent.com/u/27291415?u=5607ae1ce75c5f54f09500ca854227f7bfd2033b&v=4)@luzzodev](https://github.com/luzzodev)

Questions replied: 2

### FastAPI Experts - 3 Months[¶](#fastapi-experts-3-months "Permanent link")

These are the users that have been [helping others the most with questions in GitHub](../help-fastapi/#help-others-with-questions-in-github) during the last 3 months. üòé

[![](https://avatars.githubusercontent.com/u/109919500?u=b9b13d598dddfab529a52d264df80a900bfe7060&v=4)@YuriiMotov](https://github.com/YuriiMotov)

Questions replied: 397

[![](https://avatars.githubusercontent.com/u/12831905?u=aae1ebc675c91e8fa582df4fcc4fc4128106344d&v=4)@valentinDruzhinin](https://github.com/valentinDruzhinin)

Questions replied: 24

[![](https://avatars.githubusercontent.com/u/27291415?u=5607ae1ce75c5f54f09500ca854227f7bfd2033b&v=4)@luzzodev](https://github.com/luzzodev)

Questions replied: 17

[![](https://avatars.githubusercontent.com/u/75417963?u=060c62870ec5a791765e63ac20d8885d11143786&v=4)@raceychan](https://github.com/raceychan)

Questions replied: 6

[![](https://avatars.githubusercontent.com/u/37829370?u=da44ca53aefd5c23f346fab8e9fd2e108294c179&v=4)@yinziyan1206](https://github.com/yinziyan1206)

Questions replied: 5

[![](https://avatars.githubusercontent.com/u/14076775?u=2913e70a6142772847e91e2aaa5b9152391715e9&v=4)@DoctorJohn](https://github.com/DoctorJohn)

Questions replied: 5

[![](https://avatars.githubusercontent.com/u/21972708?u=8560b97b8b41e175f476270b56de8a493b84f302&v=4)@sachinh35](https://github.com/sachinh35)

Questions replied: 4

[![](https://avatars.githubusercontent.com/u/157279130?u=58fddf77ed76966eaa8c73eea9bea4bb0c53b673&v=4)@eqsdxr](https://github.com/eqsdxr)

Questions replied: 4

[![](https://avatars.githubusercontent.com/u/210023470?u=c25d66addf36a747bd9fab773c4a6e7b238f45d4&v=4)@Jelle-tenB](https://github.com/Jelle-tenB)

Questions replied: 3

### FastAPI Experts - 6 Months[¶](#fastapi-experts-6-months "Permanent link")

These are the users that have been [helping others the most with questions in GitHub](../help-fastapi/#help-others-with-questions-in-github) during the last 6 months. üßê

[![](https://avatars.githubusercontent.com/u/109919500?u=b9b13d598dddfab529a52d264df80a900bfe7060&v=4)@YuriiMotov](https://github.com/YuriiMotov)

Questions replied: 763

[![](https://avatars.githubusercontent.com/u/27291415?u=5607ae1ce75c5f54f09500ca854227f7bfd2033b&v=4)@luzzodev](https://github.com/luzzodev)

Questions replied: 45

[![](https://avatars.githubusercontent.com/u/12831905?u=aae1ebc675c91e8fa582df4fcc4fc4128106344d&v=4)@valentinDruzhinin](https://github.com/valentinDruzhinin)

Questions replied: 24

[![](https://avatars.githubusercontent.com/u/31544722?v=4)@alv2017](https://github.com/alv2017)

Questions replied: 16

[![](https://avatars.githubusercontent.com/u/21972708?u=8560b97b8b41e175f476270b56de8a493b84f302&v=4)@sachinh35](https://github.com/sachinh35)

Questions replied: 9

[![](https://avatars.githubusercontent.com/u/51629535?u=fc1817060daf2df438bfca86c44f33da5cd667db&v=4)@yauhen-sobaleu](https://github.com/yauhen-sobaleu)

Questions replied: 9

[![](https://avatars.githubusercontent.com/u/72013291?u=ae5679e6bd971d9d98cd5e76e8683f83642ba950&v=4)@JavierSanchezCastro](https://github.com/JavierSanchezCastro)

Questions replied: 6

[![](https://avatars.githubusercontent.com/u/75417963?u=060c62870ec5a791765e63ac20d8885d11143786&v=4)@raceychan](https://github.com/raceychan)

Questions replied: 6

[![](https://avatars.githubusercontent.com/u/37829370?u=da44ca53aefd5c23f346fab8e9fd2e108294c179&v=4)@yinziyan1206](https://github.com/yinziyan1206)

Questions replied: 5

### FastAPI Experts - 1 Year[¶](#fastapi-experts-1-year "Permanent link")

These are the users that have been [helping others the most with questions in GitHub](../help-fastapi/#help-others-with-questions-in-github) during the last year. üßë‚Äçüî¨

[![](https://avatars.githubusercontent.com/u/109919500?u=b9b13d598dddfab529a52d264df80a900bfe7060&v=4)@YuriiMotov](https://github.com/YuriiMotov)

Questions replied: 824

[![](https://avatars.githubusercontent.com/u/27291415?u=5607ae1ce75c5f54f09500ca854227f7bfd2033b&v=4)@luzzodev](https://github.com/luzzodev)

Questions replied: 89

[![](https://avatars.githubusercontent.com/u/7353520?u=df8a3f06ba8f55ae1967a3e2d5ed882903a4e330&v=4)@Kludex](https://github.com/Kludex)

Questions replied: 50

[![](https://avatars.githubusercontent.com/u/30960668?v=4)@sinisaos](https://github.com/sinisaos)

Questions replied: 33

[![](https://avatars.githubusercontent.com/u/31544722?v=4)@alv2017](https://github.com/alv2017)

Questions replied: 26

[![](https://avatars.githubusercontent.com/u/12831905?u=aae1ebc675c91e8fa582df4fcc4fc4128106344d&v=4)@valentinDruzhinin](https://github.com/valentinDruzhinin)

Questions replied: 24

[![](https://avatars.githubusercontent.com/u/72013291?u=ae5679e6bd971d9d98cd5e76e8683f83642ba950&v=4)@JavierSanchezCastro](https://github.com/JavierSanchezCastro)

Questions replied: 24

[![](https://avatars.githubusercontent.com/u/4335847?u=ed77f67e0bb069084639b24d812dbb2a2b1dc554&v=4)@jgould22](https://github.com/jgould22)

Questions replied: 17

[![](https://avatars.githubusercontent.com/u/57500876?u=a3bf923ab27bce3d1b13779a8dd22eb7675017fd&v=4)@Kfir-G](https://github.com/Kfir-G)

Questions replied: 13

[![](https://avatars.githubusercontent.com/u/14166324?u=8fac65e84dfff24245d304a5b5b09f7b5bd69dc9&v=4)@sehraramiz](https://github.com/sehraramiz)

Questions replied: 11

[![](https://avatars.githubusercontent.com/u/21972708?u=8560b97b8b41e175f476270b56de8a493b84f302&v=4)@sachinh35](https://github.com/sachinh35)

Questions replied: 9

[![](https://avatars.githubusercontent.com/u/51629535?u=fc1817060daf2df438bfca86c44f33da5cd667db&v=4)@yauhen-sobaleu](https://github.com/yauhen-sobaleu)

Questions replied: 9

[![](https://avatars.githubusercontent.com/u/10840422?u=1900887aeed268699e5ea6f3fb7db614f7b77cd3&v=4)@estebanx64](https://github.com/estebanx64)

Questions replied: 7

[![](https://avatars.githubusercontent.com/u/235213?u=edcce471814a1eba9f0cdaa4cd0de18921a940a6&v=4)@ceb10n](https://github.com/ceb10n)

Questions replied: 7

[![](https://avatars.githubusercontent.com/u/36999744?v=4)@yvallois](https://github.com/yvallois)

Questions replied: 7

[![](https://avatars.githubusercontent.com/u/75417963?u=060c62870ec5a791765e63ac20d8885d11143786&v=4)@raceychan](https://github.com/raceychan)

Questions replied: 6

[![](https://avatars.githubusercontent.com/u/37829370?u=da44ca53aefd5c23f346fab8e9fd2e108294c179&v=4)@yinziyan1206](https://github.com/yinziyan1206)

Questions replied: 5

[![](https://avatars.githubusercontent.com/u/14076775?u=2913e70a6142772847e91e2aaa5b9152391715e9&v=4)@DoctorJohn](https://github.com/DoctorJohn)

Questions replied: 5

[![](https://avatars.githubusercontent.com/u/2964996?v=4)@n8sty](https://github.com/n8sty)

Questions replied: 5

### FastAPI Experts - All Time[¶](#fastapi-experts-all-time "Permanent link")

Here are the all time **FastAPI Experts**. ü§ìü§Ø

These are the users that have [helped others the most with questions in GitHub](../help-fastapi/#help-others-with-questions-in-github) through _all time_. üßô

[![](https://avatars.githubusercontent.com/u/109919500?u=b9b13d598dddfab529a52d264df80a900bfe7060&v=4)@YuriiMotov](https://github.com/YuriiMotov)

Questions replied: 971

[![](https://avatars.githubusercontent.com/u/7353520?u=df8a3f06ba8f55ae1967a3e2d5ed882903a4e330&v=4)@Kludex](https://github.com/Kludex)

Questions replied: 654

[![](https://avatars.githubusercontent.com/u/4335847?u=ed77f67e0bb069084639b24d812dbb2a2b1dc554&v=4)@jgould22](https://github.com/jgould22)

Questions replied: 263

[![](https://avatars.githubusercontent.com/u/35119617?u=540f30c937a6450812628b9592a1dfe91bbe148e&v=4)@dmontagu](https://github.com/dmontagu)

Questions replied: 240

[![](https://avatars.githubusercontent.com/u/1405026?v=4)@Mause](https://github.com/Mause)

Questions replied: 219

[![](https://avatars.githubusercontent.com/u/62724709?u=f1e7bae394a315da950912c92dc861a8eaf95d4c&v=4)@ycd](https://github.com/ycd)

Questions replied: 216

[![](https://avatars.githubusercontent.com/u/13659033?u=e8bea32d07a5ef72f7dde3b2079ceb714923ca05&v=4)@JarroVGIT](https://github.com/JarroVGIT)

Questions replied: 190

[![](https://avatars.githubusercontent.com/u/1104190?u=321a2e953e6645a7d09b732786c7a8061e0f8a8b&v=4)@euri10](https://github.com/euri10)

Questions replied: 153

[![](https://avatars.githubusercontent.com/u/10519440?u=f09cdd745e5bf16138f29b42732dd57c7f02bee1&v=4)@iudeen](https://github.com/iudeen)

Questions replied: 128

[![](https://avatars.githubusercontent.com/u/331403?v=4)@phy25](https://github.com/phy25)

Questions replied: 126

[![](https://avatars.githubusercontent.com/u/72013291?u=ae5679e6bd971d9d98cd5e76e8683f83642ba950&v=4)@JavierSanchezCastro](https://github.com/JavierSanchezCastro)

Questions replied: 94

[![](https://avatars.githubusercontent.com/u/27291415?u=5607ae1ce75c5f54f09500ca854227f7bfd2033b&v=4)@luzzodev](https://github.com/luzzodev)

Questions replied: 89

[![](https://avatars.githubusercontent.com/u/10202690?u=e6f86f5c0c3026a15d6b51792fa3e532b12f1371&v=4)@raphaelauv](https://github.com/raphaelauv)

Questions replied: 83

[![](https://avatars.githubusercontent.com/u/31127044?u=b0f2c37142f4b762e41ad65dc49581813422bd71&v=4)@ArcLightSlavik](https://github.com/ArcLightSlavik)

Questions replied: 71

[![](https://avatars.githubusercontent.com/u/23500353?u=e2e1d736f924d9be81e8bfc565b6d8836ba99773&v=4)@ghandic](https://github.com/ghandic)

Questions replied: 71

[![](https://avatars.githubusercontent.com/u/2964996?v=4)@n8sty](https://github.com/n8sty)

Questions replied: 67

[![](https://avatars.githubusercontent.com/u/653031?u=ad9838e089058c9e5a0bab94c0eec7cc181e0cd0&v=4)@falkben](https://github.com/falkben)

Questions replied: 59

[![](https://avatars.githubusercontent.com/u/37829370?u=da44ca53aefd5c23f346fab8e9fd2e108294c179&v=4)@yinziyan1206](https://github.com/yinziyan1206)

Questions replied: 54

[![](https://avatars.githubusercontent.com/u/516999?u=437c0c5038558c67e887ccd863c1ba0f846c03da&v=4)@sm-Fifteen](https://github.com/sm-Fifteen)

Questions replied: 49

[![](https://avatars.githubusercontent.com/u/685002?u=b5094ab4527fc84b006c0ac9ff54367bdebb2267&v=4)@acidjunk](https://github.com/acidjunk)

Questions replied: 49

[![](https://avatars.githubusercontent.com/u/1755071?u=612704256e38d6ac9cbed24f10e4b6ac2da74ecb&v=4)@adriangb](https://github.com/adriangb)

Questions replied: 46

[![](https://avatars.githubusercontent.com/u/27180793?u=5cf2877f50b3eb2bc55086089a78a36f07042889&v=4)@Dustyposa](https://github.com/Dustyposa)

Questions replied: 45

[![](https://avatars.githubusercontent.com/u/16958893?u=f8be7088d5076d963984a21f95f44e559192d912&v=4)@insomnes](https://github.com/insomnes)

Questions replied: 45

[![](https://avatars.githubusercontent.com/u/1144727?u=c159fe047727aedecbbeeaa96a1b03ceb9d39add&v=4)@frankie567](https://github.com/frankie567)

Questions replied: 43

[![](https://avatars.githubusercontent.com/u/87550035?u=241a71f6b7068738b81af3e57f45ffd723538401&v=4)@odiseo0](https://github.com/odiseo0)

Questions replied: 43

[![](https://avatars.githubusercontent.com/u/30960668?v=4)@sinisaos](https://github.com/sinisaos)

Questions replied: 41

[![](https://avatars.githubusercontent.com/u/11836741?u=8bd5ef7e62fe6a82055e33c4c0e0a7879ff8cfb6&v=4)@includeamin](https://github.com/includeamin)

Questions replied: 40

[![](https://avatars.githubusercontent.com/u/5167622?u=de8f597c81d6336fcebc37b32dfd61a3f877160c&v=4)@STeveShary](https://github.com/STeveShary)

Questions replied: 37

[![](https://avatars.githubusercontent.com/u/7534547?v=4)@chbndrhnns](https://github.com/chbndrhnns)

Questions replied: 37

[![](https://avatars.githubusercontent.com/u/31960541?u=47f4829c77f4962ab437ffb7995951e41eeebe9b&v=4)@krishnardt](https://github.com/krishnardt)

Questions replied: 35

[![](https://avatars.githubusercontent.com/u/41326348?u=ba2fda6b30110411ecbf406d187907e2b420ac19&v=4)@panla](https://github.com/panla)

Questions replied: 32

[![](https://avatars.githubusercontent.com/u/28061158?u=6918e39a1224194ba636e897461a02a20126d7ad&v=4)@prostomarkeloff](https://github.com/prostomarkeloff)

Questions replied: 28

[![](https://avatars.githubusercontent.com/u/13135006?u=99f0b0f0fc47e88e8abb337b4447357939ef93e7&v=4)@hasansezertasan](https://github.com/hasansezertasan)

Questions replied: 27

[![](https://avatars.githubusercontent.com/u/31544722?v=4)@alv2017](https://github.com/alv2017)

Questions replied: 26

[![](https://avatars.githubusercontent.com/u/43723790?u=9d726785d08e50b1e1cd96505800c8ea8405bce2&v=4)@dbanty](https://github.com/dbanty)

Questions replied: 26

[![](https://avatars.githubusercontent.com/u/365303?u=07ca03c5ee811eb0920e633cc3c3db73dbec1aa5&v=4)@wshayes](https://github.com/wshayes)

Questions replied: 25

[![](https://avatars.githubusercontent.com/u/12831905?u=aae1ebc675c91e8fa582df4fcc4fc4128106344d&v=4)@valentinDruzhinin](https://github.com/valentinDruzhinin)

Questions replied: 24

[![](https://avatars.githubusercontent.com/u/9435877?u=719327b7d2c4c62212456d771bfa7c6b8dbb9eac&v=4)@SirTelemak](https://github.com/SirTelemak)

Questions replied: 23

[![](https://avatars.githubusercontent.com/u/9054108?u=e151d5f545a3395136d711c227c22032fda67cfa&v=4)@connebs](https://github.com/connebs)

Questions replied: 22

[![](https://avatars.githubusercontent.com/u/4216559?u=360a36fb602cded27273cbfc0afc296eece90662&v=4)@nymous](https://github.com/nymous)

Questions replied: 22

[![](https://avatars.githubusercontent.com/u/79946379?u=03d85b22d696a58a9603e55fbbbe2de6b0f4face&v=4)@chrisK824](https://github.com/chrisK824)

Questions replied: 22

[![](https://avatars.githubusercontent.com/u/51059348?u=5fe59a56e1f2f9ccd8005d71752a8276f133ae1a&v=4)@rafsaf](https://github.com/rafsaf)

Questions replied: 21

[![](https://avatars.githubusercontent.com/u/22559461?u=a9cc3238217e21dc8796a1a500f01b722adb082c&v=4)@nsidnev](https://github.com/nsidnev)

Questions replied: 20

[![](https://avatars.githubusercontent.com/u/565544?v=4)@chris-allnutt](https://github.com/chris-allnutt)

Questions replied: 20

[![](https://avatars.githubusercontent.com/u/100039558?u=8b91053b3abe4a9209375e3651e1c1ef192d884b&v=4)@ebottos94](https://github.com/ebottos94)

Questions replied: 20

[![](https://avatars.githubusercontent.com/u/10840422?u=1900887aeed268699e5ea6f3fb7db614f7b77cd3&v=4)@estebanx64](https://github.com/estebanx64)

Questions replied: 19

[![](https://avatars.githubusercontent.com/u/14166324?u=8fac65e84dfff24245d304a5b5b09f7b5bd69dc9&v=4)@sehraramiz](https://github.com/sehraramiz)

Questions replied: 18

[![](https://avatars.githubusercontent.com/u/24581770?v=4)@retnikt](https://github.com/retnikt)

Questions replied: 18

## Top Contributors[¶](#top-contributors "Permanent link")

Here are the **Top Contributors**. üë∑

These users have [created the most Pull Requests](../help-fastapi/#create-a-pull-request) that have been _merged_.

They have contributed source code, documentation, etc. üì¶

[![](https://avatars.githubusercontent.com/u/90076947?u=0facffe3abf87f57a1f05fa773d1119cc5c2f6a5&v=4)@alejsdev](https://github.com/alejsdev)

Pull Requests: 53

[![](https://avatars.githubusercontent.com/u/109919500?u=bc48be95c429989224786106b027f3c5e40cc354&v=4)@YuriiMotov](https://github.com/YuriiMotov)

Pull Requests: 38

[![](https://avatars.githubusercontent.com/u/7353520?u=df8a3f06ba8f55ae1967a3e2d5ed882903a4e330&v=4)@Kludex](https://github.com/Kludex)

Pull Requests: 25

[![](https://avatars.githubusercontent.com/u/35119617?u=540f30c937a6450812628b9592a1dfe91bbe148e&v=4)@dmontagu](https://github.com/dmontagu)

Pull Requests: 17

[![](https://avatars.githubusercontent.com/u/8796347?u=556c97650c27021911b0b9447ec55e75987b0e8a&v=4)@svlandeg](https://github.com/svlandeg)

Pull Requests: 17

[![](https://avatars.githubusercontent.com/u/6892179?u=1dca6a22195d6cd1ab20737c0e19a4c55d639472&v=4)@nilslindemann](https://github.com/nilslindemann)

Pull Requests: 15

[![](https://avatars.githubusercontent.com/u/1104190?u=321a2e953e6645a7d09b732786c7a8061e0f8a8b&v=4)@euri10](https://github.com/euri10)

Pull Requests: 13

[![](https://avatars.githubusercontent.com/u/3978368?u=cccc199291f991a73b1ebba5abc735a948e0bd16&v=4)@kantandane](https://github.com/kantandane)

Pull Requests: 13

[![](https://avatars.githubusercontent.com/u/65422392?u=8260f8781f50248410ebfa4c9bf70e143fe5c9f2&v=4)@zhaohan-dong](https://github.com/zhaohan-dong)

Pull Requests: 11

[![](https://avatars.githubusercontent.com/u/11489395?u=4adb6986bf3debfc2b8216ae701f2bd47d73da7d&v=4)@mariacamilagl](https://github.com/mariacamilagl)

Pull Requests: 9

[![](https://avatars.githubusercontent.com/u/12239103?u=6c39ef15d14c6d5211f5dd775cc4842f8d7f2f3a&v=4)@handabaldeep](https://github.com/handabaldeep)

Pull Requests: 9

[![](https://avatars.githubusercontent.com/u/84698110?u=8af5de0520dd4fa195f53c2850a26f57c0f6bc64&v=4)@vishnuvskvkl](https://github.com/vishnuvskvkl)

Pull Requests: 8

[![](https://avatars.githubusercontent.com/u/96190409?u=be42d85938c241be781505a5a872575be28b2906&v=4)@alissadb](https://github.com/alissadb)

Pull Requests: 6

[![](https://avatars.githubusercontent.com/u/31544722?v=4)@alv2017](https://github.com/alv2017)

Pull Requests: 6

[![](https://avatars.githubusercontent.com/u/365303?u=07ca03c5ee811eb0920e633cc3c3db73dbec1aa5&v=4)@wshayes](https://github.com/wshayes)

Pull Requests: 5

[![](https://avatars.githubusercontent.com/u/4039449?u=42eb3b833047c8c4b4f647a031eaef148c16d93f&v=4)@samuelcolvin](https://github.com/samuelcolvin)

Pull Requests: 5

[![](https://avatars.githubusercontent.com/u/39515546?u=ec35139777597cdbbbddda29bf8b9d4396b429a9&v=4)@waynerv](https://github.com/waynerv)

Pull Requests: 5

[![](https://avatars.githubusercontent.com/u/6898909?u=9010312053e7141383b9bdf538036c7f37fbaba0&v=4)@musicinmybrain](https://github.com/musicinmybrain)

Pull Requests: 5

[![](https://avatars.githubusercontent.com/u/31798870?u=950693b28f3ae01105fd545c046e46ca3d31ab06&v=4)@krishnamadhavan](https://github.com/krishnamadhavan)

Pull Requests: 5

[![](https://avatars.githubusercontent.com/u/2546697?u=a027452387d85bd4a14834e19d716c99255fb3b7&v=4)@jekirl](https://github.com/jekirl)

Pull Requests: 4

[![](https://avatars.githubusercontent.com/u/3360631?u=5fa1f475ad784d64eb9666bdd43cc4d285dcc773&v=4)@hitrust](https://github.com/hitrust)

Pull Requests: 4

[![](https://avatars.githubusercontent.com/u/3852029?u=2dc6402d9053ee53f7afc407089cbab21c68f21d&v=4)@ShahriyarR](https://github.com/ShahriyarR)

Pull Requests: 4

[![](https://avatars.githubusercontent.com/u/1755071?u=612704256e38d6ac9cbed24f10e4b6ac2da74ecb&v=4)@adriangb](https://github.com/adriangb)

Pull Requests: 4

[![](https://avatars.githubusercontent.com/u/10519440?u=f09cdd745e5bf16138f29b42732dd57c7f02bee1&v=4)@iudeen](https://github.com/iudeen)

Pull Requests: 4

[![](https://avatars.githubusercontent.com/u/55271518?u=d30994d339aaaf1f6bf1b8fc810132016fbd4fdc&v=4)@philipokiokio](https://github.com/philipokiokio)

Pull Requests: 4

[![](https://avatars.githubusercontent.com/u/3949212?u=c4c0c615e0ea33d00bfe16b779cf6ebc0f58071c&v=4)@AlexWendland](https://github.com/AlexWendland)

Pull Requests: 4

[![](https://avatars.githubusercontent.com/u/1397556?v=4)@divums](https://github.com/divums)

Pull Requests: 3

[![](https://avatars.githubusercontent.com/u/28061158?u=6918e39a1224194ba636e897461a02a20126d7ad&v=4)@prostomarkeloff](https://github.com/prostomarkeloff)

Pull Requests: 3

[![](https://avatars.githubusercontent.com/u/1144727?u=f3e79acfe4ed207e15c2145161a8a9759925fcd2&v=4)@frankie567](https://github.com/frankie567)

Pull Requests: 3

[![](https://avatars.githubusercontent.com/u/22559461?u=a9cc3238217e21dc8796a1a500f01b722adb082c&v=4)@nsidnev](https://github.com/nsidnev)

Pull Requests: 3

[![](https://avatars.githubusercontent.com/u/3999221?u=b030e4c89df2f3a36bc4710b925bdeb6745c9856&v=4)@pawamoy](https://github.com/pawamoy)

Pull Requests: 3

[![](https://avatars.githubusercontent.com/u/3589536?u=53aef07250d226d35e526768e26891964907b41a&v=4)@patrickmckenna](https://github.com/patrickmckenna)

Pull Requests: 3

[![](https://avatars.githubusercontent.com/u/3275109?u=77bb83759127965eacbfe67e2ca983066e964fde&v=4)@hukkin](https://github.com/hukkin)

Pull Requests: 3

[![](https://avatars.githubusercontent.com/u/6181089?u=03c50eec631857d84df5232890780d00a3f76903&v=4)@marcosmmb](https://github.com/marcosmmb)

Pull Requests: 3

[![](https://avatars.githubusercontent.com/u/22691749?u=4795b880e13ca33a73e52fc0ef7dc9c60c8fce47&v=4)@Serrones](https://github.com/Serrones)

Pull Requests: 3

[![](https://avatars.githubusercontent.com/u/32038156?u=c26ca9b821fcf6499b84db75f553d4980bf8d023&v=4)@uriyyo](https://github.com/uriyyo)

Pull Requests: 3

[![](https://avatars.githubusercontent.com/u/889657?u=d70187989940b085bcbfa3bedad8dbc5f3ab1fe7&v=4)@andrew222651](https://github.com/andrew222651)

Pull Requests: 3

[![](https://avatars.githubusercontent.com/u/23391143?u=56ab6bff50be950fa8cae5cf736f2ae66e319ff3&v=4)@rkbeatss](https://github.com/rkbeatss)

Pull Requests: 3

[![](https://avatars.githubusercontent.com/u/22955146?u=4553ebf5b5a7c7fe031a46182083aa224faba2e1&v=4)@asheux](https://github.com/asheux)

Pull Requests: 3

[![](https://avatars.githubusercontent.com/u/49960770?u=7d8a6d5f0a75a5e9a865a2527edfd48895ea27ae&v=4)@blkst8](https://github.com/blkst8)

Pull Requests: 3

[![](https://avatars.githubusercontent.com/u/23500353?u=e2e1d736f924d9be81e8bfc565b6d8836ba99773&v=4)@ghandic](https://github.com/ghandic)

Pull Requests: 3

[![](https://avatars.githubusercontent.com/u/13070236?u=96fdae85800ef85dcfcc4b5f8281dc8778c8cb7d&v=4)@TeoZosa](https://github.com/TeoZosa)

Pull Requests: 3

[![](https://avatars.githubusercontent.com/u/413772?v=4)@graingert](https://github.com/graingert)

Pull Requests: 3

[![](https://avatars.githubusercontent.com/u/11191137?u=299205a95e9b6817a43144a48b643346a5aac5cc&v=4)@jaystone776](https://github.com/jaystone776)

Pull Requests: 3

[![](https://avatars.githubusercontent.com/u/2586601?u=e5c86f7ff3b859e7e183187ac2b17fd6ee32b3ab&v=4)@zanieb](https://github.com/zanieb)

Pull Requests: 3

[![](https://avatars.githubusercontent.com/u/19514231?u=158c91874ea98d6e9e6f0c6db37ee2ce60c55ff2&v=4)@MicaelJarniac](https://github.com/MicaelJarniac)

Pull Requests: 3

There are hundreds of other contributors, you can see them all in the [FastAPI GitHub Contributors page](https://github.com/fastapi/fastapi/graphs/contributors). üë∑

## Top Translation Reviewers[¶](#top-translation-reviewers "Permanent link")

These users are the **Top Translation Reviewers**. üïµÔ∏è

Translation reviewers have the [**power to approve translations**](../contributing/#translations) of the documentation. Without them, there wouldn't be documentation in several other languages.

[![](https://avatars.githubusercontent.com/u/4954856?v=4)@s111d](https://github.com/s111d)

Reviews: 147

[![](https://avatars.githubusercontent.com/u/85196001?u=f8e2dc7e5104f109cef944af79050ea8d1b8f914&v=4)@Xewus](https://github.com/Xewus)

Reviews: 140

[![](https://avatars.githubusercontent.com/u/66295123?u=be939db90f1119efee9e6110cc05066ff1f40f00&v=4)@sodaMelon](https://github.com/sodaMelon)

Reviews: 128

[![](https://avatars.githubusercontent.com/u/235213?u=edcce471814a1eba9f0cdaa4cd0de18921a940a6&v=4)@ceb10n](https://github.com/ceb10n)

Reviews: 119

[![](https://avatars.githubusercontent.com/u/41147016?u=55010621aece725aa702270b54fed829b6a1fe60&v=4)@tokusumi](https://github.com/tokusumi)

Reviews: 104

[![](https://avatars.githubusercontent.com/u/9651103?u=78d12d1acdf853c817700145e73de7fd9e5d068b&v=4)@hard-coders](https://github.com/hard-coders)

Reviews: 102

[![](https://avatars.githubusercontent.com/u/13135006?u=99f0b0f0fc47e88e8abb337b4447357939ef93e7&v=4)@hasansezertasan](https://github.com/hasansezertasan)

Reviews: 95

[![](https://avatars.githubusercontent.com/u/31544722?v=4)@alv2017](https://github.com/alv2017)

Reviews: 88

[![](https://avatars.githubusercontent.com/u/31008635?u=f69ddc4ea8bda3bdfac7aa0e2ea38de282e6ee2d&v=4)@nazarepiedady](https://github.com/nazarepiedady)

Reviews: 87

[![](https://avatars.githubusercontent.com/u/15695000?u=f5a4944c6df443030409c88da7d7fa0b7ead985c&v=4)@AlertRED](https://github.com/AlertRED)

Reviews: 81

[![](https://avatars.githubusercontent.com/u/119126536?u=9fc0d48f3307817bafecc5861eb2168401a6cb04&v=4)@Alexandrhub](https://github.com/Alexandrhub)

Reviews: 68

[![](https://avatars.githubusercontent.com/u/3127847?u=a08022b191ddbd0a6159b2981d9d878b6d5bb71f&v=4)@cassiobotaro](https://github.com/cassiobotaro)

Reviews: 64

[![](https://avatars.githubusercontent.com/u/39515546?u=ec35139777597cdbbbddda29bf8b9d4396b429a9&v=4)@waynerv](https://github.com/waynerv)

Reviews: 63

[![](https://avatars.githubusercontent.com/u/6892179?u=1dca6a22195d6cd1ab20737c0e19a4c55d639472&v=4)@nilslindemann](https://github.com/nilslindemann)

Reviews: 61

[![](https://avatars.githubusercontent.com/u/24987826?u=58e37fb3927b9124b458945ac4c97aa0f1062d85&v=4)@mattwang44](https://github.com/mattwang44)

Reviews: 61

[![](https://avatars.githubusercontent.com/u/109919500?u=bc48be95c429989224786106b027f3c5e40cc354&v=4)@YuriiMotov](https://github.com/YuriiMotov)

Reviews: 56

[![](https://avatars.githubusercontent.com/u/59285379?v=4)@Laineyzhang55](https://github.com/Laineyzhang55)

Reviews: 48

[![](https://avatars.githubusercontent.com/u/7353520?u=df8a3f06ba8f55ae1967a3e2d5ed882903a4e330&v=4)@Kludex](https://github.com/Kludex)

Reviews: 47

[![](https://avatars.githubusercontent.com/u/39375566?u=260ad6b1a4b34c07dbfa728da5e586f16f6d1824&v=4)@komtaki](https://github.com/komtaki)

Reviews: 45

[![](https://avatars.githubusercontent.com/u/8796347?u=556c97650c27021911b0b9447ec55e75987b0e8a&v=4)@svlandeg](https://github.com/svlandeg)

Reviews: 43

[![](https://avatars.githubusercontent.com/u/11443899?u=e26a635c2ba220467b308a326a579b8ccf4a8701&v=4)@rostik1410](https://github.com/rostik1410)

Reviews: 42

[![](https://avatars.githubusercontent.com/u/34214152?u=2c5acad3461d4dbc2d48371ba86cac56ae9b25cc&v=4)@alperiox](https://github.com/alperiox)

Reviews: 42

[![](https://avatars.githubusercontent.com/u/66554797?v=4)@Rishat-F](https://github.com/Rishat-F)

Reviews: 42

[![](https://avatars.githubusercontent.com/u/53390?u=bb0e71a2fc3910a8e0ee66da67c33de40ea695f8&v=4)@Winand](https://github.com/Winand)

Reviews: 40

[![](https://avatars.githubusercontent.com/u/46193920?u=789927ee09cfabd752d3bd554fa6baf4850d2777&v=4)@solomein-sv](https://github.com/solomein-sv)

Reviews: 38

[![](https://avatars.githubusercontent.com/u/72013291?u=ae5679e6bd971d9d98cd5e76e8683f83642ba950&v=4)@JavierSanchezCastro](https://github.com/JavierSanchezCastro)

Reviews: 38

[![](https://avatars.githubusercontent.com/u/90076947?u=0facffe3abf87f57a1f05fa773d1119cc5c2f6a5&v=4)@alejsdev](https://github.com/alejsdev)

Reviews: 37

[![](https://avatars.githubusercontent.com/u/41520940?u=4a9c765af688389d54296845d18b8f6cd6ddf09a&v=4)@mezgoodle](https://github.com/mezgoodle)

Reviews: 37

[![](https://avatars.githubusercontent.com/u/61513630?u=c22d8850e9dc396a8820766a59837f967e14f9a0&v=4)@stlucasgarcia](https://github.com/stlucasgarcia)

Reviews: 36

[![](https://avatars.githubusercontent.com/u/52768429?u=6a3aa15277406520ad37f6236e89466ed44bc5b8&v=4)@SwftAlpc](https://github.com/SwftAlpc)

Reviews: 36

[![](https://avatars.githubusercontent.com/u/53824764?u=db3d0cea2f5fab64d810113c5039a369699a2774&v=4)@timothy-jeong](https://github.com/timothy-jeong)

Reviews: 36

[![](https://avatars.githubusercontent.com/u/56785022?u=d5c3a02567c8649e146fcfc51b6060ccaf8adef8&v=4)@rjNemo](https://github.com/rjNemo)

Reviews: 34

[![](https://avatars.githubusercontent.com/u/103817302?u=3a042740dc0ff58615da0d8679230966fd7693e8&v=4)@codingjenny](https://github.com/codingjenny)

Reviews: 34

[![](https://avatars.githubusercontent.com/u/53393089?u=6e528bb4789d56af887ce6fe237bea4010885406&v=4)@akarev0](https://github.com/akarev0)

Reviews: 33

[![](https://avatars.githubusercontent.com/u/81342412?u=ab5e256a4077a4a91f3f9cd2115ba80780454cbe&v=4)@Vincy1230](https://github.com/Vincy1230)

Reviews: 33

[![](https://avatars.githubusercontent.com/u/132477732?v=4)@romashevchenko](https://github.com/romashevchenko)

Reviews: 32

[![](https://avatars.githubusercontent.com/u/16273730?u=095b66f243a2cd6a0aadba9a095009f8aaf18393&v=4)@LorhanSohaky](https://github.com/LorhanSohaky)

Reviews: 30

[![](https://avatars.githubusercontent.com/u/18581590?u=7b6336166d0797fbbd44ea70c1c3ecadfc89af9e&v=4)@black-redoc](https://github.com/black-redoc)

Reviews: 29

[![](https://avatars.githubusercontent.com/u/16860088?u=abf922a7b920bf8fdb7867d8b43e091f1e796178&v=4)@pedabraham](https://github.com/pedabraham)

Reviews: 28

[![](https://avatars.githubusercontent.com/u/16785985?u=ffe99fa954c8e774ef1117e58d34aece92051e27&v=4)@Smlep](https://github.com/Smlep)

Reviews: 28

[![](https://avatars.githubusercontent.com/u/26196675?u=e2966887124e67932853df4f10f86cb526edc7b0&v=4)@dedkot01](https://github.com/dedkot01)

Reviews: 28

[![](https://avatars.githubusercontent.com/u/24913710?u=7d25a398e478b6e63503bf6f26c54efa9e0da07b&v=4)@hsuanchi](https://github.com/hsuanchi)

Reviews: 28

[![](https://avatars.githubusercontent.com/u/3204540?u=a2e1465e3ee10d537614d513589607eddefde09f&v=4)@dpinezich](https://github.com/dpinezich)

Reviews: 28

[![](https://avatars.githubusercontent.com/u/7887703?v=4)@maoyibo](https://github.com/maoyibo)

Reviews: 27

[![](https://avatars.githubusercontent.com/u/63915557?u=47debaa860fd52c9b98c97ef357ddcec3b3fb399&v=4)@0417taehyun](https://github.com/0417taehyun)

Reviews: 27

[![](https://avatars.githubusercontent.com/u/47563997?u=63ed66e304fe8d765762c70587d61d9196e5c82d&v=4)@BilalAlpaslan](https://github.com/BilalAlpaslan)

Reviews: 26

[![](https://avatars.githubusercontent.com/u/75025529?u=2451c256e888fa2a06bcfc0646d09b87ddb6a945&v=4)@junah201](https://github.com/junah201)

Reviews: 26

[![](https://avatars.githubusercontent.com/u/67154681?u=5d634834cc514028ea3f9115f7030b99a1f4d5a4&v=4)@zy7y](https://github.com/zy7y)

Reviews: 25

[![](https://avatars.githubusercontent.com/u/6161385?u=e3cec75bd6d938a0d73fae0dc5534d1ab2ed1b0e&v=4)@mycaule](https://github.com/mycaule)

Reviews: 25

## Sponsors[¶](#sponsors "Permanent link")

These are the **Sponsors**. üòé

They are supporting my work with **FastAPI** (and others), mainly through [GitHub Sponsors](https://github.com/sponsors/tiangolo).

### Gold Sponsors[¶](#gold-sponsors "Permanent link")

[![](https://fastapi.tiangolo.com/img/sponsors/blockbee.png)](https://blockbee.io?ref=fastapi "BlockBee Cryptocurrency Payment Gateway") [![](https://fastapi.tiangolo.com/img/sponsors/scalar.svg)](https://github.com/scalar/scalar/?utm_source=fastapi&utm_medium=website&utm_campaign=main-badge "Scalar: Beautiful Open-Source API References from Swagger/OpenAPI files") [![](https://fastapi.tiangolo.com/img/sponsors/propelauth.png)](https://www.propelauth.com/?utm_source=fastapi&utm_campaign=1223&utm_medium=mainbadge "Auth, user management and more for your B2B product") [![](https://fastapi.tiangolo.com/img/sponsors/zuplo.png)](https://zuplo.link/fastapi-gh "Zuplo: Deploy, Secure, Document, and Monetize your FastAPI") [![](https://fastapi.tiangolo.com/img/sponsors/liblab.png)](https://liblab.com?utm_source=fastapi "liblab - Generate SDKs from FastAPI") [![](https://fastapi.tiangolo.com/img/sponsors/render.svg)](https://docs.render.com/deploy-fastapi?utm_source=deploydoc&utm_medium=referral&utm_campaign=fastapi "Deploy & scale any full-stack web app on Render. Focus on building apps, not infra.") [![](https://fastapi.tiangolo.com/img/sponsors/coderabbit.png)](https://www.coderabbit.ai/?utm_source=fastapi&utm_medium=badge&utm_campaign=fastapi "Cut Code Review Time & Bugs in Half with CodeRabbit") [![](https://fastapi.tiangolo.com/img/sponsors/subtotal.svg)](https://subtotal.com/?utm_source=fastapi&utm_medium=sponsorship&utm_campaign=open-source "The Gold Standard in Retail Account Linking") [![](https://fastapi.tiangolo.com/img/sponsors/railway.png)](https://docs.railway.com/guides/fastapi?utm_medium=integration&utm_source=docs&utm_campaign=fastapi "Deploy enterprise applications at startup speed") [![](https://fastapi.tiangolo.com/img/sponsors/serpapi.png)](https://serpapi.com/?utm_source=fastapi_website "SerpApi: Web Search API") [![](https://fastapi.tiangolo.com/img/sponsors/greptile.png)](https://www.greptile.com/?utm_source=fastapi&utm_medium=sponsorship&utm_campaign=fastapi_sponsor_page "Greptile: The AI Code Reviewer")

### Silver Sponsors[¶](#silver-sponsors "Permanent link")

[![](https://fastapi.tiangolo.com/img/sponsors/databento.svg)](https://databento.com/?utm_source=fastapi&utm_medium=sponsor&utm_content=display "Pay as you go for market data") [![](https://fastapi.tiangolo.com/img/sponsors/speakeasy.png)](https://speakeasy.com/editor?utm_source=fastapi+repo&utm_medium=github+sponsorship "SDKs for your API | Speakeasy") [![](https://fastapi.tiangolo.com/img/sponsors/svix.svg)](https://www.svix.com/ "Svix - Webhooks as a service") [![](https://fastapi.tiangolo.com/img/sponsors/stainless.png)](https://www.stainlessapi.com/?utm_source=fastapi&utm_medium=referral "Stainless | Generate best-in-class SDKs") [![](https://fastapi.tiangolo.com/img/sponsors/permit.png)](https://www.permit.io/blog/implement-authorization-in-fastapi?utm_source=github&utm_medium=referral&utm_campaign=fastapi "Fine-Grained Authorization for FastAPI") [![](https://fastapi.tiangolo.com/img/sponsors/interviewpal.png)](https://www.interviewpal.com/?utm_source=fastapi&utm_medium=open-source&utm_campaign=dev-hiring "InterviewPal - AI Interview Coach for Engineers and Devs") [![](https://fastapi.tiangolo.com/img/sponsors/dribia.png)](https://dribia.com/en/ "Dribia - Data Science within your reach")

### Bronze Sponsors[¶](#bronze-sponsors "Permanent link")

[![](https://fastapi.tiangolo.com/img/sponsors/exoflare.png)](https://www.exoflare.com/open-source/?utm_source=FastAPI&utm_campaign=open_source "Biosecurity risk assessments made easy.") [![](https://fastapi.tiangolo.com/img/sponsors/testmu.png)](https://www.testmu.ai/?utm_source=fastapi&utm_medium=partner&utm_campaign=sponsor&utm_term=opensource&utm_content=webpage "TestMu AI. The Native AI-Agentic Cloud Platform to Supercharge Quality Engineering.")

### Individual Sponsors[¶](#individual-sponsors "Permanent link")

[![](https://avatars.githubusercontent.com/u/114745848?v=4)@Ponte-Energy-Partners](https://github.com/Ponte-Energy-Partners)

[![](https://avatars.githubusercontent.com/u/57932412?v=4)@BoostryJP](https://github.com/BoostryJP)

[![](https://avatars.githubusercontent.com/u/7601056?v=4)@acsone](https://github.com/acsone)

[![](https://avatars.githubusercontent.com/u/8161763?v=4)@Trivie](https://github.com/Trivie)

[![](https://avatars.githubusercontent.com/u/33813153?u=2d0522bceba0b8b69adf1f2db866503bd96f944e&v=4)@takashi-yoneya](https://github.com/takashi-yoneya)

[![](https://avatars.githubusercontent.com/u/55092103?v=4)@mainframeindustries](https://github.com/mainframeindustries)

[![](https://avatars.githubusercontent.com/u/29543316?u=44357eb2a93bccf30fb9d389b8befe94a3d00985&v=4)@alixlahuec](https://github.com/alixlahuec)

[![](https://avatars.githubusercontent.com/u/62146168?v=4)@primer-io](https://github.com/primer-io)

[![](https://avatars.githubusercontent.com/u/43346262?v=4)@upciti](https://github.com/upciti)

[![](https://avatars.githubusercontent.com/u/26000165?v=4)@ChargeStorm](https://github.com/ChargeStorm)

[![](https://avatars.githubusercontent.com/u/113442282?v=4)@ibrahimpelumi6142](https://github.com/ibrahimpelumi6142)

[![](https://avatars.githubusercontent.com/u/6892179?u=1dca6a22195d6cd1ab20737c0e19a4c55d639472&v=4)@nilslindemann](https://github.com/nilslindemann)

[![](https://avatars.githubusercontent.com/u/4039449?u=42eb3b833047c8c4b4f647a031eaef148c16d93f&v=4)@samuelcolvin](https://github.com/samuelcolvin)

[![](https://avatars.githubusercontent.com/u/42260747?u=69d089387c743d89427aa4ad8740cfb34045a9e0&v=4)@otosky](https://github.com/otosky)

[![](https://avatars.githubusercontent.com/u/45269580?u=3358750b3a5854d7c3ed77aaca7dd20a0f529d32&v=4)@ramonalmeidam](https://github.com/ramonalmeidam)

[![](https://avatars.githubusercontent.com/u/53104118?v=4)@roboflow](https://github.com/roboflow)

[![](https://avatars.githubusercontent.com/u/53487583?u=3a57542938ebfd57579a0111db2b297e606d9681&v=4)@dudikbender](https://github.com/dudikbender)

[![](https://avatars.githubusercontent.com/u/25950317?u=cec1a3e0643b785288ae8260cc295a85ab344995&v=4)@ehaca](https://github.com/ehaca)

[![](https://avatars.githubusercontent.com/u/28026311?u=91e1c00d9ac4f8045527e13de8050d504531cbc0&v=4)@raphaellaude](https://github.com/raphaellaude)

[![](https://avatars.githubusercontent.com/u/28362229?u=9a745ca31372ee324af682715ae88ce8522f9094&v=4)@timlrx](https://github.com/timlrx)

[![](https://avatars.githubusercontent.com/u/32212558?u=c4aa9c1737e515959382a5515381757b1fd86c53&v=4)@Leay15](https://github.com/Leay15)

[![](https://avatars.githubusercontent.com/u/116043716?u=ae590d79c38ac79c91b9c5caa6887d061e865a3d&v=4)@jugeeem](https://github.com/jugeeem)

[![](https://avatars.githubusercontent.com/u/90465103?u=7feb1018abb1a5631cfd9a91fea723d1ceb5f49b&v=4)@Karine-Bauch](https://github.com/Karine-Bauch)

[![](https://avatars.githubusercontent.com/u/80977929?u=1b61d10142b490e56af932ddf08a390fae8ee94f&v=4)@kaoru0310](https://github.com/kaoru0310)

[![](https://avatars.githubusercontent.com/u/79477966?u=ae2b894aa954070db1d7830dab99b49eba4e4567&v=4)@chickenandstats](https://github.com/chickenandstats)

[![](https://avatars.githubusercontent.com/u/73832292?u=5f471f156e19ee7920e62ae0f4a47b95580e61cf&v=4)@patricioperezv](https://github.com/patricioperezv)

[![](https://avatars.githubusercontent.com/u/72019805?u=60bdf46240cff8fca482ff0fc07d963fd5e1a27c&v=4)@anthonycepeda](https://github.com/anthonycepeda)

[![](https://avatars.githubusercontent.com/u/68378354?u=0bdeea9356d24f638244131f6d8d1e2d2f3601ca&v=4)@AalbatrossGuy](https://github.com/AalbatrossGuy)

[![](https://avatars.githubusercontent.com/u/61111267?u=3271b85f7a37b479c8d0ae0a235182e83c166edf&v=4)@patsatsia](https://github.com/patsatsia)

[![](https://avatars.githubusercontent.com/u/4471774?u=534191f25e32eeaadda22dfab4b0a428733d5489&v=4)@oliverxchen](https://github.com/oliverxchen)

[![](https://avatars.githubusercontent.com/u/4381365?v=4)@jaredtrog](https://github.com/jaredtrog)

[![](https://avatars.githubusercontent.com/u/4292423?u=679ff84cb7b988c5795a5fa583857f574a055763&v=4)@Ryandaydev](https://github.com/Ryandaydev)

[![](https://avatars.githubusercontent.com/u/4141690?u=ec119ebc4bdf00a7bc84657a71aa17834f4f27f3&v=4)@gorhack](https://github.com/gorhack)

[![](https://avatars.githubusercontent.com/u/3890353?u=1c627ac1a024515b4871de5c3ebbfaa1a57f65d4&v=4)@mj0331](https://github.com/mj0331)

[![](https://avatars.githubusercontent.com/u/3654837?v=4)@anomaly](https://github.com/anomaly)

[![](https://avatars.githubusercontent.com/u/3634801?u=eaadda178c964178fcb64886f6c732172c8f8219&v=4)@aacayaco](https://github.com/aacayaco)

[![](https://avatars.githubusercontent.com/u/3631417?u=7c8f743f1ae325dfadea7c62bbf1abd6a824fc55&v=4)@kennywakeland](https://github.com/kennywakeland)

[![](https://avatars.githubusercontent.com/u/3532625?u=ba75a5dc744d1116ccfeaaf30d41cb2fe81fe8dd&v=4)@zsinx6](https://github.com/zsinx6)

[![](https://avatars.githubusercontent.com/u/3528486?v=4)@dblackrun](https://github.com/dblackrun)

[![](https://avatars.githubusercontent.com/u/2358812?u=c48cb6362b309d74cbf144bd6ad3aed3eb443e82&v=4)@knallgelb](https://github.com/knallgelb)

[![](https://avatars.githubusercontent.com/u/1362607?u=9bf1e0e520cccc547c046610c468ce6115bbcf9f&v=4)@dodo5522](https://github.com/dodo5522)

[![](https://avatars.githubusercontent.com/u/769950?u=ecfbd79a97d33177e0d093ddb088283cf7fe8444&v=4)@mintuhouse](https://github.com/mintuhouse)

[![](https://avatars.githubusercontent.com/u/653031?u=ad9838e089058c9e5a0bab94c0eec7cc181e0cd0&v=4)@falkben](https://github.com/falkben)

[![](https://avatars.githubusercontent.com/u/630670?u=507d8577b4b3670546b449c4c2ccbc5af40d72f7&v=4)@koxudaxi](https://github.com/koxudaxi)

[![](https://avatars.githubusercontent.com/u/365303?u=07ca03c5ee811eb0920e633cc3c3db73dbec1aa5&v=4)@wshayes](https://github.com/wshayes)

[![](https://avatars.githubusercontent.com/u/297042?v=4)@pamelafox](https://github.com/pamelafox)

[![](https://avatars.githubusercontent.com/u/296686?v=4)@robintw](https://github.com/robintw)

[![](https://avatars.githubusercontent.com/u/63288?u=c3658d57d2862c607a0e19c2101c3c51876e36ad&v=4)@jstanden](https://github.com/jstanden)

[![](https://avatars.githubusercontent.com/u/20320552?v=4)@RaamEEIL](https://github.com/RaamEEIL)

[![](https://avatars.githubusercontent.com/u/17105294?u=99c7a854035e5398d8e7b674f2d42baae6c957f8&v=4)@ashi-agrawal](https://github.com/ashi-agrawal)

[![](https://avatars.githubusercontent.com/u/16784016?u=38fad2e6b411244560b3af99c5f5a4751bc81865&v=4)@mjohnsey](https://github.com/mjohnsey)

[![](https://avatars.githubusercontent.com/u/13686061?u=59f25ef42ecf04c22657aac4238ce0e2d3d30304&v=4)@khadrawy](https://github.com/khadrawy)

[![](https://avatars.githubusercontent.com/u/13680237?u=418ee985bd41577b20fde81417fb2d901e875e8a&v=4)@dannywade](https://github.com/dannywade)

[![](https://avatars.githubusercontent.com/u/12414216?u=620921d94196546cc8b9eae2cc4cbc3f95bab42f&v=4)@jsoques](https://github.com/jsoques)

[![](https://avatars.githubusercontent.com/u/11562137?u=371272f2c69e680e0559a7b0a57385e83a5dc728&v=4)@wdwinslow](https://github.com/wdwinslow)

[![](https://avatars.githubusercontent.com/u/7343177?v=4)@hiancdtrsnm](https://github.com/hiancdtrsnm)

[![](https://avatars.githubusercontent.com/u/7015688?u=3afb0ba200feebbc7f958950e92db34df2a3c172&v=4)@Rehket](https://github.com/Rehket)

[![](https://avatars.githubusercontent.com/u/6262214?u=58ba6d5888fa7f355934e52db19f950e20b38162&v=4)@FernandoCelmer](https://github.com/FernandoCelmer)

[![](https://avatars.githubusercontent.com/u/5920492?u=208d419cf667b8ac594c82a8db01932c7e50d057&v=4)@eseglem](https://github.com/eseglem)

[![](https://avatars.githubusercontent.com/u/5481618?u=513a26b02a39e7a28d587cd37c6cc877ea368e6e&v=4)@ternaus](https://github.com/ternaus)

[![](https://avatars.githubusercontent.com/u/63471891?u=e8691f386037e51a737cc0ba866cd8c89e5cf109&v=4)@Artur-Galstyan](https://github.com/Artur-Galstyan)

[![](https://avatars.githubusercontent.com/u/23669137?u=b12e84b28a84369ab5b30bd5a79e5788df5a0756&v=4)@manoelpqueiroz](https://github.com/manoelpqueiroz)

[![](https://avatars.githubusercontent.com/u/3999221?u=b030e4c89df2f3a36bc4710b925bdeb6745c9856&v=4)@pawamoy](https://github.com/pawamoy)

[![](https://avatars.githubusercontent.com/u/43583410?u=562005ddc7901cd27a1219a118a2363817b14977&v=4)@siavashyj](https://github.com/siavashyj)

[![](https://avatars.githubusercontent.com/u/44370805?v=4)@mobyw](https://github.com/mobyw)

[![](https://avatars.githubusercontent.com/u/44609997?v=4)@ArtyomVancyan](https://github.com/ArtyomVancyan)

[![](https://avatars.githubusercontent.com/u/45425937?u=5f3d66ea5edea94c028c51ebf1c0f3b37e6c3db5&v=4)@caviri](https://github.com/caviri)

[![](https://avatars.githubusercontent.com/u/50397689?u=6cc9028f3db63f8f60ad21c17b1ce4b88c4e2e60&v=4)@hgalytoby](https://github.com/hgalytoby)

[![](https://avatars.githubusercontent.com/u/54412955?u=47dd06082d1c39caa90c752eb55566e4f3813957&v=4)@johnl28](https://github.com/johnl28)

[![](https://avatars.githubusercontent.com/u/4472301?v=4)@danielunderwood](https://github.com/danielunderwood)

[![](https://avatars.githubusercontent.com/u/25708487?u=cda07434f0509ac728d9edf5e681117c0f6b818b&v=4)@hoenie-ams](https://github.com/hoenie-ams)

[![](https://avatars.githubusercontent.com/u/26282974?v=4)@joerambo](https://github.com/joerambo)

[![](https://avatars.githubusercontent.com/u/33275230?u=eb223cad27017bb1e936ee9b429b450d092d0236&v=4)@engineerjoe440](https://github.com/engineerjoe440)

[![](https://avatars.githubusercontent.com/u/34930566?u=4771ac4e64066f0847d40e5b29910adabd9b2372&v=4)@bnkc](https://github.com/bnkc)

[![](https://avatars.githubusercontent.com/u/37613029?u=75aa8c6729e6e8f85a300561c4dbeef9d65c8797&v=4)@petercool](https://github.com/petercool)

[![](https://avatars.githubusercontent.com/u/77930606?v=4)@PelicanQ](https://github.com/PelicanQ)

[![](https://avatars.githubusercontent.com/u/70463212?u=1a835cfbc99295a60c8282f6aa6199d1b42241a5&v=4)@PunRabbit](https://github.com/PunRabbit)

[![](https://avatars.githubusercontent.com/u/1825270?v=4)@my3](https://github.com/my3)

[![](https://avatars.githubusercontent.com/u/1661551?u=8a80356e3e7d5a417157aba7ea565dabc8678327&v=4)@WillHogan](https://github.com/WillHogan)

[![](https://avatars.githubusercontent.com/u/1484589?u=54556072b8136efa12ae3b6902032ea2a39ace4b&v=4)@miguelgr](https://github.com/miguelgr)

[![](https://avatars.githubusercontent.com/u/851759?v=4)@tochikuji](https://github.com/tochikuji)

[![](https://avatars.githubusercontent.com/u/235213?u=edcce471814a1eba9f0cdaa4cd0de18921a940a6&v=4)@ceb10n](https://github.com/ceb10n)

[![](https://avatars.githubusercontent.com/u/210173?v=4)@slafs](https://github.com/slafs)

[![](https://avatars.githubusercontent.com/u/144028?u=defda4f90e93429221cc667500944abde60ebe4a&v=4)@bryanculbertson](https://github.com/bryanculbertson)

[![](https://avatars.githubusercontent.com/u/113563?u=ed1dc79de72f93bd78581f88ebc6952b62f472da&v=4)@ddanier](https://github.com/ddanier)

[![](https://avatars.githubusercontent.com/u/25281462?u=e562484c451fdfc59053163f64405f8eb262b8b0&v=4)@nisutec](https://github.com/nisutec)

[![](https://avatars.githubusercontent.com/u/17817563?u=f1bf05b690d1fc164218f0b420cdd3acb7913e21&v=4)@joshuatz](https://github.com/joshuatz)

[![](https://avatars.githubusercontent.com/u/16740832?u=b0dfdbdb27b79729430c71c6128962f77b7b53f7&v=4)@TheR1D](https://github.com/TheR1D)

[![](https://avatars.githubusercontent.com/u/10934846?u=1ef43e075ddc87bd1178372bf4d95ee6175cae27&v=4)@Zuzah](https://github.com/Zuzah)

[![](https://avatars.githubusercontent.com/u/10390224?v=4)@mntolia](https://github.com/mntolia)

[![](https://avatars.githubusercontent.com/u/9651103?u=78d12d1acdf853c817700145e73de7fd9e5d068b&v=4)@hard-coders](https://github.com/hard-coders)

[![](https://avatars.githubusercontent.com/u/9536869?u=652dd0d49717803c0cbcbf44f7740e53cf2d4892&v=4)@DMantis](https://github.com/DMantis)

[![](https://avatars.githubusercontent.com/u/9462045?u=a80a7bb349555b277645632ed66639ff43400614&v=4)@xncbf](https://github.com/xncbf)

[![](https://avatars.githubusercontent.com/u/8532038?u=d9f8b855a429fff9397c3833c2ff83849ebf989d&v=4)@moonape1226](https://github.com/moonape1226)

[![](https://avatars.githubusercontent.com/u/7780198?v=4)@harsh183](https://github.com/harsh183)

[![](https://avatars.githubusercontent.com/u/7674948?u=09767eb13e07e09496c5fee4e5ce21d9eac34a56&v=4)@katnoria](https://github.com/katnoria)

[![](https://avatars.githubusercontent.com/u/6329898?u=8b236810db9b96333230430837e1f021f9246da1&v=4)@KentShikama](https://github.com/KentShikama)

[![](https://avatars.githubusercontent.com/u/5708590?v=4)@Baghdady92](https://github.com/Baghdady92)

[![](https://avatars.githubusercontent.com/u/5250987?u=4ed9a120c89805a8aefda1cbdc0cf6512e64d1b4&v=4)@sdevkota](https://github.com/sdevkota)

[![](https://avatars.githubusercontent.com/u/5235430?u=e254d4af4ace5a05fa58372ae677c7d26f0d5a53&v=4)@rangulvers](https://github.com/rangulvers)

[![](https://avatars.githubusercontent.com/u/38822500?u=9dfc0a697df1c9628f08e20dc3fb17b1afc4e5a7&v=4)@KOZ39](https://github.com/KOZ39)

[![](https://avatars.githubusercontent.com/u/40308458?u=cd04a39e3655923be4f25c2ba8a5a07b3da3230a&v=4)@rwxd](https://github.com/rwxd)

[![](https://avatars.githubusercontent.com/u/47593005?u=c30ab7230f82a12a9b938dcb54f84a996931409a&v=4)@morzan1001](https://github.com/morzan1001)

[![](https://avatars.githubusercontent.com/u/25399456?u=3e87b5239a2f4600975ba13be73054f8567c6060&v=4)@Olegt0rr](https://github.com/Olegt0rr)

[![](https://avatars.githubusercontent.com/u/34173819?u=74958599695bf83ac9f1addd935a51548a10c6b0&v=4)@larsyngvelundin](https://github.com/larsyngvelundin)

[![](https://avatars.githubusercontent.com/u/37807517?u=9b9be3b41da9bda60957da9ef37b50dbf65baa61&v=4)@andrecorumba](https://github.com/andrecorumba)

[![](https://avatars.githubusercontent.com/u/152043745?u=4ff541efffb7d134e60c5fcf2dd1e343f90bb782&v=4)@CoderDeltaLAN](https://github.com/CoderDeltaLAN)

[![](https://avatars.githubusercontent.com/u/135493401?u=1164ef48a645a7c12664fabc1638fbb7e1c459b0&v=4)@hippoley](https://github.com/hippoley)

[![](https://avatars.githubusercontent.com/u/74111380?u=752e99a5e139389fdc0a0677122adc08438eb076&v=4)@nayasinghania](https://github.com/nayasinghania)

[![](https://avatars.githubusercontent.com/u/62360849?u=746dd21c34e7e06eefb11b03e8bb01aaae3c2a4f&v=4)@onestn](https://github.com/onestn)

[![](https://avatars.githubusercontent.com/u/1710406?u=5eebb23b46cd26e48643b9e5179536cad491c17a&v=4)@Toothwitch](https://github.com/Toothwitch)

[![](https://avatars.githubusercontent.com/u/636391?u=13d90cb8ec313593a5b71fbd4e33b78d6da736f5&v=4)@andreagrandi](https://github.com/andreagrandi)

[![](https://avatars.githubusercontent.com/u/6334934?u=82c4489eb1559d88d2990d60001901b14f722bbb&v=4)@msserpa](https://github.com/msserpa)

## About the data - technical details[¶](#about-the-data-technical-details "Permanent link")

The main intention of this page is to highlight the effort of the community to help others.

Especially including efforts that are normally less visible, and in many cases more arduous, like helping others with questions and reviewing Pull Requests with translations.

The data is calculated each month, you can read the [source code here](https://github.com/fastapi/fastapi/blob/master/scripts/).

Here I'm also highlighting contributions from sponsors.

I also reserve the right to update the algorithm, sections, thresholds, etc (just in case ü§∑).

---

#### Resources¶

# Resources[¶](#resources "Permanent link")

Additional resources, external links, and more. ‚úàÔ∏è

---

###### Help FastAPI - Get Help¶

# Help FastAPI - Get Help[¶](#help-fastapi-get-help "Permanent link")

Do you like **FastAPI**?

Would you like to help FastAPI, other users, and the author?

Or would you like to get help with **FastAPI**?

There are very simple ways to help (several involve just one or two clicks).

And there are several ways to get help too.

## Subscribe to the newsletter[¶](#subscribe-to-the-newsletter "Permanent link")

You can subscribe to the (infrequent) [**FastAPI and friends** newsletter](../newsletter/) to stay updated about:

  * News about FastAPI and friends üöÄ
  * Guides üìù
  * Features ‚ú®
  * Breaking changes üö®
  * Tips and tricks ‚úÖ

## Follow FastAPI on X (Twitter)[¶](#follow-fastapi-on-x-twitter "Permanent link")

[Follow @fastapi on **X (Twitter)**](https://x.com/fastapi) to get the latest news about **FastAPI**. üê¶

## Star **FastAPI** in GitHub[¶](#star-fastapi-in-github "Permanent link")

You can "star" FastAPI in GitHub (clicking the star button at the top right): <https://github.com/fastapi/fastapi>. ‚≠êÔ∏è

By adding a star, other users will be able to find it more easily and see that it has been already useful for others.

## Watch the GitHub repository for releases[¶](#watch-the-github-repository-for-releases "Permanent link")

You can "watch" FastAPI in GitHub (clicking the "watch" button at the top right): <https://github.com/fastapi/fastapi>. üëÄ

There you can select "Releases only".

By doing it, you will receive notifications (in your email) whenever there's a new release (a new version) of **FastAPI** with bug fixes and new features.

## Connect with the author[¶](#connect-with-the-author "Permanent link")

You can connect with [me (Sebasti√°n Ram√≠rez / `tiangolo`)](https://tiangolo.com), the author.

You can:

  * [Follow me on **GitHub**](https://github.com/tiangolo).
    * See other Open Source projects I have created that could help you.
    * Follow me to see when I create a new Open Source project.
  * [Follow me on **X (Twitter)**](https://x.com/tiangolo) or [Mastodon](https://fosstodon.org/@tiangolo).
    * Tell me how you use FastAPI (I love to hear that).
    * Hear when I make announcements or release new tools.
    * You can also [follow @fastapi on X (Twitter)](https://x.com/fastapi) (a separate account).
  * [Follow me on **LinkedIn**](https://www.linkedin.com/in/tiangolo/).
    * Hear when I make announcements or release new tools (although I use X (Twitter) more often ü§∑‚Äç‚ôÇ).
  * Read what I write (or follow me) on [**Dev.to**](https://dev.to/tiangolo) or [**Medium**](https://medium.com/@tiangolo).
    * Read other ideas, articles, and read about tools I have created.
    * Follow me to read when I publish something new.

## Tweet about **FastAPI**[¶](#tweet-about-fastapi "Permanent link")

[Tweet about **FastAPI**](https://x.com/compose/tweet?text=I'm loving @fastapi because... https://github.com/fastapi/fastapi) and let me and others know why you like it. üéâ

I love to hear about how **FastAPI** is being used, what you have liked in it, in which project/company are you using it, etc.

## Vote for FastAPI[¶](#vote-for-fastapi "Permanent link")

  * [Vote for **FastAPI** in Slant](https://www.slant.co/options/34241/~fastapi-review).
  * [Vote for **FastAPI** in AlternativeTo](https://alternativeto.net/software/fastapi/about/).
  * [Say you use **FastAPI** on StackShare](https://stackshare.io/pypi-fastapi).

## Help others with questions in GitHub[¶](#help-others-with-questions-in-github "Permanent link")

You can try and help others with their questions in:

  * [GitHub Discussions](https://github.com/fastapi/fastapi/discussions/categories/questions?discussions_q=category%3AQuestions+is%3Aunanswered)
  * [GitHub Issues](https://github.com/fastapi/fastapi/issues?q=is%3Aissue+is%3Aopen+sort%3Aupdated-desc+label%3Aquestion+-label%3Aanswered+)

In many cases you might already know the answer for those questions. ü§ì

If you are helping a lot of people with their questions, you will become an official [FastAPI Expert](../fastapi-people/#fastapi-experts). üéâ

Just remember, the most important point is: try to be kind. People come with their frustrations and in many cases don't ask in the best way, but try as best as you can to be kind. ü§ó

The idea is for the **FastAPI** community to be kind and welcoming. At the same time, don't accept bullying or disrespectful behavior towards others. We have to take care of each other.

* * *

Here's how to help others with questions (in discussions or issues):

### Understand the question[¶](#understand-the-question "Permanent link")

  * Check if you can understand what is the **purpose** and use case of the person asking.

  * Then check if the question (the vast majority are questions) is **clear**.

  * In many cases the question asked is about an imaginary solution from the user, but there might be a **better** one. If you can understand the problem and use case better, you might be able to suggest a better **alternative solution**.

  * If you can't understand the question, ask for more **details**.

### Reproduce the problem[¶](#reproduce-the-problem "Permanent link")

For most of the cases and most of the questions there's something related to the person's **original code**.

In many cases they will only copy a fragment of the code, but that's not enough to **reproduce the problem**.

  * You can ask them to provide a [minimal, reproducible, example](https://stackoverflow.com/help/minimal-reproducible-example), that you can **copy-paste** and run locally to see the same error or behavior they are seeing, or to understand their use case better.

  * If you are feeling too generous, you can try to **create an example** like that yourself, just based on the description of the problem. Just keep in mind that this might take a lot of time and it might be better to ask them to clarify the problem first.

### Suggest solutions[¶](#suggest-solutions "Permanent link")

  * After being able to understand the question, you can give them a possible **answer**.

  * In many cases, it's better to understand their **underlying problem or use case** , because there might be a better way to solve it than what they are trying to do.

### Ask to close[¶](#ask-to-close "Permanent link")

If they reply, there's a high chance you would have solved their problem, congrats, **you're a hero**! ü¶∏

  * Now, if that solved their problem, you can ask them to:

    * In GitHub Discussions: mark the comment as the **answer**.
    * In GitHub Issues: **close** the issue.

## Watch the GitHub repository[¶](#watch-the-github-repository "Permanent link")

You can "watch" FastAPI in GitHub (clicking the "watch" button at the top right): <https://github.com/fastapi/fastapi>. üëÄ

If you select "Watching" instead of "Releases only" you will receive notifications when someone creates a new issue or question. You can also specify that you only want to be notified about new issues, or discussions, or PRs, etc.

Then you can try and help them solve those questions.

## Ask Questions[¶](#ask-questions "Permanent link")

You can [create a new question](https://github.com/fastapi/fastapi/discussions/new?category=questions) in the GitHub repository, for example to:

  * Ask a **question** or ask about a **problem**.
  * Suggest a new **feature**.

**Note** : if you do it, then I'm going to ask you to also help others. üòâ

## Review Pull Requests[¶](#review-pull-requests "Permanent link")

You can help me review pull requests from others.

Again, please try your best to be kind. ü§ó

* * *

Here's what to keep in mind and how to review a pull request:

### Understand the problem[¶](#understand-the-problem "Permanent link")

  * First, make sure you **understand the problem** that the pull request is trying to solve. It might have a longer discussion in a GitHub Discussion or issue.

  * There's also a good chance that the pull request is not actually needed because the problem can be solved in a **different way**. Then you can suggest or ask about that.

### Don't worry about style[¶](#dont-worry-about-style "Permanent link")

  * Don't worry too much about things like commit message styles, I will squash and merge customizing the commit manually.

  * Also don't worry about style rules, there are already automatized tools checking that.

And if there's any other style or consistency need, I'll ask directly for that, or I'll add commits on top with the needed changes.

### Check the code[¶](#check-the-code "Permanent link")

  * Check and read the code, see if it makes sense, **run it locally** and see if it actually solves the problem.

  * Then **comment** saying that you did that, that's how I will know you really checked it.

Info

Unfortunately, I can't simply trust PRs that just have several approvals.

Several times it has happened that there are PRs with 3, 5 or more approvals, probably because the description is appealing, but when I check the PRs, they are actually broken, have a bug, or don't solve the problem they claim to solve. üòÖ

So, it's really important that you actually read and run the code, and let me know in the comments that you did. ü§ì

  * If the PR can be simplified in a way, you can ask for that, but there's no need to be too picky, there might be a lot of subjective points of view (and I will have my own as well üôà), so it's better if you can focus on the fundamental things.

### Tests[¶](#tests "Permanent link")

  * Help me check that the PR has **tests**.

  * Check that the tests **fail** before the PR. üö®

  * Then check that the tests **pass** after the PR. ‚úÖ

  * Many PRs don't have tests, you can **remind** them to add tests, or you can even **suggest** some tests yourself. That's one of the things that consume most time and you can help a lot with that.

  * Then also comment what you tried, that way I'll know that you checked it. ü§ì

## Create a Pull Request[¶](#create-a-pull-request "Permanent link")

You can [contribute](../contributing/) to the source code with Pull Requests, for example:

  * To fix a typo you found on the documentation.
  * To share an article, video, or podcast you created or found about FastAPI by [editing this file](https://github.com/fastapi/fastapi/edit/master/docs/en/data/external_links.yml).
    * Make sure you add your link to the start of the corresponding section.
  * To help [translate the documentation](../contributing/#translations) to your language.
    * You can also help to review the translations created by others.
  * To propose new documentation sections.
  * To fix an existing issue/bug.
    * Make sure to add tests.
  * To add a new feature.
    * Make sure to add tests.
    * Make sure to add documentation if it's relevant.

## Help Maintain FastAPI[¶](#help-maintain-fastapi "Permanent link")

Help me maintain **FastAPI**! ü§ì

There's a lot of work to do, and for most of it, **YOU** can do it.

The main tasks that you can do right now are:

  * [Help others with questions in GitHub](#help-others-with-questions-in-github) (see the section above).
  * [Review Pull Requests](#review-pull-requests) (see the section above).

Those two tasks are what **consume time the most**. That's the main work of maintaining FastAPI.

If you can help me with that, **you are helping me maintain FastAPI** and making sure it keeps **advancing faster and better**. üöÄ

## Join the chat[¶](#join-the-chat "Permanent link")

Join the üë• [Discord chat server](https://discord.gg/VQjSZaeJmf) üë• and hang out with others in the FastAPI community.

Tip

For questions, ask them in [GitHub Discussions](https://github.com/fastapi/fastapi/discussions/new?category=questions), there's a much better chance you will receive help by the [FastAPI Experts](../fastapi-people/#fastapi-experts).

Use the chat only for other general conversations.

### Don't use the chat for questions[¶](#dont-use-the-chat-for-questions "Permanent link")

Keep in mind that as chats allow more "free conversation", it's easy to ask questions that are too general and more difficult to answer, so, you might not receive answers.

In GitHub, the template will guide you to write the right question so that you can more easily get a good answer, or even solve the problem yourself even before asking. And in GitHub I can make sure I always answer everything, even if it takes some time. I can't personally do that with the chat systems. üòÖ

Conversations in the chat systems are also not as easily searchable as in GitHub, so questions and answers might get lost in the conversation. And only the ones in GitHub count to become a [FastAPI Expert](../fastapi-people/#fastapi-experts), so you will most probably receive more attention in GitHub.

On the other side, there are thousands of users in the chat systems, so there's a high chance you'll find someone to talk to there, almost all the time. üòÑ

## Sponsor the author[¶](#sponsor-the-author "Permanent link")

If your **product/company** depends on or is related to **FastAPI** and you want to reach its users, you can sponsor the author (me) through [GitHub sponsors](https://github.com/sponsors/tiangolo). Depending on the tier, you could get some extra benefits, like a badge in the docs. üéÅ

* * *

Thanks! üöÄ

---

###### Development - Contributing¶

# Development - Contributing[¶](#development-contributing "Permanent link")

First, you might want to see the basic ways to [help FastAPI and get help](../help-fastapi/).

## Developing[¶](#developing "Permanent link")

If you already cloned the [fastapi repository](https://github.com/fastapi/fastapi) and you want to deep dive in the code, here are some guidelines to set up your environment.

### Install requirements[¶](#install-requirements "Permanent link")

Create a virtual environment and install the required packages with [`uv`](https://github.com/astral-sh/uv):
    
    
    $ uv sync --extra all
    
    ---> 100%
    

It will install all the dependencies and your local FastAPI in your local environment.

### Using your local FastAPI[¶](#using-your-local-fastapi "Permanent link")

If you create a Python file that imports and uses FastAPI, and run it with the Python from your local environment, it will use your cloned local FastAPI source code.

And if you update that local FastAPI source code when you run that Python file again, it will use the fresh version of FastAPI you just edited.

That way, you don't have to "install" your local version to be able to test every change.

Technical Details

This only happens when you install using `uv sync --extra all` instead of running `pip install fastapi` directly.

That is because `uv sync --extra all` will install the local version of FastAPI in "editable" mode by default.

### Format the code[¶](#format-the-code "Permanent link")

There is a script that you can run that will format and clean all your code:
    
    
    $ bash scripts/format.sh
    

It will also auto-sort all your imports.

## Tests[¶](#tests "Permanent link")

There is a script that you can run locally to test all the code and generate coverage reports in HTML:
    
    
    $ bash scripts/test-cov-html.sh
    

This command generates a directory `./htmlcov/`, if you open the file `./htmlcov/index.html` in your browser, you can explore interactively the regions of code that are covered by the tests, and notice if there is any region missing.

## Docs[¶](#docs "Permanent link")

First, make sure you set up your environment as described above, that will install all the requirements.

### Docs live[¶](#docs-live "Permanent link")

During local development, there is a script that builds the site and checks for any changes, live-reloading:
    
    
    $ python ./scripts/docs.py live
    
    <span style="color: green;">[INFO]</span> Serving on http://127.0.0.1:8008
    <span style="color: green;">[INFO]</span> Start watching changes
    <span style="color: green;">[INFO]</span> Start detecting changes
    

It will serve the documentation on `http://127.0.0.1:8008`.

That way, you can edit the documentation/source files and see the changes live.

Tip

Alternatively, you can perform the same steps that scripts does manually.

Go into the language directory, for the main docs in English it's at `docs/en/`:
    
    
    $ cd docs/en/
    

Then run `mkdocs` in that directory:
    
    
    $ mkdocs serve --dev-addr 127.0.0.1:8008
    

#### Typer CLI (optional)[¶](#typer-cli-optional "Permanent link")

The instructions here show you how to use the script at `./scripts/docs.py` with the `python` program directly.

But you can also use [Typer CLI](https://typer.tiangolo.com/typer-cli/), and you will get autocompletion in your terminal for the commands after installing completion.

If you install Typer CLI, you can install completion with:
    
    
    $ typer --install-completion
    
    zsh completion installed in /home/user/.bashrc.
    Completion will take effect once you restart the terminal.
    

### Docs Structure[¶](#docs-structure "Permanent link")

The documentation uses [MkDocs](https://www.mkdocs.org/).

And there are extra tools/scripts in place to handle translations in `./scripts/docs.py`.

Tip

You don't need to see the code in `./scripts/docs.py`, you just use it in the command line.

All the documentation is in Markdown format in the directory `./docs/en/`.

Many of the tutorials have blocks of code.

In most of the cases, these blocks of code are actual complete applications that can be run as is.

In fact, those blocks of code are not written inside the Markdown, they are Python files in the `./docs_src/` directory.

And those Python files are included/injected in the documentation when generating the site.

### Docs for tests[¶](#docs-for-tests "Permanent link")

Most of the tests actually run against the example source files in the documentation.

This helps to make sure that:

  * The documentation is up-to-date.
  * The documentation examples can be run as is.
  * Most of the features are covered by the documentation, ensured by test coverage.

#### Apps and docs at the same time[¶](#apps-and-docs-at-the-same-time "Permanent link")

If you run the examples with, e.g.:
    
    
    $ fastapi dev tutorial001.py
    
    <span style="color: green;">INFO</span>:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
    

as Uvicorn by default will use the port `8000`, the documentation on port `8008` won't clash.

### Translations[¶](#translations "Permanent link")

Help with translations is VERY MUCH appreciated! And it can't be done without the help from the community. üåé üöÄ

Translation pull requests are made by LLMs guided with prompts designed by the FastAPI team together with the community of native speakers for each supported language.

#### LLM Prompt per Language[¶](#llm-prompt-per-language "Permanent link")

Each language has a directory: <https://github.com/fastapi/fastapi/tree/master/docs>, in it you can see a file `llm-prompt.md` with the prompt specific for that language.

For example, for Spanish, the prompt is at: [`docs/es/llm-prompt.md`](https://github.com/fastapi/fastapi/blob/master/docs/es/llm-prompt.md).

If you see mistakes in your language, you can make suggestions to the prompt in that file for your language, and request the specific pages you would like to re-generate after the changes.

#### Reviewing Translation PRs[¶](#reviewing-translation-prs "Permanent link")

You can also check the currently [existing pull requests](https://github.com/fastapi/fastapi/pulls) for your language. You can filter the pull requests by the ones with the label for your language. For example, for Spanish, the label is [`lang-es`](https://github.com/fastapi/fastapi/pulls?q=is%3Aopen+sort%3Aupdated-desc+label%3Alang-es+label%3Aawaiting-review).

When reviewing a pull request, it's better not to suggest changes in the same pull request, because it is LLM generated, and it won't be possible to make sure that small individual changes are replicated in other similar sections, or that they are preserved when translating the same content again.

Instead of adding suggestions to the translation PR, make the suggestions to the LLM prompt file for that language, in a new PR. For example, for Spanish, the LLM prompt file is at: [`docs/es/llm-prompt.md`](https://github.com/fastapi/fastapi/blob/master/docs/es/llm-prompt.md).

Tip

Check the docs about [adding a pull request review](https://help.github.com/en/github/collaborating-with-issues-and-pull-requests/about-pull-request-reviews) to approve it or request changes.

#### Subscribe to Notifications for Your Language[¶](#subscribe-to-notifications-for-your-language "Permanent link")

Check if there's a [GitHub Discussion](https://github.com/fastapi/fastapi/discussions/categories/translations) to coordinate translations for your language. You can subscribe to it, and when there's a new pull request to review, an automatic comment will be added to the discussion.

To check the 2-letter code for the language you want to translate, you can use the table [List of ISO 639-1 codes](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes).

#### Request a New Language[¶](#request-a-new-language "Permanent link")

Let's say that you want to request translations for a language that is not yet translated, not even some pages. For example, Latin.

  * The first step would be for you to find other 2 people that would be willing to be reviewing translation PRs for that language with you.
  * Once there are at least 3 people that would be willing to commit to help maintain that language, you can continue the next steps.
  * Create a new discussion following the template.
  * Tag the other 2 people that will help with the language, and ask them to confirm there they will help.

Once there are several people in the discussion, the FastAPI team can evaluate it and can make it an official translation.

Then the docs will be automatically translated using LLMs, and the team of native speakers can review the translation, and help tweak the LLM prompts.

Once there's a new translation, for example if docs are updated or there's a new section, there will be a comment in the same discussion with the link to the new translation to review.

## Automated Code and AI[¶](#automated-code-and-ai "Permanent link")

You are encouraged to use all the tools you want to do your work and contribute as efficiently as possible, this includes AI (LLM) tools, etc. Nevertheless, contributions should have meaningful human intervention, judgement, context, etc.

If the **human effort** put in a PR, e.g. writing LLM prompts, is **less** than the **effort we would need to put** to **review it** , please **don't** submit the PR.

Think of it this way: we can already write LLM prompts or run automated tools ourselves, and that would be faster than reviewing external PRs.

### Closing Automated and AI PRs[¶](#closing-automated-and-ai-prs "Permanent link")

If we see PRs that seem AI generated or automated in similar ways, we'll flag them and close them.

The same applies to comments and descriptions, please don't copy paste the content generated by an LLM.

### Human Effort Denial of Service[¶](#human-effort-denial-of-service "Permanent link")

Using automated tools and AI to submit PRs or comments that we have to carefully review and handle would be the equivalent of a [Denial-of-service attack](https://en.wikipedia.org/wiki/Denial-of-service_attack) on our human effort.

It would be very little effort from the person submitting the PR (an LLM prompt) that generates a large amount of effort on our side (carefully reviewing code).

Please don't do that.

We'll need to block accounts that spam us with repeated automated PRs or comments.

### Use Tools Wisely[¶](#use-tools-wisely "Permanent link")

As Uncle Ben said:

> With great ~~power~~ **tools** comes great responsibility. 

Avoid inadvertently doing harm.

You have amazing tools at hand, use them wisely to help effectively.

---

###### Full Stack FastAPI Template¶

# Full Stack FastAPI Template[¶](#full-stack-fastapi-template "Permanent link")

Templates, while typically come with a specific setup, are designed to be flexible and customizable. This allows you to modify and adapt them to your project's requirements, making them an excellent starting point. üèÅ

You can use this template to get started, as it includes a lot of the initial set up, security, database and some API endpoints already done for you.

GitHub Repository: [Full Stack FastAPI Template](https://github.com/tiangolo/full-stack-fastapi-template)

## Full Stack FastAPI Template - Technology Stack and Features[¶](#full-stack-fastapi-template-technology-stack-and-features "Permanent link")

  * ‚ö° [**FastAPI**](https://fastapi.tiangolo.com) for the Python backend API.
  * üß∞ [SQLModel](https://sqlmodel.tiangolo.com) for the Python SQL database interactions (ORM).
  * üîç [Pydantic](https://docs.pydantic.dev), used by FastAPI, for the data validation and settings management.
  * üíæ [PostgreSQL](https://www.postgresql.org) as the SQL database.
  * üöÄ [React](https://react.dev) for the frontend.
  * üíÉ Using TypeScript, hooks, Vite, and other parts of a modern frontend stack.
  * üé® [Tailwind CSS](https://tailwindcss.com) and [shadcn/ui](https://ui.shadcn.com) for the frontend components.
  * ü§ñ An automatically generated frontend client.
  * üß™ [Playwright](https://playwright.dev) for End-to-End testing.
  * ü¶á Dark mode support.
  * üêã [Docker Compose](https://www.docker.com) for development and production.
  * üîí Secure password hashing by default.
  * üîë JWT (JSON Web Token) authentication.
  * üì´ Email based password recovery.
  * ‚úÖ Tests with [Pytest](https://pytest.org).
  * üìû [Traefik](https://traefik.io) as a reverse proxy / load balancer.
  * üö¢ Deployment instructions using Docker Compose, including how to set up a frontend Traefik proxy to handle automatic HTTPS certificates.
  * üè≠ CI (continuous integration) and CD (continuous deployment) based on GitHub Actions.

---

###### External Links¶

# External Links[¶](#external-links "Permanent link")

**FastAPI** has a great community constantly growing.

There are many posts, articles, tools, and projects, related to **FastAPI**.

You could easily use a search engine or video platform to find many resources related to FastAPI.

Info

Before, this page used to list links to external articles.

But now that FastAPI is the backend framework with the most GitHub stars across languages, and the most starred and used framework in Python, it no longer makes sense to attempt to list all articles written about it.

## GitHub Repositories[¶](#github-repositories "Permanent link")

Most starred [GitHub repositories with the topic `fastapi`](https://github.com/topics/fastapi):

[‚òÖ 41312 - full-stack-fastapi-template](https://github.com/fastapi/full-stack-fastapi-template) by [@fastapi](https://github.com/fastapi).

[‚òÖ 34206 - Hello-Python](https://github.com/mouredev/Hello-Python) by [@mouredev](https://github.com/mouredev).

[‚òÖ 21832 - serve](https://github.com/jina-ai/serve) by [@jina-ai](https://github.com/jina-ai).

[‚òÖ 20661 - HivisionIDPhotos](https://github.com/Zeyi-Lin/HivisionIDPhotos) by [@Zeyi-Lin](https://github.com/Zeyi-Lin).

[‚òÖ 17567 - sqlmodel](https://github.com/fastapi/sqlmodel) by [@fastapi](https://github.com/fastapi).

[‚òÖ 16291 - fastapi-best-practices](https://github.com/zhanymkanov/fastapi-best-practices) by [@zhanymkanov](https://github.com/zhanymkanov).

[‚òÖ 16132 - Douyin_TikTok_Download_API](https://github.com/Evil0ctal/Douyin_TikTok_Download_API) by [@Evil0ctal](https://github.com/Evil0ctal).

[‚òÖ 12723 - SurfSense](https://github.com/MODSetter/SurfSense) by [@MODSetter](https://github.com/MODSetter).

[‚òÖ 12575 - machine-learning-zoomcamp](https://github.com/DataTalksClub/machine-learning-zoomcamp) by [@DataTalksClub](https://github.com/DataTalksClub).

[‚òÖ 11478 - fastapi_mcp](https://github.com/tadata-org/fastapi_mcp) by [@tadata-org](https://github.com/tadata-org).

[‚òÖ 11018 - awesome-fastapi](https://github.com/mjhea0/awesome-fastapi) by [@mjhea0](https://github.com/mjhea0).

[‚òÖ 9938 - XHS-Downloader](https://github.com/JoeanAmier/XHS-Downloader) by [@JoeanAmier](https://github.com/JoeanAmier).

[‚òÖ 9348 - polar](https://github.com/polarsource/polar) by [@polarsource](https://github.com/polarsource).

[‚òÖ 8949 - FastUI](https://github.com/pydantic/FastUI) by [@pydantic](https://github.com/pydantic).

[‚òÖ 8060 - FileCodeBox](https://github.com/vastsa/FileCodeBox) by [@vastsa](https://github.com/vastsa).

[‚òÖ 7311 - nonebot2](https://github.com/nonebot/nonebot2) by [@nonebot](https://github.com/nonebot).

[‚òÖ 6479 - hatchet](https://github.com/hatchet-dev/hatchet) by [@hatchet-dev](https://github.com/hatchet-dev).

[‚òÖ 5970 - fastapi-users](https://github.com/fastapi-users/fastapi-users) by [@fastapi-users](https://github.com/fastapi-users).

[‚òÖ 5751 - serge](https://github.com/serge-chat/serge) by [@serge-chat](https://github.com/serge-chat).

[‚òÖ 4598 - strawberry](https://github.com/strawberry-graphql/strawberry) by [@strawberry-graphql](https://github.com/strawberry-graphql).

[‚òÖ 4407 - devpush](https://github.com/hunvreus/devpush) by [@hunvreus](https://github.com/hunvreus).

[‚òÖ 4359 - Kokoro-FastAPI](https://github.com/remsky/Kokoro-FastAPI) by [@remsky](https://github.com/remsky).

[‚òÖ 4337 - poem](https://github.com/poem-web/poem) by [@poem-web](https://github.com/poem-web).

[‚òÖ 4279 - chatgpt-web-share](https://github.com/chatpire/chatgpt-web-share) by [@chatpire](https://github.com/chatpire).

[‚òÖ 4244 - dynaconf](https://github.com/dynaconf/dynaconf) by [@dynaconf](https://github.com/dynaconf).

[‚òÖ 4154 - Yuxi-Know](https://github.com/xerrors/Yuxi-Know) by [@xerrors](https://github.com/xerrors).

[‚òÖ 4086 - atrilabs-engine](https://github.com/Atri-Labs/atrilabs-engine) by [@Atri-Labs](https://github.com/Atri-Labs).

[‚òÖ 3975 - logfire](https://github.com/pydantic/logfire) by [@pydantic](https://github.com/pydantic).

[‚òÖ 3797 - LitServe](https://github.com/Lightning-AI/LitServe) by [@Lightning-AI](https://github.com/Lightning-AI).

[‚òÖ 3785 - huma](https://github.com/danielgtaylor/huma) by [@danielgtaylor](https://github.com/danielgtaylor).

[‚òÖ 3731 - datamodel-code-generator](https://github.com/koxudaxi/datamodel-code-generator) by [@koxudaxi](https://github.com/koxudaxi).

[‚òÖ 3697 - fastapi-admin](https://github.com/fastapi-admin/fastapi-admin) by [@fastapi-admin](https://github.com/fastapi-admin).

[‚òÖ 3506 - farfalle](https://github.com/rashadphz/farfalle) by [@rashadphz](https://github.com/rashadphz).

[‚òÖ 3458 - tracecat](https://github.com/TracecatHQ/tracecat) by [@TracecatHQ](https://github.com/TracecatHQ).

[‚òÖ 3216 - mcp-context-forge](https://github.com/IBM/mcp-context-forge) by [@IBM](https://github.com/IBM).

[‚òÖ 3134 - opyrator](https://github.com/ml-tooling/opyrator) by [@ml-tooling](https://github.com/ml-tooling).

[‚òÖ 3111 - docarray](https://github.com/docarray/docarray) by [@docarray](https://github.com/docarray).

[‚òÖ 3072 - fastapi-realworld-example-app](https://github.com/nsidnev/fastapi-realworld-example-app) by [@nsidnev](https://github.com/nsidnev).

[‚òÖ 2908 - uvicorn-gunicorn-fastapi-docker](https://github.com/tiangolo/uvicorn-gunicorn-fastapi-docker) by [@tiangolo](https://github.com/tiangolo).

[‚òÖ 2728 - FastAPI-template](https://github.com/s3rius/FastAPI-template) by [@s3rius](https://github.com/s3rius).

[‚òÖ 2686 - best-of-web-python](https://github.com/ml-tooling/best-of-web-python) by [@ml-tooling](https://github.com/ml-tooling).

[‚òÖ 2648 - YC-Killer](https://github.com/sahibzada-allahyar/YC-Killer) by [@sahibzada-allahyar](https://github.com/sahibzada-allahyar).

[‚òÖ 2637 - sqladmin](https://github.com/aminalaee/sqladmin) by [@aminalaee](https://github.com/aminalaee).

[‚òÖ 2573 - fastapi-react](https://github.com/Buuntu/fastapi-react) by [@Buuntu](https://github.com/Buuntu).

[‚òÖ 2460 - RasaGPT](https://github.com/paulpierre/RasaGPT) by [@paulpierre](https://github.com/paulpierre).

[‚òÖ 2428 - supabase-py](https://github.com/supabase/supabase-py) by [@supabase](https://github.com/supabase).

[‚òÖ 2347 - 30-Days-of-Python](https://github.com/codingforentrepreneurs/30-Days-of-Python) by [@codingforentrepreneurs](https://github.com/codingforentrepreneurs).

[‚òÖ 2337 - nextpy](https://github.com/dot-agent/nextpy) by [@dot-agent](https://github.com/dot-agent).

[‚òÖ 2299 - fastapi-utils](https://github.com/fastapiutils/fastapi-utils) by [@fastapiutils](https://github.com/fastapiutils).

[‚òÖ 2255 - langserve](https://github.com/langchain-ai/langserve) by [@langchain-ai](https://github.com/langchain-ai).

[‚òÖ 2182 - NoteDiscovery](https://github.com/gamosoft/NoteDiscovery) by [@gamosoft](https://github.com/gamosoft).

[‚òÖ 2154 - solara](https://github.com/widgetti/solara) by [@widgetti](https://github.com/widgetti).

[‚òÖ 2071 - mangum](https://github.com/Kludex/mangum) by [@Kludex](https://github.com/Kludex).

[‚òÖ 2036 - fastapi_best_architecture](https://github.com/fastapi-practices/fastapi_best_architecture) by [@fastapi-practices](https://github.com/fastapi-practices).

[‚òÖ 1983 - vue-fastapi-admin](https://github.com/mizhexiaoxiao/vue-fastapi-admin) by [@mizhexiaoxiao](https://github.com/mizhexiaoxiao).

[‚òÖ 1941 - agentkit](https://github.com/BCG-X-Official/agentkit) by [@BCG-X-Official](https://github.com/BCG-X-Official).

[‚òÖ 1920 - fastapi-langgraph-agent-production-ready-template](https://github.com/wassim249/fastapi-langgraph-agent-production-ready-template) by [@wassim249](https://github.com/wassim249).

[‚òÖ 1900 - openapi-python-client](https://github.com/openapi-generators/openapi-python-client) by [@openapi-generators](https://github.com/openapi-generators).

[‚òÖ 1894 - manage-fastapi](https://github.com/ycd/manage-fastapi) by [@ycd](https://github.com/ycd).

[‚òÖ 1891 - slowapi](https://github.com/laurentS/slowapi) by [@laurentS](https://github.com/laurentS).

[‚òÖ 1854 - piccolo](https://github.com/piccolo-orm/piccolo) by [@piccolo-orm](https://github.com/piccolo-orm).

[‚òÖ 1816 - fastapi-cache](https://github.com/long2ice/fastapi-cache) by [@long2ice](https://github.com/long2ice).

[‚òÖ 1813 - python-week-2022](https://github.com/rochacbruno/python-week-2022) by [@rochacbruno](https://github.com/rochacbruno).

[‚òÖ 1797 - ormar](https://github.com/collerek/ormar) by [@collerek](https://github.com/collerek).

[‚òÖ 1792 - FastAPI-boilerplate](https://github.com/benavlabs/FastAPI-boilerplate) by [@benavlabs](https://github.com/benavlabs).

[‚òÖ 1727 - termpair](https://github.com/cs01/termpair) by [@cs01](https://github.com/cs01).

[‚òÖ 1677 - fastapi-crudrouter](https://github.com/awtkns/fastapi-crudrouter) by [@awtkns](https://github.com/awtkns).

[‚òÖ 1634 - langchain-serve](https://github.com/jina-ai/langchain-serve) by [@jina-ai](https://github.com/jina-ai).

[‚òÖ 1607 - fastapi-pagination](https://github.com/uriyyo/fastapi-pagination) by [@uriyyo](https://github.com/uriyyo).

[‚òÖ 1592 - awesome-fastapi-projects](https://github.com/Kludex/awesome-fastapi-projects) by [@Kludex](https://github.com/Kludex).

[‚òÖ 1580 - bracket](https://github.com/evroon/bracket) by [@evroon](https://github.com/evroon).

[‚òÖ 1570 - coronavirus-tracker-api](https://github.com/ExpDev07/coronavirus-tracker-api) by [@ExpDev07](https://github.com/ExpDev07).

[‚òÖ 1512 - fastapi-amis-admin](https://github.com/amisadmin/fastapi-amis-admin) by [@amisadmin](https://github.com/amisadmin).

[‚òÖ 1471 - fastcrud](https://github.com/benavlabs/fastcrud) by [@benavlabs](https://github.com/benavlabs).

[‚òÖ 1461 - fastapi-boilerplate](https://github.com/teamhide/fastapi-boilerplate) by [@teamhide](https://github.com/teamhide).

[‚òÖ 1435 - awesome-python-resources](https://github.com/DjangoEx/awesome-python-resources) by [@DjangoEx](https://github.com/DjangoEx).

[‚òÖ 1417 - prometheus-fastapi-instrumentator](https://github.com/trallnag/prometheus-fastapi-instrumentator) by [@trallnag](https://github.com/trallnag).

[‚òÖ 1382 - fastapi-code-generator](https://github.com/koxudaxi/fastapi-code-generator) by [@koxudaxi](https://github.com/koxudaxi).

[‚òÖ 1367 - fastapi-scaff](https://github.com/atpuxiner/fastapi-scaff) by [@atpuxiner](https://github.com/atpuxiner).

[‚òÖ 1360 - fastapi-tutorial](https://github.com/liaogx/fastapi-tutorial) by [@liaogx](https://github.com/liaogx).

[‚òÖ 1343 - budgetml](https://github.com/ebhy/budgetml) by [@ebhy](https://github.com/ebhy).

[‚òÖ 1276 - bolt-python](https://github.com/slackapi/bolt-python) by [@slackapi](https://github.com/slackapi).

[‚òÖ 1268 - bedrock-chat](https://github.com/aws-samples/bedrock-chat) by [@aws-samples](https://github.com/aws-samples).

[‚òÖ 1265 - fastapi-alembic-sqlmodel-async](https://github.com/vargasjona/fastapi-alembic-sqlmodel-async) by [@vargasjona](https://github.com/vargasjona).

[‚òÖ 1227 - fastapi_production_template](https://github.com/zhanymkanov/fastapi_production_template) by [@zhanymkanov](https://github.com/zhanymkanov).

[‚òÖ 1200 - restish](https://github.com/rest-sh/restish) by [@rest-sh](https://github.com/rest-sh).

[‚òÖ 1183 - langchain-extract](https://github.com/langchain-ai/langchain-extract) by [@langchain-ai](https://github.com/langchain-ai).

[‚òÖ 1162 - odmantic](https://github.com/art049/odmantic) by [@art049](https://github.com/art049).

[‚òÖ 1155 - aktools](https://github.com/akfamily/aktools) by [@akfamily](https://github.com/akfamily).

[‚òÖ 1155 - RuoYi-Vue3-FastAPI](https://github.com/insistence/RuoYi-Vue3-FastAPI) by [@insistence](https://github.com/insistence).

[‚òÖ 1142 - authx](https://github.com/yezz123/authx) by [@yezz123](https://github.com/yezz123).

[‚òÖ 1110 - SAG](https://github.com/Zleap-AI/SAG) by [@Zleap-AI](https://github.com/Zleap-AI).

[‚òÖ 1069 - flock](https://github.com/Onelevenvy/flock) by [@Onelevenvy](https://github.com/Onelevenvy).

[‚òÖ 1063 - fastapi-observability](https://github.com/blueswen/fastapi-observability) by [@blueswen](https://github.com/blueswen).

[‚òÖ 1061 - enterprise-deep-research](https://github.com/SalesforceAIResearch/enterprise-deep-research) by [@SalesforceAIResearch](https://github.com/SalesforceAIResearch).

[‚òÖ 1039 - titiler](https://github.com/developmentseed/titiler) by [@developmentseed](https://github.com/developmentseed).

[‚òÖ 1017 - every-pdf](https://github.com/DDULDDUCK/every-pdf) by [@DDULDDUCK](https://github.com/DDULDDUCK).

[‚òÖ 1005 - autollm](https://github.com/viddexa/autollm) by [@viddexa](https://github.com/viddexa).

[‚òÖ 995 - lanarky](https://github.com/ajndkr/lanarky) by [@ajndkr](https://github.com/ajndkr).

---

###### FastAPI and friends newsletter¶

# FastAPI and friends newsletter[¶](#fastapi-and-friends-newsletter "Permanent link")

---

###### Repository Management Tasks¶

# Repository Management Tasks[¶](#repository-management-tasks "Permanent link")

These are the tasks that can be performed to manage the FastAPI repository by [team members](../fastapi-people/#team).

Tip

This section is useful only to a handful of people, team members with permissions to manage the repository. You can probably skip it. üòâ

...so, you are a [team member of FastAPI](../fastapi-people/#team)? Wow, you are so cool! üòé

You can help with everything on [Help FastAPI - Get Help](../help-fastapi/) the same ways as external contributors. But additionally, there are some tasks that only you (as part of the team) can perform.

Here are the general instructions for the tasks you can perform.

Thanks a lot for your help. üôá

## Be Nice[¶](#be-nice "Permanent link")

First of all, be nice. üòä

You probably are super nice if you were added to the team, but it's worth mentioning it. ü§ì

### When Things are Difficult[¶](#when-things-are-difficult "Permanent link")

When things are great, everything is easier, so that doesn't need much instructions. But when things are difficult, here are some guidelines.

Try to find the good side. In general, if people are not being unfriendly, try to thank their effort and interest, even if you disagree with the main subject (discussion, PR), just thank them for being interested in the project, or for having dedicated some time to try to do something.

It's difficult to convey emotion in text, use emojis to help. üòÖ

In discussions and PRs, in many cases, people bring their frustration and show it without filter, in many cases exaggerating, complaining, being entitled, etc. That's really not nice, and when it happens, it lowers our priority to solve their problems. But still, try to breath, and be gentle with your answers.

Try to avoid using bitter sarcasm or potentially passive-aggressive comments. If something is wrong, it's better to be direct (try to be gentle) than sarcastic.

Try to be as specific and objective as possible, avoid generalizations.

For conversations that are more difficult, for example to reject a PR, you can ask me (@tiangolo) to handle it directly.

## Edit PR Titles[¶](#edit-pr-titles "Permanent link")

  * Edit the PR title to start with an emoji from [gitmoji](https://gitmoji.dev/).
    * Use the emoji character, not the GitHub code. So, use `üêõ` instead of `:bug:`. This is so that it shows up correctly outside of GitHub, for example in the release notes.
    * For translations use the `üåê` emoji ("globe with meridians").
  * Start the title with a verb. For example `Add`, `Refactor`, `Fix`, etc. This way the title will say the action that the PR does. Like `Add support for teleporting`, instead of `Teleporting wasn't working, so this PR fixes it`.
  * Edit the text of the PR title to start in "imperative", like giving an order. So, instead of `Adding support for teleporting` use `Add support for teleporting`.
  * Try to make the title descriptive about what it achieves. If it's a feature, try to describe it, for example `Add support for teleporting` instead of `Create TeleportAdapter class`.
  * Do not finish the title with a period (`.`).
  * When the PR is for a translation, start with the `üåê` and then `Add {language} translation for` and then the translated file path. For example:

    
    
    üåê Add Spanish translation for `docs/es/docs/teleporting.md`
    

Once the PR is merged, a GitHub Action ([latest-changes](https://github.com/tiangolo/latest-changes)) will use the PR title to update the latest changes automatically.

So, having a nice PR title will not only look nice in GitHub, but also in the release notes. üìù

## Add Labels to PRs[¶](#add-labels-to-prs "Permanent link")

The same GitHub Action [latest-changes](https://github.com/tiangolo/latest-changes) uses one label in the PR to decide the section in the release notes to put this PR in.

Make sure you use a supported label from the [latest-changes list of labels](https://github.com/tiangolo/latest-changes#using-labels):

  * `breaking`: Breaking Changes
    * Existing code will break if they update the version without changing their code. This rarely happens, so this label is not frequently used.
  * `security`: Security Fixes
    * This is for security fixes, like vulnerabilities. It would almost never be used.
  * `feature`: Features
    * New features, adding support for things that didn't exist before.
  * `bug`: Fixes
    * Something that was supported didn't work, and this fixes it. There are many PRs that claim to be bug fixes because the user is doing something in an unexpected way that is not supported, but they considered it what should be supported by default. Many of these are actually features or refactors. But in some cases there's an actual bug.
  * `refactor`: Refactors
    * This is normally for changes to the internal code that don't change the behavior. Normally it improves maintainability, or enables future features, etc.
  * `upgrade`: Upgrades
    * This is for upgrades to direct dependencies from the project, or extra optional dependencies, normally in `pyproject.toml`. So, things that would affect final users, they would end up receiving the upgrade in their code base once they update. But this is not for upgrades to internal dependencies used for development, testing, docs, etc. Those internal dependencies or GitHub Action versions should be marked as `internal`, not `upgrade`.
  * `docs`: Docs
    * Changes in docs. This includes updating the docs, fixing typos. But it doesn't include changes to translations.
    * You can normally quickly detect it by going to the "Files changed" tab in the PR and checking if the updated file(s) starts with `docs/en/docs`. The original version of the docs is always in English, so in `docs/en/docs`.
  * `lang-all`: Translations
    * Use this for translations. You can normally quickly detect it by going to the "Files changed" tab in the PR and checking if the updated file(s) starts with `docs/{some lang}/docs` but not `docs/en/docs`. For example, `docs/es/docs`.
  * `internal`: Internal
    * Use this for changes that only affect how the repo is managed. For example upgrades to internal dependencies, changes in GitHub Actions or scripts, etc.

Tip

Some tools like Dependabot, will add some labels, like `dependencies`, but have in mind that this label is not used by the `latest-changes` GitHub Action, so it won't be used in the release notes. Please make sure one of the labels above is added.

## Add Labels to Translation PRs[¶](#add-labels-to-translation-prs "Permanent link")

When there's a PR for a translation, apart from adding the `lang-all` label, also add a label for the language.

There will be a label for each language using the language code, like `lang-{lang code}`, for example, `lang-es` for Spanish, `lang-fr` for French, etc.

  * Add the specific language label.
  * Add the label `awaiting-review`.

The label `awaiting-review` is special, only used for translations. A GitHub Action will detect it, then it will read the language label, and it will update the GitHub Discussions managing the translations for that language to notify people that there's a new translation to review.

Once a native speaker comes, reviews the PR, and approves it, the GitHub Action will come and remove the `awaiting-review` label, and add the `approved-1` label.

This way, we can notice when there are new translations ready, because they have the `approved-1` label.

## Merge Translation PRs[¶](#merge-translation-prs "Permanent link")

Translations are generated automatically with LLMs and scripts.

There's one GitHub Action that can be manually run to add or update translations for a language: [`translate.yml`](https://github.com/fastapi/fastapi/actions/workflows/translate.yml).

For these language translation PRs, confirm that:

  * The PR was automated (authored by @tiangolo), not made by another user.
  * It has the labels `lang-all` and `lang-{lang code}`.
  * If the PR is approved by at least one native speaker, you can merge it.

## Review PRs[¶](#review-prs "Permanent link")

  * If a PR doesn't explain what it does or why, if it seems like it could be useful, ask for more information. Otherwise, feel free to close it.

  * If a PR seems to be spam, meaningless, only to change statistics (to appear as "contributor") or similar, you can simply mark it as `invalid`, and it will be automatically closed.

  * If a PR seems to be AI generated, and seems like reviewing it would take more time from you than the time it took to write the prompt, mark it as `maybe-ai`, and it will be automatically closed.

  * A PR should have a specific use case that it is solving.

  * If the PR is for a feature, it should have docs.

    * Unless it's a feature we want to discourage, like support for a corner case that we don't want users to use.
  * The docs should include a source example file, not write Python directly in Markdown.
  * If the source example(s) file can have different syntax for different Python versions, there should be different versions of the file, and they should be shown in tabs in the docs.
  * There should be tests testing the source example.
  * Before the PR is applied, the new tests should fail.
  * After applying the PR, the new tests should pass.
  * Coverage should stay at 100%.
  * If you see the PR makes sense, or we discussed it and considered it should be accepted, you can add commits on top of the PR to tweak it, to add docs, tests, format, refactor, remove extra files, etc.
  * Feel free to comment in the PR to ask for more information, to suggest changes, etc.
  * Once you think the PR is ready, move it in the internal GitHub project for me to review it.

## FastAPI People PRs[¶](#fastapi-people-prs "Permanent link")

Every month, a GitHub Action updates the FastAPI People data. Those PRs look like this one: [üë• Update FastAPI People](https://github.com/fastapi/fastapi/pull/11669).

If the tests are passing, you can merge it right away.

## Dependabot PRs[¶](#dependabot-prs "Permanent link")

Dependabot will create PRs to update dependencies for several things, and those PRs all look similar, but some are way more delicate than others.

  * If the PR is for a direct dependency, so, Dependabot is modifying `pyproject.toml` in the main dependencies, **don't merge it**. üò± Let me check it first. There's a good chance that some additional tweaks or updates are needed.
  * If the PR updates one of the internal dependencies, for example the group `dev` in `pyproject.toml`, or GitHub Action versions, if the tests are passing, the release notes (shown in a summary in the PR) don't show any obvious potential breaking change, you can merge it. üòé

## Mark GitHub Discussions Answers[¶](#mark-github-discussions-answers "Permanent link")

When a question in GitHub Discussions has been answered, mark the answer by clicking "Mark as answer".

You can filter discussions by [`Questions` that are `Unanswered`](https://github.com/tiangolo/fastapi/discussions/categories/questions?discussions_q=category:Questions+is:open+is:unanswered).

---

#### About¶

# About[¶](#about "Permanent link")

About FastAPI, its design, inspiration and more. ü§ì

---

###### Alternatives, Inspiration and Comparisons¶

# Alternatives, Inspiration and Comparisons[¶](#alternatives-inspiration-and-comparisons "Permanent link")

What inspired **FastAPI** , how it compares to alternatives and what it learned from them.

## Intro[¶](#intro "Permanent link")

**FastAPI** wouldn't exist if not for the previous work of others.

There have been many tools created before that have helped inspire its creation.

I have been avoiding the creation of a new framework for several years. First I tried to solve all the features covered by **FastAPI** using many different frameworks, plug-ins, and tools.

But at some point, there was no other option than creating something that provided all these features, taking the best ideas from previous tools, and combining them in the best way possible, using language features that weren't even available before (Python 3.6+ type hints).

## Previous tools[¶](#previous-tools "Permanent link")

### [Django](https://www.djangoproject.com/)[¶](#django "Permanent link")

It's the most popular Python framework and is widely trusted. It is used to build systems like Instagram.

It's relatively tightly coupled with relational databases (like MySQL or PostgreSQL), so, having a NoSQL database (like Couchbase, MongoDB, Cassandra, etc) as the main store engine is not very easy.

It was created to generate the HTML in the backend, not to create APIs used by a modern frontend (like React, Vue.js and Angular) or by other systems (like IoT devices) communicating with it.

### [Django REST Framework](https://www.django-rest-framework.org/)[¶](#django-rest-framework "Permanent link")

Django REST framework was created to be a flexible toolkit for building Web APIs using Django underneath, to improve its API capabilities.

It is used by many companies including Mozilla, Red Hat and Eventbrite.

It was one of the first examples of **automatic API documentation** , and this was specifically one of the first ideas that inspired "the search for" **FastAPI**.

Note

Django REST Framework was created by Tom Christie. The same creator of Starlette and Uvicorn, on which **FastAPI** is based.

Inspired **FastAPI** to

Have an automatic API documentation web user interface.

### [Flask](https://flask.palletsprojects.com)[¶](#flask "Permanent link")

Flask is a "microframework", it doesn't include database integrations nor many of the things that come by default in Django.

This simplicity and flexibility allow doing things like using NoSQL databases as the main data storage system.

As it is very simple, it's relatively intuitive to learn, although the documentation gets somewhat technical at some points.

It is also commonly used for other applications that don't necessarily need a database, user management, or any of the many features that come pre-built in Django. Although many of these features can be added with plug-ins.

This decoupling of parts, and being a "microframework" that could be extended to cover exactly what is needed was a key feature that I wanted to keep.

Given the simplicity of Flask, it seemed like a good match for building APIs. The next thing to find was a "Django REST Framework" for Flask.

Inspired **FastAPI** to

Be a micro-framework. Making it easy to mix and match the tools and parts needed.

Have a simple and easy to use routing system.

### [Requests](https://requests.readthedocs.io)[¶](#requests "Permanent link")

**FastAPI** is not actually an alternative to **Requests**. Their scope is very different.

It would actually be common to use Requests _inside_ of a FastAPI application.

But still, FastAPI got quite some inspiration from Requests.

**Requests** is a library to _interact_ with APIs (as a client), while **FastAPI** is a library to _build_ APIs (as a server).

They are, more or less, at opposite ends, complementing each other.

Requests has a very simple and intuitive design, it's very easy to use, with sensible defaults. But at the same time, it's very powerful and customizable.

That's why, as said in the official website:

> Requests is one of the most downloaded Python packages of all time

The way you use it is very simple. For example, to do a `GET` request, you would write:
    
    
    response = requests.get("http://example.com/some/url")
    

The FastAPI counterpart API _path operation_ could look like:
    
    
    @app.get("/some/url")
    def read_url():
        return {"message": "Hello World"}
    

See the similarities in `requests.get(...)` and `@app.get(...)`.

Inspired **FastAPI** to

  * Have a simple and intuitive API.
  * Use HTTP method names (operations) directly, in a straightforward and intuitive way.
  * Have sensible defaults, but powerful customizations.

### [Swagger](https://swagger.io/) / [OpenAPI](https://github.com/OAI/OpenAPI-Specification/)[¶](#swagger-openapi "Permanent link")

The main feature I wanted from Django REST Framework was the automatic API documentation.

Then I found that there was a standard to document APIs, using JSON (or YAML, an extension of JSON) called Swagger.

And there was a web user interface for Swagger APIs already created. So, being able to generate Swagger documentation for an API would allow using this web user interface automatically.

At some point, Swagger was given to the Linux Foundation, to be renamed OpenAPI.

That's why when talking about version 2.0 it's common to say "Swagger", and for version 3+ "OpenAPI".

Inspired **FastAPI** to

Adopt and use an open standard for API specifications, instead of a custom schema.

And integrate standards-based user interface tools:

  * [Swagger UI](https://github.com/swagger-api/swagger-ui)
  * [ReDoc](https://github.com/Rebilly/ReDoc)

These two were chosen for being fairly popular and stable, but doing a quick search, you could find dozens of alternative user interfaces for OpenAPI (that you can use with **FastAPI**).

### Flask REST frameworks[¶](#flask-rest-frameworks "Permanent link")

There are several Flask REST frameworks, but after investing the time and work into investigating them, I found that many are discontinued or abandoned, with several standing issues that made them unfit.

### [Marshmallow](https://marshmallow.readthedocs.io/en/stable/)[¶](#marshmallow "Permanent link")

One of the main features needed by API systems is data "serialization" which is taking data from the code (Python) and converting it into something that can be sent through the network. For example, converting an object containing data from a database into a JSON object. Converting `datetime` objects into strings, etc.

Another big feature needed by APIs is data validation, making sure that the data is valid, given certain parameters. For example, that some field is an `int`, and not some random string. This is especially useful for incoming data.

Without a data validation system, you would have to do all the checks by hand, in code.

These features are what Marshmallow was built to provide. It is a great library, and I have used it a lot before.

But it was created before there existed Python type hints. So, to define every schema you need to use specific utils and classes provided by Marshmallow.

Inspired **FastAPI** to

Use code to define "schemas" that provide data types and validation, automatically.

### [Webargs](https://webargs.readthedocs.io/en/latest/)[¶](#webargs "Permanent link")

Another big feature required by APIs is parsing data from incoming requests.

Webargs is a tool that was made to provide that on top of several frameworks, including Flask.

It uses Marshmallow underneath to do the data validation. And it was created by the same developers.

It's a great tool and I have used it a lot too, before having **FastAPI**.

Info

Webargs was created by the same Marshmallow developers.

Inspired **FastAPI** to

Have automatic validation of incoming request data.

### [APISpec](https://apispec.readthedocs.io/en/stable/)[¶](#apispec "Permanent link")

Marshmallow and Webargs provide validation, parsing and serialization as plug-ins.

But documentation is still missing. Then APISpec was created.

It is a plug-in for many frameworks (and there's a plug-in for Starlette too).

The way it works is that you write the definition of the schema using YAML format inside the docstring of each function handling a route.

And it generates OpenAPI schemas.

That's how it works in Flask, Starlette, Responder, etc.

But then, we have again the problem of having a micro-syntax, inside of a Python string (a big YAML).

The editor can't help much with that. And if we modify parameters or Marshmallow schemas and forget to also modify that YAML docstring, the generated schema would be obsolete.

Info

APISpec was created by the same Marshmallow developers.

Inspired **FastAPI** to

Support the open standard for APIs, OpenAPI.

### [Flask-apispec](https://flask-apispec.readthedocs.io/en/latest/)[¶](#flask-apispec "Permanent link")

It's a Flask plug-in, that ties together Webargs, Marshmallow and APISpec.

It uses the information from Webargs and Marshmallow to automatically generate OpenAPI schemas, using APISpec.

It's a great tool, very underrated. It should be way more popular than many Flask plug-ins out there. It might be due to its documentation being too concise and abstract.

This solved having to write YAML (another syntax) inside of Python docstrings.

This combination of Flask, Flask-apispec with Marshmallow and Webargs was my favorite backend stack until building **FastAPI**.

Using it led to the creation of several Flask full-stack generators. These are the main stacks I (and several external teams) have been using up to now:

  * <https://github.com/tiangolo/full-stack>
  * <https://github.com/tiangolo/full-stack-flask-couchbase>
  * <https://github.com/tiangolo/full-stack-flask-couchdb>

And these same full-stack generators were the base of the [**FastAPI** Project Generators](../project-generation/).

Info

Flask-apispec was created by the same Marshmallow developers.

Inspired **FastAPI** to

Generate the OpenAPI schema automatically, from the same code that defines serialization and validation.

### [NestJS](https://nestjs.com/) (and [Angular](https://angular.io/))[¶](#nestjs-and-angular "Permanent link")

This isn't even Python, NestJS is a JavaScript (TypeScript) NodeJS framework inspired by Angular.

It achieves something somewhat similar to what can be done with Flask-apispec.

It has an integrated dependency injection system, inspired by Angular 2. It requires pre-registering the "injectables" (like all the other dependency injection systems I know), so, it adds to the verbosity and code repetition.

As the parameters are described with TypeScript types (similar to Python type hints), editor support is quite good.

But as TypeScript data is not preserved after compilation to JavaScript, it cannot rely on the types to define validation, serialization and documentation at the same time. Due to this and some design decisions, to get validation, serialization and automatic schema generation, it's needed to add decorators in many places. So, it becomes quite verbose.

It can't handle nested models very well. So, if the JSON body in the request is a JSON object that has inner fields that in turn are nested JSON objects, it cannot be properly documented and validated.

Inspired **FastAPI** to

Use Python types to have great editor support.

Have a powerful dependency injection system. Find a way to minimize code repetition.

### [Sanic](https://sanic.readthedocs.io/en/latest/)[¶](#sanic "Permanent link")

It was one of the first extremely fast Python frameworks based on `asyncio`. It was made to be very similar to Flask.

Technical Details

It used [`uvloop`](https://github.com/MagicStack/uvloop) instead of the default Python `asyncio` loop. That's what made it so fast.

It clearly inspired Uvicorn and Starlette, that are currently faster than Sanic in open benchmarks.

Inspired **FastAPI** to

Find a way to have a crazy performance.

That's why **FastAPI** is based on Starlette, as it is the fastest framework available (tested by third-party benchmarks).

### [Falcon](https://falconframework.org/)[¶](#falcon "Permanent link")

Falcon is another high performance Python framework, it is designed to be minimal, and work as the foundation of other frameworks like Hug.

It is designed to have functions that receive two parameters, one "request" and one "response". Then you "read" parts from the request, and "write" parts to the response. Because of this design, it is not possible to declare request parameters and bodies with standard Python type hints as function parameters.

So, data validation, serialization, and documentation, have to be done in code, not automatically. Or they have to be implemented as a framework on top of Falcon, like Hug. This same distinction happens in other frameworks that are inspired by Falcon's design, of having one request object and one response object as parameters.

Inspired **FastAPI** to

Find ways to get great performance.

Along with Hug (as Hug is based on Falcon) inspired **FastAPI** to declare a `response` parameter in functions.

Although in FastAPI it's optional, and is used mainly to set headers, cookies, and alternative status codes.

### [Molten](https://moltenframework.com/)[¶](#molten "Permanent link")

I discovered Molten in the first stages of building **FastAPI**. And it has quite similar ideas:

  * Based on Python type hints.
  * Validation and documentation from these types.
  * Dependency Injection system.

It doesn't use a data validation, serialization and documentation third-party library like Pydantic, it has its own. So, these data type definitions would not be reusable as easily.

It requires a little bit more verbose configurations. And as it is based on WSGI (instead of ASGI), it is not designed to take advantage of the high performance provided by tools like Uvicorn, Starlette and Sanic.

The dependency injection system requires pre-registration of the dependencies and the dependencies are solved based on the declared types. So, it's not possible to declare more than one "component" that provides a certain type.

Routes are declared in a single place, using functions declared in other places (instead of using decorators that can be placed right on top of the function that handles the endpoint). This is closer to how Django does it than to how Flask (and Starlette) does it. It separates in the code things that are relatively tightly coupled.

Inspired **FastAPI** to

Define extra validations for data types using the "default" value of model attributes. This improves editor support, and it was not available in Pydantic before.

This actually inspired updating parts of Pydantic, to support the same validation declaration style (all this functionality is now already available in Pydantic).

### [Hug](https://github.com/hugapi/hug)[¶](#hug "Permanent link")

Hug was one of the first frameworks to implement the declaration of API parameter types using Python type hints. This was a great idea that inspired other tools to do the same.

It used custom types in its declarations instead of standard Python types, but it was still a huge step forward.

It also was one of the first frameworks to generate a custom schema declaring the whole API in JSON.

It was not based on a standard like OpenAPI and JSON Schema. So it wouldn't be straightforward to integrate it with other tools, like Swagger UI. But again, it was a very innovative idea.

It has an interesting, uncommon feature: using the same framework, it's possible to create APIs and also CLIs.

As it is based on the previous standard for synchronous Python web frameworks (WSGI), it can't handle Websockets and other things, although it still has high performance too.

Info

Hug was created by Timothy Crosley, the same creator of [`isort`](https://github.com/timothycrosley/isort), a great tool to automatically sort imports in Python files.

Ideas inspiring **FastAPI**

Hug inspired parts of APIStar, and was one of the tools I found most promising, alongside APIStar.

Hug helped inspiring **FastAPI** to use Python type hints to declare parameters, and to generate a schema defining the API automatically.

Hug inspired **FastAPI** to declare a `response` parameter in functions to set headers and cookies.

### [APIStar](https://github.com/encode/apistar) (<= 0.5)[¶](#apistar-0-5 "Permanent link")

Right before deciding to build **FastAPI** I found **APIStar** server. It had almost everything I was looking for and had a great design.

It was one of the first implementations of a framework using Python type hints to declare parameters and requests that I ever saw (before NestJS and Molten). I found it more or less at the same time as Hug. But APIStar used the OpenAPI standard.

It had automatic data validation, data serialization and OpenAPI schema generation based on the same type hints in several places.

Body schema definitions didn't use the same Python type hints like Pydantic, it was a bit more similar to Marshmallow, so, editor support wouldn't be as good, but still, APIStar was the best available option.

It had the best performance benchmarks at the time (only surpassed by Starlette).

At first, it didn't have an automatic API documentation web UI, but I knew I could add Swagger UI to it.

It had a dependency injection system. It required pre-registration of components, as other tools discussed above. But still, it was a great feature.

I was never able to use it in a full project, as it didn't have security integration, so, I couldn't replace all the features I was having with the full-stack generators based on Flask-apispec. I had in my backlog of projects to create a pull request adding that functionality.

But then, the project's focus shifted.

It was no longer an API web framework, as the creator needed to focus on Starlette.

Now APIStar is a set of tools to validate OpenAPI specifications, not a web framework.

Info

APIStar was created by Tom Christie. The same guy that created:

  * Django REST Framework
  * Starlette (in which **FastAPI** is based)
  * Uvicorn (used by Starlette and **FastAPI**)

Inspired **FastAPI** to

Exist.

The idea of declaring multiple things (data validation, serialization and documentation) with the same Python types, that at the same time provided great editor support, was something I considered a brilliant idea.

And after searching for a long time for a similar framework and testing many different alternatives, APIStar was the best option available.

Then APIStar stopped to exist as a server and Starlette was created, and was a new better foundation for such a system. That was the final inspiration to build **FastAPI**.

I consider **FastAPI** a "spiritual successor" to APIStar, while improving and increasing the features, typing system, and other parts, based on the learnings from all these previous tools.

## Used by **FastAPI**[¶](#used-by-fastapi "Permanent link")

### [Pydantic](https://docs.pydantic.dev/)[¶](#pydantic "Permanent link")

Pydantic is a library to define data validation, serialization and documentation (using JSON Schema) based on Python type hints.

That makes it extremely intuitive.

It is comparable to Marshmallow. Although it's faster than Marshmallow in benchmarks. And as it is based on the same Python type hints, the editor support is great.

**FastAPI** uses it to

Handle all the data validation, data serialization and automatic model documentation (based on JSON Schema).

**FastAPI** then takes that JSON Schema data and puts it in OpenAPI, apart from all the other things it does.

### [Starlette](https://www.starlette.dev/)[¶](#starlette "Permanent link")

Starlette is a lightweight ASGI framework/toolkit, which is ideal for building high-performance asyncio services.

It is very simple and intuitive. It's designed to be easily extensible, and have modular components.

It has:

  * Seriously impressive performance.
  * WebSocket support.
  * In-process background tasks.
  * Startup and shutdown events.
  * Test client built on HTTPX.
  * CORS, GZip, Static Files, Streaming responses.
  * Session and Cookie support.
  * 100% test coverage.
  * 100% type annotated codebase.
  * Few hard dependencies.

Starlette is currently the fastest Python framework tested. Only surpassed by Uvicorn, which is not a framework, but a server.

Starlette provides all the basic web microframework functionality.

But it doesn't provide automatic data validation, serialization or documentation.

That's one of the main things that **FastAPI** adds on top, all based on Python type hints (using Pydantic). That, plus the dependency injection system, security utilities, OpenAPI schema generation, etc.

Technical Details

ASGI is a new "standard" being developed by Django core team members. It is still not a "Python standard" (a PEP), although they are in the process of doing that.

Nevertheless, it is already being used as a "standard" by several tools. This greatly improves interoperability, as you could switch Uvicorn for any other ASGI server (like Daphne or Hypercorn), or you could add ASGI compatible tools, like `python-socketio`.

**FastAPI** uses it to

Handle all the core web parts. Adding features on top.

The class `FastAPI` itself inherits directly from the class `Starlette`.

So, anything that you can do with Starlette, you can do it directly with **FastAPI** , as it is basically Starlette on steroids.

### [Uvicorn](https://www.uvicorn.dev/)[¶](#uvicorn "Permanent link")

Uvicorn is a lightning-fast ASGI server, built on uvloop and httptools.

It is not a web framework, but a server. For example, it doesn't provide tools for routing by paths. That's something that a framework like Starlette (or **FastAPI**) would provide on top.

It is the recommended server for Starlette and **FastAPI**.

**FastAPI** recommends it as

The main web server to run **FastAPI** applications.

You can also use the `--workers` command line option to have an asynchronous multi-process server.

Check more details in the [Deployment](../deployment/) section.

## Benchmarks and speed[¶](#benchmarks-and-speed "Permanent link")

To understand, compare, and see the difference between Uvicorn, Starlette and FastAPI, check the section about [Benchmarks](../benchmarks/).
  *[IoT]: Internet of Things
  *[serialization]: also called marshalling, conversion
  *[schema]: the definition of how data should be formed
  *[parsing]: reading and converting to Python data
  *[ASGI]: The new standard for building asynchronous Python web applications

---

###### History, Design and Future¶

# History, Design and Future[¶](#history-design-and-future "Permanent link")

Some time ago, [a **FastAPI** user asked](https://github.com/fastapi/fastapi/issues/3#issuecomment-454956920):

> What‚Äôs the history of this project? It seems to have come from nowhere to awesome in a few weeks [...]

Here's a little bit of that history.

## Alternatives[¶](#alternatives "Permanent link")

I have been creating APIs with complex requirements for several years (Machine Learning, distributed systems, asynchronous jobs, NoSQL databases, etc), leading several teams of developers.

As part of that, I needed to investigate, test and use many alternatives.

The history of **FastAPI** is in great part the history of its predecessors.

As said in the section [Alternatives](../alternatives/):

> **FastAPI** wouldn't exist if not for the previous work of others.
> 
> There have been many tools created before that have helped inspire its creation.
> 
> I have been avoiding the creation of a new framework for several years. First I tried to solve all the features covered by **FastAPI** using many different frameworks, plug-ins, and tools.
> 
> But at some point, there was no other option than creating something that provided all these features, taking the best ideas from previous tools, and combining them in the best way possible, using language features that weren't even available before (Python 3.6+ type hints).

## Investigation[¶](#investigation "Permanent link")

By using all the previous alternatives I had the chance to learn from all of them, take ideas, and combine them in the best way I could find for myself and the teams of developers I have worked with.

For example, it was clear that ideally it should be based on standard Python type hints.

Also, the best approach was to use already existing standards.

So, before even starting to code **FastAPI** , I spent several months studying the specs for OpenAPI, JSON Schema, OAuth2, etc. Understanding their relationship, overlap, and differences.

## Design[¶](#design "Permanent link")

Then I spent some time designing the developer "API" I wanted to have as a user (as a developer using FastAPI).

I tested several ideas in the most popular Python editors: PyCharm, VS Code, Jedi based editors.

By the last [Python Developer Survey](https://www.jetbrains.com/research/python-developers-survey-2018/#development-tools), that covers about 80% of the users.

It means that **FastAPI** was specifically tested with the editors used by 80% of the Python developers. And as most of the other editors tend to work similarly, all its benefits should work for virtually all editors.

That way I could find the best ways to reduce code duplication as much as possible, to have completion everywhere, type and error checks, etc.

All in a way that provided the best development experience for all the developers.

## Requirements[¶](#requirements "Permanent link")

After testing several alternatives, I decided that I was going to use [**Pydantic**](https://docs.pydantic.dev/) for its advantages.

Then I contributed to it, to make it fully compliant with JSON Schema, to support different ways to define constraint declarations, and to improve editor support (type checks, autocompletion) based on the tests in several editors.

During the development, I also contributed to [**Starlette**](https://www.starlette.dev/), the other key requirement.

## Development[¶](#development "Permanent link")

By the time I started creating **FastAPI** itself, most of the pieces were already in place, the design was defined, the requirements and tools were ready, and the knowledge about the standards and specifications was clear and fresh.

## Future[¶](#future "Permanent link")

By this point, it's already clear that **FastAPI** with its ideas is being useful for many people.

It is being chosen over previous alternatives for suiting many use cases better.

Many developers and teams already depend on **FastAPI** for their projects (including me and my team).

But still, there are many improvements and features to come.

**FastAPI** has a great future ahead.

And [your help](../help-fastapi/) is greatly appreciated.

---

###### Benchmarks¶

# Benchmarks[¶](#benchmarks "Permanent link")

Independent TechEmpower benchmarks show **FastAPI** applications running under Uvicorn as [one of the fastest Python frameworks available](https://www.techempower.com/benchmarks/#section=test&runid=7464e520-0dc2-473d-bd34-dbdfd7e85911&hw=ph&test=query&l=zijzen-7), only below Starlette and Uvicorn themselves (used internally by FastAPI).

But when checking benchmarks and comparisons you should keep the following in mind.

## Benchmarks and speed[¶](#benchmarks-and-speed "Permanent link")

When you check the benchmarks, it is common to see several tools of different types compared as equivalent.

Specifically, to see Uvicorn, Starlette and FastAPI compared together (among many other tools).

The simpler the problem solved by the tool, the better performance it will get. And most of the benchmarks don't test the additional features provided by the tool.

The hierarchy is like:

  * **Uvicorn** : an ASGI server

    * **Starlette** : (uses Uvicorn) a web microframework
      * **FastAPI** : (uses Starlette) an API microframework with several additional features for building APIs, with data validation, etc.
  * **Uvicorn** :

    * Will have the best performance, as it doesn't have much extra code apart from the server itself.
    * You wouldn't write an application in Uvicorn directly. That would mean that your code would have to include more or less, at least, all the code provided by Starlette (or **FastAPI**). And if you did that, your final application would have the same overhead as having used a framework and minimizing your app code and bugs.
    * If you are comparing Uvicorn, compare it against Daphne, Hypercorn, uWSGI, etc. Application servers.
  * **Starlette** :
    * Will have the next best performance, after Uvicorn. In fact, Starlette uses Uvicorn to run. So, it probably can only get "slower" than Uvicorn by having to execute more code.
    * But it provides you the tools to build simple web applications, with routing based on paths, etc.
    * If you are comparing Starlette, compare it against Sanic, Flask, Django, etc. Web frameworks (or microframeworks).
  * **FastAPI** :
    * The same way that Starlette uses Uvicorn and cannot be faster than it, **FastAPI** uses Starlette, so it cannot be faster than it.
    * FastAPI provides more features on top of Starlette. Features that you almost always need when building APIs, like data validation and serialization. And by using it, you get automatic documentation for free (the automatic documentation doesn't even add overhead to running applications, it is generated on startup).
    * If you didn't use FastAPI and used Starlette directly (or another tool, like Sanic, Flask, Responder, etc) you would have to implement all the data validation and serialization yourself. So, your final application would still have the same overhead as if it was built using FastAPI. And in many cases, this data validation and serialization is the biggest amount of code written in applications.
    * So, by using FastAPI you are saving development time, bugs, lines of code, and you would probably get the same performance (or better) you would if you didn't use it (as you would have to implement it all in your code).
    * If you are comparing FastAPI, compare it against a web application framework (or set of tools) that provides data validation, serialization and documentation, like Flask-apispec, NestJS, Molten, etc. Frameworks with integrated automatic data validation, serialization and documentation.

---

###### Repository Management¶

# Repository Management[¶](#repository-management "Permanent link")

Here's a short description of how the FastAPI repository is managed and maintained.

## Owner[¶](#owner "Permanent link")

I, [@tiangolo](https://github.com/tiangolo), am the creator and owner of the FastAPI repository. ü§ì

I normally give the final review to each PR before merging them. I make the final decisions on the project, I'm the [BDFL](https://en.wikipedia.org/wiki/Benevolent_dictator_for_life). üòÖ

## Team[¶](#team "Permanent link")

There's a team of people that help manage and maintain the project. üòé

They have different levels of permissions and [specific instructions](../management-tasks/).

Some of the tasks they can perform include:

  * Adding labels to PRs.
  * Editing PR titles.
  * Adding commits on top of PRs to tweak them.
  * Mark answers in GitHub Discussions questions, etc.
  * Merge some specific types of PRs.

You can see the current team members in [FastAPI People - Team](../fastapi-people/#team).

Joining the team is by invitation only, and I could update or remove permissions, instructions, or membership.

## FastAPI Experts[¶](#fastapi-experts "Permanent link")

The people that help others the most in GitHub Discussions can become [**FastAPI Experts**](../fastapi-people/#fastapi-experts).

This is normally the best way to contribute to the project.

## External Contributions[¶](#external-contributions "Permanent link")

External contributions are very welcome and appreciated, including answering questions, submitting PRs, etc. üôá‚Äç‚ôÇÔ∏è

There are many ways to [help maintain FastAPI](../help-fastapi/#help-maintain-fastapi).
  *[BDFL]: Benevolent Dictator For Life

---

### Release Notes¶

# Release Notes[¶](#release-notes "Permanent link")

## Latest Changes[¶](#latest-changes "Permanent link")

## 0.128.2[¶](#01282 "Permanent link")

### Features[¶](#features "Permanent link")

  * âœ¨ Add support for PEP695 `TypeAliasType`. PR [#13920](https://github.com/fastapi/fastapi/pull/13920) by [@cstruct](https://github.com/cstruct).
  * âœ¨ Allow `Response` type hint as dependency annotation. PR [#14794](https://github.com/fastapi/fastapi/pull/14794) by [@jonathan-fulton](https://github.com/jonathan-fulton).

### Fixes[¶](#fixes "Permanent link")

  * ğŸ�› Fix using `Json[list[str]]` type (issue #10997). PR [#14616](https://github.com/fastapi/fastapi/pull/14616) by [@mkanetsuna](https://github.com/mkanetsuna).

### Docs[¶](#docs "Permanent link")

  * ğŸ“� Update docs for translations. PR [#14830](https://github.com/fastapi/fastapi/pull/14830) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ“� Fix duplicate word in `advanced-dependencies.md`. PR [#14815](https://github.com/fastapi/fastapi/pull/14815) by [@Rayyan-Oumlil](https://github.com/Rayyan-Oumlil).

### Translations[¶](#translations "Permanent link")

  * ğŸŒ� Enable Traditional Chinese translations. PR [#14842](https://github.com/fastapi/fastapi/pull/14842) by [@tiangolo](https://github.com/tiangolo).
  * ğŸŒ� Enable French docs translations. PR [#14841](https://github.com/fastapi/fastapi/pull/14841) by [@tiangolo](https://github.com/tiangolo).
  * ğŸŒ� Update translations for fr (translate-page). PR [#14837](https://github.com/fastapi/fastapi/pull/14837) by [@tiangolo](https://github.com/tiangolo).
  * ğŸŒ� Update translations for de (update-outdated). PR [#14836](https://github.com/fastapi/fastapi/pull/14836) by [@tiangolo](https://github.com/tiangolo).
  * ğŸŒ� Update translations for pt (update-outdated). PR [#14833](https://github.com/fastapi/fastapi/pull/14833) by [@tiangolo](https://github.com/tiangolo).
  * ğŸŒ� Update translations for ko (update-outdated). PR [#14835](https://github.com/fastapi/fastapi/pull/14835) by [@tiangolo](https://github.com/tiangolo).
  * ğŸŒ� Update translations for es (update-outdated). PR [#14832](https://github.com/fastapi/fastapi/pull/14832) by [@tiangolo](https://github.com/tiangolo).
  * ğŸŒ� Update translations for tr (update-outdated). PR [#14831](https://github.com/fastapi/fastapi/pull/14831) by [@tiangolo](https://github.com/tiangolo).
  * ğŸŒ� Update translations for tr (add-missing). PR [#14790](https://github.com/fastapi/fastapi/pull/14790) by [@tiangolo](https://github.com/tiangolo).
  * ğŸŒ� Update translations for fr (update-outdated). PR [#14826](https://github.com/fastapi/fastapi/pull/14826) by [@tiangolo](https://github.com/tiangolo).
  * ğŸŒ� Update translations for zh-hant (update-outdated). PR [#14825](https://github.com/fastapi/fastapi/pull/14825) by [@tiangolo](https://github.com/tiangolo).
  * ğŸŒ� Update translations for uk (update-outdated). PR [#14822](https://github.com/fastapi/fastapi/pull/14822) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”¨ Update docs and translations scripts, enable Turkish. PR [#14824](https://github.com/fastapi/fastapi/pull/14824) by [@tiangolo](https://github.com/tiangolo).

### Internal[¶](#internal "Permanent link")

  * ğŸ”¨ Add max pages to translate to configs. PR [#14840](https://github.com/fastapi/fastapi/pull/14840) by [@tiangolo](https://github.com/tiangolo).

## 0.128.1[¶](#01281 "Permanent link")

### Features[¶](#features_1 "Permanent link")

  * âœ¨ Add `viewport` meta tag to improve Swagger UI on mobile devices. PR [#14777](https://github.com/fastapi/fastapi/pull/14777) by [@Joab0](https://github.com/Joab0).
  * ğŸš¸ Improve error message for invalid query parameter type annotations. PR [#14479](https://github.com/fastapi/fastapi/pull/14479) by [@retwish](https://github.com/retwish).

### Fixes[¶](#fixes_1 "Permanent link")

  * ğŸ�› Update `ValidationError` schema to include `input` and `ctx`. PR [#14791](https://github.com/fastapi/fastapi/pull/14791) by [@jonathan-fulton](https://github.com/jonathan-fulton).
  * ğŸ�› Fix TYPE_CHECKING annotations for Python 3.14 (PEP 649). PR [#14789](https://github.com/fastapi/fastapi/pull/14789) by [@mgu](https://github.com/mgu).
  * ğŸ�› Strip whitespaces from `Authorization` header credentials. PR [#14786](https://github.com/fastapi/fastapi/pull/14786) by [@WaveTheory1](https://github.com/WaveTheory1).
  * ğŸ�› Fix OpenAPI duplication of `anyOf` refs for app-level responses with specified `content` and `model` as `Union`. PR [#14463](https://github.com/fastapi/fastapi/pull/14463) by [@DJMcoder](https://github.com/DJMcoder).

### Refactors[¶](#refactors "Permanent link")

  * ğŸ�¨ Tweak types for mypy. PR [#14816](https://github.com/fastapi/fastapi/pull/14816) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ�·ï¸� Re-export `IncEx` type from Pydantic instead of duplicating it. PR [#14641](https://github.com/fastapi/fastapi/pull/14641) by [@mvanderlee](https://github.com/mvanderlee).
  * ğŸ’¡ Update comment for Pydantic internals. PR [#14814](https://github.com/fastapi/fastapi/pull/14814) by [@tiangolo](https://github.com/tiangolo).

### Docs[¶](#docs_1 "Permanent link")

  * ğŸ“� Update docs for contributing translations, simplify title. PR [#14817](https://github.com/fastapi/fastapi/pull/14817) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ“� Fix typing issue in `docs_src/app_testing/app_b` code example. PR [#14573](https://github.com/fastapi/fastapi/pull/14573) by [@timakaa](https://github.com/timakaa).
  * ğŸ“� Fix example of license identifier in documentation. PR [#14492](https://github.com/fastapi/fastapi/pull/14492) by [@johnson-earls](https://github.com/johnson-earls).
  * ğŸ“� Add banner to translated pages. PR [#14809](https://github.com/fastapi/fastapi/pull/14809) by [@YuriiMotov](https://github.com/YuriiMotov).
  * ğŸ“� Add links to related sections of docs to docstrings. PR [#14776](https://github.com/fastapi/fastapi/pull/14776) by [@YuriiMotov](https://github.com/YuriiMotov).
  * ğŸ“� Update embedded code examples to Python 3.10 syntax. PR [#14758](https://github.com/fastapi/fastapi/pull/14758) by [@YuriiMotov](https://github.com/YuriiMotov).
  * ğŸ“� Fix dependency installation command in `docs/en/docs/contributing.md`. PR [#14757](https://github.com/fastapi/fastapi/pull/14757) by [@YuriiMotov](https://github.com/YuriiMotov).
  * ğŸ“� Use return type annotation instead of `response_model` when possible. PR [#14753](https://github.com/fastapi/fastapi/pull/14753) by [@YuriiMotov](https://github.com/YuriiMotov).
  * ğŸ“� Use `WSGIMiddleware` from `a2wsgi` instead of deprecated `fastapi.middleware.wsgi.WSGIMiddleware`. PR [#14756](https://github.com/fastapi/fastapi/pull/14756) by [@YuriiMotov](https://github.com/YuriiMotov).
  * ğŸ“� Fix minor typos in release notes. PR [#14780](https://github.com/fastapi/fastapi/pull/14780) by [@whyvineet](https://github.com/whyvineet).
  * ğŸ�› Fix copy button in custom.js. PR [#14722](https://github.com/fastapi/fastapi/pull/14722) by [@fcharrier](https://github.com/fcharrier).
  * ğŸ“� Add contribution instructions about LLM generated code and comments and automated tools for PRs. PR [#14706](https://github.com/fastapi/fastapi/pull/14706) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ“� Update docs for management tasks. PR [#14705](https://github.com/fastapi/fastapi/pull/14705) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ“� Update docs about managing translations. PR [#14704](https://github.com/fastapi/fastapi/pull/14704) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ“� Update docs for contributing with translations. PR [#14701](https://github.com/fastapi/fastapi/pull/14701) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ“� Specify language code for code block. PR [#14656](https://github.com/fastapi/fastapi/pull/14656) by [@YuriiMotov](https://github.com/YuriiMotov).

### Translations[¶](#translations_1 "Permanent link")

  * ğŸŒ� Improve LLM prompt of `uk` documentation. PR [#14795](https://github.com/fastapi/fastapi/pull/14795) by [@roli2py](https://github.com/roli2py).
  * ğŸŒ� Update translations for ja (update-outdated). PR [#14588](https://github.com/fastapi/fastapi/pull/14588) by [@tiangolo](https://github.com/tiangolo).
  * ğŸŒ� Update translations for uk (update outdated, found by fixer tool). PR [#14739](https://github.com/fastapi/fastapi/pull/14739) by [@YuriiMotov](https://github.com/YuriiMotov).
  * ğŸŒ� Update translations for tr (update-outdated). PR [#14745](https://github.com/fastapi/fastapi/pull/14745) by [@tiangolo](https://github.com/tiangolo).
  * ğŸŒ� Update `llm-prompt.md` for Korean language. PR [#14763](https://github.com/fastapi/fastapi/pull/14763) by [@seuthootDev](https://github.com/seuthootDev).
  * ğŸŒ� Update translations for ko (update outdated, found by fixer tool). PR [#14738](https://github.com/fastapi/fastapi/pull/14738) by [@YuriiMotov](https://github.com/YuriiMotov).
  * ğŸŒ� Update translations for de (update-outdated). PR [#14690](https://github.com/fastapi/fastapi/pull/14690) by [@tiangolo](https://github.com/tiangolo).
  * ğŸŒ� Update LLM prompt for Russian translations. PR [#14733](https://github.com/fastapi/fastapi/pull/14733) by [@YuriiMotov](https://github.com/YuriiMotov).
  * ğŸŒ� Update translations for ru (update-outdated). PR [#14693](https://github.com/fastapi/fastapi/pull/14693) by [@tiangolo](https://github.com/tiangolo).
  * ğŸŒ� Update translations for pt (update-outdated). PR [#14724](https://github.com/fastapi/fastapi/pull/14724) by [@tiangolo](https://github.com/tiangolo).
  * ğŸŒ� Update Korean LLM prompt. PR [#14740](https://github.com/fastapi/fastapi/pull/14740) by [@hard-coders](https://github.com/hard-coders).
  * ğŸŒ� Improve LLM prompt for Turkish translations. PR [#14728](https://github.com/fastapi/fastapi/pull/14728) by [@Kadermiyanyedi](https://github.com/Kadermiyanyedi).
  * ğŸŒ� Update portuguese llm-prompt.md. PR [#14702](https://github.com/fastapi/fastapi/pull/14702) by [@ceb10n](https://github.com/ceb10n).
  * ğŸŒ� Update LLM prompt instructions file for French. PR [#14618](https://github.com/fastapi/fastapi/pull/14618) by [@tiangolo](https://github.com/tiangolo).
  * ğŸŒ� Update translations for ko (add-missing). PR [#14699](https://github.com/fastapi/fastapi/pull/14699) by [@tiangolo](https://github.com/tiangolo).
  * ğŸŒ� Update translations for ko (update-outdated). PR [#14589](https://github.com/fastapi/fastapi/pull/14589) by [@tiangolo](https://github.com/tiangolo).
  * ğŸŒ� Update translations for uk (update-outdated). PR [#14587](https://github.com/fastapi/fastapi/pull/14587) by [@tiangolo](https://github.com/tiangolo).
  * ğŸŒ� Update translations for es (update-outdated). PR [#14686](https://github.com/fastapi/fastapi/pull/14686) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”§ Add LLM prompt file for Turkish, generated from the existing translations. PR [#14547](https://github.com/fastapi/fastapi/pull/14547) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”§ Add LLM prompt file for Traditional Chinese, generated from the existing translations. PR [#14550](https://github.com/fastapi/fastapi/pull/14550) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”§ Add LLM prompt file for Simplified Chinese, generated from the existing translations. PR [#14549](https://github.com/fastapi/fastapi/pull/14549) by [@tiangolo](https://github.com/tiangolo).

### Internal[¶](#internal_1 "Permanent link")

  * â¬‡ï¸� Downgrade LLM translations model to GPT-5 to reduce mistakes. PR [#14823](https://github.com/fastapi/fastapi/pull/14823) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ�› Fix translation script commit in place. PR [#14818](https://github.com/fastapi/fastapi/pull/14818) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”¨ Update translation script to retry if LLM-response doesn't pass validation with Translation Fixer tool. PR [#14749](https://github.com/fastapi/fastapi/pull/14749) by [@YuriiMotov](https://github.com/YuriiMotov).
  * ğŸ‘· Run tests only on relevant code changes (not on docs). PR [#14813](https://github.com/fastapi/fastapi/pull/14813) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘· Run mypy by pre-commit. PR [#14806](https://github.com/fastapi/fastapi/pull/14806) by [@YuriiMotov](https://github.com/YuriiMotov).
  * â¬† Bump ruff from 0.14.3 to 0.14.14. PR [#14798](https://github.com/fastapi/fastapi/pull/14798) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * â¬† Bump pyasn1 from 0.6.1 to 0.6.2. PR [#14804](https://github.com/fastapi/fastapi/pull/14804) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * â¬† Bump sqlmodel from 0.0.27 to 0.0.31. PR [#14802](https://github.com/fastapi/fastapi/pull/14802) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * â¬† Bump mkdocs-macros-plugin from 1.4.1 to 1.5.0. PR [#14801](https://github.com/fastapi/fastapi/pull/14801) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * â¬† Bump gitpython from 3.1.45 to 3.1.46. PR [#14800](https://github.com/fastapi/fastapi/pull/14800) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * â¬† Bump typer from 0.16.0 to 0.21.1. PR [#14799](https://github.com/fastapi/fastapi/pull/14799) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * ğŸ‘¥ Update FastAPI GitHub topic repositories. PR [#14803](https://github.com/fastapi/fastapi/pull/14803) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘¥ Update FastAPI People - Contributors and Translators. PR [#14796](https://github.com/fastapi/fastapi/pull/14796) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”§ Ensure that an edit to `uv.lock` gets the `internal` label. PR [#14759](https://github.com/fastapi/fastapi/pull/14759) by [@svlandeg](https://github.com/svlandeg).
  * ğŸ”§ Update sponsors: remove Requestly. PR [#14735](https://github.com/fastapi/fastapi/pull/14735) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”§ Update sponsors, LambdaTest changes to TestMu AI. PR [#14734](https://github.com/fastapi/fastapi/pull/14734) by [@tiangolo](https://github.com/tiangolo).
  * â¬† Bump actions/cache from 4 to 5. PR [#14511](https://github.com/fastapi/fastapi/pull/14511) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * â¬† Bump actions/upload-artifact from 5 to 6. PR [#14525](https://github.com/fastapi/fastapi/pull/14525) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * â¬† Bump actions/download-artifact from 6 to 7. PR [#14526](https://github.com/fastapi/fastapi/pull/14526) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * ğŸ‘· Tweak CI input names. PR [#14688](https://github.com/fastapi/fastapi/pull/14688) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”¨ Refactor translation script to allow committing in place. PR [#14687](https://github.com/fastapi/fastapi/pull/14687) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ�› Fix translation script path. PR [#14685](https://github.com/fastapi/fastapi/pull/14685) by [@tiangolo](https://github.com/tiangolo).
  * âœ… Enable tests in CI for scripts. PR [#14684](https://github.com/fastapi/fastapi/pull/14684) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”§ Add pre-commit local script to fix language translations. PR [#14683](https://github.com/fastapi/fastapi/pull/14683) by [@tiangolo](https://github.com/tiangolo).
  * â¬†ï¸� Migrate to uv. PR [#14676](https://github.com/fastapi/fastapi/pull/14676) by [@DoctorJohn](https://github.com/DoctorJohn).
  * ğŸ”¨ Add LLM translations tool fixer. PR [#14652](https://github.com/fastapi/fastapi/pull/14652) by [@YuriiMotov](https://github.com/YuriiMotov).
  * ğŸ‘¥ Update FastAPI People - Sponsors. PR [#14626](https://github.com/fastapi/fastapi/pull/14626) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘¥ Update FastAPI GitHub topic repositories. PR [#14630](https://github.com/fastapi/fastapi/pull/14630) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘¥ Update FastAPI People - Contributors and Translators. PR [#14625](https://github.com/fastapi/fastapi/pull/14625) by [@tiangolo](https://github.com/tiangolo).
  * ğŸŒ� Update translation prompts. PR [#14619](https://github.com/fastapi/fastapi/pull/14619) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”¨ Update LLM translation script to guide reviewers to change the prompt. PR [#14614](https://github.com/fastapi/fastapi/pull/14614) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘· Do not run translations on cron while finishing updating existing languages. PR [#14613](https://github.com/fastapi/fastapi/pull/14613) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”¥ Remove test variants for Pydantic v1 in test_request_params. PR [#14612](https://github.com/fastapi/fastapi/pull/14612) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”¥ Remove Pydantic v1 specific test variants. PR [#14611](https://github.com/fastapi/fastapi/pull/14611) by [@tiangolo](https://github.com/tiangolo).

## 0.128.0[¶](#01280 "Permanent link")

### Breaking Changes[¶](#breaking-changes "Permanent link")

  * â�– Drop support for `pydantic.v1`. PR [#14609](https://github.com/fastapi/fastapi/pull/14609) by [@tiangolo](https://github.com/tiangolo).

### Internal[¶](#internal_2 "Permanent link")

  * âœ… Run performance tests only on Pydantic v2. PR [#14608](https://github.com/fastapi/fastapi/pull/14608) by [@tiangolo](https://github.com/tiangolo).

## 0.127.1[¶](#01271 "Permanent link")

### Refactors[¶](#refactors_1 "Permanent link")

  * ğŸ”Š Add a custom `FastAPIDeprecationWarning`. PR [#14605](https://github.com/fastapi/fastapi/pull/14605) by [@tiangolo](https://github.com/tiangolo).

### Docs[¶](#docs_2 "Permanent link")

  * ğŸ“� Add documentary to website. PR [#14600](https://github.com/fastapi/fastapi/pull/14600) by [@tiangolo](https://github.com/tiangolo).

### Translations[¶](#translations_2 "Permanent link")

  * ğŸŒ� Update translations for de (update-outdated). PR [#14602](https://github.com/fastapi/fastapi/pull/14602) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Update translations for de (update-outdated). PR [#14581](https://github.com/fastapi/fastapi/pull/14581) by [@nilslindemann](https://github.com/nilslindemann).

### Internal[¶](#internal_3 "Permanent link")

  * ğŸ”§ Update pre-commit to use local Ruff instead of hook. PR [#14604](https://github.com/fastapi/fastapi/pull/14604) by [@tiangolo](https://github.com/tiangolo).
  * âœ… Add missing tests for code examples. PR [#14569](https://github.com/fastapi/fastapi/pull/14569) by [@YuriiMotov](https://github.com/YuriiMotov).
  * ğŸ‘· Remove `lint` job from `test` CI workflow. PR [#14593](https://github.com/fastapi/fastapi/pull/14593) by [@YuriiMotov](https://github.com/YuriiMotov).
  * ğŸ‘· Update secrets check. PR [#14592](https://github.com/fastapi/fastapi/pull/14592) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘· Run CodSpeed tests in parallel to other tests to speed up CI. PR [#14586](https://github.com/fastapi/fastapi/pull/14586) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”¨ Update scripts and pre-commit to autofix files. PR [#14585](https://github.com/fastapi/fastapi/pull/14585) by [@tiangolo](https://github.com/tiangolo).

## 0.127.0[¶](#01270 "Permanent link")

### Breaking Changes[¶](#breaking-changes_1 "Permanent link")

  * ğŸ”Š Add deprecation warnings when using `pydantic.v1`. PR [#14583](https://github.com/fastapi/fastapi/pull/14583) by [@tiangolo](https://github.com/tiangolo).

### Translations[¶](#translations_3 "Permanent link")

  * ğŸ”§ Add LLM prompt file for Korean, generated from the existing translations. PR [#14546](https://github.com/fastapi/fastapi/pull/14546) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”§ Add LLM prompt file for Japanese, generated from the existing translations. PR [#14545](https://github.com/fastapi/fastapi/pull/14545) by [@tiangolo](https://github.com/tiangolo).

### Internal[¶](#internal_4 "Permanent link")

  * â¬†ï¸� Upgrade OpenAI model for translations to gpt-5.2. PR [#14579](https://github.com/fastapi/fastapi/pull/14579) by [@tiangolo](https://github.com/tiangolo).

## 0.126.0[¶](#01260 "Permanent link")

### Upgrades[¶](#upgrades "Permanent link")

  * â�– Drop support for Pydantic v1, keeping short temporary support for Pydantic v2's `pydantic.v1`. PR [#14575](https://github.com/fastapi/fastapi/pull/14575) by [@tiangolo](https://github.com/tiangolo).
    * The minimum version of Pydantic installed is now `pydantic >=2.7.0`.
    * The `standard` dependencies now include `pydantic-settings >=2.0.0` and `pydantic-extra-types >=2.0.0`.

### Docs[¶](#docs_3 "Permanent link")

  * ğŸ“� Fix duplicated variable in `docs_src/python_types/tutorial005_py39.py`. PR [#14565](https://github.com/fastapi/fastapi/pull/14565) by [@paras-verma7454](https://github.com/paras-verma7454).

### Translations[¶](#translations_4 "Permanent link")

  * ğŸ”§ Add LLM prompt file for Ukrainian, generated from the existing translations. PR [#14548](https://github.com/fastapi/fastapi/pull/14548) by [@tiangolo](https://github.com/tiangolo).

### Internal[¶](#internal_5 "Permanent link")

  * ğŸ”§ Tweak pre-commit to allow committing release-notes. PR [#14577](https://github.com/fastapi/fastapi/pull/14577) by [@tiangolo](https://github.com/tiangolo).
  * â¬†ï¸� Use prek as a pre-commit alternative. PR [#14572](https://github.com/fastapi/fastapi/pull/14572) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘· Add performance tests with CodSpeed. PR [#14558](https://github.com/fastapi/fastapi/pull/14558) by [@tiangolo](https://github.com/tiangolo).

## 0.125.0[¶](#01250 "Permanent link")

### Breaking Changes[¶](#breaking-changes_2 "Permanent link")

  * ğŸ”§ Drop support for Python 3.8. PR [#14563](https://github.com/fastapi/fastapi/pull/14563) by [@tiangolo](https://github.com/tiangolo).
    * This would actually not be a _breaking_ change as no code would really break. Any Python 3.8 installer would just refuse to install the latest version of FastAPI and would only install 0.124.4. Only marking it as a "breaking change" to make it visible.

### Refactors[¶](#refactors_2 "Permanent link")

  * â™»ï¸� Upgrade internal syntax to Python 3.9+ ğŸ�‰. PR [#14564](https://github.com/fastapi/fastapi/pull/14564) by [@tiangolo](https://github.com/tiangolo).

### Docs[¶](#docs_4 "Permanent link")

  * âš°ï¸� Remove Python 3.8 from CI and remove Python 3.8 examples from source docs. PR [#14559](https://github.com/fastapi/fastapi/pull/14559) by [@YuriiMotov](https://github.com/YuriiMotov) and [@tiangolo](https://github.com/tiangolo).

### Translations[¶](#translations_5 "Permanent link")

  * ğŸŒ� Update translations for pt (add-missing). PR [#14539](https://github.com/fastapi/fastapi/pull/14539) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”§ Add LLM prompt file for French, generated from the existing French docs. PR [#14544](https://github.com/fastapi/fastapi/pull/14544) by [@tiangolo](https://github.com/tiangolo).
  * ğŸŒ� Sync Portuguese docs (pages found with script). PR [#14554](https://github.com/fastapi/fastapi/pull/14554) by [@YuriiMotov](https://github.com/YuriiMotov).
  * ğŸŒ� Sync Spanish docs (outdated pages found with script). PR [#14553](https://github.com/fastapi/fastapi/pull/14553) by [@YuriiMotov](https://github.com/YuriiMotov).
  * ğŸŒ� Sync German docs. PR [#14519](https://github.com/fastapi/fastapi/pull/14519) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸ”¥ Remove inactive/scarce translations to Vietnamese. PR [#14543](https://github.com/fastapi/fastapi/pull/14543) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”¥ Remove inactive/scarce translations to Persian. PR [#14542](https://github.com/fastapi/fastapi/pull/14542) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”¥ Remove translation to emoji to simplify the new setup with LLM autotranslations. PR [#14541](https://github.com/fastapi/fastapi/pull/14541) by [@tiangolo](https://github.com/tiangolo).
  * ğŸŒ� Update translations for pt (update-outdated). PR [#14537](https://github.com/fastapi/fastapi/pull/14537) by [@tiangolo](https://github.com/tiangolo).
  * ğŸŒ� Update translations for es (update-outdated). PR [#14532](https://github.com/fastapi/fastapi/pull/14532) by [@tiangolo](https://github.com/tiangolo).
  * ğŸŒ� Update translations for es (add-missing). PR [#14533](https://github.com/fastapi/fastapi/pull/14533) by [@tiangolo](https://github.com/tiangolo).
  * ğŸŒ� Remove translations for removed docs. PR [#14516](https://github.com/fastapi/fastapi/pull/14516) by [@tiangolo](https://github.com/tiangolo).

### Internal[¶](#internal_6 "Permanent link")

  * â¬† Bump `markdown-include-variants` from 0.0.7 to 0.0.8. PR [#14556](https://github.com/fastapi/fastapi/pull/14556) by [@YuriiMotov](https://github.com/YuriiMotov).
  * ğŸ”§ Temporarily disable translations still in progress, being migrated to the new LLM setup. PR [#14555](https://github.com/fastapi/fastapi/pull/14555) by [@YuriiMotov](https://github.com/YuriiMotov).
  * ğŸ”§ Update test workflow config, remove commented code. PR [#14540](https://github.com/fastapi/fastapi/pull/14540) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘· Configure coverage, error on main tests, don't wait for Smokeshow. PR [#14536](https://github.com/fastapi/fastapi/pull/14536) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘· Run Smokeshow always, even on test failures. PR [#14538](https://github.com/fastapi/fastapi/pull/14538) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘· Make Pydantic versions customizable in CI. PR [#14535](https://github.com/fastapi/fastapi/pull/14535) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘· Fix checkout GitHub Action fetch-depth for LLM translations, enable cron monthly. PR [#14531](https://github.com/fastapi/fastapi/pull/14531) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘· Fix Typer command for CI LLM translations. PR [#14530](https://github.com/fastapi/fastapi/pull/14530) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘· Update LLM translation CI, add language matrix and extra commands, prepare for scheduled run. PR [#14529](https://github.com/fastapi/fastapi/pull/14529) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘· Update github-actions user for GitHub Actions workflows. PR [#14528](https://github.com/fastapi/fastapi/pull/14528) by [@tiangolo](https://github.com/tiangolo).
  * â�• Add requirements for translations. PR [#14515](https://github.com/fastapi/fastapi/pull/14515) by [@tiangolo](https://github.com/tiangolo).

## 0.124.4[¶](#01244 "Permanent link")

### Fixes[¶](#fixes_2 "Permanent link")

  * ğŸ�› Fix parameter aliases. PR [#14371](https://github.com/fastapi/fastapi/pull/14371) by [@YuriiMotov](https://github.com/YuriiMotov).

## 0.124.3[¶](#01243 "Permanent link")

### Fixes[¶](#fixes_3 "Permanent link")

  * ğŸ�› Fix support for tagged union with discriminator inside of `Annotated` with `Body()`. PR [#14512](https://github.com/fastapi/fastapi/pull/14512) by [@tiangolo](https://github.com/tiangolo).

### Refactors[¶](#refactors_3 "Permanent link")

  * âœ… Add set of tests for request parameters and alias. PR [#14358](https://github.com/fastapi/fastapi/pull/14358) by [@YuriiMotov](https://github.com/YuriiMotov).

### Docs[¶](#docs_5 "Permanent link")

  * ğŸ“� Tweak links format. PR [#14505](https://github.com/fastapi/fastapi/pull/14505) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ“� Update docs about re-raising validation errors, do not include string as is to not leak information. PR [#14487](https://github.com/fastapi/fastapi/pull/14487) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”¥ Remove external links section. PR [#14486](https://github.com/fastapi/fastapi/pull/14486) by [@tiangolo](https://github.com/tiangolo).

### Translations[¶](#translations_6 "Permanent link")

  * ğŸŒ� Sync Russian docs. PR [#14509](https://github.com/fastapi/fastapi/pull/14509) by [@YuriiMotov](https://github.com/YuriiMotov).
  * ğŸŒ� Sync German docs. PR [#14488](https://github.com/fastapi/fastapi/pull/14488) by [@nilslindemann](https://github.com/nilslindemann).

### Internal[¶](#internal_7 "Permanent link")

  * ğŸ‘· Tweak coverage to not pass Smokeshow max file size limit. PR [#14507](https://github.com/fastapi/fastapi/pull/14507) by [@tiangolo](https://github.com/tiangolo).
  * âœ… Expand test matrix to include Windows and MacOS. PR [#14171](https://github.com/fastapi/fastapi/pull/14171) by [@svlandeg](https://github.com/svlandeg).

## 0.124.2[¶](#01242 "Permanent link")

### Fixes[¶](#fixes_4 "Permanent link")

  * ğŸ�› Fix support for `if TYPE_CHECKING`, non-evaluated stringified annotations. PR [#14485](https://github.com/fastapi/fastapi/pull/14485) by [@tiangolo](https://github.com/tiangolo).

## 0.124.1[¶](#01241 "Permanent link")

### Fixes[¶](#fixes_5 "Permanent link")

  * ğŸ�› Fix handling arbitrary types when using `arbitrary_types_allowed=True`. PR [#14482](https://github.com/fastapi/fastapi/pull/14482) by [@tiangolo](https://github.com/tiangolo).

### Docs[¶](#docs_6 "Permanent link")

  * ğŸ“� Add variants for code examples in "Advanced User Guide". PR [#14413](https://github.com/fastapi/fastapi/pull/14413) by [@YuriiMotov](https://github.com/YuriiMotov).
  * ğŸ“� Update tech stack in project generation docs. PR [#14472](https://github.com/fastapi/fastapi/pull/14472) by [@alejsdev](https://github.com/alejsdev).

### Internal[¶](#internal_8 "Permanent link")

  * âœ… Add test for Pydantic v2, dataclasses, UUID, and `__annotations__`. PR [#14477](https://github.com/fastapi/fastapi/pull/14477) by [@tiangolo](https://github.com/tiangolo).

## 0.124.0[¶](#01240 "Permanent link")

### Features[¶](#features_2 "Permanent link")

  * ğŸš¸ Improve tracebacks by adding endpoint metadata. PR [#14306](https://github.com/fastapi/fastapi/pull/14306) by [@savannahostrowski](https://github.com/savannahostrowski).

### Internal[¶](#internal_9 "Permanent link")

  * âœ�ï¸� Fix typo in `scripts/mkdocs_hooks.py`. PR [#14457](https://github.com/fastapi/fastapi/pull/14457) by [@yujiteshima](https://github.com/yujiteshima).

## 0.123.10[¶](#012310 "Permanent link")

### Fixes[¶](#fixes_6 "Permanent link")

  * ğŸ�› Fix using class (not instance) dependency that has `__call__` method. PR [#14458](https://github.com/fastapi/fastapi/pull/14458) by [@YuriiMotov](https://github.com/YuriiMotov).
  * ğŸ�› Fix `separate_input_output_schemas=False` with `computed_field`. PR [#14453](https://github.com/fastapi/fastapi/pull/14453) by [@YuriiMotov](https://github.com/YuriiMotov).

## 0.123.9[¶](#01239 "Permanent link")

### Fixes[¶](#fixes_7 "Permanent link")

  * ğŸ�› Fix OAuth2 scopes in OpenAPI in extra corner cases, parent dependency with scopes, sub-dependency security scheme without scopes. PR [#14459](https://github.com/fastapi/fastapi/pull/14459) by [@tiangolo](https://github.com/tiangolo).

## 0.123.8[¶](#01238 "Permanent link")

### Fixes[¶](#fixes_8 "Permanent link")

  * ğŸ�› Fix OpenAPI security scheme OAuth2 scopes declaration, deduplicate security schemes with different scopes. PR [#14455](https://github.com/fastapi/fastapi/pull/14455) by [@tiangolo](https://github.com/tiangolo).

## 0.123.7[¶](#01237 "Permanent link")

### Fixes[¶](#fixes_9 "Permanent link")

  * ğŸ�› Fix evaluating stringified annotations in Python 3.10. PR [#11355](https://github.com/fastapi/fastapi/pull/11355) by [@chaen](https://github.com/chaen).

## 0.123.6[¶](#01236 "Permanent link")

### Fixes[¶](#fixes_10 "Permanent link")

  * ğŸ�› Fix support for functools wraps and partial combined, for async and regular functions and classes in path operations and dependencies. PR [#14448](https://github.com/fastapi/fastapi/pull/14448) by [@tiangolo](https://github.com/tiangolo).

## 0.123.5[¶](#01235 "Permanent link")

### Features[¶](#features_3 "Permanent link")

  * âœ¨ Allow using dependables with `functools.partial()`. PR [#9753](https://github.com/fastapi/fastapi/pull/9753) by [@lieryan](https://github.com/lieryan).
  * âœ¨ Add support for wrapped functions (e.g. `@functools.wraps()`) used with forward references. PR [#5077](https://github.com/fastapi/fastapi/pull/5077) by [@lucaswiman](https://github.com/lucaswiman).
  * âœ¨ Handle wrapped dependencies. PR [#9555](https://github.com/fastapi/fastapi/pull/9555) by [@phy1729](https://github.com/phy1729).

### Fixes[¶](#fixes_11 "Permanent link")

  * ğŸ�› Fix optional sequence handling with new union syntax from Python 3.10. PR [#14430](https://github.com/fastapi/fastapi/pull/14430) by [@Viicos](https://github.com/Viicos).

### Refactors[¶](#refactors_4 "Permanent link")

  * ğŸ”¥ Remove dangling extra conditional no longer needed. PR [#14435](https://github.com/fastapi/fastapi/pull/14435) by [@tiangolo](https://github.com/tiangolo).
  * â™»ï¸� Refactor internals, update `is_coroutine` check to reuse internal supported variants (unwrap, check class). PR [#14434](https://github.com/fastapi/fastapi/pull/14434) by [@tiangolo](https://github.com/tiangolo).

### Translations[¶](#translations_7 "Permanent link")

  * ğŸŒ� Sync German docs. PR [#14367](https://github.com/fastapi/fastapi/pull/14367) by [@nilslindemann](https://github.com/nilslindemann).

## 0.123.4[¶](#01234 "Permanent link")

### Fixes[¶](#fixes_12 "Permanent link")

  * ğŸ�› Fix OpenAPI schema support for computed fields when using `separate_input_output_schemas=False`. PR [#13207](https://github.com/fastapi/fastapi/pull/13207) by [@vgrafe](https://github.com/vgrafe).

### Docs[¶](#docs_7 "Permanent link")

  * ğŸ“� Fix docstring of `servers` parameter. PR [#14405](https://github.com/fastapi/fastapi/pull/14405) by [@YuriiMotov](https://github.com/YuriiMotov).

## 0.123.3[¶](#01233 "Permanent link")

### Fixes[¶](#fixes_13 "Permanent link")

  * ğŸ�› Fix Query\Header\Cookie parameter model alias. PR [#14360](https://github.com/fastapi/fastapi/pull/14360) by [@YuriiMotov](https://github.com/YuriiMotov).
  * ğŸ�› Fix optional sequence handling in `serialize sequence value` with Pydantic V2. PR [#14297](https://github.com/fastapi/fastapi/pull/14297) by [@YuriiMotov](https://github.com/YuriiMotov).

## 0.123.2[¶](#01232 "Permanent link")

### Fixes[¶](#fixes_14 "Permanent link")

  * ğŸ�› Fix unformatted `{type_}` in FastAPIError. PR [#14416](https://github.com/fastapi/fastapi/pull/14416) by [@Just-Helpful](https://github.com/Just-Helpful).
  * ğŸ�› Fix parsing extra non-body parameter list. PR [#14356](https://github.com/fastapi/fastapi/pull/14356) by [@YuriiMotov](https://github.com/YuriiMotov).
  * ğŸ�› Fix parsing extra `Form` parameter list. PR [#14303](https://github.com/fastapi/fastapi/pull/14303) by [@YuriiMotov](https://github.com/YuriiMotov).
  * ğŸ�› Fix support for form values with empty strings interpreted as missing (`None` if that's the default), for compatibility with HTML forms. PR [#13537](https://github.com/fastapi/fastapi/pull/13537) by [@MarinPostma](https://github.com/MarinPostma).

### Docs[¶](#docs_8 "Permanent link")

  * ğŸ“� Add tip on how to install `pip` in case of `No module named pip` error in `virtual-environments.md`. PR [#14211](https://github.com/fastapi/fastapi/pull/14211) by [@zadevhub](https://github.com/zadevhub).
  * ğŸ“� Update Primary Key notes for the SQL databases tutorial to avoid confusion. PR [#14120](https://github.com/fastapi/fastapi/pull/14120) by [@FlaviusRaducu](https://github.com/FlaviusRaducu).
  * ğŸ“� Clarify estimation note in documentation. PR [#14070](https://github.com/fastapi/fastapi/pull/14070) by [@SaisakthiM](https://github.com/SaisakthiM).

## 0.123.1[¶](#01231 "Permanent link")

### Fixes[¶](#fixes_15 "Permanent link")

  * ğŸ�› Avoid accessing non-existing "$ref" key for Pydantic v2 compat remapping. PR [#14361](https://github.com/fastapi/fastapi/pull/14361) by [@svlandeg](https://github.com/svlandeg).
  * ğŸ�› Fix `TypeError` when encoding a decimal with a `NaN` or `Infinity` value. PR [#12935](https://github.com/fastapi/fastapi/pull/12935) by [@kentwelcome](https://github.com/kentwelcome).

### Internal[¶](#internal_10 "Permanent link")

  * ğŸ�› Fix Windows UnicodeEncodeError in CLI test. PR [#14295](https://github.com/fastapi/fastapi/pull/14295) by [@hemanth-thirthahalli](https://github.com/hemanth-thirthahalli).
  * ğŸ”§ Update sponsors: add Greptile. PR [#14429](https://github.com/fastapi/fastapi/pull/14429) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘¥ Update FastAPI GitHub topic repositories. PR [#14426](https://github.com/fastapi/fastapi/pull/14426) by [@tiangolo](https://github.com/tiangolo).
  * â¬† Bump markdown-include-variants from 0.0.6 to 0.0.7. PR [#14423](https://github.com/fastapi/fastapi/pull/14423) by [@YuriiMotov](https://github.com/YuriiMotov).
  * ğŸ‘¥ Update FastAPI People - Sponsors. PR [#14422](https://github.com/fastapi/fastapi/pull/14422) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘¥ Update FastAPI People - Contributors and Translators. PR [#14420](https://github.com/fastapi/fastapi/pull/14420) by [@tiangolo](https://github.com/tiangolo).

## 0.123.0[¶](#01230 "Permanent link")

### Fixes[¶](#fixes_16 "Permanent link")

  * ğŸ�› Cache dependencies that don't use scopes and don't have sub-dependencies with scopes. PR [#14419](https://github.com/fastapi/fastapi/pull/14419) by [@tiangolo](https://github.com/tiangolo).

## 0.122.1[¶](#01221 "Permanent link")

### Fixes[¶](#fixes_17 "Permanent link")

  * ğŸ�› Fix hierarchical security scope propagation. PR [#5624](https://github.com/fastapi/fastapi/pull/5624) by [@kristjanvalur](https://github.com/kristjanvalur).

### Docs[¶](#docs_9 "Permanent link")

  * ğŸ’… Update CSS to explicitly use emoji font. PR [#14415](https://github.com/fastapi/fastapi/pull/14415) by [@tiangolo](https://github.com/tiangolo).

### Internal[¶](#internal_11 "Permanent link")

  * â¬† Bump markdown-include-variants from 0.0.5 to 0.0.6. PR [#14418](https://github.com/fastapi/fastapi/pull/14418) by [@YuriiMotov](https://github.com/YuriiMotov).

## 0.122.0[¶](#01220 "Permanent link")

### Fixes[¶](#fixes_18 "Permanent link")

  * ğŸ�› Use `401` status code in security classes when credentials are missing. PR [#13786](https://github.com/fastapi/fastapi/pull/13786) by [@YuriiMotov](https://github.com/YuriiMotov).
    * If your code depended on these classes raising the old (less correct) `403` status code, check the new docs about how to override the classes, to use the same old behavior: [Use Old 403 Authentication Error Status Codes](https://fastapi.tiangolo.com/how-to/authentication-error-status-code/).

### Internal[¶](#internal_12 "Permanent link")

  * ğŸ”§ Configure labeler to exclude files that start from underscore for `lang-all` label. PR [#14213](https://github.com/fastapi/fastapi/pull/14213) by [@YuriiMotov](https://github.com/YuriiMotov).
  * ğŸ‘· Add pre-commit config with local script for permalinks. PR [#14398](https://github.com/fastapi/fastapi/pull/14398) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ’„ Use font Fira Code to fix display of Rich panels in docs in Windows. PR [#14387](https://github.com/fastapi/fastapi/pull/14387) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘· Add custom pre-commit CI. PR [#14397](https://github.com/fastapi/fastapi/pull/14397) by [@tiangolo](https://github.com/tiangolo).
  * â¬† Bump actions/checkout from 5 to 6. PR [#14381](https://github.com/fastapi/fastapi/pull/14381) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * ğŸ‘· Upgrade `latest-changes` GitHub Action and pin `actions/checkout@v5`. PR [#14403](https://github.com/fastapi/fastapi/pull/14403) by [@svlandeg](https://github.com/svlandeg).
  * ğŸ› ï¸� Add `add-permalinks` and `add-permalinks-page` to `scripts/docs.py`. PR [#14033](https://github.com/fastapi/fastapi/pull/14033) by [@YuriiMotov](https://github.com/YuriiMotov).
  * ğŸ”§ Upgrade Material for MkDocs and remove insiders. PR [#14375](https://github.com/fastapi/fastapi/pull/14375) by [@tiangolo](https://github.com/tiangolo).

## 0.121.3[¶](#01213 "Permanent link")

### Refactors[¶](#refactors_5 "Permanent link")

  * â™»ï¸� Make the result of `Depends()` and `Security()` hashable, as a workaround for other tools interacting with these internal parts. PR [#14372](https://github.com/fastapi/fastapi/pull/14372) by [@tiangolo](https://github.com/tiangolo).

### Upgrades[¶](#upgrades_1 "Permanent link")

  * â¬†ï¸� Bump Starlette to <`0.51.0`. PR [#14282](https://github.com/fastapi/fastapi/pull/14282) by [@musicinmybrain](https://github.com/musicinmybrain).

### Docs[¶](#docs_10 "Permanent link")

  * ğŸ“� Add missing hash part. PR [#14369](https://github.com/fastapi/fastapi/pull/14369) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸ“� Fix typos in code comments. PR [#14364](https://github.com/fastapi/fastapi/pull/14364) by [@Edge-Seven](https://github.com/Edge-Seven).
  * ğŸ“� Add docs for using FastAPI Cloud. PR [#14359](https://github.com/fastapi/fastapi/pull/14359) by [@tiangolo](https://github.com/tiangolo).

## 0.121.2[¶](#01212 "Permanent link")

### Fixes[¶](#fixes_19 "Permanent link")

  * ğŸ�› Fix handling of JSON Schema attributes named "$ref". PR [#14349](https://github.com/fastapi/fastapi/pull/14349) by [@tiangolo](https://github.com/tiangolo).

### Docs[¶](#docs_11 "Permanent link")

  * ğŸ“� Add EuroPython talk & podcast episode with SebastiÃ¡n RamÃ­rez. PR [#14260](https://github.com/fastapi/fastapi/pull/14260) by [@clytaemnestra](https://github.com/clytaemnestra).
  * âœ�ï¸� Fix links and add missing permalink in docs. PR [#14217](https://github.com/fastapi/fastapi/pull/14217) by [@YuriiMotov](https://github.com/YuriiMotov).

### Translations[¶](#translations_8 "Permanent link")

  * ğŸŒ� Update Portuguese translations with LLM prompt. PR [#14228](https://github.com/fastapi/fastapi/pull/14228) by [@ceb10n](https://github.com/ceb10n).
  * ğŸ”¨ Add Portuguese translations LLM prompt. PR [#14208](https://github.com/fastapi/fastapi/pull/14208) by [@ceb10n](https://github.com/ceb10n).
  * ğŸŒ� Sync Russian docs. PR [#14331](https://github.com/fastapi/fastapi/pull/14331) by [@YuriiMotov](https://github.com/YuriiMotov).
  * ğŸŒ� Sync German docs. PR [#14317](https://github.com/fastapi/fastapi/pull/14317) by [@nilslindemann](https://github.com/nilslindemann).

## 0.121.1[¶](#01211 "Permanent link")

### Fixes[¶](#fixes_20 "Permanent link")

  * ğŸ�› Fix `Depends(func, scope='function')` for top level (parameterless) dependencies. PR [#14301](https://github.com/fastapi/fastapi/pull/14301) by [@luzzodev](https://github.com/luzzodev).

### Docs[¶](#docs_12 "Permanent link")

  * ğŸ“� Update docs for advanced dependencies with `yield`, noting the changes in 0.121.0, adding `scope`. PR [#14287](https://github.com/fastapi/fastapi/pull/14287) by [@tiangolo](https://github.com/tiangolo).

### Internal[¶](#internal_13 "Permanent link")

  * â¬† Bump ruff from 0.13.2 to 0.14.3. PR [#14276](https://github.com/fastapi/fastapi/pull/14276) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * â¬† [pre-commit.ci] pre-commit autoupdate. PR [#14289](https://github.com/fastapi/fastapi/pull/14289) by [@pre-commit-ci[bot]](https://github.com/apps/pre-commit-ci).

## 0.121.0[¶](#01210 "Permanent link")

### Features[¶](#features_4 "Permanent link")

  * âœ¨ Add support for dependencies with scopes, support `scope="request"` for dependencies with `yield` that exit before the response is sent. PR [#14262](https://github.com/fastapi/fastapi/pull/14262) by [@tiangolo](https://github.com/tiangolo).
    * New docs: [Dependencies with `yield` \- Early exit and `scope`](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-with-yield/#early-exit-and-scope).

### Internal[¶](#internal_14 "Permanent link")

  * ğŸ‘¥ Update FastAPI People - Contributors and Translators. PR [#14273](https://github.com/fastapi/fastapi/pull/14273) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘¥ Update FastAPI People - Sponsors. PR [#14274](https://github.com/fastapi/fastapi/pull/14274) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘¥ Update FastAPI GitHub topic repositories. PR [#14280](https://github.com/fastapi/fastapi/pull/14280) by [@tiangolo](https://github.com/tiangolo).
  * â¬† Bump mkdocs-macros-plugin from 1.4.0 to 1.4.1. PR [#14277](https://github.com/fastapi/fastapi/pull/14277) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * â¬† Bump mkdocstrings[python] from 0.26.1 to 0.30.1. PR [#14279](https://github.com/fastapi/fastapi/pull/14279) by [@dependabot[bot]](https://github.com/apps/dependabot).

## 0.120.4[¶](#01204 "Permanent link")

### Fixes[¶](#fixes_21 "Permanent link")

  * ğŸ�› Fix security schemes in OpenAPI when added at the top level app. PR [#14266](https://github.com/fastapi/fastapi/pull/14266) by [@YuriiMotov](https://github.com/YuriiMotov).

## 0.120.3[¶](#01203 "Permanent link")

### Refactors[¶](#refactors_6 "Permanent link")

  * â™»ï¸� Reduce internal cyclic recursion in dependencies, from 2 functions calling each other to 1 calling itself. PR [#14256](https://github.com/fastapi/fastapi/pull/14256) by [@tiangolo](https://github.com/tiangolo).
  * â™»ï¸� Refactor internals of dependencies, simplify code and remove `get_param_sub_dependant`. PR [#14255](https://github.com/fastapi/fastapi/pull/14255) by [@tiangolo](https://github.com/tiangolo).
  * â™»ï¸� Refactor internals of dependencies, simplify using dataclasses. PR [#14254](https://github.com/fastapi/fastapi/pull/14254) by [@tiangolo](https://github.com/tiangolo).

### Docs[¶](#docs_13 "Permanent link")

  * ğŸ“� Update note for untranslated pages. PR [#14257](https://github.com/fastapi/fastapi/pull/14257) by [@YuriiMotov](https://github.com/YuriiMotov).

## 0.120.2[¶](#01202 "Permanent link")

### Fixes[¶](#fixes_22 "Permanent link")

  * ğŸ�› Fix separation of schemas with nested models introduced in 0.119.0. PR [#14246](https://github.com/fastapi/fastapi/pull/14246) by [@tiangolo](https://github.com/tiangolo).

### Internal[¶](#internal_15 "Permanent link")

  * ğŸ”§ Add sponsor: SerpApi. PR [#14248](https://github.com/fastapi/fastapi/pull/14248) by [@tiangolo](https://github.com/tiangolo).
  * â¬† Bump actions/download-artifact from 5 to 6. PR [#14236](https://github.com/fastapi/fastapi/pull/14236) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * â¬† [pre-commit.ci] pre-commit autoupdate. PR [#14237](https://github.com/fastapi/fastapi/pull/14237) by [@pre-commit-ci[bot]](https://github.com/apps/pre-commit-ci).
  * â¬† Bump actions/upload-artifact from 4 to 5. PR [#14235](https://github.com/fastapi/fastapi/pull/14235) by [@dependabot[bot]](https://github.com/apps/dependabot).

## 0.120.1[¶](#01201 "Permanent link")

### Upgrades[¶](#upgrades_2 "Permanent link")

  * â¬†ï¸� Bump Starlette to <`0.50.0`. PR [#14234](https://github.com/fastapi/fastapi/pull/14234) by [@YuriiMotov](https://github.com/YuriiMotov).

### Internal[¶](#internal_16 "Permanent link")

  * ğŸ”§ Add `license` and `license-files` to `pyproject.toml`, remove `License` from `classifiers`. PR [#14230](https://github.com/fastapi/fastapi/pull/14230) by [@YuriiMotov](https://github.com/YuriiMotov).

## 0.120.0[¶](#01200 "Permanent link")

There are no major nor breaking changes in this release. â˜•ï¸�

The internal reference documentation now uses `annotated_doc.Doc` instead of `typing_extensions.Doc`, this adds a new (very small) dependency on [`annotated-doc`](https://github.com/fastapi/annotated-doc), a package made just to provide that `Doc` documentation utility class.

I would expect `typing_extensions.Doc` to be deprecated and then removed at some point from `typing_extensions`, for that reason there's the new `annotated-doc` micro-package. If you are curious about this, you can read more in the repo for [`annotated-doc`](https://github.com/fastapi/annotated-doc).

This new version `0.120.0` only contains that transition to the new home package for that utility class `Doc`.

### Translations[¶](#translations_9 "Permanent link")

  * ğŸŒ� Sync German docs. PR [#14188](https://github.com/fastapi/fastapi/pull/14188) by [@nilslindemann](https://github.com/nilslindemann).

### Internal[¶](#internal_17 "Permanent link")

  * â�• Migrate internal reference documentation from `typing_extensions.Doc` to `annotated_doc.Doc`. PR [#14222](https://github.com/fastapi/fastapi/pull/14222) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ› ï¸� Update German LLM prompt and test file. PR [#14189](https://github.com/fastapi/fastapi/pull/14189) by [@nilslindemann](https://github.com/nilslindemann).
  * â¬† [pre-commit.ci] pre-commit autoupdate. PR [#14181](https://github.com/fastapi/fastapi/pull/14181) by [@pre-commit-ci[bot]](https://github.com/apps/pre-commit-ci).

## 0.119.1[¶](#01191 "Permanent link")

### Fixes[¶](#fixes_23 "Permanent link")

  * ğŸ�› Fix internal Pydantic v1 compatibility (warnings) for Python 3.14 and Pydantic 2.12.1. PR [#14186](https://github.com/fastapi/fastapi/pull/14186) by [@svlandeg](https://github.com/svlandeg).

### Docs[¶](#docs_14 "Permanent link")

  * ğŸ“� Replace `starlette.io` by `starlette.dev` and `uvicorn.org` by `uvicorn.dev`. PR [#14176](https://github.com/fastapi/fastapi/pull/14176) by [@Kludex](https://github.com/Kludex).

### Internal[¶](#internal_18 "Permanent link")

  * ğŸ”§ Add sponsor Requestly. PR [#14205](https://github.com/fastapi/fastapi/pull/14205) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”§ Configure reminder for `waiting` label in `issue-manager`. PR [#14156](https://github.com/fastapi/fastapi/pull/14156) by [@YuriiMotov](https://github.com/YuriiMotov).

## 0.119.0[¶](#01190 "Permanent link")

FastAPI now (temporarily) supports both Pydantic v2 models and `pydantic.v1` models at the same time in the same app, to make it easier for any FastAPI apps still using Pydantic v1 to gradually but quickly **migrate to Pydantic v2**.
    
    
    from fastapi import FastAPI
    from pydantic import BaseModel as BaseModelV2
    from pydantic.v1 import BaseModel
    
    
    class Item(BaseModel):
        name: str
        description: str | None = None
    
    
    class ItemV2(BaseModelV2):
        title: str
        summary: str | None = None
    
    
    app = FastAPI()
    
    
    @app.post("/items/", response_model=ItemV2)
    def create_item(item: Item):
        return {"title": item.name, "summary": item.description}
    

Adding this feature was a big effort with the main objective of making it easier for the few applications still stuck in Pydantic v1 to migrate to Pydantic v2.

And with this, support for **Pydantic v1 is now deprecated** and will be **removed** from FastAPI in a future version soon.

**Note** : have in mind that the Pydantic team already stopped supporting Pydantic v1 for recent versions of Python, starting with Python 3.14.

You can read in the docs more about how to [Migrate from Pydantic v1 to Pydantic v2](https://fastapi.tiangolo.com/how-to/migrate-from-pydantic-v1-to-pydantic-v2/).

### Features[¶](#features_5 "Permanent link")

  * âœ¨ Add support for `from pydantic.v1 import BaseModel`, mixed Pydantic v1 and v2 models in the same app. PR [#14168](https://github.com/fastapi/fastapi/pull/14168) by [@tiangolo](https://github.com/tiangolo).

## 0.118.3[¶](#01183 "Permanent link")

### Upgrades[¶](#upgrades_3 "Permanent link")

  * â¬†ï¸� Add support for Python 3.14. PR [#14165](https://github.com/fastapi/fastapi/pull/14165) by [@svlandeg](https://github.com/svlandeg).

## 0.118.2[¶](#01182 "Permanent link")

### Fixes[¶](#fixes_24 "Permanent link")

  * ğŸ�› Fix tagged discriminated union not recognized as body field. PR [#12942](https://github.com/fastapi/fastapi/pull/12942) by [@frankie567](https://github.com/frankie567).

### Internal[¶](#internal_19 "Permanent link")

  * â¬† Bump astral-sh/setup-uv from 6 to 7. PR [#14167](https://github.com/fastapi/fastapi/pull/14167) by [@dependabot[bot]](https://github.com/apps/dependabot).

## 0.118.1[¶](#01181 "Permanent link")

### Upgrades[¶](#upgrades_4 "Permanent link")

  * ğŸ‘½ï¸� Ensure compatibility with Pydantic 2.12.0. PR [#14036](https://github.com/fastapi/fastapi/pull/14036) by [@cjwatson](https://github.com/cjwatson).

### Docs[¶](#docs_15 "Permanent link")

  * ğŸ“� Add External Link: Getting started with logging in FastAPI. PR [#14152](https://github.com/fastapi/fastapi/pull/14152) by [@itssimon](https://github.com/itssimon).

### Translations[¶](#translations_10 "Permanent link")

  * ğŸ”¨ Add Russian translations LLM prompt. PR [#13936](https://github.com/fastapi/fastapi/pull/13936) by [@tiangolo](https://github.com/tiangolo).
  * ğŸŒ� Sync German docs. PR [#14149](https://github.com/fastapi/fastapi/pull/14149) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Add Russian translations for missing pages (LLM-generated). PR [#14135](https://github.com/fastapi/fastapi/pull/14135) by [@YuriiMotov](https://github.com/YuriiMotov).
  * ğŸŒ� Update Russian translations for existing pages (LLM-generated). PR [#14123](https://github.com/fastapi/fastapi/pull/14123) by [@YuriiMotov](https://github.com/YuriiMotov).
  * ğŸŒ� Remove configuration files for inactive translations. PR [#14130](https://github.com/fastapi/fastapi/pull/14130) by [@tiangolo](https://github.com/tiangolo).

### Internal[¶](#internal_20 "Permanent link")

  * ğŸ”¨ Move local coverage logic to its own script. PR [#14166](https://github.com/fastapi/fastapi/pull/14166) by [@tiangolo](https://github.com/tiangolo).
  * â¬† [pre-commit.ci] pre-commit autoupdate. PR [#14161](https://github.com/fastapi/fastapi/pull/14161) by [@pre-commit-ci[bot]](https://github.com/apps/pre-commit-ci).
  * â¬† Bump griffe-typingdoc from 0.2.8 to 0.2.9. PR [#14144](https://github.com/fastapi/fastapi/pull/14144) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * â¬† Bump mkdocs-macros-plugin from 1.3.9 to 1.4.0. PR [#14145](https://github.com/fastapi/fastapi/pull/14145) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * â¬† Bump markdown-include-variants from 0.0.4 to 0.0.5. PR [#14146](https://github.com/fastapi/fastapi/pull/14146) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * â¬† [pre-commit.ci] pre-commit autoupdate. PR [#14126](https://github.com/fastapi/fastapi/pull/14126) by [@pre-commit-ci[bot]](https://github.com/apps/pre-commit-ci).
  * ğŸ‘¥ Update FastAPI GitHub topic repositories. PR [#14150](https://github.com/fastapi/fastapi/pull/14150) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘¥ Update FastAPI People - Sponsors. PR [#14139](https://github.com/fastapi/fastapi/pull/14139) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘¥ Update FastAPI People - Contributors and Translators. PR [#14138](https://github.com/fastapi/fastapi/pull/14138) by [@tiangolo](https://github.com/tiangolo).
  * â¬† Bump ruff from 0.12.7 to 0.13.2. PR [#14147](https://github.com/fastapi/fastapi/pull/14147) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * â¬† Bump sqlmodel from 0.0.24 to 0.0.25. PR [#14143](https://github.com/fastapi/fastapi/pull/14143) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * â¬† Bump tiangolo/issue-manager from 0.5.1 to 0.6.0. PR [#14148](https://github.com/fastapi/fastapi/pull/14148) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * ğŸ‘· Update docs previews comment, single comment, add failure status. PR [#14129](https://github.com/fastapi/fastapi/pull/14129) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”¨ Modify `mkdocs_hooks.py` to add `title` to page's metadata (remove permalinks in social cards). PR [#14125](https://github.com/fastapi/fastapi/pull/14125) by [@YuriiMotov](https://github.com/YuriiMotov).

## 0.118.0[¶](#01180 "Permanent link")

### Fixes[¶](#fixes_25 "Permanent link")

  * ğŸ�› Fix support for `StreamingResponse`s with dependencies with `yield` or `UploadFile`s, close after the response is done. PR [#14099](https://github.com/fastapi/fastapi/pull/14099) by [@tiangolo](https://github.com/tiangolo).

Before FastAPI 0.118.0, if you used a dependency with `yield`, it would run the exit code after the _path operation function_ returned but right before sending the response.

This change also meant that if you returned a `StreamingResponse`, the exit code of the dependency with `yield` would have been already run.

For example, if you had a database session in a dependency with `yield`, the `StreamingResponse` would not be able to use that session while streaming data because the session would have already been closed in the exit code after `yield`.

This behavior was reverted in 0.118.0, to make the exit code after `yield` be executed after the response is sent.

You can read more about it in the docs for [Advanced Dependencies - Dependencies with `yield`, `HTTPException`, `except` and Background Tasks](https://fastapi.tiangolo.com/advanced/advanced-dependencies#dependencies-with-yield-httpexception-except-and-background-tasks). Including what you could do if you wanted to close a database session earlier, before returning the response to the client.

### Docs[¶](#docs_16 "Permanent link")

  * ğŸ“� Update `tutorial/security/oauth2-jwt/` to use `pwdlib` with Argon2 instead of `passlib`. PR [#13917](https://github.com/fastapi/fastapi/pull/13917) by [@Neizvestnyj](https://github.com/Neizvestnyj).
  * âœ�ï¸� Fix typos in OAuth2 password request forms. PR [#14112](https://github.com/fastapi/fastapi/pull/14112) by [@alv2017](https://github.com/alv2017).
  * ğŸ“� Update contributing guidelines for installing requirements. PR [#14095](https://github.com/fastapi/fastapi/pull/14095) by [@alejsdev](https://github.com/alejsdev).

### Translations[¶](#translations_11 "Permanent link")

  * ğŸŒ� Sync German docs. PR [#14098](https://github.com/fastapi/fastapi/pull/14098) by [@nilslindemann](https://github.com/nilslindemann).

### Internal[¶](#internal_21 "Permanent link")

  * â¬† [pre-commit.ci] pre-commit autoupdate. PR [#14103](https://github.com/fastapi/fastapi/pull/14103) by [@pre-commit-ci[bot]](https://github.com/apps/pre-commit-ci).
  * â™»ï¸� Refactor sponsor image handling. PR [#14102](https://github.com/fastapi/fastapi/pull/14102) by [@alejsdev](https://github.com/alejsdev).
  * ğŸ�› Fix sponsor display issue by hiding element on image error. PR [#14097](https://github.com/fastapi/fastapi/pull/14097) by [@alejsdev](https://github.com/alejsdev).
  * ğŸ�› Hide sponsor badge when sponsor image is not displayed. PR [#14096](https://github.com/fastapi/fastapi/pull/14096) by [@alejsdev](https://github.com/alejsdev).

## 0.117.1[¶](#01171 "Permanent link")

### Fixes[¶](#fixes_26 "Permanent link")

  * ğŸ�› Fix validation error when `File` is declared after `Form` parameter. PR [#11194](https://github.com/fastapi/fastapi/pull/11194) by [@thomasleveil](https://github.com/thomasleveil).

## 0.117.0[¶](#01170 "Permanent link")

### Features[¶](#features_6 "Permanent link")

  * âœ¨ Allow `None` as return type for bodiless responses. PR [#9425](https://github.com/fastapi/fastapi/pull/9425) by [@hofrob](https://github.com/hofrob).
  * âœ¨ Allow array values for OpenAPI schema `type` field. PR [#13639](https://github.com/fastapi/fastapi/pull/13639) by [@sammasak](https://github.com/sammasak).
  * âœ¨ Add OpenAPI `external_docs` parameter to `FastAPI`. PR [#13713](https://github.com/fastapi/fastapi/pull/13713) by [@cmtoro](https://github.com/cmtoro).

### Fixes[¶](#fixes_27 "Permanent link")

  * âš¡ï¸� Fix `default_factory` for response model field with Pydantic V1. PR [#9704](https://github.com/fastapi/fastapi/pull/9704) by [@vvanglro](https://github.com/vvanglro).
  * ğŸ�› Fix inconsistent processing of model docstring formfeed char with Pydantic V1. PR [#6039](https://github.com/fastapi/fastapi/pull/6039) by [@MaxwellPayne](https://github.com/MaxwellPayne).
  * ğŸ�› Fix `jsonable_encoder` alters `json_encoders` of Pydantic v1 objects. PR [#4972](https://github.com/fastapi/fastapi/pull/4972) by [@aboubacs](https://github.com/aboubacs).
  * ğŸ�› Reenable `allow_arbitrary_types` when only 1 argument is used on the API endpoint. PR [#13694](https://github.com/fastapi/fastapi/pull/13694) by [@rmawatson](https://github.com/rmawatson).
  * ğŸ�› Fix `inspect.getcoroutinefunction()` can break testing with `unittest.mock.patch()`. PR [#14022](https://github.com/fastapi/fastapi/pull/14022) by [@secrett2633](https://github.com/secrett2633).

### Refactors[¶](#refactors_7 "Permanent link")

  * â™»ï¸� Create `dependency-cache` dict in `solve_dependencies` only if `None` (don't re-create if empty). PR [#13689](https://github.com/fastapi/fastapi/pull/13689) by [@bokshitsky](https://github.com/bokshitsky).
  * âœ… Enable test case for duplicated headers in `test_tutorial/test_header_params/test_tutorial003.py`. PR [#13864](https://github.com/fastapi/fastapi/pull/13864) by [@Amogha-ark](https://github.com/Amogha-ark).
  * ğŸ“Œ Pin `httpx` to `>=0.23.0,<1.0.0`. PR [#14086](https://github.com/fastapi/fastapi/pull/14086) by [@YuriiMotov](https://github.com/YuriiMotov).

### Docs[¶](#docs_17 "Permanent link")

  * ğŸ“� Add note about Cookies and JavaScript on `tutorial/cookie-params.md`. PR [#13510](https://github.com/fastapi/fastapi/pull/13510) by [@Kludex](https://github.com/Kludex).
  * ğŸ“� Remove outdated formatting from `path-params-numeric-validations.md` for languages `en`, `es` and `uk`.. PR [#14059](https://github.com/fastapi/fastapi/pull/14059) by [@svlandeg](https://github.com/svlandeg).
  * ğŸ“� Fix and Improve English Documentation. PR [#14048](https://github.com/fastapi/fastapi/pull/14048) by [@nilslindemann](https://github.com/nilslindemann).

### Translations[¶](#translations_12 "Permanent link")

  * ğŸ“� Update prompts and German translation. PR [#14015](https://github.com/fastapi/fastapi/pull/14015) by [@nilslindemann](https://github.com/nilslindemann).

### Internal[¶](#internal_22 "Permanent link")

  * âœ… Simplify tests for response_model. PR [#14062](https://github.com/fastapi/fastapi/pull/14062) by [@dynamicy](https://github.com/dynamicy).
  * ğŸš¨ Install pydantic.mypy plugin. PR [#14081](https://github.com/fastapi/fastapi/pull/14081) by [@svlandeg](https://github.com/svlandeg).
  * âœ… Add LLM test file. PR [#14049](https://github.com/fastapi/fastapi/pull/14049) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸ”¨ Update translations script. PR [#13968](https://github.com/fastapi/fastapi/pull/13968) by [@YuriiMotov](https://github.com/YuriiMotov).
  * ğŸ› ï¸� Update `docs.py generate-readme` command to remove permalinks from headers. PR [#14055](https://github.com/fastapi/fastapi/pull/14055) by [@YuriiMotov](https://github.com/YuriiMotov).
  * â¬†ï¸� Update mypy to 1.14.1. PR [#12970](https://github.com/fastapi/fastapi/pull/12970) by [@tamird](https://github.com/tamird).

## 0.116.2[¶](#01162 "Permanent link")

### Upgrades[¶](#upgrades_5 "Permanent link")

  * â¬†ï¸� Upgrade Starlette supported version range to >=0.40.0,<0.49.0. PR [#14077](https://github.com/fastapi/fastapi/pull/14077) by [@musicinmybrain](https://github.com/musicinmybrain).

### Docs[¶](#docs_18 "Permanent link")

  * ğŸ“� Add documentation for Behind a Proxy - Proxy Forwarded Headers, using `--forwarded-allow-ips="*"`. PR [#14028](https://github.com/fastapi/fastapi/pull/14028) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ“� Add deprecation info block about `dict()` in `docs/tutorial/body.md`. PR [#13906](https://github.com/fastapi/fastapi/pull/13906) by [@jomkv](https://github.com/jomkv).
  * ğŸ“� Fix Twitter to be X (Twitter) everywhere in documentation. PR [#13809](https://github.com/fastapi/fastapi/pull/13809) by [@valentinDruzhinin](https://github.com/valentinDruzhinin).
  * ğŸ�› Prevent scroll-to-top on restart/fast buttons in `termynal.js`. PR [#13714](https://github.com/fastapi/fastapi/pull/13714) by [@Ashish-Pandey62](https://github.com/Ashish-Pandey62).
  * ğŸ“� Update testing events documentation. PR [#13259](https://github.com/fastapi/fastapi/pull/13259) by [@z0z0r4](https://github.com/z0z0r4).
  * ğŸ“� Remove obsolete `url` field in error responses in docs. PR [#13655](https://github.com/fastapi/fastapi/pull/13655) by [@Taoup](https://github.com/Taoup).
  * ğŸ“� Bring the `scope` claim in line with the standard in `docs_src/security/tutorial005.py`. PR [#11189](https://github.com/fastapi/fastapi/pull/11189) by [@DurandA](https://github.com/DurandA).
  * ğŸ“� Update TrustedHostMiddleware Documentation. PR [#11441](https://github.com/fastapi/fastapi/pull/11441) by [@soulee-dev](https://github.com/soulee-dev).
  * ğŸ“� Remove links to site callbackhell.com that doesn't exist anymore. PR [#14006](https://github.com/fastapi/fastapi/pull/14006) by [@dennybiasiolli](https://github.com/dennybiasiolli).
  * ğŸ“� Add permalinks to headers in English docs. PR [#13993](https://github.com/fastapi/fastapi/pull/13993) by [@YuriiMotov](https://github.com/YuriiMotov).
  * ğŸ“� Update `docs/en/docs/advanced/generate-clients.md`. PR [#13793](https://github.com/fastapi/fastapi/pull/13793) by [@mrlubos](https://github.com/mrlubos).
  * ğŸ“� Add discussion template for new language translation requests. PR [#13535](https://github.com/fastapi/fastapi/pull/13535) by [@alejsdev](https://github.com/alejsdev).

### Translations[¶](#translations_13 "Permanent link")

  * ğŸ“� Fix code include for Pydantic models example in `docs/zh/docs/python-types.md`. PR [#13997](https://github.com/fastapi/fastapi/pull/13997) by [@anfreshman](https://github.com/anfreshman).
  * ğŸŒ� Update Portuguese Translation for `docs/pt/docs/async.md`. PR [#13863](https://github.com/fastapi/fastapi/pull/13863) by [@EdmilsonRodrigues](https://github.com/EdmilsonRodrigues).
  * ğŸ“� Fix highlight line in `docs/ja/docs/tutorial/body.md`. PR [#13927](https://github.com/fastapi/fastapi/pull/13927) by [@KoyoMiyazaki](https://github.com/KoyoMiyazaki).
  * ğŸŒ� Add Persian translation for `docs/fa/docs/environment-variables.md`. PR [#13923](https://github.com/fastapi/fastapi/pull/13923) by [@Mohammad222PR](https://github.com/Mohammad222PR).
  * ğŸŒ� Add Persian translation for `docs/fa/docs/python-types.md`. PR [#13524](https://github.com/fastapi/fastapi/pull/13524) by [@Mohammad222PR](https://github.com/Mohammad222PR).
  * ğŸŒ� Update Portuguese Translation for `docs/pt/docs/project-generation.md`. PR [#13875](https://github.com/fastapi/fastapi/pull/13875) by [@EdmilsonRodrigues](https://github.com/EdmilsonRodrigues).
  * ğŸŒ� Add Persian translation for `docs/fa/docs/async.md`. PR [#13541](https://github.com/fastapi/fastapi/pull/13541) by [@Mohammad222PR](https://github.com/Mohammad222PR).
  * ğŸŒ� Add Bangali translation for `docs/bn/about/index.md`. PR [#13882](https://github.com/fastapi/fastapi/pull/13882) by [@sajjadrahman56](https://github.com/sajjadrahman56).

### Internal[¶](#internal_23 "Permanent link")

  * â¬† Bump pyjwt from 2.8.0 to 2.9.0. PR [#13960](https://github.com/fastapi/fastapi/pull/13960) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * â¬† [pre-commit.ci] pre-commit autoupdate. PR [#14080](https://github.com/fastapi/fastapi/pull/14080) by [@pre-commit-ci[bot]](https://github.com/apps/pre-commit-ci).
  * â¬† Bump actions/setup-python from 5 to 6. PR [#14042](https://github.com/fastapi/fastapi/pull/14042) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * â¬† Bump actions/labeler from 5 to 6. PR [#14046](https://github.com/fastapi/fastapi/pull/14046) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * â¬† [pre-commit.ci] pre-commit autoupdate. PR [#14056](https://github.com/fastapi/fastapi/pull/14056) by [@pre-commit-ci[bot]](https://github.com/apps/pre-commit-ci).
  * â¬† [pre-commit.ci] pre-commit autoupdate. PR [#14035](https://github.com/fastapi/fastapi/pull/14035) by [@pre-commit-ci[bot]](https://github.com/apps/pre-commit-ci).
  * â¬† Bump pypa/gh-action-pypi-publish from 1.12.4 to 1.13.0. PR [#14041](https://github.com/fastapi/fastapi/pull/14041) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * ğŸ‘¥ Update FastAPI People - Contributors and Translators. PR [#14029](https://github.com/fastapi/fastapi/pull/14029) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘¥ Update FastAPI People - Sponsors. PR [#14030](https://github.com/fastapi/fastapi/pull/14030) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘¥ Update FastAPI GitHub topic repositories. PR [#14031](https://github.com/fastapi/fastapi/pull/14031) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘¥ Update FastAPI People - Experts. PR [#14034](https://github.com/fastapi/fastapi/pull/14034) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘· Detect and label merge conflicts on PRs automatically. PR [#14045](https://github.com/fastapi/fastapi/pull/14045) by [@svlandeg](https://github.com/svlandeg).
  * ğŸ”§ Update sponsors: remove Platform.sh. PR [#14027](https://github.com/fastapi/fastapi/pull/14027) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”§ Update sponsors: remove Mobb. PR [#14026](https://github.com/fastapi/fastapi/pull/14026) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ› ï¸� Update `mkdocs_hooks` to handle headers with permalinks when building docs. PR [#14025](https://github.com/fastapi/fastapi/pull/14025) by [@tiangolo](https://github.com/tiangolo).
  * â¬† [pre-commit.ci] pre-commit autoupdate. PR [#14016](https://github.com/fastapi/fastapi/pull/14016) by [@pre-commit-ci[bot]](https://github.com/apps/pre-commit-ci).
  * â¬† Bump `mkdocs-macros-plugin` from 1.3.7 to 1.3.9. PR [#14003](https://github.com/fastapi/fastapi/pull/14003) by [@YuriiMotov](https://github.com/YuriiMotov).
  * â¬† [pre-commit.ci] pre-commit autoupdate. PR [#13999](https://github.com/fastapi/fastapi/pull/13999) by [@pre-commit-ci[bot]](https://github.com/apps/pre-commit-ci).
  * â¬† [pre-commit.ci] pre-commit autoupdate. PR [#13983](https://github.com/fastapi/fastapi/pull/13983) by [@pre-commit-ci[bot]](https://github.com/apps/pre-commit-ci).
  * â¬† Bump actions/checkout from 4 to 5. PR [#13986](https://github.com/fastapi/fastapi/pull/13986) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * ğŸ”§ Update Speakeasy sponsor graphic. PR [#13971](https://github.com/fastapi/fastapi/pull/13971) by [@chailandau](https://github.com/chailandau).
  * â¬† [pre-commit.ci] pre-commit autoupdate. PR [#13969](https://github.com/fastapi/fastapi/pull/13969) by [@pre-commit-ci[bot]](https://github.com/apps/pre-commit-ci).
  * â¬† Bump actions/download-artifact from 4 to 5. PR [#13975](https://github.com/fastapi/fastapi/pull/13975) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * ğŸ‘¥ Update FastAPI People - Experts. PR [#13963](https://github.com/fastapi/fastapi/pull/13963) by [@tiangolo](https://github.com/tiangolo).
  * â¬† Bump ruff from 0.11.2 to 0.12.7. PR [#13957](https://github.com/fastapi/fastapi/pull/13957) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * â¬† Bump cairosvg from 2.7.1 to 2.8.2. PR [#13959](https://github.com/fastapi/fastapi/pull/13959) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * â¬† Bump pydantic-ai from 0.0.30 to 0.4.10. PR [#13958](https://github.com/fastapi/fastapi/pull/13958) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * ğŸ‘¥ Update FastAPI GitHub topic repositories. PR [#13962](https://github.com/fastapi/fastapi/pull/13962) by [@tiangolo](https://github.com/tiangolo).
  * â¬† Bump mkdocs-material from 9.6.15 to 9.6.16. PR [#13961](https://github.com/fastapi/fastapi/pull/13961) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * â¬† Bump tiangolo/latest-changes from 0.3.2 to 0.4.0. PR [#13952](https://github.com/fastapi/fastapi/pull/13952) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * ğŸ‘¥ Update FastAPI People - Sponsors. PR [#13956](https://github.com/fastapi/fastapi/pull/13956) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘¥ Update FastAPI People - Contributors and Translators. PR [#13955](https://github.com/fastapi/fastapi/pull/13955) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”§ Update sponsors: Databento link and sponsors_badge data. PR [#13954](https://github.com/fastapi/fastapi/pull/13954) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”§ Update sponsors: Add Railway. PR [#13953](https://github.com/fastapi/fastapi/pull/13953) by [@tiangolo](https://github.com/tiangolo).
  * âš’ï¸� Update translate script, update prompt to minimize generated diff. PR [#13947](https://github.com/fastapi/fastapi/pull/13947) by [@YuriiMotov](https://github.com/YuriiMotov).
  * â¬† [pre-commit.ci] pre-commit autoupdate. PR [#13943](https://github.com/fastapi/fastapi/pull/13943) by [@pre-commit-ci[bot]](https://github.com/apps/pre-commit-ci).
  * âš’ï¸� Tweak translate script and CI. PR [#13939](https://github.com/fastapi/fastapi/pull/13939) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘· Add CI to translate with LLMs. PR [#13937](https://github.com/fastapi/fastapi/pull/13937) by [@tiangolo](https://github.com/tiangolo).
  * âš’ï¸� Update translate script, show and update outdated translations. PR [#13933](https://github.com/fastapi/fastapi/pull/13933) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”¨ Refactor translate script with extra feedback (prints). PR [#13932](https://github.com/fastapi/fastapi/pull/13932) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”¨ Update translations script to remove old (removed) files. PR [#13928](https://github.com/fastapi/fastapi/pull/13928) by [@tiangolo](https://github.com/tiangolo).
  * â¬† [pre-commit.ci] pre-commit autoupdate. PR [#13894](https://github.com/fastapi/fastapi/pull/13894) by [@pre-commit-ci[bot]](https://github.com/apps/pre-commit-ci).
  * â¬† Update httpx requirement to >=0.23.0,<0.29.0. PR [#13114](https://github.com/fastapi/fastapi/pull/13114) by [@yan12125](https://github.com/yan12125).
  * ğŸ”§ Update sponsors: Add Mobb. PR [#13916](https://github.com/fastapi/fastapi/pull/13916) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘¥ Update FastAPI People - Experts. PR [#13889](https://github.com/fastapi/fastapi/pull/13889) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”¨ Update FastAPI People sleep interval, use external settings. PR [#13888](https://github.com/fastapi/fastapi/pull/13888) by [@tiangolo](https://github.com/tiangolo).

## 0.116.1[¶](#01161 "Permanent link")

### Upgrades[¶](#upgrades_6 "Permanent link")

  * â¬†ï¸� Upgrade Starlette supported version range to `>=0.40.0,<0.48.0`. PR [#13884](https://github.com/fastapi/fastapi/pull/13884) by [@tiangolo](https://github.com/tiangolo).

### Docs[¶](#docs_19 "Permanent link")

  * ğŸ“� Add notification about impending changes in Translations to `docs/en/docs/contributing.md`. PR [#13886](https://github.com/fastapi/fastapi/pull/13886) by [@YuriiMotov](https://github.com/YuriiMotov).

### Internal[¶](#internal_24 "Permanent link")

  * â¬† [pre-commit.ci] pre-commit autoupdate. PR [#13871](https://github.com/fastapi/fastapi/pull/13871) by [@pre-commit-ci[bot]](https://github.com/apps/pre-commit-ci).

## 0.116.0[¶](#01160 "Permanent link")

### Features[¶](#features_7 "Permanent link")

  * âœ¨ Add support for deploying to FastAPI Cloud with `fastapi deploy`. PR [#13870](https://github.com/fastapi/fastapi/pull/13870) by [@tiangolo](https://github.com/tiangolo).

Installing `fastapi[standard]` now includes `fastapi-cloud-cli`.

This will allow you to deploy to [FastAPI Cloud](https://fastapicloud.com) with the `fastapi deploy` command.

If you want to install `fastapi` with the standard dependencies but without `fastapi-cloud-cli`, you can install instead `fastapi[standard-no-fastapi-cloud-cli]`.

### Translations[¶](#translations_14 "Permanent link")

  * ğŸŒ� Add Russian translation for `docs/ru/docs/advanced/response-directly.md`. PR [#13801](https://github.com/fastapi/fastapi/pull/13801) by [@NavesSapnis](https://github.com/NavesSapnis).
  * ğŸŒ� Add Russian translation for `docs/ru/docs/advanced/additional-status-codes.md`. PR [#13799](https://github.com/fastapi/fastapi/pull/13799) by [@NavesSapnis](https://github.com/NavesSapnis).
  * ğŸŒ� Add Ukrainian translation for `docs/uk/docs/tutorial/body-updates.md`. PR [#13804](https://github.com/fastapi/fastapi/pull/13804) by [@valentinDruzhinin](https://github.com/valentinDruzhinin).

### Internal[¶](#internal_25 "Permanent link")

  * â¬† Bump pillow from 11.1.0 to 11.3.0. PR [#13852](https://github.com/fastapi/fastapi/pull/13852) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * ğŸ‘¥ Update FastAPI People - Sponsors. PR [#13846](https://github.com/fastapi/fastapi/pull/13846) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘¥ Update FastAPI GitHub topic repositories. PR [#13848](https://github.com/fastapi/fastapi/pull/13848) by [@tiangolo](https://github.com/tiangolo).
  * â¬† Bump mkdocs-material from 9.6.1 to 9.6.15. PR [#13849](https://github.com/fastapi/fastapi/pull/13849) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * â¬† [pre-commit.ci] pre-commit autoupdate. PR [#13843](https://github.com/fastapi/fastapi/pull/13843) by [@pre-commit-ci[bot]](https://github.com/apps/pre-commit-ci).
  * ğŸ‘¥ Update FastAPI People - Contributors and Translators. PR [#13845](https://github.com/fastapi/fastapi/pull/13845) by [@tiangolo](https://github.com/tiangolo).

## 0.115.14[¶](#011514 "Permanent link")

### Fixes[¶](#fixes_28 "Permanent link")

  * ğŸ�› Fix support for unions when using `Form`. PR [#13827](https://github.com/fastapi/fastapi/pull/13827) by [@patrick91](https://github.com/patrick91).

### Docs[¶](#docs_20 "Permanent link")

  * âœ�ï¸� Fix grammar mistake in `docs/en/docs/advanced/response-directly.md`. PR [#13800](https://github.com/fastapi/fastapi/pull/13800) by [@NavesSapnis](https://github.com/NavesSapnis).
  * ğŸ“� Update Speakeasy URL to Speakeasy Sandbox. PR [#13697](https://github.com/fastapi/fastapi/pull/13697) by [@ndimares](https://github.com/ndimares).

### Translations[¶](#translations_15 "Permanent link")

  * ğŸŒ� Add Ukrainian translation for `docs/uk/docs/tutorial/response-model.md`. PR [#13792](https://github.com/fastapi/fastapi/pull/13792) by [@valentinDruzhinin](https://github.com/valentinDruzhinin).
  * ğŸŒ� Add Ukrainian translation for `docs/uk/docs/tutorial/security/index.md`. PR [#13805](https://github.com/fastapi/fastapi/pull/13805) by [@valentinDruzhinin](https://github.com/valentinDruzhinin).
  * âœ�ï¸� Fix typo in `docs/ja/docs/tutorial/encoder.md`. PR [#13815](https://github.com/fastapi/fastapi/pull/13815) by [@ruzia](https://github.com/ruzia).
  * âœ�ï¸� Fix typo in `docs/ja/docs/tutorial/handling-errors.md`. PR [#13814](https://github.com/fastapi/fastapi/pull/13814) by [@ruzia](https://github.com/ruzia).
  * âœ�ï¸� Fix typo in `docs/ja/docs/tutorial/body-fields.md`. PR [#13802](https://github.com/fastapi/fastapi/pull/13802) by [@ruzia](https://github.com/ruzia).
  * ğŸŒ� Add Russian translation for `docs/ru/docs/advanced/index.md`. PR [#13797](https://github.com/fastapi/fastapi/pull/13797) by [@NavesSapnis](https://github.com/NavesSapnis).

### Internal[¶](#internal_26 "Permanent link")

  * â¬† [pre-commit.ci] pre-commit autoupdate. PR [#13823](https://github.com/fastapi/fastapi/pull/13823) by [@pre-commit-ci[bot]](https://github.com/apps/pre-commit-ci).

## 0.115.13[¶](#011513 "Permanent link")

### Fixes[¶](#fixes_29 "Permanent link")

  * ğŸ�› Fix truncating the model's description with form feed (`\f`) character for Pydantic V2. PR [#13698](https://github.com/fastapi/fastapi/pull/13698) by [@YuriiMotov](https://github.com/YuriiMotov).

### Refactors[¶](#refactors_8 "Permanent link")

  * âœ¨ Add `refreshUrl` parameter in `OAuth2PasswordBearer`. PR [#11460](https://github.com/fastapi/fastapi/pull/11460) by [@snosratiershad](https://github.com/snosratiershad).
  * ğŸš¸ Set format to password for fields `password` and `client_secret` in `OAuth2PasswordRequestForm`, make docs show password fields for passwords. PR [#11032](https://github.com/fastapi/fastapi/pull/11032) by [@Thodoris1999](https://github.com/Thodoris1999).
  * âœ… Simplify tests for `settings`. PR [#13505](https://github.com/fastapi/fastapi/pull/13505) by [@valentinDruzhinin](https://github.com/valentinDruzhinin).
  * âœ… Simplify tests for `validate_response_recursive`. PR [#13507](https://github.com/fastapi/fastapi/pull/13507) by [@valentinDruzhinin](https://github.com/valentinDruzhinin).

### Upgrades[¶](#upgrades_7 "Permanent link")

  * â¬†ï¸� Update ReDoc to version 2.x. PR [#9700](https://github.com/fastapi/fastapi/pull/9700) by [@joakimnordling](https://github.com/joakimnordling).

### Docs[¶](#docs_21 "Permanent link")

  * ğŸ“� Add annotations to HTTP middleware example. PR [#11530](https://github.com/fastapi/fastapi/pull/11530) by [@Kilo59](https://github.com/Kilo59).
  * ğŸ“� Clarify in CORS docs that wildcards and credentials are mutually exclusive. PR [#9829](https://github.com/fastapi/fastapi/pull/9829) by [@dfioravanti](https://github.com/dfioravanti).
  * âœ�ï¸� Fix typo in docstring. PR [#13532](https://github.com/fastapi/fastapi/pull/13532) by [@comp64](https://github.com/comp64).
  * ğŸ“� Clarify guidance on using `async def` without `await`. PR [#13642](https://github.com/fastapi/fastapi/pull/13642) by [@swastikpradhan1999](https://github.com/swastikpradhan1999).
  * ğŸ“� Update exclude-parameters-from-openapi documentation links. PR [#13600](https://github.com/fastapi/fastapi/pull/13600) by [@timonrieger](https://github.com/timonrieger).
  * ğŸ“� Clarify the middleware execution order in docs. PR [#13699](https://github.com/fastapi/fastapi/pull/13699) by [@YuriiMotov](https://github.com/YuriiMotov).
  * ğŸ�± Update Drawio diagrams SVGs, single file per diagram, sans-serif font. PR [#13706](https://github.com/fastapi/fastapi/pull/13706) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ“� Update docs for "Help FastAPI", simplify and reduce "sponsor" section. PR [#13670](https://github.com/fastapi/fastapi/pull/13670) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ“� Remove unnecessary bullet from docs. PR [#13641](https://github.com/fastapi/fastapi/pull/13641) by [@Adamowoc](https://github.com/Adamowoc).
  * âœ�ï¸� Fix syntax error in `docs/en/docs/tutorial/handling-errors.md`. PR [#13623](https://github.com/fastapi/fastapi/pull/13623) by [@gsheni](https://github.com/gsheni).
  * ğŸ“� Fix typo in documentation. PR [#13599](https://github.com/fastapi/fastapi/pull/13599) by [@Taoup](https://github.com/Taoup).
  * ğŸ“� Fix liblab client generation doc link. PR [#13571](https://github.com/fastapi/fastapi/pull/13571) by [@EFord36](https://github.com/EFord36).
  * âœ�ï¸� Fix talk information typo. PR [#13544](https://github.com/fastapi/fastapi/pull/13544) by [@blueswen](https://github.com/blueswen).
  * ğŸ“� Add External Link: Taiwanese talk on FastAPI with observability . PR [#13527](https://github.com/fastapi/fastapi/pull/13527) by [@blueswen](https://github.com/blueswen).

### Translations[¶](#translations_16 "Permanent link")

  * ğŸŒ� Add Russian Translation for `docs/ru/docs/advanced/response-change-status-code.md`. PR [#13791](https://github.com/fastapi/fastapi/pull/13791) by [@NavesSapnis](https://github.com/NavesSapnis).
  * ğŸŒ� Add Persian translation for `docs/fa/docs/learn/index.md`. PR [#13518](https://github.com/fastapi/fastapi/pull/13518) by [@Mohammad222PR](https://github.com/Mohammad222PR).
  * ğŸŒ� Add Korean translation for `docs/ko/docs/advanced/sub-applications.md`. PR [#4543](https://github.com/fastapi/fastapi/pull/4543) by [@NinaHwang](https://github.com/NinaHwang).
  * ğŸŒ� Add Ukrainian translation for `docs/uk/docs/tutorial/schema-extra-example.md`. PR [#13769](https://github.com/fastapi/fastapi/pull/13769) by [@valentinDruzhinin](https://github.com/valentinDruzhinin).
  * âœ�ï¸� Remove redundant words in docs/zh/docs/python-types.md. PR [#13774](https://github.com/fastapi/fastapi/pull/13774) by [@CharleeWa](https://github.com/CharleeWa).
  * ğŸŒ� Add Ukrainian translation for `docs/uk/docs/tutorial/query-param-models.md`. PR [#13748](https://github.com/fastapi/fastapi/pull/13748) by [@valentinDruzhinin](https://github.com/valentinDruzhinin).
  * ğŸŒ� Add Bengali translation for `docs/bn/docs/environment-variables.md`. PR [#13629](https://github.com/fastapi/fastapi/pull/13629) by [@SakibSibly](https://github.com/SakibSibly).
  * ğŸŒ� Add Ukrainian translation for `docs/uk/docs/tutorial/query-params-str-validations.md` page. PR [#13546](https://github.com/fastapi/fastapi/pull/13546) by [@valentinDruzhinin](https://github.com/valentinDruzhinin).
  * ğŸŒ� Add Russian translation for `docs/ru/docs/tutorial/cookie-param-models.md`. PR [#13616](https://github.com/fastapi/fastapi/pull/13616) by [@EgorOnishchuk](https://github.com/EgorOnishchuk).
  * ğŸŒ� Add Korean translation for `docs/ko/docs/tutorial/extra-models.md`. PR [#13063](https://github.com/fastapi/fastapi/pull/13063) by [@timothy-jeong](https://github.com/timothy-jeong).
  * ğŸŒ� Add Ukrainian translation for `docs/uk/docs/tutorial/path-params-numeric-validations.md` page. PR [#13548](https://github.com/fastapi/fastapi/pull/13548) by [@valentinDruzhinin](https://github.com/valentinDruzhinin).
  * ğŸŒ� Add Ukrainian translation for `docs/uk/docs/tutorial/middleware.md` page. PR [#13520](https://github.com/fastapi/fastapi/pull/13520) by [@valentinDruzhinin](https://github.com/valentinDruzhinin).
  * ğŸŒ� Add Ukrainian translation for `docs/uk/docs/tutorial/background-tasks.md` page. PR [#13502](https://github.com/fastapi/fastapi/pull/13502) by [@valentinDruzhinin](https://github.com/valentinDruzhinin).
  * ğŸŒ� Add Ukrainian translation for `docs/uk/docs/tutorial/cors.md` page. PR [#13519](https://github.com/fastapi/fastapi/pull/13519) by [@valentinDruzhinin](https://github.com/valentinDruzhinin).
  * ğŸŒ� Update Korean translation for `docs/ko/docs/advanced/events.md`. PR [#13487](https://github.com/fastapi/fastapi/pull/13487) by [@bom1215](https://github.com/bom1215).
  * ğŸŒ� Add Ukrainian translation for `docs/uk/docs/tutorial/handling-errors.md` page. PR [#13420](https://github.com/fastapi/fastapi/pull/13420) by [@valentinDruzhinin](https://github.com/valentinDruzhinin).
  * ğŸŒ� Add Russian translation for `docs/ru/docs/tutorial/request-form-models.md`. PR [#13552](https://github.com/fastapi/fastapi/pull/13552) by [@EgorOnishchuk](https://github.com/EgorOnishchuk).
  * ğŸ“� Fix internal anchor link in Spanish deployment docs. PR [#13737](https://github.com/fastapi/fastapi/pull/13737) by [@fabianfalon](https://github.com/fabianfalon).
  * ğŸŒ� Update Korean translation for `docs/ko/docs/virtual-environments.md`. PR [#13630](https://github.com/fastapi/fastapi/pull/13630) by [@sungchan1](https://github.com/sungchan1).
  * ğŸŒ� Add Russian translation for `docs/ru/docs/tutorial/header-param-models.md`. PR [#13526](https://github.com/fastapi/fastapi/pull/13526) by [@minaton-ru](https://github.com/minaton-ru).
  * ğŸŒ� Update Chinese translation for `docs/zh/docs/tutorial/index.md`. PR [#13374](https://github.com/fastapi/fastapi/pull/13374) by [@Zhongheng-Cheng](https://github.com/Zhongheng-Cheng).
  * ğŸŒ� Update Chinese translation for `docs/zh/docs/deployment/manually.md`. PR [#13324](https://github.com/fastapi/fastapi/pull/13324) by [@Zhongheng-Cheng](https://github.com/Zhongheng-Cheng).
  * ğŸŒ� Update Chinese translation for `docs/zh/docs/deployment/server-workers.md`. PR [#13292](https://github.com/fastapi/fastapi/pull/13292) by [@Zhongheng-Cheng](https://github.com/Zhongheng-Cheng).
  * ğŸŒ� Update Chinese translation for `docs/zh/docs/tutorial/first-steps.md`. PR [#13348](https://github.com/fastapi/fastapi/pull/13348) by [@Zhongheng-Cheng](https://github.com/Zhongheng-Cheng).

### Internal[¶](#internal_27 "Permanent link")

  * ğŸ”¨ Resolve Pydantic deprecation warnings in internal script. PR [#13696](https://github.com/fastapi/fastapi/pull/13696) by [@emmanuel-ferdman](https://github.com/emmanuel-ferdman).
  * ğŸ”§ Update sponsors: remove Porter. PR [#13783](https://github.com/fastapi/fastapi/pull/13783) by [@tiangolo](https://github.com/tiangolo).
  * â¬† [pre-commit.ci] pre-commit autoupdate. PR [#13781](https://github.com/fastapi/fastapi/pull/13781) by [@pre-commit-ci[bot]](https://github.com/apps/pre-commit-ci).
  * â¬† [pre-commit.ci] pre-commit autoupdate. PR [#13757](https://github.com/fastapi/fastapi/pull/13757) by [@pre-commit-ci[bot]](https://github.com/apps/pre-commit-ci).
  * â¬† Bump griffe-typingdoc from 0.2.7 to 0.2.8. PR [#13751](https://github.com/fastapi/fastapi/pull/13751) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * ğŸ�± Update sponsors: Dribia badge size. PR [#13773](https://github.com/fastapi/fastapi/pull/13773) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”§ Update sponsors: add Dribia. PR [#13771](https://github.com/fastapi/fastapi/pull/13771) by [@tiangolo](https://github.com/tiangolo).
  * â¬† Bump typer from 0.15.3 to 0.16.0. PR [#13752](https://github.com/fastapi/fastapi/pull/13752) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * ğŸ‘¥ Update FastAPI GitHub topic repositories. PR [#13754](https://github.com/fastapi/fastapi/pull/13754) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘¥ Update FastAPI People - Sponsors. PR [#13750](https://github.com/fastapi/fastapi/pull/13750) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘¥ Update FastAPI People - Contributors and Translators. PR [#13749](https://github.com/fastapi/fastapi/pull/13749) by [@tiangolo](https://github.com/tiangolo).
  * â¬† [pre-commit.ci] pre-commit autoupdate. PR [#13736](https://github.com/fastapi/fastapi/pull/13736) by [@pre-commit-ci[bot]](https://github.com/apps/pre-commit-ci).
  * ğŸ”§ Update sponsors: Add InterviewPal. PR [#13728](https://github.com/fastapi/fastapi/pull/13728) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”§ Remove Google Analytics. PR [#13727](https://github.com/fastapi/fastapi/pull/13727) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”§ Update sponsors: remove MongoDB. PR [#13725](https://github.com/fastapi/fastapi/pull/13725) by [@tiangolo](https://github.com/tiangolo).
  * â¬† [pre-commit.ci] pre-commit autoupdate. PR [#13711](https://github.com/fastapi/fastapi/pull/13711) by [@pre-commit-ci[bot]](https://github.com/apps/pre-commit-ci).
  * ğŸ”§ Update sponsors: add Subtotal. PR [#13701](https://github.com/fastapi/fastapi/pull/13701) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”§ Update sponsors: remove deepset / Haystack. PR [#13700](https://github.com/fastapi/fastapi/pull/13700) by [@tiangolo](https://github.com/tiangolo).
  * â¬† [pre-commit.ci] pre-commit autoupdate. PR [#13688](https://github.com/fastapi/fastapi/pull/13688) by [@pre-commit-ci[bot]](https://github.com/apps/pre-commit-ci).
  * ğŸ‘¥ Update FastAPI People - Experts. PR [#13671](https://github.com/fastapi/fastapi/pull/13671) by [@tiangolo](https://github.com/tiangolo).
  * â¬† Bump typer from 0.12.5 to 0.15.3. PR [#13666](https://github.com/fastapi/fastapi/pull/13666) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * â¬† Bump sqlmodel from 0.0.23 to 0.0.24. PR [#13665](https://github.com/fastapi/fastapi/pull/13665) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * ğŸ”§ Update Sponsors: Zuplo logo and alt text. PR [#13645](https://github.com/fastapi/fastapi/pull/13645) by [@martyndavies](https://github.com/martyndavies).
  * ğŸ‘¥ Update FastAPI GitHub topic repositories. PR [#13667](https://github.com/fastapi/fastapi/pull/13667) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”§ Update links for LinkedIn and bottom. PR [#13669](https://github.com/fastapi/fastapi/pull/13669) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”§ Update sponsors: remove Bump.sh and Coherence. PR [#13668](https://github.com/fastapi/fastapi/pull/13668) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘¥ Update FastAPI People - Sponsors. PR [#13664](https://github.com/fastapi/fastapi/pull/13664) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘¥ Update FastAPI People - Contributors and Translators. PR [#13662](https://github.com/fastapi/fastapi/pull/13662) by [@tiangolo](https://github.com/tiangolo).
  * â¬† [pre-commit.ci] pre-commit autoupdate. PR [#13656](https://github.com/fastapi/fastapi/pull/13656) by [@pre-commit-ci[bot]](https://github.com/apps/pre-commit-ci).
  * âœ… Use `inline-snapshot` to support different Pydantic versions in the test suite. PR [#12534](https://github.com/fastapi/fastapi/pull/12534) by [@15r10nk](https://github.com/15r10nk).
  * â¬† Bump astral-sh/setup-uv from 5 to 6. PR [#13648](https://github.com/fastapi/fastapi/pull/13648) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * â¬† [pre-commit.ci] pre-commit autoupdate. PR [#13634](https://github.com/fastapi/fastapi/pull/13634) by [@pre-commit-ci[bot]](https://github.com/apps/pre-commit-ci).
  * â¬† [pre-commit.ci] pre-commit autoupdate. PR [#13619](https://github.com/fastapi/fastapi/pull/13619) by [@pre-commit-ci[bot]](https://github.com/apps/pre-commit-ci).
  * â¬† [pre-commit.ci] pre-commit autoupdate. PR [#13594](https://github.com/fastapi/fastapi/pull/13594) by [@pre-commit-ci[bot]](https://github.com/apps/pre-commit-ci).
  * ğŸ‘¥ Update FastAPI People - Experts. PR [#13568](https://github.com/fastapi/fastapi/pull/13568) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘¥ Update FastAPI GitHub topic repositories. PR [#13565](https://github.com/fastapi/fastapi/pull/13565) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘¥ Update FastAPI People - Sponsors. PR [#13559](https://github.com/fastapi/fastapi/pull/13559) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘¥ Update FastAPI People - Contributors and Translators. PR [#13558](https://github.com/fastapi/fastapi/pull/13558) by [@tiangolo](https://github.com/tiangolo).
  * â¬† Bump dirty-equals from 0.8.0 to 0.9.0. PR [#13561](https://github.com/fastapi/fastapi/pull/13561) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * ğŸ”§ Clean up `docs/en/mkdocs.yml` configuration file. PR [#13542](https://github.com/fastapi/fastapi/pull/13542) by [@svlandeg](https://github.com/svlandeg).
  * â¬† [pre-commit.ci] pre-commit autoupdate. PR [#12986](https://github.com/fastapi/fastapi/pull/12986) by [@pre-commit-ci[bot]](https://github.com/apps/pre-commit-ci).

## 0.115.12[¶](#011512 "Permanent link")

### Fixes[¶](#fixes_30 "Permanent link")

  * ğŸ�› Fix `convert_underscores=False` for header Pydantic models. PR [#13515](https://github.com/fastapi/fastapi/pull/13515) by [@tiangolo](https://github.com/tiangolo).

### Docs[¶](#docs_22 "Permanent link")

  * ğŸ“� Update `docs/en/docs/tutorial/middleware.md`. PR [#13444](https://github.com/fastapi/fastapi/pull/13444) by [@Rishat-F](https://github.com/Rishat-F).
  * ğŸ‘¥ Update FastAPI People - Experts. PR [#13493](https://github.com/fastapi/fastapi/pull/13493) by [@tiangolo](https://github.com/tiangolo).

### Translations[¶](#translations_17 "Permanent link")

  * ğŸŒ� Add Ukrainian translation for `docs/uk/docs/tutorial/metadata.md` page. PR [#13459](https://github.com/fastapi/fastapi/pull/13459) by [@valentinDruzhinin](https://github.com/valentinDruzhinin).
  * ğŸŒ� Add Ukrainian translation for `docs/uk/docs/tutorial/response-status-code.md` page. PR [#13462](https://github.com/fastapi/fastapi/pull/13462) by [@valentinDruzhinin](https://github.com/valentinDruzhinin).
  * ğŸŒ� Add Ukrainian translation for `docs/uk/docs/tutorial/cookie-param-models.md` page. PR [#13460](https://github.com/fastapi/fastapi/pull/13460) by [@valentinDruzhinin](https://github.com/valentinDruzhinin).
  * ğŸŒ� Add Ukrainian translation for `docs/uk/docs/tutorial/header-param-models.md` page. PR [#13461](https://github.com/fastapi/fastapi/pull/13461) by [@valentinDruzhinin](https://github.com/valentinDruzhinin).
  * ğŸŒ� Add Japanese translation for `docs/ja/docs/virtual-environments.md`. PR [#13304](https://github.com/fastapi/fastapi/pull/13304) by [@k94-ishi](https://github.com/k94-ishi).
  * ğŸŒ� Add Korean translation for `docs/ko/docs/tutorial/security/oauth2-jwt.md`. PR [#13333](https://github.com/fastapi/fastapi/pull/13333) by [@yes0ng](https://github.com/yes0ng).
  * ğŸŒ� Add Vietnamese translation for `docs/vi/docs/deployment/cloud.md`. PR [#13407](https://github.com/fastapi/fastapi/pull/13407) by [@ptt3199](https://github.com/ptt3199).

### Internal[¶](#internal_28 "Permanent link")

  * â¬† Bump pydantic-ai from 0.0.15 to 0.0.30. PR [#13438](https://github.com/fastapi/fastapi/pull/13438) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * â¬† Bump sqlmodel from 0.0.22 to 0.0.23. PR [#13437](https://github.com/fastapi/fastapi/pull/13437) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * â¬† Bump black from 24.10.0 to 25.1.0. PR [#13436](https://github.com/fastapi/fastapi/pull/13436) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * â¬† Bump ruff to 0.9.4. PR [#13299](https://github.com/fastapi/fastapi/pull/13299) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * ğŸ”§ Update sponsors: pause TestDriven. PR [#13446](https://github.com/fastapi/fastapi/pull/13446) by [@tiangolo](https://github.com/tiangolo).

## 0.115.11[¶](#011511 "Permanent link")

### Fixes[¶](#fixes_31 "Permanent link")

  * ğŸ�› Add docs examples and tests (support) for `Annotated` custom validations, like `AfterValidator`, revert [#13440](https://github.com/fastapi/fastapi/pull/13440). PR [#13442](https://github.com/fastapi/fastapi/pull/13442) by [@tiangolo](https://github.com/tiangolo).
    * New docs: [Query Parameters and String Validations - Custom Validation](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#custom-validation).

### Translations[¶](#translations_18 "Permanent link")

  * ğŸŒ� Add Russian translation for `docs/ru/docs/tutorial/middleware.md`. PR [#13412](https://github.com/fastapi/fastapi/pull/13412) by [@alv2017](https://github.com/alv2017).

### Internal[¶](#internal_29 "Permanent link")

  * ğŸ‘¥ Update FastAPI GitHub topic repositories. PR [#13439](https://github.com/fastapi/fastapi/pull/13439) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘¥ Update FastAPI People - Contributors and Translators. PR [#13432](https://github.com/fastapi/fastapi/pull/13432) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘¥ Update FastAPI People - Sponsors. PR [#13433](https://github.com/fastapi/fastapi/pull/13433) by [@tiangolo](https://github.com/tiangolo).

## 0.115.10[¶](#011510 "Permanent link")

### Fixes[¶](#fixes_32 "Permanent link")

  * â™»ï¸� Update internal annotation usage for compatibility with Pydantic 2.11. PR [#13314](https://github.com/fastapi/fastapi/pull/13314) by [@Viicos](https://github.com/Viicos).

### Upgrades[¶](#upgrades_8 "Permanent link")

  * â¬†ï¸� Bump Starlette to allow up to 0.46.0: `>=0.40.0,<0.47.0`. PR [#13426](https://github.com/fastapi/fastapi/pull/13426) by [@musicinmybrain](https://github.com/musicinmybrain).

### Translations[¶](#translations_19 "Permanent link")

  * ğŸŒ� Add Ukrainian translation for `docs/uk/docs/tutorial/debugging.md`. PR [#13370](https://github.com/fastapi/fastapi/pull/13370) by [@valentinDruzhinin](https://github.com/valentinDruzhinin).
  * ğŸŒ� Add Ukrainian translation for `docs/uk/docs/tutorial/query-params.md`. PR [#13362](https://github.com/fastapi/fastapi/pull/13362) by [@valentinDruzhinin](https://github.com/valentinDruzhinin).
  * ğŸŒ� Add Ukrainian translation for `docs/uk/docs/tutorial/path-params.md`. PR [#13354](https://github.com/fastapi/fastapi/pull/13354) by [@valentinDruzhinin](https://github.com/valentinDruzhinin).
  * ğŸŒ� Add Japanese translation for `docs/ja/docs/tutorial/cookie-param-models.md`. PR [#13330](https://github.com/fastapi/fastapi/pull/13330) by [@k94-ishi](https://github.com/k94-ishi).
  * ğŸŒ� Add Ukrainian translation for `docs/uk/docs/tutorial/body-multiple-params.md`. PR [#13408](https://github.com/fastapi/fastapi/pull/13408) by [@valentinDruzhinin](https://github.com/valentinDruzhinin).
  * ğŸŒ� Add Japanese translation for `docs/ja/docs/tutorial/query-param-models.md`. PR [#13323](https://github.com/fastapi/fastapi/pull/13323) by [@k94-ishi](https://github.com/k94-ishi).
  * ğŸŒ� Add Ukrainian translation for `docs/uk/docs/tutorial/body-nested-models.md`. PR [#13409](https://github.com/fastapi/fastapi/pull/13409) by [@valentinDruzhinin](https://github.com/valentinDruzhinin).
  * ğŸŒ� Add Vietnamese translation for `docs/vi/docs/deployment/versions.md`. PR [#13406](https://github.com/fastapi/fastapi/pull/13406) by [@ptt3199](https://github.com/ptt3199).
  * ğŸŒ� Add Vietnamese translation for `docs/vi/docs/deployment/index.md`. PR [#13405](https://github.com/fastapi/fastapi/pull/13405) by [@ptt3199](https://github.com/ptt3199).
  * ğŸŒ� Add Ukrainian translation for `docs/uk/docs/tutorial/request-forms.md`. PR [#13383](https://github.com/fastapi/fastapi/pull/13383) by [@valentinDruzhinin](https://github.com/valentinDruzhinin).
  * ğŸŒ� Add Ukrainian translation for `docs/uk/docs/tutorial/testing.md`. PR [#13371](https://github.com/fastapi/fastapi/pull/13371) by [@valentinDruzhinin](https://github.com/valentinDruzhinin).

## 0.115.9[¶](#01159 "Permanent link")

### Fixes[¶](#fixes_33 "Permanent link")

  * ğŸ�› Ensure that `HTTPDigest` only raises an exception when `auto_error is True`. PR [#2939](https://github.com/fastapi/fastapi/pull/2939) by [@arthurio](https://github.com/arthurio).

### Refactors[¶](#refactors_9 "Permanent link")

  * âœ… Simplify tests for `query_params_str_validations`. PR [#13218](https://github.com/fastapi/fastapi/pull/13218) by [@alv2017](https://github.com/alv2017).
  * âœ… Simplify tests for `app_testing`. PR [#13220](https://github.com/fastapi/fastapi/pull/13220) by [@alv2017](https://github.com/alv2017).
  * âœ… Simplify tests for `dependency_testing`. PR [#13223](https://github.com/fastapi/fastapi/pull/13223) by [@alv2017](https://github.com/alv2017).

### Docs[¶](#docs_23 "Permanent link")

  * ğŸ�± Update sponsors: CodeRabbit logo. PR [#13424](https://github.com/fastapi/fastapi/pull/13424) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ©º Unify the badges across all tutorial translations. PR [#13329](https://github.com/fastapi/fastapi/pull/13329) by [@svlandeg](https://github.com/svlandeg).
  * ğŸ“� Fix typos in virtual environments documentation. PR [#13396](https://github.com/fastapi/fastapi/pull/13396) by [@bullet-ant](https://github.com/bullet-ant).
  * ğŸ�› Fix issue with Swagger theme change example in the official tutorial. PR [#13289](https://github.com/fastapi/fastapi/pull/13289) by [@Zerohertz](https://github.com/Zerohertz).
  * ğŸ“� Add more precise description of HTTP status code range in docs. PR [#13347](https://github.com/fastapi/fastapi/pull/13347) by [@DanielYang59](https://github.com/DanielYang59).
  * ğŸ”¥ Remove manual type annotations in JWT tutorial to avoid typing expectations (JWT doesn't provide more types). PR [#13378](https://github.com/fastapi/fastapi/pull/13378) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ“� Update docs for Query Params and String Validations, remove obsolete Ellipsis docs (`...`). PR [#13377](https://github.com/fastapi/fastapi/pull/13377) by [@tiangolo](https://github.com/tiangolo).
  * âœ�ï¸� Remove duplicate title in docs `body-multiple-params`. PR [#13345](https://github.com/fastapi/fastapi/pull/13345) by [@DanielYang59](https://github.com/DanielYang59).
  * ğŸ“� Fix test badge. PR [#13313](https://github.com/fastapi/fastapi/pull/13313) by [@esadek](https://github.com/esadek).

### Translations[¶](#translations_20 "Permanent link")

  * ğŸŒ� Add Ukrainian translation for `docs/uk/docs/tutorial/header-params.md`. PR [#13381](https://github.com/fastapi/fastapi/pull/13381) by [@valentinDruzhinin](https://github.com/valentinDruzhinin).
  * ğŸŒ� Add Ukrainian translation for `docs/uk/docs/tutorial/request-files.md`. PR [#13395](https://github.com/fastapi/fastapi/pull/13395) by [@valentinDruzhinin](https://github.com/valentinDruzhinin).
  * ğŸŒ� Add Ukrainian translation for `docs/uk/docs/tutorial/request-form-models.md`. PR [#13384](https://github.com/fastapi/fastapi/pull/13384) by [@valentinDruzhinin](https://github.com/valentinDruzhinin).
  * ğŸŒ� Add Ukrainian translation for `docs/uk/docs/tutorial/request-forms-and-files.md`. PR [#13386](https://github.com/fastapi/fastapi/pull/13386) by [@valentinDruzhinin](https://github.com/valentinDruzhinin).
  * ğŸŒ� Update Korean translation for `docs/ko/docs/help-fastapi.md`. PR [#13262](https://github.com/fastapi/fastapi/pull/13262) by [@Zerohertz](https://github.com/Zerohertz).
  * ğŸŒ� Add Korean translation for `docs/ko/docs/advanced/custom-response.md`. PR [#13265](https://github.com/fastapi/fastapi/pull/13265) by [@11kkw](https://github.com/11kkw).
  * ğŸŒ� Update Korean translation for `docs/ko/docs/tutorial/security/simple-oauth2.md`. PR [#13335](https://github.com/fastapi/fastapi/pull/13335) by [@yes0ng](https://github.com/yes0ng).
  * ğŸŒ� Add Russian translation for `docs/ru/docs/advanced/response-cookies.md`. PR [#13327](https://github.com/fastapi/fastapi/pull/13327) by [@Stepakinoyan](https://github.com/Stepakinoyan).
  * ğŸŒ� Add Vietnamese translation for `docs/vi/docs/tutorial/static-files.md`. PR [#11291](https://github.com/fastapi/fastapi/pull/11291) by [@ptt3199](https://github.com/ptt3199).
  * ğŸŒ� Add Korean translation for `docs/ko/docs/tutorial/dependencies/dependencies-with-yield.md`. PR [#13257](https://github.com/fastapi/fastapi/pull/13257) by [@11kkw](https://github.com/11kkw).
  * ğŸŒ� Add Vietnamese translation for `docs/vi/docs/virtual-environments.md`. PR [#13282](https://github.com/fastapi/fastapi/pull/13282) by [@ptt3199](https://github.com/ptt3199).
  * ğŸŒ� Add Ukrainian translation for `docs/uk/docs/tutorial/static-files.md`. PR [#13285](https://github.com/fastapi/fastapi/pull/13285) by [@valentinDruzhinin](https://github.com/valentinDruzhinin).
  * ğŸŒ� Add Vietnamese translation for `docs/vi/docs/environment-variables.md`. PR [#13287](https://github.com/fastapi/fastapi/pull/13287) by [@ptt3199](https://github.com/ptt3199).
  * ğŸŒ� Add Vietnamese translation for `docs/vi/docs/fastapi-cli.md`. PR [#13294](https://github.com/fastapi/fastapi/pull/13294) by [@ptt3199](https://github.com/ptt3199).
  * ğŸŒ� Add Ukrainian translation for `docs/uk/docs/features.md`. PR [#13308](https://github.com/fastapi/fastapi/pull/13308) by [@valentinDruzhinin](https://github.com/valentinDruzhinin).
  * ğŸŒ� Add Ukrainian translation for `docs/uk/docs/learn/index.md`. PR [#13306](https://github.com/fastapi/fastapi/pull/13306) by [@valentinDruzhinin](https://github.com/valentinDruzhinin).
  * ğŸŒ� Update Portuguese Translation for `docs/pt/docs/deployment/https.md`. PR [#13317](https://github.com/fastapi/fastapi/pull/13317) by [@Joao-Pedro-P-Holanda](https://github.com/Joao-Pedro-P-Holanda).
  * ğŸŒ� Update Portuguese Translation for `docs/pt/docs/index.md`. PR [#13328](https://github.com/fastapi/fastapi/pull/13328) by [@ceb10n](https://github.com/ceb10n).
  * ğŸŒ� Add Russian translation for `docs/ru/docs/advanced/websockets.md`. PR [#13279](https://github.com/fastapi/fastapi/pull/13279) by [@Rishat-F](https://github.com/Rishat-F).

### Internal[¶](#internal_30 "Permanent link")

  * âœ… Fix a minor bug in the test `tests/test_modules_same_name_body/test_main.py`. PR [#13411](https://github.com/fastapi/fastapi/pull/13411) by [@alv2017](https://github.com/alv2017).
  * ğŸ‘· Use `wrangler-action` v3. PR [#13415](https://github.com/fastapi/fastapi/pull/13415) by [@joakimnordling](https://github.com/joakimnordling).
  * ğŸ”§ Update sponsors: add CodeRabbit. PR [#13402](https://github.com/fastapi/fastapi/pull/13402) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”§ Update team: Add Ludovico. PR [#13390](https://github.com/fastapi/fastapi/pull/13390) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”§ Update sponsors: Add LambdaTest. PR [#13389](https://github.com/fastapi/fastapi/pull/13389) by [@tiangolo](https://github.com/tiangolo).
  * â¬† Bump cloudflare/wrangler-action from 3.13 to 3.14. PR [#13350](https://github.com/fastapi/fastapi/pull/13350) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * â¬† Bump mkdocs-material from 9.5.18 to 9.6.1. PR [#13301](https://github.com/fastapi/fastapi/pull/13301) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * â¬† Bump pillow from 11.0.0 to 11.1.0. PR [#13300](https://github.com/fastapi/fastapi/pull/13300) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * ğŸ‘¥ Update FastAPI People - Sponsors. PR [#13295](https://github.com/fastapi/fastapi/pull/13295) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘¥ Update FastAPI People - Experts. PR [#13303](https://github.com/fastapi/fastapi/pull/13303) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘¥ Update FastAPI GitHub topic repositories. PR [#13302](https://github.com/fastapi/fastapi/pull/13302) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘¥ Update FastAPI People - Contributors and Translators. PR [#13293](https://github.com/fastapi/fastapi/pull/13293) by [@tiangolo](https://github.com/tiangolo).
  * â¬† Bump inline-snapshot from 0.18.1 to 0.19.3. PR [#13298](https://github.com/fastapi/fastapi/pull/13298) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * ğŸ”§ Update sponsors, add Permit. PR [#13288](https://github.com/fastapi/fastapi/pull/13288) by [@tiangolo](https://github.com/tiangolo).

## 0.115.8[¶](#01158 "Permanent link")

### Fixes[¶](#fixes_34 "Permanent link")

  * ğŸ�› Fix `OAuth2PasswordRequestForm` and `OAuth2PasswordRequestFormStrict` fixed `grant_type` "password" RegEx. PR [#9783](https://github.com/fastapi/fastapi/pull/9783) by [@skarfie123](https://github.com/skarfie123).

### Refactors[¶](#refactors_10 "Permanent link")

  * âœ… Simplify tests for body_multiple_params . PR [#13237](https://github.com/fastapi/fastapi/pull/13237) by [@alejsdev](https://github.com/alejsdev).
  * â™»ï¸� Move duplicated code portion to a static method in the `APIKeyBase` super class. PR [#3142](https://github.com/fastapi/fastapi/pull/3142) by [@ShahriyarR](https://github.com/ShahriyarR).
  * âœ… Simplify tests for request_files. PR [#13182](https://github.com/fastapi/fastapi/pull/13182) by [@alejsdev](https://github.com/alejsdev).

### Docs[¶](#docs_24 "Permanent link")

  * ğŸ“� Change the word "unwrap" to "unpack" in `docs/en/docs/tutorial/extra-models.md`. PR [#13061](https://github.com/fastapi/fastapi/pull/13061) by [@timothy-jeong](https://github.com/timothy-jeong).
  * ğŸ“� Update Request Body's `tutorial002` to deal with `tax=0` case. PR [#13230](https://github.com/fastapi/fastapi/pull/13230) by [@togogh](https://github.com/togogh).
  * ğŸ‘¥ Update FastAPI People - Experts. PR [#13269](https://github.com/fastapi/fastapi/pull/13269) by [@tiangolo](https://github.com/tiangolo).

### Translations[¶](#translations_21 "Permanent link")

  * ğŸŒ� Add Japanese translation for `docs/ja/docs/environment-variables.md`. PR [#13226](https://github.com/fastapi/fastapi/pull/13226) by [@k94-ishi](https://github.com/k94-ishi).
  * ğŸŒ� Add Russian translation for `docs/ru/docs/advanced/async-tests.md`. PR [#13227](https://github.com/fastapi/fastapi/pull/13227) by [@Rishat-F](https://github.com/Rishat-F).
  * ğŸŒ� Update Russian translation for `docs/ru/docs/tutorial/dependencies/dependencies-in-path-operation-decorators.md`. PR [#13252](https://github.com/fastapi/fastapi/pull/13252) by [@Rishat-F](https://github.com/Rishat-F).
  * ğŸŒ� Add Russian translation for `docs/ru/docs/tutorial/bigger-applications.md`. PR [#13154](https://github.com/fastapi/fastapi/pull/13154) by [@alv2017](https://github.com/alv2017).

### Internal[¶](#internal_31 "Permanent link")

  * â¬†ï¸� Add support for Python 3.13. PR [#13274](https://github.com/fastapi/fastapi/pull/13274) by [@tiangolo](https://github.com/tiangolo).
  * â¬†ï¸� Upgrade AnyIO max version for tests, new range: `>=3.2.1,<5.0.0`. PR [#13273](https://github.com/fastapi/fastapi/pull/13273) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”§ Update Sponsors badges. PR [#13271](https://github.com/fastapi/fastapi/pull/13271) by [@tiangolo](https://github.com/tiangolo).
  * â™»ï¸� Fix `notify_translations.py` empty env var handling for PR label events vs workflow_dispatch. PR [#13272](https://github.com/fastapi/fastapi/pull/13272) by [@tiangolo](https://github.com/tiangolo).
  * â™»ï¸� Refactor and move `scripts/notify_translations.py`, no need for a custom GitHub Action. PR [#13270](https://github.com/fastapi/fastapi/pull/13270) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”¨ Update FastAPI People Experts script, refactor and optimize data fetching to handle rate limits. PR [#13267](https://github.com/fastapi/fastapi/pull/13267) by [@tiangolo](https://github.com/tiangolo).
  * â¬† Bump pypa/gh-action-pypi-publish from 1.12.3 to 1.12.4. PR [#13251](https://github.com/fastapi/fastapi/pull/13251) by [@dependabot[bot]](https://github.com/apps/dependabot).

## 0.115.7[¶](#01157 "Permanent link")

### Upgrades[¶](#upgrades_9 "Permanent link")

  * â¬†ï¸� Upgrade `python-multipart` to >=0.0.18. PR [#13219](https://github.com/fastapi/fastapi/pull/13219) by [@DanielKusyDev](https://github.com/DanielKusyDev).
  * â¬†ï¸� Bump Starlette to allow up to 0.45.0: `>=0.40.0,<0.46.0`. PR [#13117](https://github.com/fastapi/fastapi/pull/13117) by [@Kludex](https://github.com/Kludex).
  * â¬†ï¸� Upgrade `jinja2` to >=3.1.5. PR [#13194](https://github.com/fastapi/fastapi/pull/13194) by [@DanielKusyDev](https://github.com/DanielKusyDev).

### Refactors[¶](#refactors_11 "Permanent link")

  * âœ… Simplify tests for websockets. PR [#13202](https://github.com/fastapi/fastapi/pull/13202) by [@alejsdev](https://github.com/alejsdev).
  * âœ… Simplify tests for request_form_models . PR [#13183](https://github.com/fastapi/fastapi/pull/13183) by [@alejsdev](https://github.com/alejsdev).
  * âœ… Simplify tests for separate_openapi_schemas. PR [#13201](https://github.com/fastapi/fastapi/pull/13201) by [@alejsdev](https://github.com/alejsdev).
  * âœ… Simplify tests for security. PR [#13200](https://github.com/fastapi/fastapi/pull/13200) by [@alejsdev](https://github.com/alejsdev).
  * âœ… Simplify tests for schema_extra_example. PR [#13197](https://github.com/fastapi/fastapi/pull/13197) by [@alejsdev](https://github.com/alejsdev).
  * âœ… Simplify tests for request_model. PR [#13195](https://github.com/fastapi/fastapi/pull/13195) by [@alejsdev](https://github.com/alejsdev).
  * âœ… Simplify tests for request_forms_and_files. PR [#13185](https://github.com/fastapi/fastapi/pull/13185) by [@alejsdev](https://github.com/alejsdev).
  * âœ… Simplify tests for request_forms. PR [#13184](https://github.com/fastapi/fastapi/pull/13184) by [@alejsdev](https://github.com/alejsdev).
  * âœ… Simplify tests for path_query_params. PR [#13181](https://github.com/fastapi/fastapi/pull/13181) by [@alejsdev](https://github.com/alejsdev).
  * âœ… Simplify tests for path_operation_configurations. PR [#13180](https://github.com/fastapi/fastapi/pull/13180) by [@alejsdev](https://github.com/alejsdev).
  * âœ… Simplify tests for header_params. PR [#13179](https://github.com/fastapi/fastapi/pull/13179) by [@alejsdev](https://github.com/alejsdev).
  * âœ… Simplify tests for extra_models. PR [#13178](https://github.com/fastapi/fastapi/pull/13178) by [@alejsdev](https://github.com/alejsdev).
  * âœ… Simplify tests for extra_data_types. PR [#13177](https://github.com/fastapi/fastapi/pull/13177) by [@alejsdev](https://github.com/alejsdev).
  * âœ… Simplify tests for cookie_params. PR [#13176](https://github.com/fastapi/fastapi/pull/13176) by [@alejsdev](https://github.com/alejsdev).
  * âœ… Simplify tests for dependencies. PR [#13174](https://github.com/fastapi/fastapi/pull/13174) by [@alejsdev](https://github.com/alejsdev).
  * âœ… Simplify tests for body_updates. PR [#13172](https://github.com/fastapi/fastapi/pull/13172) by [@alejsdev](https://github.com/alejsdev).
  * âœ… Simplify tests for body_nested_models. PR [#13171](https://github.com/fastapi/fastapi/pull/13171) by [@alejsdev](https://github.com/alejsdev).
  * âœ… Simplify tests for body_multiple_params. PR [#13170](https://github.com/fastapi/fastapi/pull/13170) by [@alejsdev](https://github.com/alejsdev).
  * âœ… Simplify tests for body_fields. PR [#13169](https://github.com/fastapi/fastapi/pull/13169) by [@alejsdev](https://github.com/alejsdev).
  * âœ… Simplify tests for body. PR [#13168](https://github.com/fastapi/fastapi/pull/13168) by [@alejsdev](https://github.com/alejsdev).
  * âœ… Simplify tests for bigger_applications. PR [#13167](https://github.com/fastapi/fastapi/pull/13167) by [@alejsdev](https://github.com/alejsdev).
  * âœ… Simplify tests for background_tasks. PR [#13166](https://github.com/fastapi/fastapi/pull/13166) by [@alejsdev](https://github.com/alejsdev).
  * âœ… Simplify tests for additional_status_codes. PR [#13149](https://github.com/fastapi/fastapi/pull/13149) by [@tiangolo](https://github.com/tiangolo).

### Docs[¶](#docs_25 "Permanent link")

  * âœ�ï¸� Update Strawberry integration docs. PR [#13155](https://github.com/fastapi/fastapi/pull/13155) by [@kinuax](https://github.com/kinuax).
  * ğŸ”¥ Remove unused Peewee tutorial files. PR [#13158](https://github.com/fastapi/fastapi/pull/13158) by [@alejsdev](https://github.com/alejsdev).
  * ğŸ“� Update image in body-nested-model docs. PR [#11063](https://github.com/fastapi/fastapi/pull/11063) by [@untilhamza](https://github.com/untilhamza).
  * ğŸ“� Update `fastapi-cli` UI examples in docs. PR [#13107](https://github.com/fastapi/fastapi/pull/13107) by [@Zhongheng-Cheng](https://github.com/Zhongheng-Cheng).
  * ğŸ‘· Add new GitHub Action to update contributors, translators, and translation reviewers. PR [#13136](https://github.com/fastapi/fastapi/pull/13136) by [@tiangolo](https://github.com/tiangolo).
  * âœ�ï¸� Fix typo in `docs/en/docs/virtual-environments.md`. PR [#13124](https://github.com/fastapi/fastapi/pull/13124) by [@tiangolo](https://github.com/tiangolo).
  * âœ�ï¸� Fix error in `docs/en/docs/contributing.md`. PR [#12899](https://github.com/fastapi/fastapi/pull/12899) by [@kingsubin](https://github.com/kingsubin).
  * ğŸ“� Minor corrections in `docs/en/docs/tutorial/sql-databases.md`. PR [#13081](https://github.com/fastapi/fastapi/pull/13081) by [@alv2017](https://github.com/alv2017).
  * ğŸ“� Update includes in `docs/ru/docs/tutorial/query-param-models.md`. PR [#12994](https://github.com/fastapi/fastapi/pull/12994) by [@alejsdev](https://github.com/alejsdev).
  * âœ�ï¸� Fix typo in README installation instructions. PR [#13011](https://github.com/fastapi/fastapi/pull/13011) by [@dave-hay](https://github.com/dave-hay).
  * ğŸ“� Update docs for `fastapi-cli`. PR [#13031](https://github.com/fastapi/fastapi/pull/13031) by [@tiangolo](https://github.com/tiangolo).

### Translations[¶](#translations_22 "Permanent link")

  * ğŸŒ� Update Portuguese Translation for `docs/pt/docs/tutorial/request-forms.md`. PR [#13216](https://github.com/fastapi/fastapi/pull/13216) by [@Joao-Pedro-P-Holanda](https://github.com/Joao-Pedro-P-Holanda).
  * ğŸŒ� Update Portuguese translation for `docs/pt/docs/advanced/settings.md`. PR [#13209](https://github.com/fastapi/fastapi/pull/13209) by [@ceb10n](https://github.com/ceb10n).
  * ğŸŒ� Add Portuguese translation for `docs/pt/docs/tutorial/security/oauth2-jwt.md`. PR [#13205](https://github.com/fastapi/fastapi/pull/13205) by [@ceb10n](https://github.com/ceb10n).
  * ğŸŒ� Add Indonesian translation for `docs/id/docs/index.md`. PR [#13191](https://github.com/fastapi/fastapi/pull/13191) by [@gerry-sabar](https://github.com/gerry-sabar).
  * ğŸŒ� Add Indonesian translation for `docs/id/docs/tutorial/static-files.md`. PR [#13092](https://github.com/fastapi/fastapi/pull/13092) by [@guspan-tanadi](https://github.com/guspan-tanadi).
  * ğŸŒ� Add Portuguese translation for `docs/pt/docs/tutorial/security/get-current-user.md`. PR [#13188](https://github.com/fastapi/fastapi/pull/13188) by [@ceb10n](https://github.com/ceb10n).
  * ğŸŒ� Remove Wrong Portuguese translations location for `docs/pt/docs/advanced/benchmarks.md`. PR [#13187](https://github.com/fastapi/fastapi/pull/13187) by [@ceb10n](https://github.com/ceb10n).
  * ğŸŒ� Update Portuguese translations. PR [#13156](https://github.com/fastapi/fastapi/pull/13156) by [@nillvitor](https://github.com/nillvitor).
  * ğŸŒ� Update Russian translation for `docs/ru/docs/tutorial/security/first-steps.md`. PR [#13159](https://github.com/fastapi/fastapi/pull/13159) by [@Yarous](https://github.com/Yarous).
  * âœ�ï¸� Delete unnecessary backspace in `docs/ja/docs/tutorial/path-params-numeric-validations.md`. PR [#12238](https://github.com/fastapi/fastapi/pull/12238) by [@FakeDocument](https://github.com/FakeDocument).
  * ğŸŒ� Update Chinese translation for `docs/zh/docs/fastapi-cli.md`. PR [#13102](https://github.com/fastapi/fastapi/pull/13102) by [@Zhongheng-Cheng](https://github.com/Zhongheng-Cheng).
  * ğŸŒ� Add new Spanish translations for all docs with new LLM-assisted system using PydanticAI. PR [#13122](https://github.com/fastapi/fastapi/pull/13122) by [@tiangolo](https://github.com/tiangolo).
  * ğŸŒ� Update existing Spanish translations using the new LLM-assisted system using PydanticAI. PR [#13118](https://github.com/fastapi/fastapi/pull/13118) by [@tiangolo](https://github.com/tiangolo).
  * ğŸŒ� Update Chinese translation for `docs/zh/docs/advanced/security/oauth2-scopes.md`. PR [#13110](https://github.com/fastapi/fastapi/pull/13110) by [@ChenPu2002](https://github.com/ChenPu2002).
  * ğŸŒ� Add Indonesian translation for `docs/id/docs/tutorial/path-params.md`. PR [#13086](https://github.com/fastapi/fastapi/pull/13086) by [@gerry-sabar](https://github.com/gerry-sabar).
  * ğŸŒ� Add Korean translation for `docs/ko/docs/tutorial/sql-databases.md`. PR [#13093](https://github.com/fastapi/fastapi/pull/13093) by [@GeumBinLee](https://github.com/GeumBinLee).
  * ğŸŒ� Update Chinese translation for `docs/zh/docs/async.md`. PR [#13095](https://github.com/fastapi/fastapi/pull/13095) by [@Zhongheng-Cheng](https://github.com/Zhongheng-Cheng).
  * ğŸŒ� Add Chinese translation for `docs/zh/docs/advanced/openapi-webhooks.md`. PR [#13091](https://github.com/fastapi/fastapi/pull/13091) by [@Zhongheng-Cheng](https://github.com/Zhongheng-Cheng).
  * ğŸŒ� Add Chinese translation for `docs/zh/docs/advanced/async-tests.md`. PR [#13074](https://github.com/fastapi/fastapi/pull/13074) by [@Zhongheng-Cheng](https://github.com/Zhongheng-Cheng).
  * ğŸŒ� Add Ukrainian translation for `docs/uk/docs/fastapi-cli.md`. PR [#13020](https://github.com/fastapi/fastapi/pull/13020) by [@ykertytsky](https://github.com/ykertytsky).
  * ğŸŒ� Add Chinese translation for `docs/zh/docs/advanced/events.md`. PR [#12512](https://github.com/fastapi/fastapi/pull/12512) by [@ZhibangYue](https://github.com/ZhibangYue).
  * ğŸŒ� Add Russian translation for `/docs/ru/docs/tutorial/sql-databases.md`. PR [#13079](https://github.com/fastapi/fastapi/pull/13079) by [@alv2017](https://github.com/alv2017).
  * ğŸŒ� Update Chinese translation for `docs/zh/docs/advanced/testing-dependencies.md`. PR [#13066](https://github.com/fastapi/fastapi/pull/13066) by [@Zhongheng-Cheng](https://github.com/Zhongheng-Cheng).
  * ğŸŒ� Update Traditional Chinese translation for `docs/zh-hant/docs/tutorial/index.md`. PR [#13075](https://github.com/fastapi/fastapi/pull/13075) by [@codingjenny](https://github.com/codingjenny).
  * ğŸŒ� Add Chinese translation for `docs/zh/docs/tutorial/sql-databases.md`. PR [#13051](https://github.com/fastapi/fastapi/pull/13051) by [@Zhongheng-Cheng](https://github.com/Zhongheng-Cheng).
  * ğŸŒ� Update Chinese translation for `docs/zh/docs/tutorial/query-params-str-validations.md`. PR [#12928](https://github.com/fastapi/fastapi/pull/12928) by [@Vincy1230](https://github.com/Vincy1230).
  * ğŸŒ� Add Chinese translation for `docs/zh/docs/tutorial/header-param-models.md`. PR [#13040](https://github.com/fastapi/fastapi/pull/13040) by [@Zhongheng-Cheng](https://github.com/Zhongheng-Cheng).
  * ğŸŒ� Update Chinese translation for `docs/zh/docs/tutorial/path-params.md`. PR [#12926](https://github.com/fastapi/fastapi/pull/12926) by [@Vincy1230](https://github.com/Vincy1230).
  * ğŸŒ� Update Chinese translation for `docs/zh/docs/tutorial/first-steps.md`. PR [#12923](https://github.com/fastapi/fastapi/pull/12923) by [@Vincy1230](https://github.com/Vincy1230).
  * ğŸŒ� Update Russian translation for `docs/ru/docs/deployment/docker.md`. PR [#13048](https://github.com/fastapi/fastapi/pull/13048) by [@anklav24](https://github.com/anklav24).
  * ğŸŒ� Add Portuguese translation for `docs/pt/docs/advanced/generate-clients.md`. PR [#13030](https://github.com/fastapi/fastapi/pull/13030) by [@vitumenezes](https://github.com/vitumenezes).
  * ğŸŒ� Add Indonesian translation for `docs/id/docs/tutorial/first-steps.md`. PR [#13042](https://github.com/fastapi/fastapi/pull/13042) by [@gerry-sabar](https://github.com/gerry-sabar).
  * ğŸŒ� Add Chinese translation for `docs/zh/docs/tutorial/cookie-param-models.md`. PR [#13038](https://github.com/fastapi/fastapi/pull/13038) by [@Zhongheng-Cheng](https://github.com/Zhongheng-Cheng).
  * ğŸŒ� Add Chinese translation for `docs/zh/docs/tutorial/request-form-models.md`. PR [#13045](https://github.com/fastapi/fastapi/pull/13045) by [@Zhongheng-Cheng](https://github.com/Zhongheng-Cheng).
  * ğŸŒ� Add Russian translation for `docs/ru/docs/virtual-environments.md`. PR [#13026](https://github.com/fastapi/fastapi/pull/13026) by [@alv2017](https://github.com/alv2017).
  * ğŸŒ� Add Korean translation for `docs/ko/docs/tutorial/testing.md`. PR [#12968](https://github.com/fastapi/fastapi/pull/12968) by [@jts8257](https://github.com/jts8257).
  * ğŸŒ� Add Korean translation for `docs/ko/docs/advanced/async-test.md`. PR [#12918](https://github.com/fastapi/fastapi/pull/12918) by [@icehongssii](https://github.com/icehongssii).
  * ğŸŒ� Add Russian translation for `docs/ru/docs/tutorial/security/oauth2-jwt.md`. PR [#10601](https://github.com/fastapi/fastapi/pull/10601) by [@AlertRED](https://github.com/AlertRED).
  * ğŸŒ� Add Russian translation for `docs/ru/docs/tutorial/security/simple-oauth2.md`. PR [#10599](https://github.com/fastapi/fastapi/pull/10599) by [@AlertRED](https://github.com/AlertRED).
  * ğŸŒ� Add Russian translation for `docs/ru/docs/tutorial/security/get-current-user.md`. PR [#10594](https://github.com/fastapi/fastapi/pull/10594) by [@AlertRED](https://github.com/AlertRED).
  * ğŸŒ� Add Traditional Chinese translation for `docs/zh-hant/docs/features.md`. PR [#12441](https://github.com/fastapi/fastapi/pull/12441) by [@codingjenny](https://github.com/codingjenny).
  * ğŸŒ� Add Traditional Chinese translation for `docs/zh-hant/docs/virtual-environments.md`. PR [#12791](https://github.com/fastapi/fastapi/pull/12791) by [@Vincy1230](https://github.com/Vincy1230).
  * ğŸŒ� Add Korean translation for `docs/ko/docs/advanced/templates.md`. PR [#12726](https://github.com/fastapi/fastapi/pull/12726) by [@Heumhub](https://github.com/Heumhub).
  * ğŸŒ� Add Russian translation for `docs/ru/docs/fastapi-cli.md`. PR [#13041](https://github.com/fastapi/fastapi/pull/13041) by [@alv2017](https://github.com/alv2017).
  * ğŸŒ� Add Korean translation for `docs/ko/docs/tutorial/cookie-param-models.md`. PR [#13000](https://github.com/fastapi/fastapi/pull/13000) by [@hard-coders](https://github.com/hard-coders).
  * ğŸŒ� Add Korean translation for `docs/ko/docs/tutorial/header-param-models.md`. PR [#13001](https://github.com/fastapi/fastapi/pull/13001) by [@hard-coders](https://github.com/hard-coders).
  * ğŸŒ� Add Korean translation for `docs/ko/docs/tutorial/request-form-models.md`. PR [#13002](https://github.com/fastapi/fastapi/pull/13002) by [@hard-coders](https://github.com/hard-coders).
  * ğŸŒ� Add Korean translation for `docs/ko/docs/tutorial/request-forms.md`. PR [#13003](https://github.com/fastapi/fastapi/pull/13003) by [@hard-coders](https://github.com/hard-coders).
  * ğŸŒ� Add Korean translation for `docs/ko/docs/resources/index.md`. PR [#13004](https://github.com/fastapi/fastapi/pull/13004) by [@hard-coders](https://github.com/hard-coders).
  * ğŸŒ� Add Korean translation for `docs/ko/docs/how-to/configure-swagger-ui.md`. PR [#12898](https://github.com/fastapi/fastapi/pull/12898) by [@nahyunkeem](https://github.com/nahyunkeem).
  * ğŸŒ� Add Korean translation to `docs/ko/docs/advanced/additional-status-codes.md`. PR [#12715](https://github.com/fastapi/fastapi/pull/12715) by [@nahyunkeem](https://github.com/nahyunkeem).
  * ğŸŒ� Add Traditional Chinese translation for `docs/zh-hant/docs/tutorial/first-steps.md`. PR [#12467](https://github.com/fastapi/fastapi/pull/12467) by [@codingjenny](https://github.com/codingjenny).

### Internal[¶](#internal_32 "Permanent link")

  * ğŸ”§ Add Pydantic 2 trove classifier. PR [#13199](https://github.com/fastapi/fastapi/pull/13199) by [@johnthagen](https://github.com/johnthagen).
  * ğŸ‘¥ Update FastAPI People - Sponsors. PR [#13231](https://github.com/fastapi/fastapi/pull/13231) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘· Refactor FastAPI People Sponsors to use 2 tokens. PR [#13228](https://github.com/fastapi/fastapi/pull/13228) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘· Update token for FastAPI People - Sponsors. PR [#13225](https://github.com/fastapi/fastapi/pull/13225) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘· Add independent CI automation for FastAPI People - Sponsors. PR [#13221](https://github.com/fastapi/fastapi/pull/13221) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘· Add retries to Smokeshow. PR [#13151](https://github.com/fastapi/fastapi/pull/13151) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”§ Update Speakeasy sponsor graphic. PR [#13147](https://github.com/fastapi/fastapi/pull/13147) by [@chailandau](https://github.com/chailandau).
  * ğŸ‘¥ Update FastAPI GitHub topic repositories. PR [#13146](https://github.com/fastapi/fastapi/pull/13146) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘·â€�â™€ï¸� Add script for GitHub Topic Repositories and update External Links. PR [#13135](https://github.com/fastapi/fastapi/pull/13135) by [@alejsdev](https://github.com/alejsdev).
  * ğŸ‘¥ Update FastAPI People - Contributors and Translators. PR [#13145](https://github.com/fastapi/fastapi/pull/13145) by [@tiangolo](https://github.com/tiangolo).
  * â¬† Bump markdown-include-variants from 0.0.3 to 0.0.4. PR [#13129](https://github.com/fastapi/fastapi/pull/13129) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * â¬† Bump inline-snapshot from 0.14.0 to 0.18.1. PR [#13132](https://github.com/fastapi/fastapi/pull/13132) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * â¬† Bump mkdocs-macros-plugin from 1.0.5 to 1.3.7. PR [#13133](https://github.com/fastapi/fastapi/pull/13133) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * ğŸ”¨ Add internal scripts to generate language translations with PydanticAI, include Spanish prompt. PR [#13123](https://github.com/fastapi/fastapi/pull/13123) by [@tiangolo](https://github.com/tiangolo).
  * â¬† Bump astral-sh/setup-uv from 4 to 5. PR [#13096](https://github.com/fastapi/fastapi/pull/13096) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * ğŸ”§ Update sponsors: rename CryptAPI to BlockBee. PR [#13078](https://github.com/fastapi/fastapi/pull/13078) by [@tiangolo](https://github.com/tiangolo).
  * â¬† Bump pypa/gh-action-pypi-publish from 1.12.2 to 1.12.3. PR [#13055](https://github.com/fastapi/fastapi/pull/13055) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * â¬† Bump types-ujson from 5.7.0.1 to 5.10.0.20240515. PR [#13018](https://github.com/fastapi/fastapi/pull/13018) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * â¬† Bump black from 24.3.0 to 24.10.0. PR [#13014](https://github.com/fastapi/fastapi/pull/13014) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * â¬† Bump inline-snapshot from 0.13.0 to 0.14.0. PR [#13017](https://github.com/fastapi/fastapi/pull/13017) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * â¬† Bump dirty-equals from 0.6.0 to 0.8.0. PR [#13015](https://github.com/fastapi/fastapi/pull/13015) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * â¬† Bump cloudflare/wrangler-action from 3.12 to 3.13. PR [#12996](https://github.com/fastapi/fastapi/pull/12996) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * â¬† Bump astral-sh/setup-uv from 3 to 4. PR [#12982](https://github.com/fastapi/fastapi/pull/12982) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * ğŸ”§ Remove duplicate actions/checkout in `notify-translations.yml`. PR [#12915](https://github.com/fastapi/fastapi/pull/12915) by [@tinyboxvk](https://github.com/tinyboxvk).
  * ğŸ”§ Update team members. PR [#13033](https://github.com/fastapi/fastapi/pull/13033) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ“� Update sponsors: remove Codacy. PR [#13032](https://github.com/fastapi/fastapi/pull/13032) by [@tiangolo](https://github.com/tiangolo).

## 0.115.6[¶](#01156 "Permanent link")

### Fixes[¶](#fixes_35 "Permanent link")

  * ğŸ�› Preserve traceback when an exception is raised in sync dependency with `yield`. PR [#5823](https://github.com/fastapi/fastapi/pull/5823) by [@sombek](https://github.com/sombek).

### Refactors[¶](#refactors_12 "Permanent link")

  * â™»ï¸� Update tests and internals for compatibility with Pydantic >=2.10. PR [#12971](https://github.com/fastapi/fastapi/pull/12971) by [@tamird](https://github.com/tamird).

### Docs[¶](#docs_26 "Permanent link")

  * ğŸ“� Update includes format in docs with an automated script. PR [#12950](https://github.com/fastapi/fastapi/pull/12950) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ“� Update includes for `docs/de/docs/advanced/using-request-directly.md`. PR [#12685](https://github.com/fastapi/fastapi/pull/12685) by [@alissadb](https://github.com/alissadb).
  * ğŸ“� Update includes for `docs/de/docs/how-to/conditional-openapi.md`. PR [#12689](https://github.com/fastapi/fastapi/pull/12689) by [@alissadb](https://github.com/alissadb).

### Translations[¶](#translations_23 "Permanent link")

  * ğŸŒ� Add Traditional Chinese translation for `docs/zh-hant/docs/async.md`. PR [#12990](https://github.com/fastapi/fastapi/pull/12990) by [@ILoveSorasakiHina](https://github.com/ILoveSorasakiHina).
  * ğŸŒ� Add Traditional Chinese translation for `docs/zh-hant/docs/tutorial/query-param-models.md`. PR [#12932](https://github.com/fastapi/fastapi/pull/12932) by [@Vincy1230](https://github.com/Vincy1230).
  * ğŸŒ� Add Korean translation for `docs/ko/docs/advanced/testing-dependencies.md`. PR [#12992](https://github.com/fastapi/fastapi/pull/12992) by [@Limsunoh](https://github.com/Limsunoh).
  * ğŸŒ� Add Korean translation for `docs/ko/docs/advanced/websockets.md`. PR [#12991](https://github.com/fastapi/fastapi/pull/12991) by [@kwang1215](https://github.com/kwang1215).
  * ğŸŒ� Add Portuguese translation for `docs/pt/docs/tutorial/response-model.md`. PR [#12933](https://github.com/fastapi/fastapi/pull/12933) by [@AndreBBM](https://github.com/AndreBBM).
  * ğŸŒ� Add Korean translation for `docs/ko/docs/advanced/middlewares.md`. PR [#12753](https://github.com/fastapi/fastapi/pull/12753) by [@nahyunkeem](https://github.com/nahyunkeem).
  * ğŸŒ� Add Korean translation for `docs/ko/docs/advanced/openapi-webhooks.md`. PR [#12752](https://github.com/fastapi/fastapi/pull/12752) by [@saeye](https://github.com/saeye).
  * ğŸŒ� Add Chinese translation for `docs/zh/docs/tutorial/query-param-models.md`. PR [#12931](https://github.com/fastapi/fastapi/pull/12931) by [@Vincy1230](https://github.com/Vincy1230).
  * ğŸŒ� Add Russian translation for `docs/ru/docs/tutorial/query-param-models.md`. PR [#12445](https://github.com/fastapi/fastapi/pull/12445) by [@gitgernit](https://github.com/gitgernit).
  * ğŸŒ� Add Korean translation for `docs/ko/docs/tutorial/query-param-models.md`. PR [#12940](https://github.com/fastapi/fastapi/pull/12940) by [@jts8257](https://github.com/jts8257).
  * ğŸ”¥ Remove obsolete tutorial translation to Chinese for `docs/zh/docs/tutorial/sql-databases.md`, it references files that are no longer on the repo. PR [#12949](https://github.com/fastapi/fastapi/pull/12949) by [@tiangolo](https://github.com/tiangolo).

### Internal[¶](#internal_33 "Permanent link")

  * â¬† [pre-commit.ci] pre-commit autoupdate. PR [#12954](https://github.com/fastapi/fastapi/pull/12954) by [@pre-commit-ci[bot]](https://github.com/apps/pre-commit-ci).

## 0.115.5[¶](#01155 "Permanent link")

### Refactors[¶](#refactors_13 "Permanent link")

  * â™»ï¸� Update internal checks to support Pydantic 2.10. PR [#12914](https://github.com/fastapi/fastapi/pull/12914) by [@tiangolo](https://github.com/tiangolo).

### Docs[¶](#docs_27 "Permanent link")

  * ğŸ“� Update includes for `docs/en/docs/tutorial/body.md`. PR [#12757](https://github.com/fastapi/fastapi/pull/12757) by [@gsheni](https://github.com/gsheni).
  * ğŸ“� Update includes in `docs/en/docs/advanced/testing-dependencies.md`. PR [#12647](https://github.com/fastapi/fastapi/pull/12647) by [@AyushSinghal1794](https://github.com/AyushSinghal1794).
  * ğŸ“� Update includes for `docs/en/docs/tutorial/metadata.md`. PR [#12773](https://github.com/fastapi/fastapi/pull/12773) by [@Nimitha-jagadeesha](https://github.com/Nimitha-jagadeesha).
  * ğŸ“� Update `docs/en/docs/tutorial/dependencies/dependencies-with-yield.md`. PR [#12045](https://github.com/fastapi/fastapi/pull/12045) by [@xuvjso](https://github.com/xuvjso).
  * ğŸ“� Update includes for `docs/en/docs/tutorial/dependencies/global-dependencies.md`. PR [#12653](https://github.com/fastapi/fastapi/pull/12653) by [@vishnuvskvkl](https://github.com/vishnuvskvkl).
  * ğŸ“� Update includes for `docs/en/docs/tutorial/body-updates.md`. PR [#12712](https://github.com/fastapi/fastapi/pull/12712) by [@davioc](https://github.com/davioc).
  * ğŸ“� Remove mention of Celery in the project generators. PR [#12742](https://github.com/fastapi/fastapi/pull/12742) by [@david-caro](https://github.com/david-caro).
  * ğŸ“� Update includes in `docs/en/docs/tutorial/header-param-models.md`. PR [#12814](https://github.com/fastapi/fastapi/pull/12814) by [@zhaohan-dong](https://github.com/zhaohan-dong).
  * ğŸ“� Update `contributing.md` docs, include note to not translate this page. PR [#12841](https://github.com/fastapi/fastapi/pull/12841) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ“� Update includes in `docs/en/docs/tutorial/request-forms.md`. PR [#12648](https://github.com/fastapi/fastapi/pull/12648) by [@vishnuvskvkl](https://github.com/vishnuvskvkl).
  * ğŸ“� Update includes in `docs/en/docs/tutorial/request-form-models.md`. PR [#12649](https://github.com/fastapi/fastapi/pull/12649) by [@vishnuvskvkl](https://github.com/vishnuvskvkl).
  * ğŸ“� Update includes in `docs/en/docs/tutorial/security/oauth2-jwt.md`. PR [#12650](https://github.com/fastapi/fastapi/pull/12650) by [@OCE1960](https://github.com/OCE1960).
  * ğŸ“� Update includes in `docs/vi/docs/tutorial/first-steps.md`. PR [#12754](https://github.com/fastapi/fastapi/pull/12754) by [@MxPy](https://github.com/MxPy).
  * ğŸ“� Update includes for `docs/pt/docs/advanced/wsgi.md`. PR [#12769](https://github.com/fastapi/fastapi/pull/12769) by [@Nimitha-jagadeesha](https://github.com/Nimitha-jagadeesha).
  * ğŸ“� Update includes for `docs/en/docs/tutorial/dependencies/dependencies-in-path-operation-decorators.md`. PR [#12815](https://github.com/fastapi/fastapi/pull/12815) by [@handabaldeep](https://github.com/handabaldeep).
  * ğŸ“� Update includes for `docs/en/docs/tutorial/dependencies/classes-as-dependencies.md`. PR [#12813](https://github.com/fastapi/fastapi/pull/12813) by [@handabaldeep](https://github.com/handabaldeep).
  * âœ�ï¸� Fix error in `docs/en/docs/tutorial/middleware.md`. PR [#12819](https://github.com/fastapi/fastapi/pull/12819) by [@alejsdev](https://github.com/alejsdev).
  * ğŸ“� Update includes for `docs/en/docs/tutorial/security/get-current-user.md`. PR [#12645](https://github.com/fastapi/fastapi/pull/12645) by [@OCE1960](https://github.com/OCE1960).
  * ğŸ“� Update includes for `docs/en/docs/tutorial/security/first-steps.md`. PR [#12643](https://github.com/fastapi/fastapi/pull/12643) by [@OCE1960](https://github.com/OCE1960).
  * ğŸ“� Update includes in `docs/de/docs/advanced/additional-responses.md`. PR [#12821](https://github.com/fastapi/fastapi/pull/12821) by [@zhaohan-dong](https://github.com/zhaohan-dong).
  * ğŸ“� Update includes in `docs/en/docs/advanced/generate-clients.md`. PR [#12642](https://github.com/fastapi/fastapi/pull/12642) by [@AyushSinghal1794](https://github.com/AyushSinghal1794).
  * ğŸ“� Fix admonition double quotes with new syntax. PR [#12835](https://github.com/fastapi/fastapi/pull/12835) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ“� Update includes in `docs/zh/docs/advanced/additional-responses.md`. PR [#12828](https://github.com/fastapi/fastapi/pull/12828) by [@zhaohan-dong](https://github.com/zhaohan-dong).
  * ğŸ“� Update includes in `docs/en/docs/tutorial/path-params-numeric-validations.md`. PR [#12825](https://github.com/fastapi/fastapi/pull/12825) by [@zhaohan-dong](https://github.com/zhaohan-dong).
  * ğŸ“� Update includes for `docs/en/docs/advanced/testing-websockets.md`. PR [#12761](https://github.com/fastapi/fastapi/pull/12761) by [@hamidrasti](https://github.com/hamidrasti).
  * ğŸ“� Update includes for `docs/en/docs/advanced/using-request-directly.md`. PR [#12760](https://github.com/fastapi/fastapi/pull/12760) by [@hamidrasti](https://github.com/hamidrasti).
  * ğŸ“� Update includes for `docs/advanced/wsgi.md`. PR [#12758](https://github.com/fastapi/fastapi/pull/12758) by [@hamidrasti](https://github.com/hamidrasti).
  * ğŸ“� Update includes in `docs/de/docs/tutorial/middleware.md`. PR [#12729](https://github.com/fastapi/fastapi/pull/12729) by [@paintdog](https://github.com/paintdog).
  * ğŸ“� Update includes for `docs/en/docs/tutorial/schema-extra-example.md`. PR [#12822](https://github.com/fastapi/fastapi/pull/12822) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ“� Update includes in `docs/fr/docs/advanced/additional-responses.md`. PR [#12634](https://github.com/fastapi/fastapi/pull/12634) by [@fegmorte](https://github.com/fegmorte).
  * ğŸ“� Update includes in `docs/fr/docs/advanced/path-operation-advanced-configuration.md`. PR [#12633](https://github.com/fastapi/fastapi/pull/12633) by [@kantandane](https://github.com/kantandane).
  * ğŸ“� Update includes in `docs/fr/docs/advanced/response-directly.md`. PR [#12632](https://github.com/fastapi/fastapi/pull/12632) by [@kantandane](https://github.com/kantandane).
  * ğŸ“� Update includes for `docs/en/docs/tutorial/header-params.md`. PR [#12640](https://github.com/fastapi/fastapi/pull/12640) by [@vishnuvskvkl](https://github.com/vishnuvskvkl).
  * ğŸ“� Update includes in `docs/en/docs/tutorial/cookie-param-models.md`. PR [#12639](https://github.com/fastapi/fastapi/pull/12639) by [@vishnuvskvkl](https://github.com/vishnuvskvkl).
  * ğŸ“� Update includes for `docs/en/docs/tutorial/extra-models.md`. PR [#12638](https://github.com/fastapi/fastapi/pull/12638) by [@vishnuvskvkl](https://github.com/vishnuvskvkl).
  * ğŸ“� Update includes for `docs/en/docs/tutorial/cors.md`. PR [#12637](https://github.com/fastapi/fastapi/pull/12637) by [@vishnuvskvkl](https://github.com/vishnuvskvkl).
  * ğŸ“� Update includes for `docs/en/docs/tutorial/dependencies/sub-dependencies.md`. PR [#12810](https://github.com/fastapi/fastapi/pull/12810) by [@handabaldeep](https://github.com/handabaldeep).
  * ğŸ“� Update includes in `docs/en/docs/tutorial/body-nested-models.md`. PR [#12812](https://github.com/fastapi/fastapi/pull/12812) by [@zhaohan-dong](https://github.com/zhaohan-dong).
  * ğŸ“� Update includes in `docs/en/docs/tutorial/path-operation-configuration.md`. PR [#12809](https://github.com/fastapi/fastapi/pull/12809) by [@AlexWendland](https://github.com/AlexWendland).
  * ğŸ“� Update includes in `docs/en/docs/tutorial/request-files.md`. PR [#12818](https://github.com/fastapi/fastapi/pull/12818) by [@zhaohan-dong](https://github.com/zhaohan-dong).
  * ğŸ“� Update includes for `docs/en/docs/tutorial/query-param-models.md`. PR [#12817](https://github.com/fastapi/fastapi/pull/12817) by [@handabaldeep](https://github.com/handabaldeep).
  * ğŸ“� Update includes in `docs/en/docs/tutorial/path-params.md`. PR [#12811](https://github.com/fastapi/fastapi/pull/12811) by [@AlexWendland](https://github.com/AlexWendland).
  * ğŸ“� Update includes in `docs/en/docs/tutorial/response-model.md`. PR [#12621](https://github.com/fastapi/fastapi/pull/12621) by [@kantandane](https://github.com/kantandane).
  * ğŸ“� Update includes in `docs/en/docs/advanced/websockets.md`. PR [#12606](https://github.com/fastapi/fastapi/pull/12606) by [@vishnuvskvkl](https://github.com/vishnuvskvkl).
  * ğŸ“� Updates include for `docs/en/docs/tutorial/cookie-params.md`. PR [#12808](https://github.com/fastapi/fastapi/pull/12808) by [@handabaldeep](https://github.com/handabaldeep).
  * ğŸ“� Update includes in `docs/en/docs/tutorial/middleware.md`. PR [#12807](https://github.com/fastapi/fastapi/pull/12807) by [@AlexWendland](https://github.com/AlexWendland).
  * ğŸ“� Update includes in `docs/en/docs/advanced/sub-applications.md`. PR [#12806](https://github.com/fastapi/fastapi/pull/12806) by [@zhaohan-dong](https://github.com/zhaohan-dong).
  * ğŸ“� Update includes in `docs/en/docs/advanced/response-headers.md`. PR [#12805](https://github.com/fastapi/fastapi/pull/12805) by [@zhaohan-dong](https://github.com/zhaohan-dong).
  * ğŸ“� Update includes in `docs/fr/docs/tutorial/first-steps.md`. PR [#12594](https://github.com/fastapi/fastapi/pull/12594) by [@kantandane](https://github.com/kantandane).
  * ğŸ“� Update includes in `docs/en/docs/advanced/response-cookies.md`. PR [#12804](https://github.com/fastapi/fastapi/pull/12804) by [@zhaohan-dong](https://github.com/zhaohan-dong).
  * ğŸ“� Update includes in `docs/en/docs/advanced/path-operation-advanced-configuration.md`. PR [#12802](https://github.com/fastapi/fastapi/pull/12802) by [@zhaohan-dong](https://github.com/zhaohan-dong).
  * ğŸ“� Update includes for `docs/en/docs/advanced/response-directly.md`. PR [#12803](https://github.com/fastapi/fastapi/pull/12803) by [@handabaldeep](https://github.com/handabaldeep).
  * ğŸ“� Update includes in `docs/zh/docs/tutorial/background-tasks.md`. PR [#12798](https://github.com/fastapi/fastapi/pull/12798) by [@zhaohan-dong](https://github.com/zhaohan-dong).
  * ğŸ“� Update includes for `docs/de/docs/tutorial/body-multiple-params.md`. PR [#12699](https://github.com/fastapi/fastapi/pull/12699) by [@alissadb](https://github.com/alissadb).
  * ğŸ“� Update includes in `docs/em/docs/tutorial/body-updates.md`. PR [#12799](https://github.com/fastapi/fastapi/pull/12799) by [@AlexWendland](https://github.com/AlexWendland).
  * ğŸ“� Update includes `docs/en/docs/advanced/response-change-status-code.md`. PR [#12801](https://github.com/fastapi/fastapi/pull/12801) by [@handabaldeep](https://github.com/handabaldeep).
  * ğŸ“� Update includes `docs/en/docs/advanced/openapi-callbacks.md`. PR [#12800](https://github.com/fastapi/fastapi/pull/12800) by [@handabaldeep](https://github.com/handabaldeep).
  * ğŸ“� Update includes in `docs/fr/docs/tutorial/body-multiple-params.md`. PR [#12598](https://github.com/fastapi/fastapi/pull/12598) by [@kantandane](https://github.com/kantandane).
  * ğŸ“� Update includes in `docs/en/docs/tutorial/body-multiple-params.md`. PR [#12593](https://github.com/fastapi/fastapi/pull/12593) by [@Tashanam-Shahbaz](https://github.com/Tashanam-Shahbaz).
  * ğŸ“� Update includes in `docs/pt/docs/tutorial/background-tasks.md`. PR [#12736](https://github.com/fastapi/fastapi/pull/12736) by [@bhunao](https://github.com/bhunao).
  * ğŸ“� Update includes for `docs/en/docs/advanced/custom-response.md`. PR [#12797](https://github.com/fastapi/fastapi/pull/12797) by [@handabaldeep](https://github.com/handabaldeep).
  * ğŸ“� Update includes for `docs/pt/docs/python-types.md`. PR [#12671](https://github.com/fastapi/fastapi/pull/12671) by [@ceb10n](https://github.com/ceb10n).
  * ğŸ“� Update includes for `docs/de/docs/python-types.md`. PR [#12660](https://github.com/fastapi/fastapi/pull/12660) by [@alissadb](https://github.com/alissadb).
  * ğŸ“� Update includes for `docs/de/docs/advanced/dataclasses.md`. PR [#12658](https://github.com/fastapi/fastapi/pull/12658) by [@alissadb](https://github.com/alissadb).
  * ğŸ“� Update includes in `docs/fr/docs/tutorial/path-params.md`. PR [#12592](https://github.com/fastapi/fastapi/pull/12592) by [@kantandane](https://github.com/kantandane).
  * ğŸ“� Update includes for `docs/de/docs/how-to/configure-swagger-ui.md`. PR [#12690](https://github.com/fastapi/fastapi/pull/12690) by [@alissadb](https://github.com/alissadb).
  * ğŸ“� Update includes in `docs/en/docs/advanced/security/oauth2-scopes.md`. PR [#12572](https://github.com/fastapi/fastapi/pull/12572) by [@krishnamadhavan](https://github.com/krishnamadhavan).
  * ğŸ“� Update includes for `docs/en/docs/how-to/conditional-openapi.md`. PR [#12624](https://github.com/fastapi/fastapi/pull/12624) by [@rabinlamadong](https://github.com/rabinlamadong).
  * ğŸ“� Update includes in `docs/en/docs/tutorial/dependencies/index.md`. PR [#12615](https://github.com/fastapi/fastapi/pull/12615) by [@bharara](https://github.com/bharara).
  * ğŸ“� Update includes in `docs/en/docs/tutorial/response-status-code.md`. PR [#12620](https://github.com/fastapi/fastapi/pull/12620) by [@kantandane](https://github.com/kantandane).
  * ğŸ“� Update includes in `docs/en/docs/how-to/custom-docs-ui-assets.md`. PR [#12623](https://github.com/fastapi/fastapi/pull/12623) by [@rabinlamadong](https://github.com/rabinlamadong).
  * ğŸ“� Update includes in `docs/en/docs/advanced/openapi-webhooks.md`. PR [#12605](https://github.com/fastapi/fastapi/pull/12605) by [@salmantec](https://github.com/salmantec).
  * ğŸ“� Update includes in `docs/en/docs/advanced/events.md`. PR [#12604](https://github.com/fastapi/fastapi/pull/12604) by [@salmantec](https://github.com/salmantec).
  * ğŸ“� Update includes in `docs/en/docs/advanced/dataclasses.md`. PR [#12603](https://github.com/fastapi/fastapi/pull/12603) by [@salmantec](https://github.com/salmantec).
  * ğŸ“� Update includes in `docs/es/docs/tutorial/cookie-params.md`. PR [#12602](https://github.com/fastapi/fastapi/pull/12602) by [@antonyare93](https://github.com/antonyare93).
  * ğŸ“� Update includes in `docs/fr/docs/tutorial/path-params-numeric-validations.md`. PR [#12601](https://github.com/fastapi/fastapi/pull/12601) by [@kantandane](https://github.com/kantandane).
  * ğŸ“� Update includes in `docs/fr/docs/tutorial/background-tasks.md`. PR [#12600](https://github.com/fastapi/fastapi/pull/12600) by [@kantandane](https://github.com/kantandane).
  * ğŸ“� Update includes in `docs/en/docs/tutorial/encoder.md`. PR [#12597](https://github.com/fastapi/fastapi/pull/12597) by [@tonyjly](https://github.com/tonyjly).
  * ğŸ“� Update includes in `docs/en/docs/how-to/custom-docs-ui-assets.md`. PR [#12557](https://github.com/fastapi/fastapi/pull/12557) by [@philipokiokio](https://github.com/philipokiokio).
  * ğŸ�¨ Adjust spacing. PR [#12635](https://github.com/fastapi/fastapi/pull/12635) by [@alejsdev](https://github.com/alejsdev).
  * ğŸ“� Update includes in `docs/en/docs/how-to/custom-request-and-route.md`. PR [#12560](https://github.com/fastapi/fastapi/pull/12560) by [@philipokiokio](https://github.com/philipokiokio).

### Translations[¶](#translations_24 "Permanent link")

  * ğŸŒ� Add Korean translation for `docs/ko/docs/advanced/testing-websockets.md`. PR [#12739](https://github.com/fastapi/fastapi/pull/12739) by [@Limsunoh](https://github.com/Limsunoh).
  * ğŸŒ� Add Traditional Chinese translation for `docs/zh-hant/docs/environment-variables.md`. PR [#12785](https://github.com/fastapi/fastapi/pull/12785) by [@Vincy1230](https://github.com/Vincy1230).
  * ğŸŒ� Add Chinese translation for `docs/zh/docs/environment-variables.md`. PR [#12784](https://github.com/fastapi/fastapi/pull/12784) by [@Vincy1230](https://github.com/Vincy1230).
  * ğŸŒ� Add Korean translation for `ko/docs/advanced/response-headers.md`. PR [#12740](https://github.com/fastapi/fastapi/pull/12740) by [@kwang1215](https://github.com/kwang1215).
  * ğŸŒ� Add Chinese translation for `docs/zh/docs/virtual-environments.md`. PR [#12790](https://github.com/fastapi/fastapi/pull/12790) by [@Vincy1230](https://github.com/Vincy1230).
  * ğŸŒ� Add Korean translation for `/docs/ko/docs/environment-variables.md`. PR [#12526](https://github.com/fastapi/fastapi/pull/12526) by [@Tolerblanc](https://github.com/Tolerblanc).
  * ğŸŒ� Add Korean translation for `docs/ko/docs/history-design-future.md`. PR [#12646](https://github.com/fastapi/fastapi/pull/12646) by [@saeye](https://github.com/saeye).
  * ğŸŒ� Add Korean translation for `docs/ko/docs/advanced/advanced-dependencies.md`. PR [#12675](https://github.com/fastapi/fastapi/pull/12675) by [@kim-sangah](https://github.com/kim-sangah).
  * ğŸŒ� Add Korean translation for `docs/ko/docs/how-to/conditional-openapi.md`. PR [#12731](https://github.com/fastapi/fastapi/pull/12731) by [@sptcnl](https://github.com/sptcnl).
  * ğŸŒ� Add Korean translation for `docs/ko/docs/advanced/using_request_directly.md`. PR [#12738](https://github.com/fastapi/fastapi/pull/12738) by [@kwang1215](https://github.com/kwang1215).
  * ğŸŒ� Add Korean translation for `docs/ko/docs/advanced/testing-events.md`. PR [#12741](https://github.com/fastapi/fastapi/pull/12741) by [@9zimin9](https://github.com/9zimin9).
  * ğŸŒ� Add Korean translation for `docs/ko/docs/security/index.md`. PR [#12743](https://github.com/fastapi/fastapi/pull/12743) by [@kim-sangah](https://github.com/kim-sangah).
  * ğŸŒ� Add Portuguese translation for `docs/pt/docs/advanced/path-operation-advanced-configuration.md`. PR [#12762](https://github.com/fastapi/fastapi/pull/12762) by [@Joao-Pedro-P-Holanda](https://github.com/Joao-Pedro-P-Holanda).
  * ğŸŒ� Add Korean translation for `docs/ko/docs/advanced/wsgi.md`. PR [#12659](https://github.com/fastapi/fastapi/pull/12659) by [@Limsunoh](https://github.com/Limsunoh).
  * ğŸŒ� Add Portuguese translation for `docs/pt/docs/advanced/websockets.md`. PR [#12703](https://github.com/fastapi/fastapi/pull/12703) by [@devfernandoa](https://github.com/devfernandoa).
  * ğŸŒ� Add Portuguese translation for `docs/pt/docs/tutorial/security/simple-oauth2.md`. PR [#12520](https://github.com/fastapi/fastapi/pull/12520) by [@LidiaDomingos](https://github.com/LidiaDomingos).
  * ğŸŒ� Add Korean translation for `docs/ko/docs/advanced/response-directly.md`. PR [#12674](https://github.com/fastapi/fastapi/pull/12674) by [@9zimin9](https://github.com/9zimin9).
  * ğŸŒ� Add Portuguese translation for `docs/pt/docs/advanced/middleware.md`. PR [#12704](https://github.com/fastapi/fastapi/pull/12704) by [@devluisrodrigues](https://github.com/devluisrodrigues).
  * ğŸŒ� Add Portuguese translation for `docs/pt/docs/advanced/openapi-callbacks.md`. PR [#12705](https://github.com/fastapi/fastapi/pull/12705) by [@devfernandoa](https://github.com/devfernandoa).
  * ğŸŒ� Add Portuguese translation for `docs/pt/docs/tutorial/request-files.md`. PR [#12706](https://github.com/fastapi/fastapi/pull/12706) by [@devluisrodrigues](https://github.com/devluisrodrigues).
  * ğŸŒ� Add Portuguese Translation for `docs/pt/docs/advanced/custom-response.md`. PR [#12631](https://github.com/fastapi/fastapi/pull/12631) by [@Joao-Pedro-P-Holanda](https://github.com/Joao-Pedro-P-Holanda).
  * ğŸŒ� Add Portuguese translation for `docs/pt/docs/tutorial/metadata.md`. PR [#12538](https://github.com/fastapi/fastapi/pull/12538) by [@LinkolnR](https://github.com/LinkolnR).
  * ğŸŒ� Add Korean translation for `docs/ko/docs/tutorial/metadata.md`. PR [#12541](https://github.com/fastapi/fastapi/pull/12541) by [@kwang1215](https://github.com/kwang1215).
  * ğŸŒ� Add Korean Translation for `docs/ko/docs/advanced/response-cookies.md`. PR [#12546](https://github.com/fastapi/fastapi/pull/12546) by [@kim-sangah](https://github.com/kim-sangah).
  * ğŸŒ� Add Korean translation for `docs/ko/docs/fastapi-cli.md`. PR [#12515](https://github.com/fastapi/fastapi/pull/12515) by [@dhdld](https://github.com/dhdld).
  * ğŸŒ� Add Korean Translation for `docs/ko/docs/advanced/response-change-status-code.md`. PR [#12547](https://github.com/fastapi/fastapi/pull/12547) by [@9zimin9](https://github.com/9zimin9).

### Internal[¶](#internal_34 "Permanent link")

  * â¬† [pre-commit.ci] pre-commit autoupdate. PR [#12907](https://github.com/fastapi/fastapi/pull/12907) by [@pre-commit-ci[bot]](https://github.com/apps/pre-commit-ci).
  * ğŸ”¨ Update docs preview script to show previous version and English version. PR [#12856](https://github.com/fastapi/fastapi/pull/12856) by [@tiangolo](https://github.com/tiangolo).
  * â¬† Bump tiangolo/latest-changes from 0.3.1 to 0.3.2. PR [#12794](https://github.com/fastapi/fastapi/pull/12794) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * â¬† Bump pypa/gh-action-pypi-publish from 1.12.0 to 1.12.2. PR [#12788](https://github.com/fastapi/fastapi/pull/12788) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * â¬† Bump pypa/gh-action-pypi-publish from 1.11.0 to 1.12.0. PR [#12781](https://github.com/fastapi/fastapi/pull/12781) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * â¬† Bump cloudflare/wrangler-action from 3.11 to 3.12. PR [#12777](https://github.com/fastapi/fastapi/pull/12777) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * â¬† [pre-commit.ci] pre-commit autoupdate. PR [#12766](https://github.com/fastapi/fastapi/pull/12766) by [@pre-commit-ci[bot]](https://github.com/apps/pre-commit-ci).
  * â¬† Bump pypa/gh-action-pypi-publish from 1.10.3 to 1.11.0. PR [#12721](https://github.com/fastapi/fastapi/pull/12721) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * â¬† Update pre-commit requirement from <4.0.0,>=2.17.0 to >=2.17.0,<5.0.0. PR [#12749](https://github.com/fastapi/fastapi/pull/12749) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * â¬† Bump typer from 0.12.3 to 0.12.5. PR [#12748](https://github.com/fastapi/fastapi/pull/12748) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * â¬† Update flask requirement from <3.0.0,>=1.1.2 to >=1.1.2,<4.0.0. PR [#12747](https://github.com/fastapi/fastapi/pull/12747) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * â¬† Bump pillow from 10.4.0 to 11.0.0. PR [#12746](https://github.com/fastapi/fastapi/pull/12746) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * â¬† Update pytest requirement from <8.0.0,>=7.1.3 to >=7.1.3,<9.0.0. PR [#12745](https://github.com/fastapi/fastapi/pull/12745) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * ğŸ”§ Update sponsors: add Render. PR [#12733](https://github.com/fastapi/fastapi/pull/12733) by [@tiangolo](https://github.com/tiangolo).
  * â¬† [pre-commit.ci] pre-commit autoupdate. PR [#12707](https://github.com/fastapi/fastapi/pull/12707) by [@pre-commit-ci[bot]](https://github.com/apps/pre-commit-ci).

## 0.115.4[¶](#01154 "Permanent link")

### Refactors[¶](#refactors_14 "Permanent link")

  * â™»ï¸� Update logic to import and check `python-multipart` for compatibility with newer version. PR [#12627](https://github.com/fastapi/fastapi/pull/12627) by [@tiangolo](https://github.com/tiangolo).

### Docs[¶](#docs_28 "Permanent link")

  * ğŸ“� Update includes in `docs/fr/docs/tutorial/body.md`. PR [#12596](https://github.com/fastapi/fastapi/pull/12596) by [@kantandane](https://github.com/kantandane).
  * ğŸ“� Update includes in `docs/fr/docs/tutorial/debugging.md`. PR [#12595](https://github.com/fastapi/fastapi/pull/12595) by [@kantandane](https://github.com/kantandane).
  * ğŸ“� Update includes in `docs/fr/docs/tutorial/query-params-str-validations.md`. PR [#12591](https://github.com/fastapi/fastapi/pull/12591) by [@kantandane](https://github.com/kantandane).
  * ğŸ“� Update includes in `docs/fr/docs/tutorial/query-params.md`. PR [#12589](https://github.com/fastapi/fastapi/pull/12589) by [@kantandane](https://github.com/kantandane).
  * ğŸ“� Update includes in `docs/en/tutorial/body-fields.md`. PR [#12588](https://github.com/fastapi/fastapi/pull/12588) by [@lucaromagnoli](https://github.com/lucaromagnoli).
  * ğŸ“� Update includes in `docs/de/docs/tutorial/response-status-code.md`. PR [#12585](https://github.com/fastapi/fastapi/pull/12585) by [@abejaranoh](https://github.com/abejaranoh).
  * ğŸ“� Update includes in `docs/en/docs/tutorial/body.md`. PR [#12586](https://github.com/fastapi/fastapi/pull/12586) by [@lucaromagnoli](https://github.com/lucaromagnoli).
  * ğŸ“� Update includes in `docs/en/docs/advanced/behind-a-proxy.md`. PR [#12583](https://github.com/fastapi/fastapi/pull/12583) by [@imjuanleonard](https://github.com/imjuanleonard).
  * ğŸ“� Update includes syntax for `docs/pl/docs/tutorial/first-steps.md`. PR [#12584](https://github.com/fastapi/fastapi/pull/12584) by [@sebkozlo](https://github.com/sebkozlo).
  * ğŸ“� Update includes in `docs/en/docs/advanced/middleware.md`. PR [#12582](https://github.com/fastapi/fastapi/pull/12582) by [@montanarograziano](https://github.com/montanarograziano).
  * ğŸ“� Update includes in `docs/en/docs/advanced/additional-status-codes.md`. PR [#12577](https://github.com/fastapi/fastapi/pull/12577) by [@krishnamadhavan](https://github.com/krishnamadhavan).
  * ğŸ“� Update includes in `docs/en/docs/advanced/advanced-dependencies.md`. PR [#12578](https://github.com/fastapi/fastapi/pull/12578) by [@krishnamadhavan](https://github.com/krishnamadhavan).
  * ğŸ“� Update includes in `docs/en/docs/advanced/additional-responses.md`. PR [#12576](https://github.com/fastapi/fastapi/pull/12576) by [@krishnamadhavan](https://github.com/krishnamadhavan).
  * ğŸ“� Update includes in `docs/en/docs/tutorial/static-files.md`. PR [#12575](https://github.com/fastapi/fastapi/pull/12575) by [@lucaromagnoli](https://github.com/lucaromagnoli).
  * ğŸ“� Update includes in `docs/en/docs/advanced/async-tests.md`. PR [#12568](https://github.com/fastapi/fastapi/pull/12568) by [@krishnamadhavan](https://github.com/krishnamadhavan).
  * ğŸ“� Update includes in `docs/pt/docs/advanced/behind-a-proxy.md`. PR [#12563](https://github.com/fastapi/fastapi/pull/12563) by [@asmioglou](https://github.com/asmioglou).
  * ğŸ“� Update includes in `docs/de/docs/advanced/security/http-basic-auth.md`. PR [#12561](https://github.com/fastapi/fastapi/pull/12561) by [@Nimitha-jagadeesha](https://github.com/Nimitha-jagadeesha).
  * ğŸ“� Update includes in `docs/en/docs/tutorial/background-tasks.md`. PR [#12559](https://github.com/fastapi/fastapi/pull/12559) by [@FarhanAliRaza](https://github.com/FarhanAliRaza).
  * ğŸ“� Update includes in `docs/fr/docs/python-types.md`. PR [#12558](https://github.com/fastapi/fastapi/pull/12558) by [@Ismailtlem](https://github.com/Ismailtlem).
  * ğŸ“� Update includes in `docs/en/docs/how-to/graphql.md`. PR [#12564](https://github.com/fastapi/fastapi/pull/12564) by [@philipokiokio](https://github.com/philipokiokio).
  * ğŸ“� Update includes in `docs/en/docs/how-to/extending-openapi.md`. PR [#12562](https://github.com/fastapi/fastapi/pull/12562) by [@philipokiokio](https://github.com/philipokiokio).
  * ğŸ“� Update includes for `docs/en/docs/how-to/configure-swagger-ui.md`. PR [#12556](https://github.com/fastapi/fastapi/pull/12556) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ“� Update includes for `docs/en/docs/how-to/separate-openapi-schemas.md`. PR [#12555](https://github.com/fastapi/fastapi/pull/12555) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ“� Update includes for `docs/en/docs/advanced/security/http-basic-auth.md`. PR [#12553](https://github.com/fastapi/fastapi/pull/12553) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ“� Update includes in `docs/en/docs/tutorial/first-steps.md`. PR [#12552](https://github.com/fastapi/fastapi/pull/12552) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ“� Update includes in `docs/en/docs/python-types.md`. PR [#12551](https://github.com/fastapi/fastapi/pull/12551) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ“� Fix link in OAuth2 docs. PR [#12550](https://github.com/fastapi/fastapi/pull/12550) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ“� Add External Link: FastAPI do Zero. PR [#12533](https://github.com/fastapi/fastapi/pull/12533) by [@rennerocha](https://github.com/rennerocha).
  * ğŸ“� Fix minor typos. PR [#12516](https://github.com/fastapi/fastapi/pull/12516) by [@kkirsche](https://github.com/kkirsche).
  * ğŸŒ� Fix rendering issue in translations. PR [#12509](https://github.com/fastapi/fastapi/pull/12509) by [@alejsdev](https://github.com/alejsdev).

### Translations[¶](#translations_25 "Permanent link")

  * ğŸ“� Update includes in `docs/de/docs/advanced/async-tests.md`. PR [#12567](https://github.com/fastapi/fastapi/pull/12567) by [@imjuanleonard](https://github.com/imjuanleonard).
  * ğŸŒ� Add Portuguese translation for `docs/pt/docs/tutorial/sql-databases.md`. PR [#12530](https://github.com/fastapi/fastapi/pull/12530) by [@ilacftemp](https://github.com/ilacftemp).
  * ğŸŒ� Add Korean translation for `docs/ko/docs/benchmarks.md`. PR [#12540](https://github.com/fastapi/fastapi/pull/12540) by [@Limsunoh](https://github.com/Limsunoh).
  * ğŸŒ� Add Portuguese translation for `docs/pt/docs/how-to/separate-openapi-schemas.md`. PR [#12518](https://github.com/fastapi/fastapi/pull/12518) by [@ilacftemp](https://github.com/ilacftemp).
  * ğŸŒ� Update Traditional Chinese translation for `docs/zh-hant/docs/deployment/index.md`. PR [#12521](https://github.com/fastapi/fastapi/pull/12521) by [@codingjenny](https://github.com/codingjenny).
  * ğŸŒ� Update Traditional Chinese translation for `docs/zh-hant/docs/deployment/cloud.md`. PR [#12522](https://github.com/fastapi/fastapi/pull/12522) by [@codingjenny](https://github.com/codingjenny).
  * ğŸŒ� Update Traditional Chinese translation for `docs/zh-hant/docs/how-to/index.md`. PR [#12523](https://github.com/fastapi/fastapi/pull/12523) by [@codingjenny](https://github.com/codingjenny).
  * ğŸŒ� Update Traditional Chinese translation for `docs/zh-hant/docs/tutorial/index.md`. PR [#12524](https://github.com/fastapi/fastapi/pull/12524) by [@codingjenny](https://github.com/codingjenny).
  * ğŸŒ� Add Traditional Chinese translation for `docs/zh-hant/docs/how-to/index.md`. PR [#12468](https://github.com/fastapi/fastapi/pull/12468) by [@codingjenny](https://github.com/codingjenny).
  * ğŸŒ� Add Traditional Chinese translation for `docs/zh-hant/docs/tutorial/index.md`. PR [#12466](https://github.com/fastapi/fastapi/pull/12466) by [@codingjenny](https://github.com/codingjenny).
  * ğŸŒ� Add Portuguese translation for `docs/pt/docs/tutorial/header-param-models.md`. PR [#12437](https://github.com/fastapi/fastapi/pull/12437) by [@Joao-Pedro-P-Holanda](https://github.com/Joao-Pedro-P-Holanda).
  * ğŸŒ� Add Portuguese translation for `docs/pt/docs/how-to/extending-openapi.md`. PR [#12470](https://github.com/fastapi/fastapi/pull/12470) by [@ilacftemp](https://github.com/ilacftemp).
  * ğŸŒ� Add Portuguese translation for `docs/pt/docs/advanced/dataclasses.md`. PR [#12475](https://github.com/fastapi/fastapi/pull/12475) by [@leoscarlato](https://github.com/leoscarlato).
  * ğŸŒ� Add Portuguese translation for `docs/pt/docs/how-to/custom-request-and-route.md`. PR [#12483](https://github.com/fastapi/fastapi/pull/12483) by [@devfernandoa](https://github.com/devfernandoa).

### Internal[¶](#internal_35 "Permanent link")

  * â¬† Bump cloudflare/wrangler-action from 3.9 to 3.11. PR [#12544](https://github.com/fastapi/fastapi/pull/12544) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * ğŸ‘· Update GitHub Action to deploy docs previews to handle missing deploy comments. PR [#12527](https://github.com/fastapi/fastapi/pull/12527) by [@tiangolo](https://github.com/tiangolo).
  * â¬† [pre-commit.ci] pre-commit autoupdate. PR [#12505](https://github.com/fastapi/fastapi/pull/12505) by [@pre-commit-ci[bot]](https://github.com/apps/pre-commit-ci).

## 0.115.3[¶](#01153 "Permanent link")

### Upgrades[¶](#upgrades_10 "Permanent link")

  * â¬†ï¸� Upgrade Starlette to `>=0.40.0,<0.42.0`. PR [#12469](https://github.com/fastapi/fastapi/pull/12469) by [@defnull](https://github.com/defnull).

### Docs[¶](#docs_29 "Permanent link")

  * ğŸ“� Fix broken link in docs. PR [#12495](https://github.com/fastapi/fastapi/pull/12495) by [@eltonjncorreia](https://github.com/eltonjncorreia).

### Translations[¶](#translations_26 "Permanent link")

  * ğŸŒ� Add Traditional Chinese translation for `docs/zh-hant/docs/fastapi-cli.md`. PR [#12444](https://github.com/fastapi/fastapi/pull/12444) by [@codingjenny](https://github.com/codingjenny).
  * ğŸŒ� Add Traditional Chinese translation for `docs/zh-hant/docs/deployment/index.md`. PR [#12439](https://github.com/fastapi/fastapi/pull/12439) by [@codingjenny](https://github.com/codingjenny).
  * ğŸŒ� Add Portuguese translation for `docs/pt/docs/how-to/testing-database.md`. PR [#12472](https://github.com/fastapi/fastapi/pull/12472) by [@GuilhermeRameh](https://github.com/GuilhermeRameh).
  * ğŸŒ� Add Portuguese translation for `docs/pt/docs/how-to/custom-docs-ui-assets.md`. PR [#12473](https://github.com/fastapi/fastapi/pull/12473) by [@devluisrodrigues](https://github.com/devluisrodrigues).
  * ğŸŒ� Add Portuguese translation for `docs/pt/docs/advanced/response-headers.md`. PR [#12458](https://github.com/fastapi/fastapi/pull/12458) by [@leonardopaloschi](https://github.com/leonardopaloschi).
  * ğŸŒ� Add Traditional Chinese translation for `docs/zh-hant/docs/deployment/cloud.md`. PR [#12440](https://github.com/fastapi/fastapi/pull/12440) by [@codingjenny](https://github.com/codingjenny).
  * ğŸŒ� Update Portuguese translation for `docs/pt/docs/python-types.md`. PR [#12428](https://github.com/fastapi/fastapi/pull/12428) by [@ceb10n](https://github.com/ceb10n).
  * ğŸŒ� Add Russian translation for `docs/ru/docs/environment-variables.md`. PR [#12436](https://github.com/fastapi/fastapi/pull/12436) by [@wisderfin](https://github.com/wisderfin).
  * ğŸŒ� Add Traditional Chinese translation for `docs/zh-hant/docs/resources/index.md`. PR [#12443](https://github.com/fastapi/fastapi/pull/12443) by [@codingjenny](https://github.com/codingjenny).
  * ğŸŒ� Add Traditional Chinese translation for `docs/zh-hant/docs/about/index.md`. PR [#12438](https://github.com/fastapi/fastapi/pull/12438) by [@codingjenny](https://github.com/codingjenny).
  * ğŸŒ� Add Portuguese translation for `docs/pt/docs/tutorial/query-param-models.md`. PR [#12414](https://github.com/fastapi/fastapi/pull/12414) by [@ceb10n](https://github.com/ceb10n).
  * ğŸŒ� Remove Portuguese translation for `docs/pt/docs/deployment.md`. PR [#12427](https://github.com/fastapi/fastapi/pull/12427) by [@ceb10n](https://github.com/ceb10n).
  * ğŸŒ� Add Portuguese translation for `docs/pt/docs/tutorial/body-updates.md`. PR [#12381](https://github.com/fastapi/fastapi/pull/12381) by [@andersonrocha0](https://github.com/andersonrocha0).
  * ğŸŒ� Add Portuguese translation for `docs/pt/docs/advanced/response-cookies.md`. PR [#12417](https://github.com/fastapi/fastapi/pull/12417) by [@Paulofalcao2002](https://github.com/Paulofalcao2002).

### Internal[¶](#internal_36 "Permanent link")

  * ğŸ‘· Update issue manager workflow . PR [#12457](https://github.com/fastapi/fastapi/pull/12457) by [@alejsdev](https://github.com/alejsdev).
  * ğŸ”§ Update team, include YuriiMotov ğŸš€. PR [#12453](https://github.com/fastapi/fastapi/pull/12453) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘· Refactor label-approved, make it an internal script instead of an external GitHub Action. PR [#12280](https://github.com/fastapi/fastapi/pull/12280) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘· Fix smokeshow, checkout files on CI. PR [#12434](https://github.com/fastapi/fastapi/pull/12434) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘· Use uv in CI. PR [#12281](https://github.com/fastapi/fastapi/pull/12281) by [@tiangolo](https://github.com/tiangolo).
  * â¬† Update httpx requirement from <0.25.0,>=0.23.0 to >=0.23.0,<0.28.0. PR [#11509](https://github.com/fastapi/fastapi/pull/11509) by [@dependabot[bot]](https://github.com/apps/dependabot).

## 0.115.2[¶](#01152 "Permanent link")

### Upgrades[¶](#upgrades_11 "Permanent link")

  * â¬†ï¸� Upgrade Starlette to `>=0.37.2,<0.41.0`. PR [#12431](https://github.com/fastapi/fastapi/pull/12431) by [@tiangolo](https://github.com/tiangolo).

## 0.115.1[¶](#01151 "Permanent link")

### Fixes[¶](#fixes_36 "Permanent link")

  * ğŸ�› Fix openapi generation with responses kwarg. PR [#10895](https://github.com/fastapi/fastapi/pull/10895) by [@flxdot](https://github.com/flxdot).
  * ğŸ�› Remove `Required` shadowing from fastapi using Pydantic v2. PR [#12197](https://github.com/fastapi/fastapi/pull/12197) by [@pachewise](https://github.com/pachewise).

### Refactors[¶](#refactors_15 "Permanent link")

  * â™»ï¸� Update type annotations for improved `python-multipart`. PR [#12407](https://github.com/fastapi/fastapi/pull/12407) by [@tiangolo](https://github.com/tiangolo).

### Docs[¶](#docs_30 "Permanent link")

  * âœ¨ Add new tutorial for SQL databases with SQLModel. PR [#12285](https://github.com/fastapi/fastapi/pull/12285) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ“� Add External Link: How to profile a FastAPI asynchronous request. PR [#12389](https://github.com/fastapi/fastapi/pull/12389) by [@brouberol](https://github.com/brouberol).
  * ğŸ”§ Remove `base_path` for `mdx_include` Markdown extension in MkDocs. PR [#12391](https://github.com/fastapi/fastapi/pull/12391) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ“� Update link to Swagger UI configuration docs. PR [#12264](https://github.com/fastapi/fastapi/pull/12264) by [@makisukurisu](https://github.com/makisukurisu).
  * ğŸ“� Adding links for Playwright and Vite in `docs/project-generation.md`. PR [#12274](https://github.com/fastapi/fastapi/pull/12274) by [@kayqueGovetri](https://github.com/kayqueGovetri).
  * ğŸ“� Fix small typos in the documentation. PR [#12213](https://github.com/fastapi/fastapi/pull/12213) by [@svlandeg](https://github.com/svlandeg).

### Translations[¶](#translations_27 "Permanent link")

  * ğŸŒ� Add Portuguese translation for `docs/pt/docs/tutorial/cookie-param-models.md`. PR [#12298](https://github.com/fastapi/fastapi/pull/12298) by [@ceb10n](https://github.com/ceb10n).
  * ğŸŒ� Add Portuguese translation for `docs/pt/docs/how-to/graphql.md`. PR [#12215](https://github.com/fastapi/fastapi/pull/12215) by [@AnandaCampelo](https://github.com/AnandaCampelo).
  * ğŸŒ� Add Portuguese translation for `docs/pt/docs/advanced/security/oauth2-scopes.md`. PR [#12263](https://github.com/fastapi/fastapi/pull/12263) by [@ceb10n](https://github.com/ceb10n).
  * ğŸŒ� Add Portuguese translation for `docs/pt/docs/deployment/concepts.md`. PR [#12219](https://github.com/fastapi/fastapi/pull/12219) by [@marcelomarkus](https://github.com/marcelomarkus).
  * ğŸŒ� Add Portuguese translation for `docs/pt/docs/how-to/conditional-openapi.md`. PR [#12221](https://github.com/fastapi/fastapi/pull/12221) by [@marcelomarkus](https://github.com/marcelomarkus).
  * ğŸŒ� Add Portuguese translation for `docs/pt/docs/advanced/response-directly.md`. PR [#12266](https://github.com/fastapi/fastapi/pull/12266) by [@Joao-Pedro-P-Holanda](https://github.com/Joao-Pedro-P-Holanda).
  * ğŸŒ� Update Portuguese translation for `docs/pt/docs/tutorial/cookie-params.md`. PR [#12297](https://github.com/fastapi/fastapi/pull/12297) by [@ceb10n](https://github.com/ceb10n).
  * ğŸŒ� Fix Korean translation for `docs/ko/docs/tutorial/index.md`. PR [#12278](https://github.com/fastapi/fastapi/pull/12278) by [@kkotipy](https://github.com/kkotipy).
  * ğŸŒ� Update Portuguese translation for `docs/pt/docs/advanced/security/http-basic-auth.md`. PR [#12275](https://github.com/fastapi/fastapi/pull/12275) by [@andersonrocha0](https://github.com/andersonrocha0).
  * ğŸŒ� Add Portuguese translation for `docs/pt/docs/deployment/cloud.md`. PR [#12217](https://github.com/fastapi/fastapi/pull/12217) by [@marcelomarkus](https://github.com/marcelomarkus).
  * âœ�ï¸� Fix typo in `docs/es/docs/python-types.md`. PR [#12235](https://github.com/fastapi/fastapi/pull/12235) by [@JavierSanchezCastro](https://github.com/JavierSanchezCastro).
  * ğŸŒ� Add Dutch translation for `docs/nl/docs/environment-variables.md`. PR [#12200](https://github.com/fastapi/fastapi/pull/12200) by [@maxscheijen](https://github.com/maxscheijen).
  * ğŸŒ� Add Portuguese translation for `docs/pt/docs/deployment/manually.md`. PR [#12210](https://github.com/fastapi/fastapi/pull/12210) by [@JoaoGustavoRogel](https://github.com/JoaoGustavoRogel).
  * ğŸŒ� Add Portuguese translation for `docs/pt/docs/deployment/server-workers.md`. PR [#12220](https://github.com/fastapi/fastapi/pull/12220) by [@marcelomarkus](https://github.com/marcelomarkus).
  * ğŸŒ� Add Portuguese translation for `docs/pt/docs/how-to/configure-swagger-ui.md`. PR [#12222](https://github.com/fastapi/fastapi/pull/12222) by [@marcelomarkus](https://github.com/marcelomarkus).

### Internal[¶](#internal_37 "Permanent link")

  * â¬† [pre-commit.ci] pre-commit autoupdate. PR [#12396](https://github.com/fastapi/fastapi/pull/12396) by [@pre-commit-ci[bot]](https://github.com/apps/pre-commit-ci).
  * ğŸ”¨ Add script to generate variants of files. PR [#12405](https://github.com/fastapi/fastapi/pull/12405) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”§ Add speakeasy-api to `sponsors_badge.yml`. PR [#12404](https://github.com/fastapi/fastapi/pull/12404) by [@tiangolo](https://github.com/tiangolo).
  * â�• Add docs dependency: markdown-include-variants. PR [#12399](https://github.com/fastapi/fastapi/pull/12399) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ“� Fix extra mdx-base-path paths. PR [#12397](https://github.com/fastapi/fastapi/pull/12397) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘· Tweak labeler to not override custom labels. PR [#12398](https://github.com/fastapi/fastapi/pull/12398) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘· Update worfkow deploy-docs-notify URL. PR [#12392](https://github.com/fastapi/fastapi/pull/12392) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘· Update Cloudflare GitHub Action. PR [#12387](https://github.com/fastapi/fastapi/pull/12387) by [@tiangolo](https://github.com/tiangolo).
  * â¬† Bump pypa/gh-action-pypi-publish from 1.10.1 to 1.10.3. PR [#12386](https://github.com/fastapi/fastapi/pull/12386) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * â¬† Bump mkdocstrings[python] from 0.25.1 to 0.26.1. PR [#12371](https://github.com/fastapi/fastapi/pull/12371) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * â¬† Bump griffe-typingdoc from 0.2.6 to 0.2.7. PR [#12370](https://github.com/fastapi/fastapi/pull/12370) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * â¬† [pre-commit.ci] pre-commit autoupdate. PR [#12331](https://github.com/fastapi/fastapi/pull/12331) by [@pre-commit-ci[bot]](https://github.com/apps/pre-commit-ci).
  * ğŸ”§ Update sponsors, remove Fine.dev. PR [#12271](https://github.com/fastapi/fastapi/pull/12271) by [@tiangolo](https://github.com/tiangolo).
  * â¬† [pre-commit.ci] pre-commit autoupdate. PR [#12253](https://github.com/fastapi/fastapi/pull/12253) by [@pre-commit-ci[bot]](https://github.com/apps/pre-commit-ci).
  * âœ�ï¸� Fix docstring typos in http security. PR [#12223](https://github.com/fastapi/fastapi/pull/12223) by [@albertvillanova](https://github.com/albertvillanova).

## 0.115.0[¶](#01150 "Permanent link")

### Highlights[¶](#highlights "Permanent link")

Now you can declare `Query`, `Header`, and `Cookie` parameters with Pydantic models. ğŸ�‰

#### `Query` Parameter Models[¶](#query-parameter-models "Permanent link")

Use Pydantic models for `Query` parameters:
    
    
    from typing import Annotated, Literal
    
    from fastapi import FastAPI, Query
    from pydantic import BaseModel, Field
    
    app = FastAPI()
    
    
    class FilterParams(BaseModel):
        limit: int = Field(100, gt=0, le=100)
        offset: int = Field(0, ge=0)
        order_by: Literal["created_at", "updated_at"] = "created_at"
        tags: list[str] = []
    
    
    @app.get("/items/")
    async def read_items(filter_query: Annotated[FilterParams, Query()]):
        return filter_query
    

Read the new docs: [Query Parameter Models](https://fastapi.tiangolo.com/tutorial/query-param-models/).

#### `Header` Parameter Models[¶](#header-parameter-models "Permanent link")

Use Pydantic models for `Header` parameters:
    
    
    from typing import Annotated
    
    from fastapi import FastAPI, Header
    from pydantic import BaseModel
    
    app = FastAPI()
    
    
    class CommonHeaders(BaseModel):
        host: str
        save_data: bool
        if_modified_since: str | None = None
        traceparent: str | None = None
        x_tag: list[str] = []
    
    
    @app.get("/items/")
    async def read_items(headers: Annotated[CommonHeaders, Header()]):
        return headers
    

Read the new docs: [Header Parameter Models](https://fastapi.tiangolo.com/tutorial/header-param-models/).

#### `Cookie` Parameter Models[¶](#cookie-parameter-models "Permanent link")

Use Pydantic models for `Cookie` parameters:
    
    
    from typing import Annotated
    
    from fastapi import Cookie, FastAPI
    from pydantic import BaseModel
    
    app = FastAPI()
    
    
    class Cookies(BaseModel):
        session_id: str
        fatebook_tracker: str | None = None
        googall_tracker: str | None = None
    
    
    @app.get("/items/")
    async def read_items(cookies: Annotated[Cookies, Cookie()]):
        return cookies
    

Read the new docs: [Cookie Parameter Models](https://fastapi.tiangolo.com/tutorial/cookie-param-models/).

#### Forbid Extra Query (Cookie, Header) Parameters[¶](#forbid-extra-query-cookie-header-parameters "Permanent link")

Use Pydantic models to restrict extra values for `Query` parameters (also applies to `Header` and `Cookie` parameters).

To achieve it, use Pydantic's `model_config = {"extra": "forbid"}`:
    
    
    from typing import Annotated, Literal
    
    from fastapi import FastAPI, Query
    from pydantic import BaseModel, Field
    
    app = FastAPI()
    
    
    class FilterParams(BaseModel):
        model_config = {"extra": "forbid"}
    
        limit: int = Field(100, gt=0, le=100)
        offset: int = Field(0, ge=0)
        order_by: Literal["created_at", "updated_at"] = "created_at"
        tags: list[str] = []
    
    
    @app.get("/items/")
    async def read_items(filter_query: Annotated[FilterParams, Query()]):
        return filter_query
    

This applies to `Query`, `Header`, and `Cookie` parameters, read the new docs:

  * [Forbid Extra Query Parameters](https://fastapi.tiangolo.com/tutorial/query-param-models/#forbid-extra-query-parameters)
  * [Forbid Extra Headers](https://fastapi.tiangolo.com/tutorial/header-param-models/#forbid-extra-headers)
  * [Forbid Extra Cookies](https://fastapi.tiangolo.com/tutorial/cookie-param-models/#forbid-extra-cookies)

### Features[¶](#features_8 "Permanent link")

  * âœ¨ Add support for Pydantic models for parameters using `Query`, `Cookie`, `Header`. PR [#12199](https://github.com/fastapi/fastapi/pull/12199) by [@tiangolo](https://github.com/tiangolo).

### Translations[¶](#translations_28 "Permanent link")

  * ğŸŒ� Add Portuguese translation for `docs/pt/docs/advanced/security/http-basic-auth.md`. PR [#12195](https://github.com/fastapi/fastapi/pull/12195) by [@ceb10n](https://github.com/ceb10n).

### Internal[¶](#internal_38 "Permanent link")

  * â¬† [pre-commit.ci] pre-commit autoupdate. PR [#12204](https://github.com/fastapi/fastapi/pull/12204) by [@pre-commit-ci[bot]](https://github.com/apps/pre-commit-ci).

## 0.114.2[¶](#01142 "Permanent link")

### Fixes[¶](#fixes_37 "Permanent link")

  * ğŸ�› Fix form field regression with `alias`. PR [#12194](https://github.com/fastapi/fastapi/pull/12194) by [@Wurstnase](https://github.com/Wurstnase).

### Translations[¶](#translations_29 "Permanent link")

  * ğŸŒ� Add Portuguese translation for `docs/pt/docs/tutorial/request-form-models.md`. PR [#12175](https://github.com/fastapi/fastapi/pull/12175) by [@ceb10n](https://github.com/ceb10n).
  * ğŸŒ� Add Chinese translation for `docs/zh/docs/project-generation.md`. PR [#12170](https://github.com/fastapi/fastapi/pull/12170) by [@waketzheng](https://github.com/waketzheng).
  * ğŸŒ� Add Dutch translation for `docs/nl/docs/python-types.md`. PR [#12158](https://github.com/fastapi/fastapi/pull/12158) by [@maxscheijen](https://github.com/maxscheijen).

### Internal[¶](#internal_39 "Permanent link")

  * ğŸ’¡ Add comments with instructions for Playwright screenshot scripts. PR [#12193](https://github.com/fastapi/fastapi/pull/12193) by [@tiangolo](https://github.com/tiangolo).
  * â�• Add inline-snapshot for tests. PR [#12189](https://github.com/fastapi/fastapi/pull/12189) by [@tiangolo](https://github.com/tiangolo).

## 0.114.1[¶](#01141 "Permanent link")

### Refactors[¶](#refactors_16 "Permanent link")

  * âš¡ï¸� Improve performance in request body parsing with a cache for internal model fields. PR [#12184](https://github.com/fastapi/fastapi/pull/12184) by [@tiangolo](https://github.com/tiangolo).

### Docs[¶](#docs_31 "Permanent link")

  * ğŸ“� Remove duplicate line in docs for `docs/en/docs/environment-variables.md`. PR [#12169](https://github.com/fastapi/fastapi/pull/12169) by [@prometek](https://github.com/prometek).

### Translations[¶](#translations_30 "Permanent link")

  * ğŸŒ� Add Portuguese translation for `docs/pt/docs/virtual-environments.md`. PR [#12163](https://github.com/fastapi/fastapi/pull/12163) by [@marcelomarkus](https://github.com/marcelomarkus).
  * ğŸŒ� Add Portuguese translation for `docs/pt/docs/environment-variables.md`. PR [#12162](https://github.com/fastapi/fastapi/pull/12162) by [@marcelomarkus](https://github.com/marcelomarkus).
  * ğŸŒ� Add Portuguese translation for `docs/pt/docs/tutorial/testing.md`. PR [#12164](https://github.com/fastapi/fastapi/pull/12164) by [@marcelomarkus](https://github.com/marcelomarkus).
  * ğŸŒ� Add Portuguese translation for `docs/pt/docs/tutorial/debugging.md`. PR [#12165](https://github.com/fastapi/fastapi/pull/12165) by [@marcelomarkus](https://github.com/marcelomarkus).
  * ğŸŒ� Add Korean translation for `docs/ko/docs/project-generation.md`. PR [#12157](https://github.com/fastapi/fastapi/pull/12157) by [@BORA040126](https://github.com/BORA040126).

### Internal[¶](#internal_40 "Permanent link")

  * â¬† Bump tiangolo/issue-manager from 0.5.0 to 0.5.1. PR [#12173](https://github.com/fastapi/fastapi/pull/12173) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * â¬† [pre-commit.ci] pre-commit autoupdate. PR [#12176](https://github.com/fastapi/fastapi/pull/12176) by [@pre-commit-ci[bot]](https://github.com/apps/pre-commit-ci).
  * ğŸ‘· Update `issue-manager.yml`. PR [#12159](https://github.com/fastapi/fastapi/pull/12159) by [@tiangolo](https://github.com/tiangolo).
  * âœ�ï¸� Fix typo in `fastapi/params.py`. PR [#12143](https://github.com/fastapi/fastapi/pull/12143) by [@surreal30](https://github.com/surreal30).

## 0.114.0[¶](#01140 "Permanent link")

You can restrict form fields to only include those declared in a Pydantic model and forbid any extra field sent in the request using Pydantic's `model_config = {"extra": "forbid"}`:
    
    
    from typing import Annotated
    
    from fastapi import FastAPI, Form
    from pydantic import BaseModel
    
    app = FastAPI()
    
    
    class FormData(BaseModel):
        username: str
        password: str
        model_config = {"extra": "forbid"}
    
    
    @app.post("/login/")
    async def login(data: Annotated[FormData, Form()]):
        return data
    

Read the new docs: [Form Models - Forbid Extra Form Fields](https://fastapi.tiangolo.com/tutorial/request-form-models/#forbid-extra-form-fields).

### Features[¶](#features_9 "Permanent link")

  * âœ¨ Add support for forbidding extra form fields with Pydantic models. PR [#12134](https://github.com/fastapi/fastapi/pull/12134) by [@tiangolo](https://github.com/tiangolo).

### Docs[¶](#docs_32 "Permanent link")

  * ğŸ“� Update docs, Form Models section title, to match config name. PR [#12152](https://github.com/fastapi/fastapi/pull/12152) by [@tiangolo](https://github.com/tiangolo).

### Internal[¶](#internal_41 "Permanent link")

  * âœ… Update internal tests for latest Pydantic, including CI tweaks to install the latest Pydantic. PR [#12147](https://github.com/fastapi/fastapi/pull/12147) by [@tiangolo](https://github.com/tiangolo).

## 0.113.0[¶](#01130 "Permanent link")

Now you can declare form fields with Pydantic models:
    
    
    from typing import Annotated
    
    from fastapi import FastAPI, Form
    from pydantic import BaseModel
    
    app = FastAPI()
    
    
    class FormData(BaseModel):
        username: str
        password: str
    
    
    @app.post("/login/")
    async def login(data: Annotated[FormData, Form()]):
        return data
    

Read the new docs: [Form Models](https://fastapi.tiangolo.com/tutorial/request-form-models/).

### Features[¶](#features_10 "Permanent link")

  * âœ¨ Add support for Pydantic models in `Form` parameters. PR [#12129](https://github.com/fastapi/fastapi/pull/12129) by [@tiangolo](https://github.com/tiangolo).

### Internal[¶](#internal_42 "Permanent link")

  * ğŸ”§ Update sponsors: Coherence link. PR [#12130](https://github.com/fastapi/fastapi/pull/12130) by [@tiangolo](https://github.com/tiangolo).

## 0.112.4[¶](#01124 "Permanent link")

This release is mainly a big internal refactor to enable adding support for Pydantic models for `Form` fields, but that feature comes in the next release.

This release shouldn't affect apps using FastAPI in any way. You don't even have to upgrade to this version yet. It's just a checkpoint. ğŸ¤“

### Refactors[¶](#refactors_17 "Permanent link")

  * â™»ï¸� Refactor deciding if `embed` body fields, do not overwrite fields, compute once per router, refactor internals in preparation for Pydantic models in `Form`, `Query` and others. PR [#12117](https://github.com/fastapi/fastapi/pull/12117) by [@tiangolo](https://github.com/tiangolo).

### Internal[¶](#internal_43 "Permanent link")

  * â�ªï¸� Temporarily revert "âœ¨ Add support for Pydantic models in `Form` parameters" to make a checkpoint release. PR [#12128](https://github.com/fastapi/fastapi/pull/12128) by [@tiangolo](https://github.com/tiangolo). Restored by PR [#12129](https://github.com/fastapi/fastapi/pull/12129).
  * âœ¨ Add support for Pydantic models in `Form` parameters. PR [#12127](https://github.com/fastapi/fastapi/pull/12127) by [@tiangolo](https://github.com/tiangolo). Reverted by PR [#12128](https://github.com/fastapi/fastapi/pull/12128) to make a checkpoint release with only refactors. Restored by PR [#12129](https://github.com/fastapi/fastapi/pull/12129).

## 0.112.3[¶](#01123 "Permanent link")

This release is mainly internal refactors, it shouldn't affect apps using FastAPI in any way. You don't even have to upgrade to this version yet. There are a few bigger releases coming right after. ğŸš€

### Refactors[¶](#refactors_18 "Permanent link")

  * â™»ï¸� Refactor internal `check_file_field()`, rename to `ensure_multipart_is_installed()` to clarify its purpose. PR [#12106](https://github.com/fastapi/fastapi/pull/12106) by [@tiangolo](https://github.com/tiangolo).
  * â™»ï¸� Rename internal `create_response_field()` to `create_model_field()` as it's used for more than response models. PR [#12103](https://github.com/fastapi/fastapi/pull/12103) by [@tiangolo](https://github.com/tiangolo).
  * â™»ï¸� Refactor and simplify internal data from `solve_dependencies()` using dataclasses. PR [#12100](https://github.com/fastapi/fastapi/pull/12100) by [@tiangolo](https://github.com/tiangolo).
  * â™»ï¸� Refactor and simplify internal `analyze_param()` to structure data with dataclasses instead of tuple. PR [#12099](https://github.com/fastapi/fastapi/pull/12099) by [@tiangolo](https://github.com/tiangolo).
  * â™»ï¸� Refactor and simplify dependencies data structures with dataclasses. PR [#12098](https://github.com/fastapi/fastapi/pull/12098) by [@tiangolo](https://github.com/tiangolo).

### Docs[¶](#docs_33 "Permanent link")

  * ğŸ“� Add External Link: Techniques and applications of SQLAlchemy global filters in FastAPI. PR [#12109](https://github.com/fastapi/fastapi/pull/12109) by [@TheShubhendra](https://github.com/TheShubhendra).
  * ğŸ“� Add note about `time.perf_counter()` in middlewares. PR [#12095](https://github.com/fastapi/fastapi/pull/12095) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ“� Tweak middleware code sample `time.time()` to `time.perf_counter()`. PR [#11957](https://github.com/fastapi/fastapi/pull/11957) by [@domdent](https://github.com/domdent).
  * ğŸ”§ Update sponsors: Coherence. PR [#12093](https://github.com/fastapi/fastapi/pull/12093) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ“� Fix async test example not to trigger DeprecationWarning. PR [#12084](https://github.com/fastapi/fastapi/pull/12084) by [@marcinsulikowski](https://github.com/marcinsulikowski).
  * ğŸ“� Update `docs_src/path_params_numeric_validations/tutorial006.py`. PR [#11478](https://github.com/fastapi/fastapi/pull/11478) by [@MuhammadAshiqAmeer](https://github.com/MuhammadAshiqAmeer).
  * ğŸ“� Update comma in `docs/en/docs/async.md`. PR [#12062](https://github.com/fastapi/fastapi/pull/12062) by [@Alec-Gillis](https://github.com/Alec-Gillis).
  * ğŸ“� Update docs about serving FastAPI: ASGI servers, Docker containers, etc.. PR [#12069](https://github.com/fastapi/fastapi/pull/12069) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ“� Clarify `response_class` parameter, validations, and returning a response directly. PR [#12067](https://github.com/fastapi/fastapi/pull/12067) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ“� Fix minor typos and issues in the documentation. PR [#12063](https://github.com/fastapi/fastapi/pull/12063) by [@svlandeg](https://github.com/svlandeg).
  * ğŸ“� Add note in Docker docs about ensuring graceful shutdowns and lifespan events with `CMD` exec form. PR [#11960](https://github.com/fastapi/fastapi/pull/11960) by [@GPla](https://github.com/GPla).

### Translations[¶](#translations_31 "Permanent link")

  * ğŸŒ� Add Dutch translation for `docs/nl/docs/features.md`. PR [#12101](https://github.com/fastapi/fastapi/pull/12101) by [@maxscheijen](https://github.com/maxscheijen).
  * ğŸŒ� Add Portuguese translation for `docs/pt/docs/advanced/testing-events.md`. PR [#12108](https://github.com/fastapi/fastapi/pull/12108) by [@ceb10n](https://github.com/ceb10n).
  * ğŸŒ� Add Portuguese translation for `docs/pt/docs/advanced/security/index.md`. PR [#12114](https://github.com/fastapi/fastapi/pull/12114) by [@ceb10n](https://github.com/ceb10n).
  * ğŸŒ� Add Dutch translation for `docs/nl/docs/index.md`. PR [#12042](https://github.com/fastapi/fastapi/pull/12042) by [@svlandeg](https://github.com/svlandeg).
  * ğŸŒ� Update Chinese translation for `docs/zh/docs/how-to/index.md`. PR [#12070](https://github.com/fastapi/fastapi/pull/12070) by [@synthpop123](https://github.com/synthpop123).

### Internal[¶](#internal_44 "Permanent link")

  * â¬† [pre-commit.ci] pre-commit autoupdate. PR [#12115](https://github.com/fastapi/fastapi/pull/12115) by [@pre-commit-ci[bot]](https://github.com/apps/pre-commit-ci).
  * â¬† Bump pypa/gh-action-pypi-publish from 1.10.0 to 1.10.1. PR [#12120](https://github.com/fastapi/fastapi/pull/12120) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * â¬† Bump pillow from 10.3.0 to 10.4.0. PR [#12105](https://github.com/fastapi/fastapi/pull/12105) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * ğŸ’š Set `include-hidden-files` to `True` when using the `upload-artifact` GH action. PR [#12118](https://github.com/fastapi/fastapi/pull/12118) by [@svlandeg](https://github.com/svlandeg).
  * â¬† Bump pypa/gh-action-pypi-publish from 1.9.0 to 1.10.0. PR [#12112](https://github.com/fastapi/fastapi/pull/12112) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * ğŸ”§ Update sponsors link: Coherence. PR [#12097](https://github.com/fastapi/fastapi/pull/12097) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”§ Update labeler config to handle sponsorships data. PR [#12096](https://github.com/fastapi/fastapi/pull/12096) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”§ Update sponsors, remove Kong. PR [#12085](https://github.com/fastapi/fastapi/pull/12085) by [@tiangolo](https://github.com/tiangolo).
  * â¬† [pre-commit.ci] pre-commit autoupdate. PR [#12076](https://github.com/fastapi/fastapi/pull/12076) by [@pre-commit-ci[bot]](https://github.com/apps/pre-commit-ci).
  * ğŸ‘· Update `latest-changes` GitHub Action. PR [#12073](https://github.com/fastapi/fastapi/pull/12073) by [@tiangolo](https://github.com/tiangolo).

## 0.112.2[¶](#01122 "Permanent link")

### Fixes[¶](#fixes_38 "Permanent link")

  * ğŸ�› Fix `allow_inf_nan` option for Param and Body classes. PR [#11867](https://github.com/fastapi/fastapi/pull/11867) by [@giunio-prc](https://github.com/giunio-prc).
  * ğŸ�› Ensure that `app.include_router` merges nested lifespans. PR [#9630](https://github.com/fastapi/fastapi/pull/9630) by [@Lancetnik](https://github.com/Lancetnik).

### Refactors[¶](#refactors_19 "Permanent link")

  * ğŸ�¨ Fix typing annotation for semi-internal `FastAPI.add_api_route()`. PR [#10240](https://github.com/fastapi/fastapi/pull/10240) by [@ordinary-jamie](https://github.com/ordinary-jamie).
  * â¬†ï¸� Upgrade version of Ruff and reformat. PR [#12032](https://github.com/fastapi/fastapi/pull/12032) by [@tiangolo](https://github.com/tiangolo).

### Docs[¶](#docs_34 "Permanent link")

  * ğŸ“� Fix a typo in `docs/en/docs/virtual-environments.md`. PR [#12064](https://github.com/fastapi/fastapi/pull/12064) by [@aymenkrifa](https://github.com/aymenkrifa).
  * ğŸ“� Add docs about Environment Variables and Virtual Environments. PR [#12054](https://github.com/fastapi/fastapi/pull/12054) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ“� Add Asyncer mention in async docs. PR [#12037](https://github.com/fastapi/fastapi/pull/12037) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ“� Move the Features docs to the top level to improve the main page menu. PR [#12036](https://github.com/fastapi/fastapi/pull/12036) by [@tiangolo](https://github.com/tiangolo).
  * âœ�ï¸� Fix import typo in reference example for `Security`. PR [#11168](https://github.com/fastapi/fastapi/pull/11168) by [@0shah0](https://github.com/0shah0).
  * ğŸ“� Highlight correct line in tutorial `docs/en/docs/tutorial/body-multiple-params.md`. PR [#11978](https://github.com/fastapi/fastapi/pull/11978) by [@svlandeg](https://github.com/svlandeg).
  * ğŸ”¥ Remove Sentry link from Advanced Middleware docs. PR [#12031](https://github.com/fastapi/fastapi/pull/12031) by [@alejsdev](https://github.com/alejsdev).
  * ğŸ“� Clarify management tasks for translations, multiples files in one PR. PR [#12030](https://github.com/fastapi/fastapi/pull/12030) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ“� Edit the link to the OpenAPI "Responses Object" and "Response Object" sections in the "Additional Responses in OpenAPI" section. PR [#11996](https://github.com/fastapi/fastapi/pull/11996) by [@VaitoSoi](https://github.com/VaitoSoi).
  * ğŸ”¨ Specify `email-validator` dependency with dash. PR [#11515](https://github.com/fastapi/fastapi/pull/11515) by [@jirikuncar](https://github.com/jirikuncar).
  * ğŸŒ� Add Spanish translation for `docs/es/docs/project-generation.md`. PR [#11947](https://github.com/fastapi/fastapi/pull/11947) by [@alejsdev](https://github.com/alejsdev).
  * ğŸ“� Fix minor typo. PR [#12026](https://github.com/fastapi/fastapi/pull/12026) by [@MicaelJarniac](https://github.com/MicaelJarniac).
  * ğŸ“� Several docs improvements, tweaks, and clarifications. PR [#11390](https://github.com/fastapi/fastapi/pull/11390) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸ“� Add missing `compresslevel` parameter on docs for `GZipMiddleware`. PR [#11350](https://github.com/fastapi/fastapi/pull/11350) by [@junah201](https://github.com/junah201).
  * ğŸ“� Fix inconsistent response code when item already exists in docs for testing. PR [#11818](https://github.com/fastapi/fastapi/pull/11818) by [@lokomilo](https://github.com/lokomilo).
  * ğŸ“� Update `docs/en/docs/tutorial/body.md` with Python 3.10 union type example. PR [#11415](https://github.com/fastapi/fastapi/pull/11415) by [@rangzen](https://github.com/rangzen).

### Translations[¶](#translations_32 "Permanent link")

  * ğŸŒ� Add Portuguese translation for `docs/pt/docs/tutorial/request_file.md`. PR [#12018](https://github.com/fastapi/fastapi/pull/12018) by [@Joao-Pedro-P-Holanda](https://github.com/Joao-Pedro-P-Holanda).
  * ğŸŒ� Add Japanese translation for `docs/ja/docs/learn/index.md`. PR [#11592](https://github.com/fastapi/fastapi/pull/11592) by [@ukwhatn](https://github.com/ukwhatn).
  * ğŸ“� Update Spanish translation docs for consistency. PR [#12044](https://github.com/fastapi/fastapi/pull/12044) by [@alejsdev](https://github.com/alejsdev).
  * ğŸŒ� Update Chinese translation for `docs/zh/docs/tutorial/dependencies/dependencies-with-yield.md`. PR [#12028](https://github.com/fastapi/fastapi/pull/12028) by [@xuvjso](https://github.com/xuvjso).
  * ğŸ“� Update FastAPI People, do not translate to have the most recent info. PR [#12034](https://github.com/fastapi/fastapi/pull/12034) by [@tiangolo](https://github.com/tiangolo).
  * ğŸŒ� Update Urdu translation for `docs/ur/docs/benchmarks.md`. PR [#10046](https://github.com/fastapi/fastapi/pull/10046) by [@AhsanSheraz](https://github.com/AhsanSheraz).

### Internal[¶](#internal_45 "Permanent link")

  * â¬† [pre-commit.ci] pre-commit autoupdate. PR [#12046](https://github.com/fastapi/fastapi/pull/12046) by [@pre-commit-ci[bot]](https://github.com/apps/pre-commit-ci).
  * ğŸ”§ Update coverage config files. PR [#12035](https://github.com/fastapi/fastapi/pull/12035) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”¨ Standardize shebang across shell scripts. PR [#11942](https://github.com/fastapi/fastapi/pull/11942) by [@gitworkflows](https://github.com/gitworkflows).
  * â¬† Update sqlalchemy requirement from <1.4.43,>=1.3.18 to >=1.3.18,<2.0.33. PR [#11979](https://github.com/fastapi/fastapi/pull/11979) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * ğŸ”Š Remove old ignore warnings. PR [#11950](https://github.com/fastapi/fastapi/pull/11950) by [@tiangolo](https://github.com/tiangolo).
  * â¬†ï¸� Upgrade griffe-typingdoc for the docs. PR [#12029](https://github.com/fastapi/fastapi/pull/12029) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ™ˆ Add .coverage* to `.gitignore`. PR [#11940](https://github.com/fastapi/fastapi/pull/11940) by [@gitworkflows](https://github.com/gitworkflows).
  * âš™ï¸� Record and show test coverage contexts (what test covers which line). PR [#11518](https://github.com/fastapi/fastapi/pull/11518) by [@slafs](https://github.com/slafs).

## 0.112.1[¶](#01121 "Permanent link")

### Upgrades[¶](#upgrades_12 "Permanent link")

  * â¬†ï¸� Allow Starlette 0.38.x, update the pin to `>=0.37.2,<0.39.0`. PR [#11876](https://github.com/fastapi/fastapi/pull/11876) by [@musicinmybrain](https://github.com/musicinmybrain).

### Docs[¶](#docs_35 "Permanent link")

  * ğŸ“� Update docs section about "Don't Translate these Pages". PR [#12022](https://github.com/fastapi/fastapi/pull/12022) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ“� Add documentation for non-translated pages and scripts to verify them. PR [#12020](https://github.com/fastapi/fastapi/pull/12020) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ“� Update docs about discussions questions. PR [#11985](https://github.com/fastapi/fastapi/pull/11985) by [@tiangolo](https://github.com/tiangolo).

### Translations[¶](#translations_33 "Permanent link")

  * ğŸŒ� Add Portuguese translation for `docs/pt/docs/tutorial/bigger-applications.md`. PR [#11971](https://github.com/fastapi/fastapi/pull/11971) by [@marcelomarkus](https://github.com/marcelomarkus).
  * ğŸŒ� Add Portuguese translation for `docs/pt/docs/advanced/testing-websockets.md`. PR [#11994](https://github.com/fastapi/fastapi/pull/11994) by [@ceb10n](https://github.com/ceb10n).
  * ğŸŒ� Add Portuguese translation for `docs/pt/docs/advanced/testing-dependencies.md`. PR [#11995](https://github.com/fastapi/fastapi/pull/11995) by [@ceb10n](https://github.com/ceb10n).
  * ğŸŒ� Add Portuguese translation for `docs/pt/docs/advanced/using-request-directly.md`. PR [#11956](https://github.com/fastapi/fastapi/pull/11956) by [@ceb10n](https://github.com/ceb10n).
  * ğŸŒ� Add French translation for `docs/fr/docs/tutorial/body-multiple-params.md`. PR [#11796](https://github.com/fastapi/fastapi/pull/11796) by [@pe-brian](https://github.com/pe-brian).
  * ğŸŒ� Update Chinese translation for `docs/zh/docs/tutorial/query-params.md`. PR [#11557](https://github.com/fastapi/fastapi/pull/11557) by [@caomingpei](https://github.com/caomingpei).
  * ğŸŒ� Update typo in Chinese translation for `docs/zh/docs/advanced/testing-dependencies.md`. PR [#11944](https://github.com/fastapi/fastapi/pull/11944) by [@bestony](https://github.com/bestony).
  * ğŸŒ� Add Portuguese translation for `docs/pt/docs/advanced/sub-applications.md` and `docs/pt/docs/advanced/behind-a-proxy.md`. PR [#11856](https://github.com/fastapi/fastapi/pull/11856) by [@marcelomarkus](https://github.com/marcelomarkus).
  * ğŸŒ� Add Portuguese translation for `docs/pt/docs/tutorial/cors.md` and `docs/pt/docs/tutorial/middleware.md`. PR [#11916](https://github.com/fastapi/fastapi/pull/11916) by [@wesinalves](https://github.com/wesinalves).
  * ğŸŒ� Add French translation for `docs/fr/docs/tutorial/path-params-numeric-validations.md`. PR [#11788](https://github.com/fastapi/fastapi/pull/11788) by [@pe-brian](https://github.com/pe-brian).

### Internal[¶](#internal_46 "Permanent link")

  * â¬† Bump pypa/gh-action-pypi-publish from 1.8.14 to 1.9.0. PR [#11727](https://github.com/fastapi/fastapi/pull/11727) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * ğŸ”§ Add changelog URL to `pyproject.toml`, shows in PyPI. PR [#11152](https://github.com/fastapi/fastapi/pull/11152) by [@Pierre-VF](https://github.com/Pierre-VF).
  * ğŸ‘· Do not sync labels as it overrides manually added labels. PR [#12024](https://github.com/fastapi/fastapi/pull/12024) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘·ğŸ�» Update Labeler GitHub Actions. PR [#12019](https://github.com/fastapi/fastapi/pull/12019) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”§ Update configs for MkDocs for languages and social cards. PR [#12016](https://github.com/fastapi/fastapi/pull/12016) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘· Update permissions and config for labeler GitHub Action. PR [#12008](https://github.com/fastapi/fastapi/pull/12008) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘·ğŸ�» Add GitHub Action label-checker. PR [#12005](https://github.com/fastapi/fastapi/pull/12005) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘· Add label checker GitHub Action. PR [#12004](https://github.com/fastapi/fastapi/pull/12004) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘· Update GitHub Action add-to-project. PR [#12002](https://github.com/fastapi/fastapi/pull/12002) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”§ Update labeler GitHub Action. PR [#12001](https://github.com/fastapi/fastapi/pull/12001) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘· Add GitHub Action labeler. PR [#12000](https://github.com/fastapi/fastapi/pull/12000) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘· Add GitHub Action add-to-project. PR [#11999](https://github.com/fastapi/fastapi/pull/11999) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ“� Update admonitions in docs missing. PR [#11998](https://github.com/fastapi/fastapi/pull/11998) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”¨ Update docs.py script to enable dirty reload conditionally. PR [#11986](https://github.com/fastapi/fastapi/pull/11986) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”§ Update MkDocs instant previews. PR [#11982](https://github.com/fastapi/fastapi/pull/11982) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ�› Fix deploy docs previews script to handle mkdocs.yml files. PR [#11984](https://github.com/fastapi/fastapi/pull/11984) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ’¡ Add comment about custom Termynal line-height. PR [#11976](https://github.com/fastapi/fastapi/pull/11976) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘· Add alls-green for test-redistribute. PR [#11974](https://github.com/fastapi/fastapi/pull/11974) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘· Update docs-previews to handle no docs changes. PR [#11975](https://github.com/fastapi/fastapi/pull/11975) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”¨ Refactor script `deploy_docs_status.py` to account for deploy URLs with or without trailing slash. PR [#11965](https://github.com/fastapi/fastapi/pull/11965) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”’ï¸� Update permissions for deploy-docs action. PR [#11964](https://github.com/fastapi/fastapi/pull/11964) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘·ğŸ�» Add deploy docs status and preview links to PRs. PR [#11961](https://github.com/fastapi/fastapi/pull/11961) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”§ Update docs setup with latest configs and plugins. PR [#11953](https://github.com/fastapi/fastapi/pull/11953) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”‡ Ignore warning from attrs in Trio. PR [#11949](https://github.com/fastapi/fastapi/pull/11949) by [@tiangolo](https://github.com/tiangolo).

## 0.112.0[¶](#01120 "Permanent link")

### Breaking Changes[¶](#breaking-changes_3 "Permanent link")

  * â™»ï¸� Add support for `pip install "fastapi[standard]"` with standard dependencies and `python -m fastapi`. PR [#11935](https://github.com/fastapi/fastapi/pull/11935) by [@tiangolo](https://github.com/tiangolo).

#### Summary[¶](#summary "Permanent link")

Install with:
    
    
    pip install "fastapi[standard]"
    

#### Other Changes[¶](#other-changes "Permanent link")

  * This adds support for calling the CLI as:

    
    
    python -m fastapi
    

  * And it upgrades `fastapi-cli[standard] >=0.0.5`.

#### Technical Details[¶](#technical-details "Permanent link")

Before this, `fastapi` would include the standard dependencies, with Uvicorn and the `fastapi-cli`, etc.

And `fastapi-slim` would not include those standard dependencies.

Now `fastapi` doesn't include those standard dependencies unless you install with `pip install "fastapi[standard]"`.

Before, you would install `pip install fastapi`, now you should include the `standard` optional dependencies (unless you want to exclude one of those): `pip install "fastapi[standard]"`.

This change is because having the standard optional dependencies installed by default was being inconvenient to several users, and having to install instead `fastapi-slim` was not being a feasible solution.

Discussed here: [#11522](https://github.com/fastapi/fastapi/pull/11522) and here: [#11525](https://github.com/fastapi/fastapi/discussions/11525)

### Docs[¶](#docs_36 "Permanent link")

  * âœ�ï¸� Fix typos in docs. PR [#11926](https://github.com/fastapi/fastapi/pull/11926) by [@jianghuyiyuan](https://github.com/jianghuyiyuan).
  * ğŸ“� Tweak management docs. PR [#11918](https://github.com/fastapi/fastapi/pull/11918) by [@tiangolo](https://github.com/tiangolo).
  * ğŸšš Rename GitHub links from tiangolo/fastapi to fastapi/fastapi. PR [#11913](https://github.com/fastapi/fastapi/pull/11913) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ“� Add docs about FastAPI team and project management. PR [#11908](https://github.com/tiangolo/fastapi/pull/11908) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ“� Re-structure docs main menu. PR [#11904](https://github.com/tiangolo/fastapi/pull/11904) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ“� Update Speakeasy URL. PR [#11871](https://github.com/tiangolo/fastapi/pull/11871) by [@ndimares](https://github.com/ndimares).

### Translations[¶](#translations_34 "Permanent link")

  * ğŸŒ� Update Portuguese translation for `docs/pt/docs/alternatives.md`. PR [#11931](https://github.com/fastapi/fastapi/pull/11931) by [@ceb10n](https://github.com/ceb10n).
  * ğŸŒ� Add Russian translation for `docs/ru/docs/tutorial/dependencies/sub-dependencies.md`. PR [#10515](https://github.com/tiangolo/fastapi/pull/10515) by [@AlertRED](https://github.com/AlertRED).
  * ğŸŒ� Add Portuguese translation for `docs/pt/docs/advanced/response-change-status-code.md`. PR [#11863](https://github.com/tiangolo/fastapi/pull/11863) by [@ceb10n](https://github.com/ceb10n).
  * ğŸŒ� Add Portuguese translation for `docs/pt/docs/reference/background.md`. PR [#11849](https://github.com/tiangolo/fastapi/pull/11849) by [@lucasbalieiro](https://github.com/lucasbalieiro).
  * ğŸŒ� Add Portuguese translation for `docs/pt/docs/tutorial/dependencies/dependencies-with-yield.md`. PR [#11848](https://github.com/tiangolo/fastapi/pull/11848) by [@Joao-Pedro-P-Holanda](https://github.com/Joao-Pedro-P-Holanda).
  * ğŸŒ� Add Portuguese translation for `docs/pt/docs/reference/apirouter.md`. PR [#11843](https://github.com/tiangolo/fastapi/pull/11843) by [@lucasbalieiro](https://github.com/lucasbalieiro).

### Internal[¶](#internal_47 "Permanent link")

  * ğŸ”§ Update sponsors: add liblab. PR [#11934](https://github.com/fastapi/fastapi/pull/11934) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘· Update GitHub Action label-approved permissions. PR [#11933](https://github.com/fastapi/fastapi/pull/11933) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘· Refactor GitHub Action to comment docs deployment URLs and update token. PR [#11925](https://github.com/fastapi/fastapi/pull/11925) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘· Update tokens for GitHub Actions. PR [#11924](https://github.com/fastapi/fastapi/pull/11924) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘· Update token permissions to comment deployment URL in docs. PR [#11917](https://github.com/fastapi/fastapi/pull/11917) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘· Update token permissions for GitHub Actions. PR [#11915](https://github.com/fastapi/fastapi/pull/11915) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘· Update GitHub Actions token usage. PR [#11914](https://github.com/fastapi/fastapi/pull/11914) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘· Update GitHub Action to notify translations with label `approved-1`. PR [#11907](https://github.com/tiangolo/fastapi/pull/11907) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”§ Update sponsors, remove Reflex. PR [#11875](https://github.com/tiangolo/fastapi/pull/11875) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”§ Update sponsors: remove TalkPython. PR [#11861](https://github.com/tiangolo/fastapi/pull/11861) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”¨ Update docs Termynal scripts to not include line nums for local dev. PR [#11854](https://github.com/tiangolo/fastapi/pull/11854) by [@tiangolo](https://github.com/tiangolo).

## 0.111.1[¶](#01111 "Permanent link")

### Upgrades[¶](#upgrades_13 "Permanent link")

  * â�– Remove `orjson` and `ujson` from default dependencies. PR [#11842](https://github.com/tiangolo/fastapi/pull/11842) by [@tiangolo](https://github.com/tiangolo).
    * These dependencies are still installed when you install with `pip install "fastapi[all]"`. But they are not included in `pip install fastapi`.
  * ğŸ“� Restored Swagger-UI links to use the latest version possible. PR [#11459](https://github.com/tiangolo/fastapi/pull/11459) by [@UltimateLobster](https://github.com/UltimateLobster).

### Docs[¶](#docs_37 "Permanent link")

  * âœ�ï¸� Rewording in `docs/en/docs/fastapi-cli.md`. PR [#11716](https://github.com/tiangolo/fastapi/pull/11716) by [@alejsdev](https://github.com/alejsdev).
  * ğŸ“� Update Hypercorn links in all the docs. PR [#11744](https://github.com/tiangolo/fastapi/pull/11744) by [@kittydoor](https://github.com/kittydoor).
  * ğŸ“� Update docs with Ariadne reference from Starlette to FastAPI. PR [#11797](https://github.com/tiangolo/fastapi/pull/11797) by [@DamianCzajkowski](https://github.com/DamianCzajkowski).
  * ğŸ“� Update fastapi instrumentation external link. PR [#11317](https://github.com/tiangolo/fastapi/pull/11317) by [@softwarebloat](https://github.com/softwarebloat).
  * âœ�ï¸� Fix links to alembic example repo in docs. PR [#11628](https://github.com/tiangolo/fastapi/pull/11628) by [@augiwan](https://github.com/augiwan).
  * âœ�ï¸� Update `docs/en/docs/fastapi-cli.md`. PR [#11715](https://github.com/tiangolo/fastapi/pull/11715) by [@alejsdev](https://github.com/alejsdev).
  * ğŸ“� Update External Links . PR [#11500](https://github.com/tiangolo/fastapi/pull/11500) by [@devon2018](https://github.com/devon2018).
  * ğŸ“� Add External Link: Tutorial de FastAPI, Â¿el mejor framework de Python?. PR [#11618](https://github.com/tiangolo/fastapi/pull/11618) by [@EduardoZepeda](https://github.com/EduardoZepeda).
  * ğŸ“� Fix typo in `docs/en/docs/tutorial/body-multiple-params.md`. PR [#11698](https://github.com/tiangolo/fastapi/pull/11698) by [@mwb-u](https://github.com/mwb-u).
  * ğŸ“� Add External Link: Deploy a Serverless FastAPI App with Neon Postgres and AWS App Runner at any scale. PR [#11633](https://github.com/tiangolo/fastapi/pull/11633) by [@ananis25](https://github.com/ananis25).
  * ğŸ“� Update `security/first-steps.md`. PR [#11674](https://github.com/tiangolo/fastapi/pull/11674) by [@alejsdev](https://github.com/alejsdev).
  * ğŸ“� Update `security/first-steps.md`. PR [#11673](https://github.com/tiangolo/fastapi/pull/11673) by [@alejsdev](https://github.com/alejsdev).
  * ğŸ“� Update note in `path-params-numeric-validations.md`. PR [#11672](https://github.com/tiangolo/fastapi/pull/11672) by [@alejsdev](https://github.com/alejsdev).
  * ğŸ“� Tweak intro docs about `Annotated` and `Query()` params. PR [#11664](https://github.com/tiangolo/fastapi/pull/11664) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ“� Update JWT auth documentation to use PyJWT instead of pyhon-jose. PR [#11589](https://github.com/tiangolo/fastapi/pull/11589) by [@estebanx64](https://github.com/estebanx64).
  * ğŸ“� Update docs. PR [#11603](https://github.com/tiangolo/fastapi/pull/11603) by [@alejsdev](https://github.com/alejsdev).
  * âœ�ï¸� Fix typo: convert every 're-use' to 'reuse'.. PR [#11598](https://github.com/tiangolo/fastapi/pull/11598) by [@hasansezertasan](https://github.com/hasansezertasan).
  * âœ�ï¸� Fix typo in `fastapi/applications.py`. PR [#11593](https://github.com/tiangolo/fastapi/pull/11593) by [@petarmaric](https://github.com/petarmaric).
  * âœ�ï¸� Fix link in `fastapi-cli.md`. PR [#11524](https://github.com/tiangolo/fastapi/pull/11524) by [@svlandeg](https://github.com/svlandeg).

### Translations[¶](#translations_35 "Permanent link")

  * ğŸŒ� Add Spanish translation for `docs/es/docs/how-to/graphql.md`. PR [#11697](https://github.com/tiangolo/fastapi/pull/11697) by [@camigomezdev](https://github.com/camigomezdev).
  * ğŸŒ� Add Portuguese translation for `docs/pt/docs/reference/index.md`. PR [#11840](https://github.com/tiangolo/fastapi/pull/11840) by [@lucasbalieiro](https://github.com/lucasbalieiro).
  * ğŸŒ� Fix link in German translation. PR [#11836](https://github.com/tiangolo/fastapi/pull/11836) by [@anitahammer](https://github.com/anitahammer).
  * ğŸŒ� Add Portuguese translation for `docs/pt/docs/tutorial/dependencies/sub-dependencies.md`. PR [#11792](https://github.com/tiangolo/fastapi/pull/11792) by [@Joao-Pedro-P-Holanda](https://github.com/Joao-Pedro-P-Holanda).
  * ğŸŒ� Add Turkish translation for `docs/tr/docs/tutorial/request-forms.md`. PR [#11553](https://github.com/tiangolo/fastapi/pull/11553) by [@hasansezertasan](https://github.com/hasansezertasan).
  * ğŸŒ� Add Portuguese translation for `docs/pt/docs/reference/exceptions.md`. PR [#11834](https://github.com/tiangolo/fastapi/pull/11834) by [@lucasbalieiro](https://github.com/lucasbalieiro).
  * ğŸŒ� Add Portuguese translation for `docs/pt/docs/tutorial/dependencies/global-dependencies.md`. PR [#11826](https://github.com/tiangolo/fastapi/pull/11826) by [@Joao-Pedro-P-Holanda](https://github.com/Joao-Pedro-P-Holanda).
  * ğŸŒ� Add Portuguese translation for `docs/pt/docs/how-to/general.md`. PR [#11825](https://github.com/tiangolo/fastapi/pull/11825) by [@lucasbalieiro](https://github.com/lucasbalieiro).
  * ğŸŒ� Add Portuguese translation for `docs/pt/docs/advanced/async-tests.md`. PR [#11808](https://github.com/tiangolo/fastapi/pull/11808) by [@ceb10n](https://github.com/ceb10n).
  * ğŸŒ� Add Ukrainian translation for `docs/uk/docs/tutorial/first-steps.md`. PR [#11809](https://github.com/tiangolo/fastapi/pull/11809) by [@vkhoroshchak](https://github.com/vkhoroshchak).
  * ğŸŒ� Add Portuguese translation for `docs/pt/docs/tutorial/dependencies/dependencies-in-path-operation-operators.md`. PR [#11804](https://github.com/tiangolo/fastapi/pull/11804) by [@Joao-Pedro-P-Holanda](https://github.com/Joao-Pedro-P-Holanda).
  * ğŸŒ� Add Chinese translation for `docs/zh/docs/fastapi-cli.md`. PR [#11786](https://github.com/tiangolo/fastapi/pull/11786) by [@logan2d5](https://github.com/logan2d5).
  * ğŸŒ� Add Portuguese translation for `docs/pt/docs/advanced/openapi-webhooks.md`. PR [#11791](https://github.com/tiangolo/fastapi/pull/11791) by [@ceb10n](https://github.com/ceb10n).
  * ğŸŒ� Update Chinese translation for `docs/tutorial/security/oauth2-jwt.md`. PR [#11781](https://github.com/tiangolo/fastapi/pull/11781) by [@logan2d5](https://github.com/logan2d5).
  * ğŸ“� Fix image missing in French translation for `docs/fr/docs/async.md` . PR [#11787](https://github.com/tiangolo/fastapi/pull/11787) by [@pe-brian](https://github.com/pe-brian).
  * ğŸŒ� Add Portuguese translation for `docs/pt/docs/advanced/advanced-dependencies.md`. PR [#11775](https://github.com/tiangolo/fastapi/pull/11775) by [@ceb10n](https://github.com/ceb10n).
  * ğŸŒ� Add Portuguese translation for `docs/pt/docs/tutorial/dependencies/classes-as-dependencies.md`. PR [#11768](https://github.com/tiangolo/fastapi/pull/11768) by [@Joao-Pedro-P-Holanda](https://github.com/Joao-Pedro-P-Holanda).
  * ğŸŒ� Add Portuguese translation for `docs/pt/docs/advanced/additional-status-codes.md`. PR [#11753](https://github.com/tiangolo/fastapi/pull/11753) by [@ceb10n](https://github.com/ceb10n).
  * ğŸŒ� Add Portuguese translation for `docs/pt/docs/tutorial/dependencies/index.md`. PR [#11757](https://github.com/tiangolo/fastapi/pull/11757) by [@Joao-Pedro-P-Holanda](https://github.com/Joao-Pedro-P-Holanda).
  * ğŸŒ� Add Portuguese translation for `docs/pt/docs/advanced/settings.md`. PR [#11739](https://github.com/tiangolo/fastapi/pull/11739) by [@Joao-Pedro-P-Holanda](https://github.com/Joao-Pedro-P-Holanda).
  * ğŸŒ� Add French translation for `docs/fr/docs/learn/index.md`. PR [#11712](https://github.com/tiangolo/fastapi/pull/11712) by [@benjaminvandammeholberton](https://github.com/benjaminvandammeholberton).
  * ğŸŒ� Add Portuguese translation for `docs/pt/docs/how-to/index.md`. PR [#11731](https://github.com/tiangolo/fastapi/pull/11731) by [@vhsenna](https://github.com/vhsenna).
  * ğŸŒ� Add Portuguese translation for `docs/pt/docs/advanced/additional-responses.md`. PR [#11736](https://github.com/tiangolo/fastapi/pull/11736) by [@ceb10n](https://github.com/ceb10n).
  * ğŸŒ� Add Portuguese translation for `docs/pt/docs/advanced/benchmarks.md`. PR [#11713](https://github.com/tiangolo/fastapi/pull/11713) by [@ceb10n](https://github.com/ceb10n).
  * ğŸŒ� Fix Korean translation for `docs/ko/docs/tutorial/response-status-code.md`. PR [#11718](https://github.com/tiangolo/fastapi/pull/11718) by [@nayeonkinn](https://github.com/nayeonkinn).
  * ğŸŒ� Add Korean translation for `docs/ko/docs/tutorial/extra-data-types.md`. PR [#11711](https://github.com/tiangolo/fastapi/pull/11711) by [@nayeonkinn](https://github.com/nayeonkinn).
  * ğŸŒ� Fix Korean translation for `docs/ko/docs/tutorial/body-nested-models.md`. PR [#11710](https://github.com/tiangolo/fastapi/pull/11710) by [@nayeonkinn](https://github.com/nayeonkinn).
  * ğŸŒ� Add Portuguese translation for `docs/pt/docs/advanced/fastapi-cli.md`. PR [#11641](https://github.com/tiangolo/fastapi/pull/11641) by [@ayr-ton](https://github.com/ayr-ton).
  * ğŸŒ� Add Traditional Chinese translation for `docs/zh-hant/docs/fastapi-people.md`. PR [#11639](https://github.com/tiangolo/fastapi/pull/11639) by [@hsuanchi](https://github.com/hsuanchi).
  * ğŸŒ� Add Turkish translation for `docs/tr/docs/advanced/index.md`. PR [#11606](https://github.com/tiangolo/fastapi/pull/11606) by [@hasansezertasan](https://github.com/hasansezertasan).
  * ğŸŒ� Add Turkish translation for `docs/tr/docs/deployment/cloud.md`. PR [#11610](https://github.com/tiangolo/fastapi/pull/11610) by [@hasansezertasan](https://github.com/hasansezertasan).
  * ğŸŒ� Add Turkish translation for `docs/tr/docs/advanced/security/index.md`. PR [#11609](https://github.com/tiangolo/fastapi/pull/11609) by [@hasansezertasan](https://github.com/hasansezertasan).
  * ğŸŒ� Add Turkish translation for `docs/tr/docs/advanced/testing-websockets.md`. PR [#11608](https://github.com/tiangolo/fastapi/pull/11608) by [@hasansezertasan](https://github.com/hasansezertasan).
  * ğŸŒ� Add Turkish translation for `docs/tr/docs/how-to/general.md`. PR [#11607](https://github.com/tiangolo/fastapi/pull/11607) by [@hasansezertasan](https://github.com/hasansezertasan).
  * ğŸŒ� Update Chinese translation for `docs/zh/docs/advanced/templates.md`. PR [#11620](https://github.com/tiangolo/fastapi/pull/11620) by [@chaoless](https://github.com/chaoless).
  * ğŸŒ� Add Turkish translation for `docs/tr/docs/deployment/index.md`. PR [#11605](https://github.com/tiangolo/fastapi/pull/11605) by [@hasansezertasan](https://github.com/hasansezertasan).
  * ğŸŒ� Add Turkish translation for `docs/tr/docs/tutorial/static-files.md`. PR [#11599](https://github.com/tiangolo/fastapi/pull/11599) by [@hasansezertasan](https://github.com/hasansezertasan).
  * ğŸŒ� Polish translation for `docs/pl/docs/fastapi-people.md`. PR [#10196](https://github.com/tiangolo/fastapi/pull/10196) by [@isulim](https://github.com/isulim).
  * ğŸŒ� Add Turkish translation for `docs/tr/docs/advanced/wsgi.md`. PR [#11575](https://github.com/tiangolo/fastapi/pull/11575) by [@hasansezertasan](https://github.com/hasansezertasan).
  * ğŸŒ� Add Turkish translation for `docs/tr/docs/tutorial/cookie-params.md`. PR [#11561](https://github.com/tiangolo/fastapi/pull/11561) by [@hasansezertasan](https://github.com/hasansezertasan).
  * ğŸŒ� Add Russian translation for `docs/ru/docs/about/index.md`. PR [#10961](https://github.com/tiangolo/fastapi/pull/10961) by [@s111d](https://github.com/s111d).
  * ğŸŒ� Update Chinese translation for `docs/zh/docs/tutorial/sql-databases.md`. PR [#11539](https://github.com/tiangolo/fastapi/pull/11539) by [@chaoless](https://github.com/chaoless).
  * ğŸŒ� Add Chinese translation for `docs/zh/docs/how-to/configure-swagger-ui.md`. PR [#11501](https://github.com/tiangolo/fastapi/pull/11501) by [@Lucas-lyh](https://github.com/Lucas-lyh).
  * ğŸŒ� Update Chinese translation for `/docs/advanced/security/http-basic-auth.md`. PR [#11512](https://github.com/tiangolo/fastapi/pull/11512) by [@nick-cjyx9](https://github.com/nick-cjyx9).

### Internal[¶](#internal_48 "Permanent link")

  * â™»ï¸� Simplify internal docs script. PR [#11777](https://github.com/tiangolo/fastapi/pull/11777) by [@gitworkflows](https://github.com/gitworkflows).
  * ğŸ”§ Update sponsors: add Fine. PR [#11784](https://github.com/tiangolo/fastapi/pull/11784) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”§ Tweak sponsors: Kong URL. PR [#11765](https://github.com/tiangolo/fastapi/pull/11765) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”§ Tweak sponsors: Kong URL. PR [#11764](https://github.com/tiangolo/fastapi/pull/11764) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”§ Update sponsors, add Stainless. PR [#11763](https://github.com/tiangolo/fastapi/pull/11763) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”§ Update sponsors, add Zuplo. PR [#11729](https://github.com/tiangolo/fastapi/pull/11729) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”§ Update Sponsor link: Coherence. PR [#11730](https://github.com/tiangolo/fastapi/pull/11730) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘¥ Update FastAPI People. PR [#11669](https://github.com/tiangolo/fastapi/pull/11669) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”§ Add sponsor Kong. PR [#11662](https://github.com/tiangolo/fastapi/pull/11662) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘· Update Smokeshow, fix sync download artifact and smokeshow configs. PR [#11563](https://github.com/tiangolo/fastapi/pull/11563) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘· Update Smokeshow download artifact GitHub Action. PR [#11562](https://github.com/tiangolo/fastapi/pull/11562) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘· Update GitHub actions to download and upload artifacts to v4, for docs and coverage. PR [#11550](https://github.com/tiangolo/fastapi/pull/11550) by [@tamird](https://github.com/tamird).
  * ğŸ‘· Tweak CI for test-redistribute, add needed env vars for slim. PR [#11549](https://github.com/tiangolo/fastapi/pull/11549) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘¥ Update FastAPI People. PR [#11511](https://github.com/tiangolo/fastapi/pull/11511) by [@tiangolo](https://github.com/tiangolo).

## 0.111.0[¶](#01110 "Permanent link")

### Features[¶](#features_11 "Permanent link")

  * âœ¨ Add FastAPI CLI, the new `fastapi` command. PR [#11522](https://github.com/tiangolo/fastapi/pull/11522) by [@tiangolo](https://github.com/tiangolo).
    * New docs: [FastAPI CLI](https://fastapi.tiangolo.com/fastapi-cli/).

Try it out with:
    
    
    $ pip install --upgrade fastapi
    
    $ fastapi dev main.py
    
    
     â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ FastAPI CLI - Development mode â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
     â”‚                                                     â”‚
     â”‚  Serving at: http://127.0.0.1:8000                  â”‚
     â”‚                                                     â”‚
     â”‚  API docs: http://127.0.0.1:8000/docs               â”‚
     â”‚                                                     â”‚
     â”‚  Running in development mode, for production use:   â”‚
     â”‚                                                     â”‚
     â”‚  fastapi run                                        â”‚
     â”‚                                                     â”‚
     â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
    
    INFO:     Will watch for changes in these directories: ['/home/user/code/awesomeapp']
    INFO:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
    INFO:     Started reloader process [2248755] using WatchFiles
    INFO:     Started server process [2248757]
    INFO:     Waiting for application startup.
    INFO:     Application startup complete.
    

### Refactors[¶](#refactors_20 "Permanent link")

  * ğŸ”§ Add configs and setup for `fastapi-slim` including optional extras `fastapi-slim[standard]`, and `fastapi` including by default the same `standard` extras. PR [#11503](https://github.com/tiangolo/fastapi/pull/11503) by [@tiangolo](https://github.com/tiangolo).

## 0.110.3[¶](#01103 "Permanent link")

### Docs[¶](#docs_38 "Permanent link")

  * ğŸ“� Update references to Python version, FastAPI supports all the current versions, no need to make the version explicit. PR [#11496](https://github.com/tiangolo/fastapi/pull/11496) by [@tiangolo](https://github.com/tiangolo).
  * âœ�ï¸� Fix typo in `fastapi/security/api_key.py`. PR [#11481](https://github.com/tiangolo/fastapi/pull/11481) by [@ch33zer](https://github.com/ch33zer).
  * âœ�ï¸� Fix typo in `security/http.py`. PR [#11455](https://github.com/tiangolo/fastapi/pull/11455) by [@omarmoo5](https://github.com/omarmoo5).

### Translations[¶](#translations_36 "Permanent link")

  * ğŸŒ� Add Traditional Chinese translation for `docs/zh-hant/benchmarks.md`. PR [#11484](https://github.com/tiangolo/fastapi/pull/11484) by [@KNChiu](https://github.com/KNChiu).
  * ğŸŒ� Update Chinese translation for `docs/zh/docs/fastapi-people.md`. PR [#11476](https://github.com/tiangolo/fastapi/pull/11476) by [@billzhong](https://github.com/billzhong).
  * ğŸŒ� Add Chinese translation for `docs/zh/docs/how-to/index.md` and `docs/zh/docs/how-to/general.md`. PR [#11443](https://github.com/tiangolo/fastapi/pull/11443) by [@billzhong](https://github.com/billzhong).
  * ğŸŒ� Add Spanish translation for cookie-params `docs/es/docs/tutorial/cookie-params.md`. PR [#11410](https://github.com/tiangolo/fastapi/pull/11410) by [@fabianfalon](https://github.com/fabianfalon).

### Internal[¶](#internal_49 "Permanent link")

  * â¬† Bump mkdocstrings[python] from 0.23.0 to 0.24.3. PR [#11469](https://github.com/tiangolo/fastapi/pull/11469) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * ğŸ”¨ Update internal scripts and remove unused ones. PR [#11499](https://github.com/tiangolo/fastapi/pull/11499) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”§ Migrate from Hatch to PDM for the internal build. PR [#11498](https://github.com/tiangolo/fastapi/pull/11498) by [@tiangolo](https://github.com/tiangolo).
  * â¬†ï¸� Upgrade MkDocs Material and re-enable cards. PR [#11466](https://github.com/tiangolo/fastapi/pull/11466) by [@tiangolo](https://github.com/tiangolo).
  * â¬† Bump pillow from 10.2.0 to 10.3.0. PR [#11403](https://github.com/tiangolo/fastapi/pull/11403) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * ğŸ”§ Ungroup dependabot updates. PR [#11465](https://github.com/tiangolo/fastapi/pull/11465) by [@tiangolo](https://github.com/tiangolo).

## 0.110.2[¶](#01102 "Permanent link")

### Fixes[¶](#fixes_39 "Permanent link")

  * ğŸ�› Fix support for query parameters with list types, handle JSON encoding Pydantic `UndefinedType`. PR [#9929](https://github.com/tiangolo/fastapi/pull/9929) by [@arjwilliams](https://github.com/arjwilliams).

### Refactors[¶](#refactors_21 "Permanent link")

  * â™»ï¸� Simplify Pydantic configs in OpenAPI models in `fastapi/openapi/models.py`. PR [#10886](https://github.com/tiangolo/fastapi/pull/10886) by [@JoeTanto2](https://github.com/JoeTanto2).
  * âœ¨ Add support for Pydantic's 2.7 new deprecated Field parameter, remove URL from validation errors response. PR [#11461](https://github.com/tiangolo/fastapi/pull/11461) by [@tiangolo](https://github.com/tiangolo).

### Docs[¶](#docs_39 "Permanent link")

  * ğŸ“� Fix types in examples under `docs_src/extra_data_types`. PR [#10535](https://github.com/tiangolo/fastapi/pull/10535) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸ“� Update references to UJSON. PR [#11464](https://github.com/tiangolo/fastapi/pull/11464) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ“� Tweak docs and translations links, typos, format. PR [#11389](https://github.com/tiangolo/fastapi/pull/11389) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸ“� Fix typo in `docs/es/docs/async.md`. PR [#11400](https://github.com/tiangolo/fastapi/pull/11400) by [@fabianfalon](https://github.com/fabianfalon).
  * ğŸ“� Update OpenAPI client generation docs to use `@hey-api/openapi-ts`. PR [#11339](https://github.com/tiangolo/fastapi/pull/11339) by [@jordanshatford](https://github.com/jordanshatford).

### Translations[¶](#translations_37 "Permanent link")

  * ğŸŒ� Update Chinese translation for `docs/zh/docs/index.html`. PR [#11430](https://github.com/tiangolo/fastapi/pull/11430) by [@waketzheng](https://github.com/waketzheng).
  * ğŸŒ� Add Russian translation for `docs/ru/docs/tutorial/dependencies/dependencies-in-path-operation-decorators.md`. PR [#11411](https://github.com/tiangolo/fastapi/pull/11411) by [@anton2yakovlev](https://github.com/anton2yakovlev).
  * ğŸŒ� Add Portuguese translations for `learn/index.md` `resources/index.md` `help/index.md` `about/index.md`. PR [#10807](https://github.com/tiangolo/fastapi/pull/10807) by [@nazarepiedady](https://github.com/nazarepiedady).
  * ğŸŒ� Update Russian translations for deployments docs. PR [#11271](https://github.com/tiangolo/fastapi/pull/11271) by [@Lufa1u](https://github.com/Lufa1u).
  * ğŸŒ� Add Bengali translations for `docs/bn/docs/python-types.md`. PR [#11376](https://github.com/tiangolo/fastapi/pull/11376) by [@imtiaz101325](https://github.com/imtiaz101325).
  * ğŸŒ� Add Korean translation for `docs/ko/docs/tutorial/security/simple-oauth2.md`. PR [#5744](https://github.com/tiangolo/fastapi/pull/5744) by [@KdHyeon0661](https://github.com/KdHyeon0661).
  * ğŸŒ� Add Korean translation for `docs/ko/docs/help-fastapi.md`. PR [#4139](https://github.com/tiangolo/fastapi/pull/4139) by [@kty4119](https://github.com/kty4119).
  * ğŸŒ� Add Korean translation for `docs/ko/docs/advanced/events.md`. PR [#5087](https://github.com/tiangolo/fastapi/pull/5087) by [@pers0n4](https://github.com/pers0n4).
  * ğŸŒ� Add Japanese translation for `docs/ja/docs/tutorial/path-operation-configuration.md`. PR [#1954](https://github.com/tiangolo/fastapi/pull/1954) by [@SwftAlpc](https://github.com/SwftAlpc).
  * ğŸŒ� Add Japanese translation for `docs/ja/docs/tutorial/request-forms-and-files.md`. PR [#1946](https://github.com/tiangolo/fastapi/pull/1946) by [@SwftAlpc](https://github.com/SwftAlpc).
  * ğŸŒ� Add Russian translation for `docs/ru/docs/tutorial/dependencies/dependencies-with-yield.md`. PR [#10532](https://github.com/tiangolo/fastapi/pull/10532) by [@AlertRED](https://github.com/AlertRED).
  * ğŸŒ� Add Korean translation for `docs/ko/docs/tutorial/debugging.md`. PR [#5695](https://github.com/tiangolo/fastapi/pull/5695) by [@JungWooGeon](https://github.com/JungWooGeon).

### Internal[¶](#internal_50 "Permanent link")

  * â¬†ï¸� Upgrade version of typer for docs. PR [#11393](https://github.com/tiangolo/fastapi/pull/11393) by [@tiangolo](https://github.com/tiangolo).

## 0.110.1[¶](#01101 "Permanent link")

### Fixes[¶](#fixes_40 "Permanent link")

  * ğŸ�› Fix parameterless `Depends()` with generics. PR [#9479](https://github.com/tiangolo/fastapi/pull/9479) by [@nzig](https://github.com/nzig).

### Refactors[¶](#refactors_22 "Permanent link")

  * â™»ï¸� Update mypy. PR [#11049](https://github.com/tiangolo/fastapi/pull/11049) by [@k0t3n](https://github.com/k0t3n).
  * â™»ï¸� Simplify string format with f-strings in `fastapi/applications.py`. PR [#11335](https://github.com/tiangolo/fastapi/pull/11335) by [@igeni](https://github.com/igeni).

### Upgrades[¶](#upgrades_14 "Permanent link")

  * â¬†ï¸� Upgrade Starlette to >=0.37.2,<0.38.0, remove Starlette filterwarning for internal tests. PR [#11266](https://github.com/tiangolo/fastapi/pull/11266) by [@nothielf](https://github.com/nothielf).

### Docs[¶](#docs_40 "Permanent link")

  * ğŸ“� Tweak docs and translations links and remove old docs translations. PR [#11381](https://github.com/tiangolo/fastapi/pull/11381) by [@tiangolo](https://github.com/tiangolo).
  * âœ�ï¸� Fix typo in `fastapi/security/oauth2.py`. PR [#11368](https://github.com/tiangolo/fastapi/pull/11368) by [@shandongbinzhou](https://github.com/shandongbinzhou).
  * ğŸ“� Update links to Pydantic docs to point to new website. PR [#11328](https://github.com/tiangolo/fastapi/pull/11328) by [@alejsdev](https://github.com/alejsdev).
  * âœ�ï¸� Fix typo in `docs/en/docs/tutorial/extra-models.md`. PR [#11329](https://github.com/tiangolo/fastapi/pull/11329) by [@alejsdev](https://github.com/alejsdev).
  * ğŸ“� Update `project-generation.md`. PR [#11326](https://github.com/tiangolo/fastapi/pull/11326) by [@alejsdev](https://github.com/alejsdev).
  * ğŸ“� Update External Links. PR [#11327](https://github.com/tiangolo/fastapi/pull/11327) by [@alejsdev](https://github.com/alejsdev).
  * ğŸ”¥ Remove link to Pydantic's benchmark, on other i18n pages.. PR [#11224](https://github.com/tiangolo/fastapi/pull/11224) by [@hirotoKirimaru](https://github.com/hirotoKirimaru).
  * âœ�ï¸� Fix typos in docstrings. PR [#11295](https://github.com/tiangolo/fastapi/pull/11295) by [@davidhuser](https://github.com/davidhuser).
  * ğŸ› ï¸� Improve Node.js script in docs to generate TypeScript clients. PR [#11293](https://github.com/tiangolo/fastapi/pull/11293) by [@alejsdev](https://github.com/alejsdev).
  * ğŸ“� Update examples for tests to replace "inexistent" for "nonexistent". PR [#11220](https://github.com/tiangolo/fastapi/pull/11220) by [@Homesteady](https://github.com/Homesteady).
  * ğŸ“� Update `python-multipart` GitHub link in all docs from `https://andrew-d.github.io/python-multipart/` to `https://github.com/Kludex/python-multipart`. PR [#11239](https://github.com/tiangolo/fastapi/pull/11239) by [@joshjhans](https://github.com/joshjhans).

### Translations[¶](#translations_38 "Permanent link")

  * ğŸŒ� Add German translation for `docs/de/docs/tutorial/response-status-code.md`. PR [#10357](https://github.com/tiangolo/fastapi/pull/10357) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Update Chinese translation for `docs/zh/docs/tutorial/query-params.md`. PR [#3480](https://github.com/tiangolo/fastapi/pull/3480) by [@jaystone776](https://github.com/jaystone776).
  * ğŸŒ� Update Chinese translation for `docs/zh/docs/tutorial/body.md`. PR [#3481](https://github.com/tiangolo/fastapi/pull/3481) by [@jaystone776](https://github.com/jaystone776).
  * ğŸŒ� Update Chinese translation for `docs/zh/docs/tutorial/path-params.md`. PR [#3479](https://github.com/tiangolo/fastapi/pull/3479) by [@jaystone776](https://github.com/jaystone776).
  * ğŸŒ� Update Chinese translation for `docs/tutorial/body-fields.md`. PR [#3496](https://github.com/tiangolo/fastapi/pull/3496) by [@jaystone776](https://github.com/jaystone776).
  * ğŸŒ� Update Chinese translation for `docs/tutorial/extra-models.md`. PR [#3497](https://github.com/tiangolo/fastapi/pull/3497) by [@jaystone776](https://github.com/jaystone776).
  * ğŸŒ� Add Japanese translation for `docs/ja/docs/tutorial/metadata.md`. PR [#2667](https://github.com/tiangolo/fastapi/pull/2667) by [@tokusumi](https://github.com/tokusumi).
  * ğŸŒ� Add German translation for `docs/de/docs/contributing.md`. PR [#10487](https://github.com/tiangolo/fastapi/pull/10487) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Update Japanese translation of `docs/ja/docs/tutorial/query-params.md`. PR [#10808](https://github.com/tiangolo/fastapi/pull/10808) by [@urushio](https://github.com/urushio).
  * ğŸŒ� Update Chinese translation for `docs/zh/docs/tutorial/security/get-current-user.md`. PR [#3842](https://github.com/tiangolo/fastapi/pull/3842) by [@jaystone776](https://github.com/jaystone776).
  * ğŸŒ� Add Chinese translation for `docs/zh/docs/advanced/openapi-callbacks.md`. PR [#3825](https://github.com/tiangolo/fastapi/pull/3825) by [@jaystone776](https://github.com/jaystone776).
  * ğŸŒ� Add Chinese translation for `docs/zh/docs/advanced/extending-openapi.md`. PR [#3823](https://github.com/tiangolo/fastapi/pull/3823) by [@jaystone776](https://github.com/jaystone776).
  * ğŸŒ� Add Chinese translation for `docs/zh/docs/advanced/testing-dependencies.md`. PR [#3819](https://github.com/tiangolo/fastapi/pull/3819) by [@jaystone776](https://github.com/jaystone776).
  * ğŸŒ� Add Chinese translation for `docs/zh/docs/advanced/custom-request-and-route.md`. PR [#3816](https://github.com/tiangolo/fastapi/pull/3816) by [@jaystone776](https://github.com/jaystone776).
  * ğŸŒ� Add Chinese translation for `docs/zh/docs/external-links.md`. PR [#3833](https://github.com/tiangolo/fastapi/pull/3833) by [@jaystone776](https://github.com/jaystone776).
  * ğŸŒ� Add Chinese translation for `docs/zh/docs/advanced/templates.md`. PR [#3812](https://github.com/tiangolo/fastapi/pull/3812) by [@jaystone776](https://github.com/jaystone776).
  * ğŸŒ� Add Chinese translation for `docs/zh/docs/advanced/sub-applications.md`. PR [#3811](https://github.com/tiangolo/fastapi/pull/3811) by [@jaystone776](https://github.com/jaystone776).
  * ğŸŒ� Add Chinese translation for `docs/zh/docs/advanced/async-sql-databases.md`. PR [#3805](https://github.com/tiangolo/fastapi/pull/3805) by [@jaystone776](https://github.com/jaystone776).
  * ğŸŒ� Add Chinese translation for `docs/zh/docs/advanced/middleware.md`. PR [#3804](https://github.com/tiangolo/fastapi/pull/3804) by [@jaystone776](https://github.com/jaystone776).
  * ğŸŒ� Add Chinese translation for `docs/zh/docs/advanced/dataclasses.md`. PR [#3803](https://github.com/tiangolo/fastapi/pull/3803) by [@jaystone776](https://github.com/jaystone776).
  * ğŸŒ� Add Chinese translation for `docs/zh/docs/advanced/using-request-directly.md`. PR [#3802](https://github.com/tiangolo/fastapi/pull/3802) by [@jaystone776](https://github.com/jaystone776).
  * ğŸŒ� Add Chinese translation for `docs/zh/docs/advanced/security/http-basic-auth.md`. PR [#3801](https://github.com/tiangolo/fastapi/pull/3801) by [@jaystone776](https://github.com/jaystone776).
  * ğŸŒ� Add Chinese translation for `docs/zh/docs/advanced/security/oauth2-scopes.md`. PR [#3800](https://github.com/tiangolo/fastapi/pull/3800) by [@jaystone776](https://github.com/jaystone776).
  * ğŸŒ� Update Chinese translation for `docs/zh/docs/tutorial/cookie-params.md`. PR [#3486](https://github.com/tiangolo/fastapi/pull/3486) by [@jaystone776](https://github.com/jaystone776).
  * ğŸŒ� Update Chinese translation for `docs/zh/docs/tutorial/header-params.md`. PR [#3487](https://github.com/tiangolo/fastapi/pull/3487) by [@jaystone776](https://github.com/jaystone776).
  * ğŸŒ� Update Chinese translation for `docs/tutorial/response-status-code.md`. PR [#3498](https://github.com/tiangolo/fastapi/pull/3498) by [@jaystone776](https://github.com/jaystone776).
  * ğŸŒ� Add German translation for `docs/de/docs/tutorial/security/first-steps.md`. PR [#10432](https://github.com/tiangolo/fastapi/pull/10432) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Add German translation for `docs/de/docs/advanced/events.md`. PR [#10693](https://github.com/tiangolo/fastapi/pull/10693) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Add German translation for `docs/de/docs/deployment/cloud.md`. PR [#10746](https://github.com/tiangolo/fastapi/pull/10746) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Add German translation for `docs/de/docs/advanced/behind-a-proxy.md`. PR [#10675](https://github.com/tiangolo/fastapi/pull/10675) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Add German translation for `docs/de/docs/help-fastapi.md`. PR [#10455](https://github.com/tiangolo/fastapi/pull/10455) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Update German translation for `docs/de/docs/python-types.md`. PR [#10287](https://github.com/tiangolo/fastapi/pull/10287) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Add German translation for `docs/de/docs/tutorial/path-params.md`. PR [#10290](https://github.com/tiangolo/fastapi/pull/10290) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Add German translation for `docs/de/docs/tutorial/handling-errors.md`. PR [#10379](https://github.com/tiangolo/fastapi/pull/10379) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Update German translation for `docs/de/docs/index.md`. PR [#10283](https://github.com/tiangolo/fastapi/pull/10283) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Add German translation for `docs/de/docs/advanced/security/http-basic-auth.md`. PR [#10651](https://github.com/tiangolo/fastapi/pull/10651) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Add German translation for `docs/de/docs/tutorial/bigger-applications.md`. PR [#10554](https://github.com/tiangolo/fastapi/pull/10554) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Add German translation for `docs/de/docs/advanced/path-operation-advanced-configuration.md`. PR [#10612](https://github.com/tiangolo/fastapi/pull/10612) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Add German translation for `docs/de/docs/tutorial/static-files.md`. PR [#10584](https://github.com/tiangolo/fastapi/pull/10584) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Add German translation for `docs/de/docs/tutorial/security/oauth2-jwt.md`. PR [#10522](https://github.com/tiangolo/fastapi/pull/10522) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Add German translation for `docs/de/docs/tutorial/response-model.md`. PR [#10345](https://github.com/tiangolo/fastapi/pull/10345) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Add German translation for `docs/de/docs/tutorial/extra-models.md`. PR [#10351](https://github.com/tiangolo/fastapi/pull/10351) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Add German translation for `docs/de/docs/tutorial/body-updates.md`. PR [#10396](https://github.com/tiangolo/fastapi/pull/10396) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Add German translation for `docs/de/docs/alternatives.md`. PR [#10855](https://github.com/tiangolo/fastapi/pull/10855) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Add German translation for `docs/de/docs/advanced/templates.md`. PR [#10678](https://github.com/tiangolo/fastapi/pull/10678) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Add German translation for `docs/de/docs/advanced/security/oauth2-scopes.md`. PR [#10643](https://github.com/tiangolo/fastapi/pull/10643) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Add German translation for `docs/de/docs/advanced/async-tests.md`. PR [#10708](https://github.com/tiangolo/fastapi/pull/10708) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Add German translation for `docs/de/docs/tutorial/metadata.md`. PR [#10581](https://github.com/tiangolo/fastapi/pull/10581) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Add German translation for `docs/de/docs/tutorial/testing.md`. PR [#10586](https://github.com/tiangolo/fastapi/pull/10586) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Add German translation for `docs/de/docs/tutorial/schema-extra-example.md`. PR [#10597](https://github.com/tiangolo/fastapi/pull/10597) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Add German translation for `docs/de/docs/advanced/index.md`. PR [#10611](https://github.com/tiangolo/fastapi/pull/10611) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Add German translation for `docs/de/docs/advanced/response-directly.md`. PR [#10618](https://github.com/tiangolo/fastapi/pull/10618) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Add German translation for `docs/de/docs/advanced/additional-responses.md`. PR [#10626](https://github.com/tiangolo/fastapi/pull/10626) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Add German translation for `docs/de/docs/advanced/response-cookies.md`. PR [#10627](https://github.com/tiangolo/fastapi/pull/10627) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Add German translation for `docs/de/docs/advanced/response-headers.md`. PR [#10628](https://github.com/tiangolo/fastapi/pull/10628) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Add German translation for `docs/de/docs/advanced/response-change-status-code.md`. PR [#10632](https://github.com/tiangolo/fastapi/pull/10632) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Add German translation for `docs/de/docs/advanced/advanced-dependencies.md`. PR [#10633](https://github.com/tiangolo/fastapi/pull/10633) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Add German translation for `docs/de/docs/advanced/security/index.md`. PR [#10635](https://github.com/tiangolo/fastapi/pull/10635) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Add German translation for `docs/de/docs/advanced/using-request-directly.md`. PR [#10653](https://github.com/tiangolo/fastapi/pull/10653) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Add German translation for `docs/de/docs/advanced/dataclasses.md`. PR [#10667](https://github.com/tiangolo/fastapi/pull/10667) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Add German translation for `docs/de/docs/advanced/middleware.md`. PR [#10668](https://github.com/tiangolo/fastapi/pull/10668) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Add German translation for `docs/de/docs/advanced/sub-applications.md`. PR [#10671](https://github.com/tiangolo/fastapi/pull/10671) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Add German translation for `docs/de/docs/advanced/websockets.md`. PR [#10687](https://github.com/tiangolo/fastapi/pull/10687) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Add German translation for `docs/de/docs/advanced/testing-websockets.md`. PR [#10703](https://github.com/tiangolo/fastapi/pull/10703) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Add German translation for `docs/de/docs/advanced/testing-events.md`. PR [#10704](https://github.com/tiangolo/fastapi/pull/10704) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Add German translation for `docs/de/docs/advanced/testing-dependencies.md`. PR [#10706](https://github.com/tiangolo/fastapi/pull/10706) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Add German translation for `docs/de/docs/advanced/openapi-callbacks.md`. PR [#10710](https://github.com/tiangolo/fastapi/pull/10710) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Add German translation for `docs/de/docs/advanced/settings.md`. PR [#10709](https://github.com/tiangolo/fastapi/pull/10709) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Add German translation for `docs/de/docs/advanced/wsgi.md`. PR [#10713](https://github.com/tiangolo/fastapi/pull/10713) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Add German translation for `docs/de/docs/deployment/index.md`. PR [#10733](https://github.com/tiangolo/fastapi/pull/10733) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Add German translation for `docs/de/docs/deployment/https.md`. PR [#10737](https://github.com/tiangolo/fastapi/pull/10737) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Add German translation for `docs/de/docs/deployment/manually.md`. PR [#10738](https://github.com/tiangolo/fastapi/pull/10738) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Add German translation for `docs/de/docs/deployment/concepts.md`. PR [#10744](https://github.com/tiangolo/fastapi/pull/10744) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Update German translation for `docs/de/docs/features.md`. PR [#10284](https://github.com/tiangolo/fastapi/pull/10284) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Add German translation for `docs/de/docs/deployment/server-workers.md`. PR [#10747](https://github.com/tiangolo/fastapi/pull/10747) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Add German translation for `docs/de/docs/deployment/docker.md`. PR [#10759](https://github.com/tiangolo/fastapi/pull/10759) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Add German translation for `docs/de/docs/how-to/index.md`. PR [#10769](https://github.com/tiangolo/fastapi/pull/10769) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Add German translation for `docs/de/docs/how-to/general.md`. PR [#10770](https://github.com/tiangolo/fastapi/pull/10770) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Add German translation for `docs/de/docs/how-to/graphql.md`. PR [#10788](https://github.com/tiangolo/fastapi/pull/10788) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Add German translation for `docs/de/docs/how-to/custom-request-and-route.md`. PR [#10789](https://github.com/tiangolo/fastapi/pull/10789) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Add German translation for `docs/de/docs/how-to/conditional-openapi.md`. PR [#10790](https://github.com/tiangolo/fastapi/pull/10790) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Add German translation for `docs/de/docs/how-to/separate-openapi-schemas.md`. PR [#10796](https://github.com/tiangolo/fastapi/pull/10796) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Add German translation for `docs/de/docs/how-to/configure-swagger-ui.md`. PR [#10804](https://github.com/tiangolo/fastapi/pull/10804) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Add German translation for `docs/de/docs/how-to/custom-docs-ui-assets.md`. PR [#10803](https://github.com/tiangolo/fastapi/pull/10803) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Add German translation for `docs/de/docs/reference/parameters.md`. PR [#10814](https://github.com/tiangolo/fastapi/pull/10814) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Add German translation for `docs/de/docs/reference/status.md`. PR [#10815](https://github.com/tiangolo/fastapi/pull/10815) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Add German translation for `docs/de/docs/reference/uploadfile.md`. PR [#10816](https://github.com/tiangolo/fastapi/pull/10816) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Add German translation for `docs/de/docs/reference/exceptions.md`. PR [#10817](https://github.com/tiangolo/fastapi/pull/10817) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Add German translation for `docs/de/docs/reference/dependencies.md`. PR [#10818](https://github.com/tiangolo/fastapi/pull/10818) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Add German translation for `docs/de/docs/reference/apirouter.md`. PR [#10819](https://github.com/tiangolo/fastapi/pull/10819) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Add German translation for `docs/de/docs/reference/websockets.md`. PR [#10822](https://github.com/tiangolo/fastapi/pull/10822) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Add German translation for `docs/de/docs/reference/httpconnection.md`. PR [#10823](https://github.com/tiangolo/fastapi/pull/10823) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Add German translation for `docs/de/docs/reference/response.md`. PR [#10824](https://github.com/tiangolo/fastapi/pull/10824) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Add German translation for `docs/de/docs/reference/middleware.md`. PR [#10837](https://github.com/tiangolo/fastapi/pull/10837) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Add German translation for `docs/de/docs/reference/openapi/*.md`. PR [#10838](https://github.com/tiangolo/fastapi/pull/10838) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Add German translation for `docs/de/docs/reference/security/index.md`. PR [#10839](https://github.com/tiangolo/fastapi/pull/10839) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Add German translation for `docs/de/docs/reference/staticfiles.md`. PR [#10841](https://github.com/tiangolo/fastapi/pull/10841) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Add German translation for `docs/de/docs/reference/testclient.md`. PR [#10843](https://github.com/tiangolo/fastapi/pull/10843) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Add German translation for `docs/de/docs/project-generation.md`. PR [#10851](https://github.com/tiangolo/fastapi/pull/10851) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Add German translation for `docs/de/docs/history-design-future.md`. PR [#10865](https://github.com/tiangolo/fastapi/pull/10865) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Add German translation for `docs/de/docs/tutorial/dependencies/dependencies-with-yield.md`. PR [#10422](https://github.com/tiangolo/fastapi/pull/10422) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Add German translation for `docs/de/docs/tutorial/dependencies/global-dependencies.md`. PR [#10420](https://github.com/tiangolo/fastapi/pull/10420) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Update German translation for `docs/de/docs/fastapi-people.md`. PR [#10285](https://github.com/tiangolo/fastapi/pull/10285) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Add German translation for `docs/de/docs/tutorial/dependencies/sub-dependencies.md`. PR [#10409](https://github.com/tiangolo/fastapi/pull/10409) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Add German translation for `docs/de/docs/tutorial/security/index.md`. PR [#10429](https://github.com/tiangolo/fastapi/pull/10429) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Add German translation for `docs/de/docs/tutorial/dependencies/dependencies-in-path-operation-decorators.md`. PR [#10411](https://github.com/tiangolo/fastapi/pull/10411) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Add German translation for `docs/de/docs/tutorial/extra-data-types.md`. PR [#10534](https://github.com/tiangolo/fastapi/pull/10534) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Add German translation for `docs/de/docs/tutorial/security/simple-oauth2.md`. PR [#10504](https://github.com/tiangolo/fastapi/pull/10504) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Add German translation for `docs/de/docs/tutorial/security/get-current-user.md`. PR [#10439](https://github.com/tiangolo/fastapi/pull/10439) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Add German translation for `docs/de/docs/tutorial/request-forms-and-files.md`. PR [#10368](https://github.com/tiangolo/fastapi/pull/10368) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Add German translation for `docs/de/docs/tutorial/encoder.md`. PR [#10385](https://github.com/tiangolo/fastapi/pull/10385) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Add German translation for `docs/de/docs/tutorial/request-forms.md`. PR [#10361](https://github.com/tiangolo/fastapi/pull/10361) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Add German translation for `docs/de/docs/deployment/versions.md`. PR [#10491](https://github.com/tiangolo/fastapi/pull/10491) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Add German translation for `docs/de/docs/async.md`. PR [#10449](https://github.com/tiangolo/fastapi/pull/10449) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Add German translation for `docs/de/docs/tutorial/cookie-params.md`. PR [#10323](https://github.com/tiangolo/fastapi/pull/10323) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Add German translation for `docs/de/docs/tutorial/dependencies/classes-as-dependencies.md`. PR [#10407](https://github.com/tiangolo/fastapi/pull/10407) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Add German translation for `docs/de/docs/tutorial/dependencies/index.md`. PR [#10399](https://github.com/tiangolo/fastapi/pull/10399) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Add German translation for `docs/de/docs/tutorial/header-params.md`. PR [#10326](https://github.com/tiangolo/fastapi/pull/10326) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Add German translation for `docs/de/docs/tutorial/path-params-numeric-validations.md`. PR [#10307](https://github.com/tiangolo/fastapi/pull/10307) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Add German translation for `docs/de/docs/tutorial/query-params-str-validations.md`. PR [#10304](https://github.com/tiangolo/fastapi/pull/10304) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Add German translation for `docs/de/docs/tutorial/request-files.md`. PR [#10364](https://github.com/tiangolo/fastapi/pull/10364) by [@nilslindemann](https://github.com/nilslindemann).
  * :globe_with_meridians: Add Portuguese translation for `docs/pt/docs/advanced/templates.md`. PR [#11338](https://github.com/tiangolo/fastapi/pull/11338) by [@SamuelBFavarin](https://github.com/SamuelBFavarin).
  * ğŸŒ� Add Bengali translations for `docs/bn/docs/learn/index.md`. PR [#11337](https://github.com/tiangolo/fastapi/pull/11337) by [@imtiaz101325](https://github.com/imtiaz101325).
  * ğŸŒ� Fix Korean translation for `docs/ko/docs/index.md`. PR [#11296](https://github.com/tiangolo/fastapi/pull/11296) by [@choi-haram](https://github.com/choi-haram).
  * ğŸŒ� Add Korean translation for `docs/ko/docs/about/index.md`. PR [#11299](https://github.com/tiangolo/fastapi/pull/11299) by [@choi-haram](https://github.com/choi-haram).
  * ğŸŒ� Add Korean translation for `docs/ko/docs/advanced/index.md`. PR [#9613](https://github.com/tiangolo/fastapi/pull/9613) by [@ElliottLarsen](https://github.com/ElliottLarsen).
  * ğŸŒ� Add German translation for `docs/de/docs/how-to/extending-openapi.md`. PR [#10794](https://github.com/tiangolo/fastapi/pull/10794) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Update Chinese translation for `docs/zh/docs/tutorial/metadata.md`. PR [#11286](https://github.com/tiangolo/fastapi/pull/11286) by [@jackleeio](https://github.com/jackleeio).
  * ğŸŒ� Update Chinese translation for `docs/zh/docs/contributing.md`. PR [#10887](https://github.com/tiangolo/fastapi/pull/10887) by [@Aruelius](https://github.com/Aruelius).
  * ğŸŒ� Add Azerbaijani translation for `docs/az/docs/fastapi-people.md`. PR [#11195](https://github.com/tiangolo/fastapi/pull/11195) by [@vusallyv](https://github.com/vusallyv).
  * ğŸŒ� Add Russian translation for `docs/ru/docs/tutorial/dependencies/index.md`. PR [#11223](https://github.com/tiangolo/fastapi/pull/11223) by [@kohiry](https://github.com/kohiry).
  * ğŸŒ� Update Chinese translation for `docs/zh/docs/tutorial/query-params.md`. PR [#11242](https://github.com/tiangolo/fastapi/pull/11242) by [@jackleeio](https://github.com/jackleeio).
  * ğŸŒ� Add Azerbaijani translation for `docs/az/learn/index.md`. PR [#11192](https://github.com/tiangolo/fastapi/pull/11192) by [@vusallyv](https://github.com/vusallyv).

### Internal[¶](#internal_51 "Permanent link")

  * ğŸ‘¥ Update FastAPI People. PR [#11387](https://github.com/tiangolo/fastapi/pull/11387) by [@tiangolo](https://github.com/tiangolo).
  * â¬† Bump actions/cache from 3 to 4. PR [#10988](https://github.com/tiangolo/fastapi/pull/10988) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * â¬† Bump pypa/gh-action-pypi-publish from 1.8.11 to 1.8.14. PR [#11318](https://github.com/tiangolo/fastapi/pull/11318) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * â¬† Bump pillow from 10.1.0 to 10.2.0. PR [#11011](https://github.com/tiangolo/fastapi/pull/11011) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * â¬† Bump black from 23.3.0 to 24.3.0. PR [#11325](https://github.com/tiangolo/fastapi/pull/11325) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * ğŸ‘· Add cron to run test once a week on monday. PR [#11377](https://github.com/tiangolo/fastapi/pull/11377) by [@estebanx64](https://github.com/estebanx64).
  * â�• Replace mkdocs-markdownextradata-plugin with mkdocs-macros-plugin. PR [#11383](https://github.com/tiangolo/fastapi/pull/11383) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘· Disable MkDocs insiders social plugin while an issue in MkDocs Material is handled. PR [#11373](https://github.com/tiangolo/fastapi/pull/11373) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘· Fix logic for when to install and use MkDocs Insiders. PR [#11372](https://github.com/tiangolo/fastapi/pull/11372) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘· Do not use Python packages cache for publish. PR [#11366](https://github.com/tiangolo/fastapi/pull/11366) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘· Add CI to test sdists for redistribution (e.g. Linux distros). PR [#11365](https://github.com/tiangolo/fastapi/pull/11365) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘· Update build-docs GitHub Action path filter. PR [#11354](https://github.com/tiangolo/fastapi/pull/11354) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”§ Update Ruff config, add extra ignore rule from SQLModel. PR [#11353](https://github.com/tiangolo/fastapi/pull/11353) by [@tiangolo](https://github.com/tiangolo).
  * â¬†ï¸� Upgrade configuration for Ruff v0.2.0. PR [#11075](https://github.com/tiangolo/fastapi/pull/11075) by [@charliermarsh](https://github.com/charliermarsh).
  * ğŸ”§ Update sponsors, add MongoDB. PR [#11346](https://github.com/tiangolo/fastapi/pull/11346) by [@tiangolo](https://github.com/tiangolo).
  * â¬† Bump dorny/paths-filter from 2 to 3. PR [#11028](https://github.com/tiangolo/fastapi/pull/11028) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * â¬† Bump dawidd6/action-download-artifact from 3.0.0 to 3.1.4. PR [#11310](https://github.com/tiangolo/fastapi/pull/11310) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * â™»ï¸� Refactor computing FastAPI People, include 3 months, 6 months, 1 year, based on comment date, not discussion date. PR [#11304](https://github.com/tiangolo/fastapi/pull/11304) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘¥ Update FastAPI People. PR [#11228](https://github.com/tiangolo/fastapi/pull/11228) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”¥ Remove Jina AI QA Bot from the docs. PR [#11268](https://github.com/tiangolo/fastapi/pull/11268) by [@nan-wang](https://github.com/nan-wang).
  * ğŸ”§ Update sponsors, remove Jina, remove Powens, move TestDriven.io. PR [#11213](https://github.com/tiangolo/fastapi/pull/11213) by [@tiangolo](https://github.com/tiangolo).

## 0.110.0[¶](#01100 "Permanent link")

### Breaking Changes[¶](#breaking-changes_4 "Permanent link")

  * ğŸ�› Fix unhandled growing memory for internal server errors, refactor dependencies with `yield` and `except` to require raising again as in regular Python. PR [#11191](https://github.com/tiangolo/fastapi/pull/11191) by [@tiangolo](https://github.com/tiangolo).
    * This is a breaking change (and only slightly) if you used dependencies with `yield`, used `except` in those dependencies, and didn't raise again.
    * This was reported internally by [@rushilsrivastava](https://github.com/rushilsrivastava) as a memory leak when the server had unhandled exceptions that would produce internal server errors, the memory allocated before that point would not be released.
    * Read the new docs: [Dependencies with `yield` and `except`](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-with-yield/#dependencies-with-yield-and-except).

In short, if you had dependencies that looked like:
    
    
    def my_dep():
        try:
            yield
        except SomeException:
            pass
    

Now you need to make sure you raise again after `except`, just as you would in regular Python:
    
    
    def my_dep():
        try:
            yield
        except SomeException:
            raise
    

### Docs[¶](#docs_41 "Permanent link")

  * âœ�ï¸� Fix minor typos in `docs/ko/docs/`. PR [#11126](https://github.com/tiangolo/fastapi/pull/11126) by [@KaniKim](https://github.com/KaniKim).
  * âœ�ï¸� Fix minor typo in `fastapi/applications.py`. PR [#11099](https://github.com/tiangolo/fastapi/pull/11099) by [@JacobHayes](https://github.com/JacobHayes).

### Translations[¶](#translations_39 "Permanent link")

  * ğŸŒ� Add German translation for `docs/de/docs/reference/background.md`. PR [#10820](https://github.com/tiangolo/fastapi/pull/10820) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Add German translation for `docs/de/docs/reference/templating.md`. PR [#10842](https://github.com/tiangolo/fastapi/pull/10842) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Add German translation for `docs/de/docs/external-links.md`. PR [#10852](https://github.com/tiangolo/fastapi/pull/10852) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Update Turkish translation for `docs/tr/docs/tutorial/query-params.md`. PR [#11162](https://github.com/tiangolo/fastapi/pull/11162) by [@hasansezertasan](https://github.com/hasansezertasan).
  * ğŸŒ� Add German translation for `docs/de/docs/reference/encoders.md`. PR [#10840](https://github.com/tiangolo/fastapi/pull/10840) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Add German translation for `docs/de/docs/reference/responses.md`. PR [#10825](https://github.com/tiangolo/fastapi/pull/10825) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Add German translation for `docs/de/docs/reference/request.md`. PR [#10821](https://github.com/tiangolo/fastapi/pull/10821) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Add Turkish translation for `docs/tr/docs/tutorial/query-params.md`. PR [#11078](https://github.com/tiangolo/fastapi/pull/11078) by [@emrhnsyts](https://github.com/emrhnsyts).
  * ğŸŒ� Add German translation for `docs/de/docs/reference/fastapi.md`. PR [#10813](https://github.com/tiangolo/fastapi/pull/10813) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Add German translation for `docs/de/docs/newsletter.md`. PR [#10853](https://github.com/tiangolo/fastapi/pull/10853) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Add Traditional Chinese translation for `docs/zh-hant/docs/learn/index.md`. PR [#11142](https://github.com/tiangolo/fastapi/pull/11142) by [@hsuanchi](https://github.com/hsuanchi).
  * ğŸŒ� Add Korean translation for `/docs/ko/docs/tutorial/dependencies/global-dependencies.md`. PR [#11123](https://github.com/tiangolo/fastapi/pull/11123) by [@riroan](https://github.com/riroan).
  * ğŸŒ� Add Korean translation for `/docs/ko/docs/tutorial/dependencies/dependencies-in-path-operation-decorators.md`. PR [#11124](https://github.com/tiangolo/fastapi/pull/11124) by [@riroan](https://github.com/riroan).
  * ğŸŒ� Add Korean translation for `/docs/ko/docs/tutorial/schema-extra-example.md`. PR [#11121](https://github.com/tiangolo/fastapi/pull/11121) by [@KaniKim](https://github.com/KaniKim).
  * ğŸŒ� Add Korean translation for `/docs/ko/docs/tutorial/body-fields.md`. PR [#11112](https://github.com/tiangolo/fastapi/pull/11112) by [@KaniKim](https://github.com/KaniKim).
  * ğŸŒ� Add Korean translation for `/docs/ko/docs/tutorial/cookie-params.md`. PR [#11118](https://github.com/tiangolo/fastapi/pull/11118) by [@riroan](https://github.com/riroan).
  * ğŸŒ� Update Korean translation for `/docs/ko/docs/dependencies/index.md`. PR [#11114](https://github.com/tiangolo/fastapi/pull/11114) by [@KaniKim](https://github.com/KaniKim).
  * ğŸŒ� Update Korean translation for `/docs/ko/docs/deployment/docker.md`. PR [#11113](https://github.com/tiangolo/fastapi/pull/11113) by [@KaniKim](https://github.com/KaniKim).
  * ğŸŒ� Update Turkish translation for `docs/tr/docs/tutorial/first-steps.md`. PR [#11094](https://github.com/tiangolo/fastapi/pull/11094) by [@hasansezertasan](https://github.com/hasansezertasan).
  * ğŸŒ� Add Spanish translation for `docs/es/docs/advanced/security/index.md`. PR [#2278](https://github.com/tiangolo/fastapi/pull/2278) by [@Xaraxx](https://github.com/Xaraxx).
  * ğŸŒ� Add Spanish translation for `docs/es/docs/advanced/response-headers.md`. PR [#2276](https://github.com/tiangolo/fastapi/pull/2276) by [@Xaraxx](https://github.com/Xaraxx).
  * ğŸŒ� Add Spanish translation for `docs/es/docs/deployment/index.md` and `~/deployment/versions.md`. PR [#9669](https://github.com/tiangolo/fastapi/pull/9669) by [@pabloperezmoya](https://github.com/pabloperezmoya).
  * ğŸŒ� Add Spanish translation for `docs/es/docs/benchmarks.md`. PR [#10928](https://github.com/tiangolo/fastapi/pull/10928) by [@pablocm83](https://github.com/pablocm83).
  * ğŸŒ� Add Spanish translation for `docs/es/docs/advanced/response-change-status-code.md`. PR [#11100](https://github.com/tiangolo/fastapi/pull/11100) by [@alejsdev](https://github.com/alejsdev).

## 0.109.2[¶](#01092 "Permanent link")

### Upgrades[¶](#upgrades_15 "Permanent link")

  * â¬†ï¸� Upgrade version of Starlette to `>= 0.36.3`. PR [#11086](https://github.com/tiangolo/fastapi/pull/11086) by [@tiangolo](https://github.com/tiangolo).

### Translations[¶](#translations_40 "Permanent link")

  * ğŸŒ� Update Turkish translation for `docs/tr/docs/fastapi-people.md`. PR [#10547](https://github.com/tiangolo/fastapi/pull/10547) by [@alperiox](https://github.com/alperiox).

### Internal[¶](#internal_52 "Permanent link")

  * ğŸ�± Add new FastAPI logo. PR [#11090](https://github.com/tiangolo/fastapi/pull/11090) by [@tiangolo](https://github.com/tiangolo).

## 0.109.1[¶](#01091 "Permanent link")

### Security fixes[¶](#security-fixes "Permanent link")

  * â¬†ï¸� Upgrade minimum version of `python-multipart` to `>=0.0.7` to fix a vulnerability when using form data with a ReDos attack. You can also simply upgrade `python-multipart`.

Read more in the [advisory: Content-Type Header ReDoS](https://github.com/tiangolo/fastapi/security/advisories/GHSA-qf9m-vfgh-m389).

### Features[¶](#features_12 "Permanent link")

  * âœ¨ Include HTTP 205 in status codes with no body. PR [#10969](https://github.com/tiangolo/fastapi/pull/10969) by [@tiangolo](https://github.com/tiangolo).

### Refactors[¶](#refactors_23 "Permanent link")

  * âœ… Refactor tests for duplicate operation ID generation for compatibility with other tools running the FastAPI test suite. PR [#10876](https://github.com/tiangolo/fastapi/pull/10876) by [@emmettbutler](https://github.com/emmettbutler).
  * â™»ï¸� Simplify string format with f-strings in `fastapi/utils.py`. PR [#10576](https://github.com/tiangolo/fastapi/pull/10576) by [@eukub](https://github.com/eukub).
  * ğŸ”§ Fix Ruff configuration unintentionally enabling and re-disabling mccabe complexity check. PR [#10893](https://github.com/tiangolo/fastapi/pull/10893) by [@jiridanek](https://github.com/jiridanek).
  * âœ… Re-enable test in `tests/test_tutorial/test_header_params/test_tutorial003.py` after fix in Starlette. PR [#10904](https://github.com/tiangolo/fastapi/pull/10904) by [@ooknimm](https://github.com/ooknimm).

### Docs[¶](#docs_42 "Permanent link")

  * ğŸ“� Tweak wording in `help-fastapi.md`. PR [#11040](https://github.com/tiangolo/fastapi/pull/11040) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ“� Tweak docs for Behind a Proxy. PR [#11038](https://github.com/tiangolo/fastapi/pull/11038) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ“� Add External Link: 10 Tips for adding SQLAlchemy to FastAPI. PR [#11036](https://github.com/tiangolo/fastapi/pull/11036) by [@Donnype](https://github.com/Donnype).
  * ğŸ“� Add External Link: Tips on migrating from Flask to FastAPI and vice-versa. PR [#11029](https://github.com/tiangolo/fastapi/pull/11029) by [@jtemporal](https://github.com/jtemporal).
  * ğŸ“� Deprecate old tutorials: Peewee, Couchbase, encode/databases. PR [#10979](https://github.com/tiangolo/fastapi/pull/10979) by [@tiangolo](https://github.com/tiangolo).
  * âœ�ï¸� Fix typo in `fastapi/security/oauth2.py`. PR [#10972](https://github.com/tiangolo/fastapi/pull/10972) by [@RafalSkolasinski](https://github.com/RafalSkolasinski).
  * ğŸ“� Update `HTTPException` details in `docs/en/docs/tutorial/handling-errors.md`. PR [#5418](https://github.com/tiangolo/fastapi/pull/5418) by [@papb](https://github.com/papb).
  * âœ�ï¸� A few tweaks in `docs/de/docs/tutorial/first-steps.md`. PR [#10959](https://github.com/tiangolo/fastapi/pull/10959) by [@nilslindemann](https://github.com/nilslindemann).
  * âœ�ï¸� Fix link in `docs/en/docs/advanced/async-tests.md`. PR [#10960](https://github.com/tiangolo/fastapi/pull/10960) by [@nilslindemann](https://github.com/nilslindemann).
  * âœ�ï¸� Fix typos for Spanish documentation. PR [#10957](https://github.com/tiangolo/fastapi/pull/10957) by [@jlopezlira](https://github.com/jlopezlira).
  * ğŸ“� Add warning about lifespan functions and backwards compatibility with events. PR [#10734](https://github.com/tiangolo/fastapi/pull/10734) by [@jacob-indigo](https://github.com/jacob-indigo).
  * âœ�ï¸� Fix broken link in `docs/tutorial/sql-databases.md` in several languages. PR [#10716](https://github.com/tiangolo/fastapi/pull/10716) by [@theoohoho](https://github.com/theoohoho).
  * âœ�ï¸� Remove broken links from `external_links.yml`. PR [#10943](https://github.com/tiangolo/fastapi/pull/10943) by [@Torabek](https://github.com/Torabek).
  * ğŸ“� Update template docs with more info about `url_for`. PR [#5937](https://github.com/tiangolo/fastapi/pull/5937) by [@EzzEddin](https://github.com/EzzEddin).
  * ğŸ“� Update usage of Token model in security docs. PR [#9313](https://github.com/tiangolo/fastapi/pull/9313) by [@piotrszacilowski](https://github.com/piotrszacilowski).
  * âœ�ï¸� Update highlighted line in `docs/en/docs/tutorial/bigger-applications.md`. PR [#5490](https://github.com/tiangolo/fastapi/pull/5490) by [@papb](https://github.com/papb).
  * ğŸ“� Add External Link: Explore How to Effectively Use JWT With FastAPI. PR [#10212](https://github.com/tiangolo/fastapi/pull/10212) by [@aanchlia](https://github.com/aanchlia).
  * ğŸ“� Add hyperlink to `docs/en/docs/tutorial/static-files.md`. PR [#10243](https://github.com/tiangolo/fastapi/pull/10243) by [@hungtsetse](https://github.com/hungtsetse).
  * ğŸ“� Add External Link: Instrument a FastAPI service adding tracing with OpenTelemetry and send/show traces in Grafana Tempo. PR [#9440](https://github.com/tiangolo/fastapi/pull/9440) by [@softwarebloat](https://github.com/softwarebloat).
  * ğŸ“� Review and rewording of `en/docs/contributing.md`. PR [#10480](https://github.com/tiangolo/fastapi/pull/10480) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸ“� Add External Link: ML serving and monitoring with FastAPI and Evidently. PR [#9701](https://github.com/tiangolo/fastapi/pull/9701) by [@mnrozhkov](https://github.com/mnrozhkov).
  * ğŸ“� Reword in docs, from "have in mind" to "keep in mind". PR [#10376](https://github.com/tiangolo/fastapi/pull/10376) by [@malicious](https://github.com/malicious).
  * ğŸ“� Add External Link: Talk by Jeny Sadadia. PR [#10265](https://github.com/tiangolo/fastapi/pull/10265) by [@JenySadadia](https://github.com/JenySadadia).
  * ğŸ“� Add location info to `tutorial/bigger-applications.md`. PR [#10552](https://github.com/tiangolo/fastapi/pull/10552) by [@nilslindemann](https://github.com/nilslindemann).
  * âœ�ï¸� Fix Pydantic method name in `docs/en/docs/advanced/path-operation-advanced-configuration.md`. PR [#10826](https://github.com/tiangolo/fastapi/pull/10826) by [@ahmedabdou14](https://github.com/ahmedabdou14).

### Translations[¶](#translations_41 "Permanent link")

  * ğŸŒ� Add Spanish translation for `docs/es/docs/external-links.md`. PR [#10933](https://github.com/tiangolo/fastapi/pull/10933) by [@pablocm83](https://github.com/pablocm83).
  * ğŸŒ� Update Korean translation for `docs/ko/docs/tutorial/first-steps.md`, `docs/ko/docs/tutorial/index.md`, `docs/ko/docs/tutorial/path-params.md`, and `docs/ko/docs/tutorial/query-params.md`. PR [#4218](https://github.com/tiangolo/fastapi/pull/4218) by [@SnowSuno](https://github.com/SnowSuno).
  * ğŸŒ� Add Chinese translation for `docs/zh/docs/tutorial/dependencies/dependencies-with-yield.md`. PR [#10870](https://github.com/tiangolo/fastapi/pull/10870) by [@zhiquanchi](https://github.com/zhiquanchi).
  * ğŸŒ� Add Chinese translation for `docs/zh/docs/deployment/concepts.md`. PR [#10282](https://github.com/tiangolo/fastapi/pull/10282) by [@xzmeng](https://github.com/xzmeng).
  * ğŸŒ� Add Azerbaijani translation for `docs/az/docs/index.md`. PR [#11047](https://github.com/tiangolo/fastapi/pull/11047) by [@aykhans](https://github.com/aykhans).
  * ğŸŒ� Add Korean translation for `docs/ko/docs/tutorial/middleware.md`. PR [#2829](https://github.com/tiangolo/fastapi/pull/2829) by [@JeongHyeongKim](https://github.com/JeongHyeongKim).
  * ğŸŒ� Add German translation for `docs/de/docs/tutorial/body-nested-models.md`. PR [#10313](https://github.com/tiangolo/fastapi/pull/10313) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Add Persian translation for `docs/fa/docs/tutorial/middleware.md`. PR [#9695](https://github.com/tiangolo/fastapi/pull/9695) by [@mojtabapaso](https://github.com/mojtabapaso).
  * ğŸŒ� Update Farsi translation for `docs/fa/docs/index.md`. PR [#10216](https://github.com/tiangolo/fastapi/pull/10216) by [@theonlykingpin](https://github.com/theonlykingpin).
  * ğŸŒ� Add German translation for `docs/de/docs/tutorial/body-fields.md`. PR [#10310](https://github.com/tiangolo/fastapi/pull/10310) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Add German translation for `docs/de/docs/tutorial/body.md`. PR [#10295](https://github.com/tiangolo/fastapi/pull/10295) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Add German translation for `docs/de/docs/tutorial/body-multiple-params.md`. PR [#10308](https://github.com/tiangolo/fastapi/pull/10308) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Add Japanese translation for `docs/ja/docs/tutorial/security/get-current-user.md`. PR [#2681](https://github.com/tiangolo/fastapi/pull/2681) by [@sh0nk](https://github.com/sh0nk).
  * ğŸŒ� Add Chinese translation for `docs/zh/docs/advanced/advanced-dependencies.md`. PR [#3798](https://github.com/tiangolo/fastapi/pull/3798) by [@jaystone776](https://github.com/jaystone776).
  * ğŸŒ� Add Chinese translation for `docs/zh/docs/advanced/events.md`. PR [#3815](https://github.com/tiangolo/fastapi/pull/3815) by [@jaystone776](https://github.com/jaystone776).
  * ğŸŒ� Add Chinese translation for `docs/zh/docs/advanced/behind-a-proxy.md`. PR [#3820](https://github.com/tiangolo/fastapi/pull/3820) by [@jaystone776](https://github.com/jaystone776).
  * ğŸŒ� Add Chinese translation for `docs/zh/docs/advanced/testing-events.md`. PR [#3818](https://github.com/tiangolo/fastapi/pull/3818) by [@jaystone776](https://github.com/jaystone776).
  * ğŸŒ� Add Chinese translation for `docs/zh/docs/advanced/testing-websockets.md`. PR [#3817](https://github.com/tiangolo/fastapi/pull/3817) by [@jaystone776](https://github.com/jaystone776).
  * ğŸŒ� Add Chinese translation for `docs/zh/docs/advanced/testing-database.md`. PR [#3821](https://github.com/tiangolo/fastapi/pull/3821) by [@jaystone776](https://github.com/jaystone776).
  * ğŸŒ� Add Chinese translation for `docs/zh/docs/deployment/deta.md`. PR [#3837](https://github.com/tiangolo/fastapi/pull/3837) by [@jaystone776](https://github.com/jaystone776).
  * ğŸŒ� Add Chinese translation for `docs/zh/docs/history-design-future.md`. PR [#3832](https://github.com/tiangolo/fastapi/pull/3832) by [@jaystone776](https://github.com/jaystone776).
  * ğŸŒ� Add Chinese translation for `docs/zh/docs/project-generation.md`. PR [#3831](https://github.com/tiangolo/fastapi/pull/3831) by [@jaystone776](https://github.com/jaystone776).
  * ğŸŒ� Add Chinese translation for `docs/zh/docs/deployment/docker.md`. PR [#10296](https://github.com/tiangolo/fastapi/pull/10296) by [@xzmeng](https://github.com/xzmeng).
  * ğŸŒ� Update Spanish translation for `docs/es/docs/features.md`. PR [#10884](https://github.com/tiangolo/fastapi/pull/10884) by [@pablocm83](https://github.com/pablocm83).
  * ğŸŒ� Add Spanish translation for `docs/es/docs/newsletter.md`. PR [#10922](https://github.com/tiangolo/fastapi/pull/10922) by [@pablocm83](https://github.com/pablocm83).
  * ğŸŒ� Add Korean translation for `docs/ko/docs/tutorial/background-tasks.md`. PR [#5910](https://github.com/tiangolo/fastapi/pull/5910) by [@junah201](https://github.com/junah201).
  * :globe_with_meridians: Add Turkish translation for `docs/tr/docs/alternatives.md`. PR [#10502](https://github.com/tiangolo/fastapi/pull/10502) by [@alperiox](https://github.com/alperiox).
  * ğŸŒ� Add Korean translation for `docs/ko/docs/tutorial/dependencies/index.md`. PR [#10989](https://github.com/tiangolo/fastapi/pull/10989) by [@KaniKim](https://github.com/KaniKim).
  * ğŸŒ� Add Korean translation for `/docs/ko/docs/tutorial/body.md`. PR [#11000](https://github.com/tiangolo/fastapi/pull/11000) by [@KaniKim](https://github.com/KaniKim).
  * ğŸŒ� Add Portuguese translation for `docs/pt/docs/tutorial/schema-extra-example.md`. PR [#4065](https://github.com/tiangolo/fastapi/pull/4065) by [@luccasmmg](https://github.com/luccasmmg).
  * ğŸŒ� Add Turkish translation for `docs/tr/docs/history-design-future.md`. PR [#11012](https://github.com/tiangolo/fastapi/pull/11012) by [@hasansezertasan](https://github.com/hasansezertasan).
  * ğŸŒ� Add Turkish translation for `docs/tr/docs/resources/index.md`. PR [#11020](https://github.com/tiangolo/fastapi/pull/11020) by [@hasansezertasan](https://github.com/hasansezertasan).
  * ğŸŒ� Add Turkish translation for `docs/tr/docs/how-to/index.md`. PR [#11021](https://github.com/tiangolo/fastapi/pull/11021) by [@hasansezertasan](https://github.com/hasansezertasan).
  * ğŸŒ� Add German translation for `docs/de/docs/tutorial/query-params.md`. PR [#10293](https://github.com/tiangolo/fastapi/pull/10293) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Add German translation for `docs/de/docs/benchmarks.md`. PR [#10866](https://github.com/tiangolo/fastapi/pull/10866) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Add Turkish translation for `docs/tr/docs/learn/index.md`. PR [#11014](https://github.com/tiangolo/fastapi/pull/11014) by [@hasansezertasan](https://github.com/hasansezertasan).
  * ğŸŒ� Add Persian translation for `docs/fa/docs/tutorial/security/index.md`. PR [#9945](https://github.com/tiangolo/fastapi/pull/9945) by [@mojtabapaso](https://github.com/mojtabapaso).
  * ğŸŒ� Add Turkish translation for `docs/tr/docs/help/index.md`. PR [#11013](https://github.com/tiangolo/fastapi/pull/11013) by [@hasansezertasan](https://github.com/hasansezertasan).
  * ğŸŒ� Add Turkish translation for `docs/tr/docs/about/index.md`. PR [#11006](https://github.com/tiangolo/fastapi/pull/11006) by [@hasansezertasan](https://github.com/hasansezertasan).
  * ğŸŒ� Update Turkish translation for `docs/tr/docs/benchmarks.md`. PR [#11005](https://github.com/tiangolo/fastapi/pull/11005) by [@hasansezertasan](https://github.com/hasansezertasan).
  * ğŸŒ� Add Italian translation for `docs/it/docs/index.md`. PR [#5233](https://github.com/tiangolo/fastapi/pull/5233) by [@matteospanio](https://github.com/matteospanio).
  * ğŸŒ� Add Korean translation for `docs/ko/docs/help/index.md`. PR [#10983](https://github.com/tiangolo/fastapi/pull/10983) by [@KaniKim](https://github.com/KaniKim).
  * ğŸŒ� Add Korean translation for `docs/ko/docs/features.md`. PR [#10976](https://github.com/tiangolo/fastapi/pull/10976) by [@KaniKim](https://github.com/KaniKim).
  * ğŸŒ� Add Korean translation for `docs/ko/docs/tutorial/security/get-current-user.md`. PR [#5737](https://github.com/tiangolo/fastapi/pull/5737) by [@KdHyeon0661](https://github.com/KdHyeon0661).
  * ğŸŒ� Add Russian translation for `docs/ru/docs/tutorial/security/first-steps.md`. PR [#10541](https://github.com/tiangolo/fastapi/pull/10541) by [@AlertRED](https://github.com/AlertRED).
  * ğŸŒ� Add Russian translation for `docs/ru/docs/tutorial/handling-errors.md`. PR [#10375](https://github.com/tiangolo/fastapi/pull/10375) by [@AlertRED](https://github.com/AlertRED).
  * ğŸŒ� Add Russian translation for `docs/ru/docs/tutorial/encoder.md`. PR [#10374](https://github.com/tiangolo/fastapi/pull/10374) by [@AlertRED](https://github.com/AlertRED).
  * ğŸŒ� Add Russian translation for `docs/ru/docs/tutorial/body-updates.md`. PR [#10373](https://github.com/tiangolo/fastapi/pull/10373) by [@AlertRED](https://github.com/AlertRED).
  * ğŸŒ� Russian translation: updated `fastapi-people.md`.. PR [#10255](https://github.com/tiangolo/fastapi/pull/10255) by [@NiKuma0](https://github.com/NiKuma0).
  * ğŸŒ� Add Japanese translation for `docs/ja/docs/tutorial/security/index.md`. PR [#5798](https://github.com/tiangolo/fastapi/pull/5798) by [@3w36zj6](https://github.com/3w36zj6).
  * ğŸŒ� Add German translation for `docs/de/docs/advanced/generate-clients.md`. PR [#10725](https://github.com/tiangolo/fastapi/pull/10725) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Add German translation for `docs/de/docs/advanced/openapi-webhooks.md`. PR [#10712](https://github.com/tiangolo/fastapi/pull/10712) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Add German translation for `docs/de/docs/advanced/custom-response.md`. PR [#10624](https://github.com/tiangolo/fastapi/pull/10624) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Add German translation for `docs/de/docs/advanced/additional-status-codes.md`. PR [#10617](https://github.com/tiangolo/fastapi/pull/10617) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Add German translation for `docs/de/docs/tutorial/middleware.md`. PR [#10391](https://github.com/tiangolo/fastapi/pull/10391) by [@JohannesJungbluth](https://github.com/JohannesJungbluth).
  * ğŸŒ� Add German translation for introduction documents. PR [#10497](https://github.com/tiangolo/fastapi/pull/10497) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸŒ� Add Japanese translation for `docs/ja/docs/tutorial/encoder.md`. PR [#1955](https://github.com/tiangolo/fastapi/pull/1955) by [@SwftAlpc](https://github.com/SwftAlpc).
  * ğŸŒ� Add Japanese translation for `docs/ja/docs/tutorial/extra-data-types.md`. PR [#1932](https://github.com/tiangolo/fastapi/pull/1932) by [@SwftAlpc](https://github.com/SwftAlpc).
  * ğŸŒ� Add Turkish translation for `docs/tr/docs/async.md`. PR [#5191](https://github.com/tiangolo/fastapi/pull/5191) by [@BilalAlpaslan](https://github.com/BilalAlpaslan).
  * ğŸŒ� Add Turkish translation for `docs/tr/docs/project-generation.md`. PR [#5192](https://github.com/tiangolo/fastapi/pull/5192) by [@BilalAlpaslan](https://github.com/BilalAlpaslan).
  * ğŸŒ� Add Korean translation for `docs/ko/docs/deployment/docker.md`. PR [#5657](https://github.com/tiangolo/fastapi/pull/5657) by [@nearnear](https://github.com/nearnear).
  * ğŸŒ� Add Korean translation for `docs/ko/docs/deployment/server-workers.md`. PR [#4935](https://github.com/tiangolo/fastapi/pull/4935) by [@jujumilk3](https://github.com/jujumilk3).
  * ğŸŒ� Add Korean translation for `docs/ko/docs/deployment/index.md`. PR [#4561](https://github.com/tiangolo/fastapi/pull/4561) by [@jujumilk3](https://github.com/jujumilk3).
  * ğŸŒ� Add Korean translation for `docs/ko/docs/tutorial/path-operation-configuration.md`. PR [#3639](https://github.com/tiangolo/fastapi/pull/3639) by [@jungsu-kwon](https://github.com/jungsu-kwon).
  * ğŸŒ� Modify the description of `zh` \- Traditional Chinese. PR [#10889](https://github.com/tiangolo/fastapi/pull/10889) by [@cherinyy](https://github.com/cherinyy).
  * ğŸŒ� Add Korean translation for `docs/ko/docs/tutorial/static-files.md`. PR [#2957](https://github.com/tiangolo/fastapi/pull/2957) by [@jeesang7](https://github.com/jeesang7).
  * ğŸŒ� Add Korean translation for `docs/ko/docs/tutorial/response-model.md`. PR [#2766](https://github.com/tiangolo/fastapi/pull/2766) by [@hard-coders](https://github.com/hard-coders).
  * ğŸŒ� Add Korean translation for `docs/ko/docs/tutorial/body-multiple-params.md`. PR [#2461](https://github.com/tiangolo/fastapi/pull/2461) by [@PandaHun](https://github.com/PandaHun).
  * ğŸŒ� Add Korean translation for `docs/ko/docs/tutorial/query-params-str-validations.md`. PR [#2415](https://github.com/tiangolo/fastapi/pull/2415) by [@hard-coders](https://github.com/hard-coders).
  * ğŸŒ� Add Korean translation for `docs/ko/docs/python-types.md`. PR [#2267](https://github.com/tiangolo/fastapi/pull/2267) by [@jrim](https://github.com/jrim).
  * ğŸŒ� Add Korean translation for `docs/ko/docs/tutorial/body-nested-models.md`. PR [#2506](https://github.com/tiangolo/fastapi/pull/2506) by [@hard-coders](https://github.com/hard-coders).
  * ğŸŒ� Add Korean translation for `docs/ko/docs/learn/index.md`. PR [#10977](https://github.com/tiangolo/fastapi/pull/10977) by [@KaniKim](https://github.com/KaniKim).
  * ğŸŒ� Initialize translations for Traditional Chinese. PR [#10505](https://github.com/tiangolo/fastapi/pull/10505) by [@hsuanchi](https://github.com/hsuanchi).
  * âœ�ï¸� Tweak the german translation of `docs/de/docs/tutorial/index.md`. PR [#10962](https://github.com/tiangolo/fastapi/pull/10962) by [@nilslindemann](https://github.com/nilslindemann).
  * âœ�ï¸� Fix typo error in `docs/ko/docs/tutorial/path-params.md`. PR [#10758](https://github.com/tiangolo/fastapi/pull/10758) by [@2chanhaeng](https://github.com/2chanhaeng).
  * ğŸŒ� Add Japanese translation for `docs/ja/docs/tutorial/dependencies/dependencies-with-yield.md`. PR [#1961](https://github.com/tiangolo/fastapi/pull/1961) by [@SwftAlpc](https://github.com/SwftAlpc).
  * ğŸŒ� Add Japanese translation for `docs/ja/docs/tutorial/dependencies/dependencies-in-path-operation-decorators.md`. PR [#1960](https://github.com/tiangolo/fastapi/pull/1960) by [@SwftAlpc](https://github.com/SwftAlpc).
  * ğŸŒ� Add Japanese translation for `docs/ja/docs/tutorial/dependencies/sub-dependencies.md`. PR [#1959](https://github.com/tiangolo/fastapi/pull/1959) by [@SwftAlpc](https://github.com/SwftAlpc).
  * ğŸŒ� Add Japanese translation for `docs/ja/docs/tutorial/background-tasks.md`. PR [#2668](https://github.com/tiangolo/fastapi/pull/2668) by [@tokusumi](https://github.com/tokusumi).
  * ğŸŒ� Add Japanese translation for `docs/ja/docs/tutorial/dependencies/index.md` and `docs/ja/docs/tutorial/dependencies/classes-as-dependencies.md`. PR [#1958](https://github.com/tiangolo/fastapi/pull/1958) by [@SwftAlpc](https://github.com/SwftAlpc).
  * ğŸŒ� Add Japanese translation for `docs/ja/docs/tutorial/response-model.md`. PR [#1938](https://github.com/tiangolo/fastapi/pull/1938) by [@SwftAlpc](https://github.com/SwftAlpc).
  * ğŸŒ� Add Japanese translation for `docs/ja/docs/tutorial/body-multiple-params.md`. PR [#1903](https://github.com/tiangolo/fastapi/pull/1903) by [@SwftAlpc](https://github.com/SwftAlpc).
  * ğŸŒ� Add Japanese translation for `docs/ja/docs/tutorial/path-params-numeric-validations.md`. PR [#1902](https://github.com/tiangolo/fastapi/pull/1902) by [@SwftAlpc](https://github.com/SwftAlpc).
  * ğŸŒ� Add Japanese translation for `docs/ja/docs/python-types.md`. PR [#1899](https://github.com/tiangolo/fastapi/pull/1899) by [@SwftAlpc](https://github.com/SwftAlpc).
  * ğŸŒ� Add Japanese translation for `docs/ja/docs/tutorial/handling-errors.md`. PR [#1953](https://github.com/tiangolo/fastapi/pull/1953) by [@SwftAlpc](https://github.com/SwftAlpc).
  * ğŸŒ� Add Japanese translation for `docs/ja/docs/tutorial/response-status-code.md`. PR [#1942](https://github.com/tiangolo/fastapi/pull/1942) by [@SwftAlpc](https://github.com/SwftAlpc).
  * ğŸŒ� Add Japanese translation for `docs/ja/docs/tutorial/extra-models.md`. PR [#1941](https://github.com/tiangolo/fastapi/pull/1941) by [@SwftAlpc](https://github.com/SwftAlpc).
  * ğŸŒ� Add Japanese translation for `docs/ja/docs/tutorial/schema-extra-example.md`. PR [#1931](https://github.com/tiangolo/fastapi/pull/1931) by [@SwftAlpc](https://github.com/SwftAlpc).
  * ğŸŒ� Add Japanese translation for `docs/ja/docs/tutorial/body-nested-models.md`. PR [#1930](https://github.com/tiangolo/fastapi/pull/1930) by [@SwftAlpc](https://github.com/SwftAlpc).
  * ğŸŒ� Add Japanese translation for `docs/ja/docs/tutorial/body-fields.md`. PR [#1923](https://github.com/tiangolo/fastapi/pull/1923) by [@SwftAlpc](https://github.com/SwftAlpc).
  * ğŸŒ� Add German translation for `docs/de/docs/tutorial/index.md`. PR [#9502](https://github.com/tiangolo/fastapi/pull/9502) by [@fhabers21](https://github.com/fhabers21).
  * ğŸŒ� Add German translation for `docs/de/docs/tutorial/background-tasks.md`. PR [#10566](https://github.com/tiangolo/fastapi/pull/10566) by [@nilslindemann](https://github.com/nilslindemann).
  * âœ�ï¸� Fix typo in `docs/ru/docs/index.md`. PR [#10672](https://github.com/tiangolo/fastapi/pull/10672) by [@Delitel-WEB](https://github.com/Delitel-WEB).
  * âœ�ï¸� Fix typos in `docs/zh/docs/tutorial/extra-data-types.md`. PR [#10727](https://github.com/tiangolo/fastapi/pull/10727) by [@HiemalBeryl](https://github.com/HiemalBeryl).
  * ğŸŒ� Add Russian translation for `docs/ru/docs/tutorial/dependencies/classes-as-dependencies.md`. PR [#10410](https://github.com/tiangolo/fastapi/pull/10410) by [@AlertRED](https://github.com/AlertRED).

### Internal[¶](#internal_53 "Permanent link")

  * ğŸ‘¥ Update FastAPI People. PR [#11074](https://github.com/tiangolo/fastapi/pull/11074) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”§ Update sponsors: add Coherence. PR [#11066](https://github.com/tiangolo/fastapi/pull/11066) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘· Upgrade GitHub Action issue-manager. PR [#11056](https://github.com/tiangolo/fastapi/pull/11056) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ�± Update sponsors: TalkPython badge. PR [#11052](https://github.com/tiangolo/fastapi/pull/11052) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”§ Update sponsors: TalkPython badge image. PR [#11048](https://github.com/tiangolo/fastapi/pull/11048) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”§ Update sponsors, remove Deta. PR [#11041](https://github.com/tiangolo/fastapi/pull/11041) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ’„ Fix CSS breaking RTL languages (erroneously introduced by a previous RTL PR). PR [#11039](https://github.com/tiangolo/fastapi/pull/11039) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”§ Add Italian to `mkdocs.yml`. PR [#11016](https://github.com/tiangolo/fastapi/pull/11016) by [@alejsdev](https://github.com/alejsdev).
  * ğŸ”¨ Verify `mkdocs.yml` languages in CI, update `docs.py`. PR [#11009](https://github.com/tiangolo/fastapi/pull/11009) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”§ Update config in `label-approved.yml` to accept translations with 1 reviewer. PR [#11007](https://github.com/tiangolo/fastapi/pull/11007) by [@alejsdev](https://github.com/alejsdev).
  * ğŸ‘· Add changes-requested handling in GitHub Action issue manager. PR [#10971](https://github.com/tiangolo/fastapi/pull/10971) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”§ Group dependencies on dependabot updates. PR [#10952](https://github.com/tiangolo/fastapi/pull/10952) by [@Kludex](https://github.com/Kludex).
  * â¬† Bump actions/setup-python from 4 to 5. PR [#10764](https://github.com/tiangolo/fastapi/pull/10764) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * â¬† Bump pypa/gh-action-pypi-publish from 1.8.10 to 1.8.11. PR [#10731](https://github.com/tiangolo/fastapi/pull/10731) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * â¬† Bump dawidd6/action-download-artifact from 2.28.0 to 3.0.0. PR [#10777](https://github.com/tiangolo/fastapi/pull/10777) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * ğŸ”§ Add support for translations to languages with a longer code name, like `zh-hant`. PR [#10950](https://github.com/tiangolo/fastapi/pull/10950) by [@tiangolo](https://github.com/tiangolo).

## 0.109.0[¶](#01090 "Permanent link")

### Features[¶](#features_13 "Permanent link")

  * âœ¨ Add support for Python 3.12. PR [#10666](https://github.com/tiangolo/fastapi/pull/10666) by [@Jamim](https://github.com/Jamim).

### Upgrades[¶](#upgrades_16 "Permanent link")

  * â¬†ï¸� Upgrade Starlette to >=0.35.0,<0.36.0. PR [#10938](https://github.com/tiangolo/fastapi/pull/10938) by [@tiangolo](https://github.com/tiangolo).

### Docs[¶](#docs_43 "Permanent link")

  * âœ�ï¸� Fix typo in `docs/en/docs/alternatives.md`. PR [#10931](https://github.com/tiangolo/fastapi/pull/10931) by [@s111d](https://github.com/s111d).
  * ğŸ“� Replace `email` with `username` in `docs_src/security/tutorial007` code examples. PR [#10649](https://github.com/tiangolo/fastapi/pull/10649) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸ“� Add VS Code tutorial link. PR [#10592](https://github.com/tiangolo/fastapi/pull/10592) by [@nilslindemann](https://github.com/nilslindemann).
  * ğŸ“� Add notes about Pydantic v2's new `.model_dump()`. PR [#10929](https://github.com/tiangolo/fastapi/pull/10929) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ“� Fix broken link in `docs/en/docs/tutorial/sql-databases.md`. PR [#10765](https://github.com/tiangolo/fastapi/pull/10765) by [@HurSungYun](https://github.com/HurSungYun).
  * ğŸ“� Add External Link: FastAPI application monitoring made easy. PR [#10917](https://github.com/tiangolo/fastapi/pull/10917) by [@tiangolo](https://github.com/tiangolo).
  * âœ¨ Generate automatic language names for docs translations. PR [#5354](https://github.com/tiangolo/fastapi/pull/5354) by [@jakul](https://github.com/jakul).
  * âœ�ï¸� Fix typos in `docs/en/docs/alternatives.md` and `docs/en/docs/tutorial/dependencies/index.md`. PR [#10906](https://github.com/tiangolo/fastapi/pull/10906) by [@s111d](https://github.com/s111d).
  * âœ�ï¸� Fix typos in `docs/en/docs/tutorial/dependencies/dependencies-with-yield.md`. PR [#10834](https://github.com/tiangolo/fastapi/pull/10834) by [@Molkree](https://github.com/Molkree).
  * ğŸ“� Add article: "Building a RESTful API with FastAPI: Secure Signup and Login Functionality Included". PR [#9733](https://github.com/tiangolo/fastapi/pull/9733) by [@dxphilo](https://github.com/dxphilo).
  * ğŸ“� Add warning about lifecycle events with `AsyncClient`. PR [#4167](https://github.com/tiangolo/fastapi/pull/4167) by [@andrew-chang-dewitt](https://github.com/andrew-chang-dewitt).
  * âœ�ï¸� Fix typos in `/docs/reference/exceptions.md` and `/en/docs/reference/status.md`. PR [#10809](https://github.com/tiangolo/fastapi/pull/10809) by [@clarencepenz](https://github.com/clarencepenz).
  * âœ�ï¸� Fix typo in `openapi-callbacks.md`. PR [#10673](https://github.com/tiangolo/fastapi/pull/10673) by [@kayjan](https://github.com/kayjan).
  * âœ�ï¸� Fix typo in `fastapi/routing.py` . PR [#10520](https://github.com/tiangolo/fastapi/pull/10520) by [@sepsh](https://github.com/sepsh).
  * ğŸ“� Replace HTTP code returned in case of existing user error in docs for testing. PR [#4482](https://github.com/tiangolo/fastapi/pull/4482) by [@TristanMarion](https://github.com/TristanMarion).
  * ğŸ“� Add blog for FastAPI & Supabase. PR [#6018](https://github.com/tiangolo/fastapi/pull/6018) by [@theinfosecguy](https://github.com/theinfosecguy).
  * ğŸ“� Update example source files for SQL databases with SQLAlchemy. PR [#9508](https://github.com/tiangolo/fastapi/pull/9508) by [@s-mustafa](https://github.com/s-mustafa).
  * ğŸ“� Update code examples in docs for body, replace name `create_item` with `update_item` when appropriate. PR [#5913](https://github.com/tiangolo/fastapi/pull/5913) by [@OttoAndrey](https://github.com/OttoAndrey).
  * âœ�ï¸� Fix typo in dependencies with yield source examples. PR [#10847](https://github.com/tiangolo/fastapi/pull/10847) by [@tiangolo](https://github.com/tiangolo).

### Translations[¶](#translations_42 "Permanent link")

  * ğŸŒ� Add Bengali translation for `docs/bn/docs/index.md`. PR [#9177](https://github.com/tiangolo/fastapi/pull/9177) by [@Fahad-Md-Kamal](https://github.com/Fahad-Md-Kamal).
  * âœ�ï¸� Update Python version in `index.md` in several languages. PR [#10711](https://github.com/tiangolo/fastapi/pull/10711) by [@tamago3keran](https://github.com/tamago3keran).
  * ğŸŒ� Add Russian translation for `docs/ru/docs/tutorial/request-forms-and-files.md`. PR [#10347](https://github.com/tiangolo/fastapi/pull/10347) by [@AlertRED](https://github.com/AlertRED).
  * ğŸŒ� Add Ukrainian translation for `docs/uk/docs/index.md`. PR [#10362](https://github.com/tiangolo/fastapi/pull/10362) by [@rostik1410](https://github.com/rostik1410).
  * âœ�ï¸� Update Python version in `docs/ko/docs/index.md`. PR [#10680](https://github.com/tiangolo/fastapi/pull/10680) by [@Eeap](https://github.com/Eeap).
  * ğŸŒ� Add Persian translation for `docs/fa/docs/features.md`. PR [#5887](https://github.com/tiangolo/fastapi/pull/5887) by [@amirilf](https://github.com/amirilf).
  * ğŸŒ� Add Chinese translation for `docs/zh/docs/advanced/additional-responses.md`. PR [#10325](https://github.com/tiangolo/fastapi/pull/10325) by [@ShuibeiC](https://github.com/ShuibeiC).
  * ğŸŒ� Fix typos in Russian translations for `docs/ru/docs/tutorial/background-tasks.md`, `docs/ru/docs/tutorial/body-nested-models.md`, `docs/ru/docs/tutorial/debugging.md`, `docs/ru/docs/tutorial/testing.md`. PR [#10311](https://github.com/tiangolo/fastapi/pull/10311) by [@AlertRED](https://github.com/AlertRED).
  * ğŸŒ� Add Russian translation for `docs/ru/docs/tutorial/request-files.md`. PR [#10332](https://github.com/tiangolo/fastapi/pull/10332) by [@AlertRED](https://github.com/AlertRED).
  * ğŸŒ� Add Chinese translation for `docs/zh/docs/deployment/server-workers.md`. PR [#10292](https://github.com/tiangolo/fastapi/pull/10292) by [@xzmeng](https://github.com/xzmeng).
  * ğŸŒ� Add Chinese translation for `docs/zh/docs/deployment/cloud.md`. PR [#10291](https://github.com/tiangolo/fastapi/pull/10291) by [@xzmeng](https://github.com/xzmeng).
  * ğŸŒ� Add Chinese translation for `docs/zh/docs/deployment/manually.md`. PR [#10279](https://github.com/tiangolo/fastapi/pull/10279) by [@xzmeng](https://github.com/xzmeng).
  * ğŸŒ� Add Chinese translation for `docs/zh/docs/deployment/https.md`. PR [#10277](https://github.com/tiangolo/fastapi/pull/10277) by [@xzmeng](https://github.com/xzmeng).
  * ğŸŒ� Add Chinese translation for `docs/zh/docs/deployment/index.md`. PR [#10275](https://github.com/tiangolo/fastapi/pull/10275) by [@xzmeng](https://github.com/xzmeng).
  * ğŸŒ� Add German translation for `docs/de/docs/tutorial/first-steps.md`. PR [#9530](https://github.com/tiangolo/fastapi/pull/9530) by [@fhabers21](https://github.com/fhabers21).
  * ğŸŒ� Update Turkish translation for `docs/tr/docs/index.md`. PR [#10444](https://github.com/tiangolo/fastapi/pull/10444) by [@hasansezertasan](https://github.com/hasansezertasan).
  * ğŸŒ� Add Chinese translation for `docs/zh/docs/learn/index.md`. PR [#10479](https://github.com/tiangolo/fastapi/pull/10479) by [@KAZAMA-DREAM](https://github.com/KAZAMA-DREAM).
  * ğŸŒ� Add Russian translation for `docs/ru/docs/learn/index.md`. PR [#10539](https://github.com/tiangolo/fastapi/pull/10539) by [@AlertRED](https://github.com/AlertRED).
  * ğŸŒ� Update SQLAlchemy instruction in Chinese translation `docs/zh/docs/tutorial/sql-databases.md`. PR [#9712](https://github.com/tiangolo/fastapi/pull/9712) by [@Royc30ne](https://github.com/Royc30ne).
  * ğŸŒ� Add Turkish translation for `docs/tr/docs/external-links.md`. PR [#10549](https://github.com/tiangolo/fastapi/pull/10549) by [@hasansezertasan](https://github.com/hasansezertasan).
  * ğŸŒ� Add Spanish translation for `docs/es/docs/learn/index.md`. PR [#10885](https://github.com/tiangolo/fastapi/pull/10885) by [@pablocm83](https://github.com/pablocm83).
  * ğŸŒ� Add Ukrainian translation for `docs/uk/docs/tutorial/body-fields.md`. PR [#10670](https://github.com/tiangolo/fastapi/pull/10670) by [@ArtemKhymenko](https://github.com/ArtemKhymenko).
  * ğŸŒ� Add Hungarian translation for `/docs/hu/docs/index.md`. PR [#10812](https://github.com/tiangolo/fastapi/pull/10812) by [@takacs](https://github.com/takacs).
  * ğŸŒ� Add Turkish translation for `docs/tr/docs/newsletter.md`. PR [#10550](https://github.com/tiangolo/fastapi/pull/10550) by [@hasansezertasan](https://github.com/hasansezertasan).
  * ğŸŒ� Add Spanish translation for `docs/es/docs/help/index.md`. PR [#10907](https://github.com/tiangolo/fastapi/pull/10907) by [@pablocm83](https://github.com/pablocm83).
  * ğŸŒ� Add Spanish translation for `docs/es/docs/about/index.md`. PR [#10908](https://github.com/tiangolo/fastapi/pull/10908) by [@pablocm83](https://github.com/pablocm83).
  * ğŸŒ� Add Spanish translation for `docs/es/docs/resources/index.md`. PR [#10909](https://github.com/tiangolo/fastapi/pull/10909) by [@pablocm83](https://github.com/pablocm83).

### Internal[¶](#internal_54 "Permanent link")

  * ğŸ‘¥ Update FastAPI People. PR [#10871](https://github.com/tiangolo/fastapi/pull/10871) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘· Upgrade custom GitHub Action comment-docs-preview-in-pr. PR [#10916](https://github.com/tiangolo/fastapi/pull/10916) by [@tiangolo](https://github.com/tiangolo).
  * â¬†ï¸� Upgrade GitHub Action latest-changes. PR [#10915](https://github.com/tiangolo/fastapi/pull/10915) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘· Upgrade GitHub Action label-approved. PR [#10913](https://github.com/tiangolo/fastapi/pull/10913) by [@tiangolo](https://github.com/tiangolo).
  * â¬†ï¸� Upgrade GitHub Action label-approved. PR [#10905](https://github.com/tiangolo/fastapi/pull/10905) by [@tiangolo](https://github.com/tiangolo).

## 0.108.0[¶](#01080 "Permanent link")

### Upgrades[¶](#upgrades_17 "Permanent link")

  * â¬†ï¸� Upgrade Starlette to `>=0.29.0,<0.33.0`, update docs and usage of templates with new Starlette arguments. Remove pin of AnyIO `>=3.7.1,<4.0.0`, add support for AnyIO 4.x.x. PR [#10846](https://github.com/tiangolo/fastapi/pull/10846) by [@tiangolo](https://github.com/tiangolo).

## 0.107.0[¶](#01070 "Permanent link")

### Upgrades[¶](#upgrades_18 "Permanent link")

  * â¬†ï¸� Upgrade Starlette to 0.28.0. PR [#9636](https://github.com/tiangolo/fastapi/pull/9636) by [@adriangb](https://github.com/adriangb).

### Docs[¶](#docs_44 "Permanent link")

  * ğŸ“� Add docs: Node.js script alternative to update OpenAPI for generated clients. PR [#10845](https://github.com/tiangolo/fastapi/pull/10845) by [@alejsdev](https://github.com/alejsdev).
  * ğŸ“� Restructure Docs section in Contributing page. PR [#10844](https://github.com/tiangolo/fastapi/pull/10844) by [@alejsdev](https://github.com/alejsdev).

## 0.106.0[¶](#01060 "Permanent link")

### Breaking Changes[¶](#breaking-changes_5 "Permanent link")

Using resources from dependencies with `yield` in background tasks is no longer supported.

This change is what supports the new features, read below. ğŸ¤“

### Dependencies with `yield`, `HTTPException` and Background Tasks[¶](#dependencies-with-yield-httpexception-and-background-tasks "Permanent link")

Dependencies with `yield` now can raise `HTTPException` and other exceptions after `yield`. ğŸ�‰

Read the new docs here: [Dependencies with `yield` and `HTTPException`](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-with-yield/#dependencies-with-yield-and-httpexception).
    
    
    from fastapi import Depends, FastAPI, HTTPException
    from typing_extensions import Annotated
    
    app = FastAPI()
    
    
    data = {
        "plumbus": {"description": "Freshly pickled plumbus", "owner": "Morty"},
        "portal-gun": {"description": "Gun to create portals", "owner": "Rick"},
    }
    
    
    class OwnerError(Exception):
        pass
    
    
    def get_username():
        try:
            yield "Rick"
        except OwnerError as e:
            raise HTTPException(status_code=400, detail=f"Owner error: {e}")
    
    
    @app.get("/items/{item_id}")
    def get_item(item_id: str, username: Annotated[str, Depends(get_username)]):
        if item_id not in data:
            raise HTTPException(status_code=404, detail="Item not found")
        item = data[item_id]
        if item["owner"] != username:
            raise OwnerError(username)
        return item
    

* * *

Before FastAPI 0.106.0, raising exceptions after `yield` was not possible, the exit code in dependencies with `yield` was executed _after_ the response was sent, so [Exception Handlers](https://fastapi.tiangolo.com/tutorial/handling-errors/#install-custom-exception-handlers) would have already run.

This was designed this way mainly to allow using the same objects "yielded" by dependencies inside of background tasks, because the exit code would be executed after the background tasks were finished.

Nevertheless, as this would mean waiting for the response to travel through the network while unnecessarily holding a resource in a dependency with yield (for example a database connection), this was changed in FastAPI 0.106.0.

Additionally, a background task is normally an independent set of logic that should be handled separately, with its own resources (e.g. its own database connection).

If you used to rely on this behavior, now you should create the resources for background tasks inside the background task itself, and use internally only data that doesn't depend on the resources of dependencies with `yield`.

For example, instead of using the same database session, you would create a new database session inside of the background task, and you would obtain the objects from the database using this new session. And then instead of passing the object from the database as a parameter to the background task function, you would pass the ID of that object and then obtain the object again inside the background task function.

The sequence of execution before FastAPI 0.106.0 was like this diagram:

Time flows from top to bottom. And each column is one of the parts interacting or executing code.
    
    
    sequenceDiagram
    
    participant client as Client
    participant handler as Exception handler
    participant dep as Dep with yield
    participant operation as Path Operation
    participant tasks as Background tasks
    
        Note over client,tasks: Can raise exception for dependency, handled after response is sent
        Note over client,operation: Can raise HTTPException and can change the response
        client ->> dep: Start request
        Note over dep: Run code up to yield
        opt raise
            dep -->> handler: Raise HTTPException
            handler -->> client: HTTP error response
            dep -->> dep: Raise other exception
        end
        dep ->> operation: Run dependency, e.g. DB session
        opt raise
            operation -->> dep: Raise HTTPException
            dep -->> handler: Auto forward exception
            handler -->> client: HTTP error response
            operation -->> dep: Raise other exception
            dep -->> handler: Auto forward exception
        end
        operation ->> client: Return response to client
        Note over client,operation: Response is already sent, can't change it anymore
        opt Tasks
            operation -->> tasks: Send background tasks
        end
        opt Raise other exception
            tasks -->> dep: Raise other exception
        end
        Note over dep: After yield
        opt Handle other exception
            dep -->> dep: Handle exception, can't change response. E.g. close DB session.
        end

The new execution flow can be found in the docs: [Execution of dependencies with `yield`](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-with-yield/#execution-of-dependencies-with-yield).

### Features[¶](#features_14 "Permanent link")

  * âœ¨ Add support for raising exceptions (including `HTTPException`) in dependencies with `yield` in the exit code, do not support them in background tasks. PR [#10831](https://github.com/tiangolo/fastapi/pull/10831) by [@tiangolo](https://github.com/tiangolo).

### Internal[¶](#internal_55 "Permanent link")

  * ğŸ‘¥ Update FastAPI People. PR [#10567](https://github.com/tiangolo/fastapi/pull/10567) by [@tiangolo](https://github.com/tiangolo).

## 0.105.0[¶](#01050 "Permanent link")

### Features[¶](#features_15 "Permanent link")

  * âœ¨ Add support for multiple Annotated annotations, e.g. `Annotated[str, Field(), Query()]`. PR [#10773](https://github.com/tiangolo/fastapi/pull/10773) by [@tiangolo](https://github.com/tiangolo).

### Refactors[¶](#refactors_24 "Permanent link")

  * ğŸ”¥ Remove unused NoneType. PR [#10774](https://github.com/tiangolo/fastapi/pull/10774) by [@tiangolo](https://github.com/tiangolo).

### Docs[¶](#docs_45 "Permanent link")

  * ğŸ“� Tweak default suggested configs for generating clients. PR [#10736](https://github.com/tiangolo/fastapi/pull/10736) by [@tiangolo](https://github.com/tiangolo).

### Internal[¶](#internal_56 "Permanent link")

  * ğŸ”§ Update sponsors, add Scalar. PR [#10728](https://github.com/tiangolo/fastapi/pull/10728) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”§ Update sponsors, add PropelAuth. PR [#10760](https://github.com/tiangolo/fastapi/pull/10760) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘· Update build docs, verify README on CI. PR [#10750](https://github.com/tiangolo/fastapi/pull/10750) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”§ Update sponsors, remove Fern. PR [#10729](https://github.com/tiangolo/fastapi/pull/10729) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”§ Update sponsors, add Codacy. PR [#10677](https://github.com/tiangolo/fastapi/pull/10677) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”§ Update sponsors, add Reflex. PR [#10676](https://github.com/tiangolo/fastapi/pull/10676) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ“� Update release notes, move and check latest-changes. PR [#10588](https://github.com/tiangolo/fastapi/pull/10588) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘· Upgrade latest-changes GitHub Action. PR [#10587](https://github.com/tiangolo/fastapi/pull/10587) by [@tiangolo](https://github.com/tiangolo).

## 0.104.1[¶](#01041 "Permanent link")

### Fixes[¶](#fixes_41 "Permanent link")

  * ğŸ“Œ Pin Swagger UI version to 5.9.0 temporarily to handle a bug crashing it in 5.9.1. PR [#10529](https://github.com/tiangolo/fastapi/pull/10529) by [@alejandraklachquin](https://github.com/alejandraklachquin).
    * This is not really a bug in FastAPI but in Swagger UI, nevertheless pinning the version will work while a solution is found on the [Swagger UI side](https://github.com/swagger-api/swagger-ui/issues/9337).

### Docs[¶](#docs_46 "Permanent link")

  * ğŸ“� Update data structure and render for external-links. PR [#10495](https://github.com/tiangolo/fastapi/pull/10495) by [@tiangolo](https://github.com/tiangolo).
  * âœ�ï¸� Fix link to SPDX license identifier in `docs/en/docs/tutorial/metadata.md`. PR [#10433](https://github.com/tiangolo/fastapi/pull/10433) by [@worldworm](https://github.com/worldworm).
  * ğŸ“� Update example validation error from Pydantic v1 to match Pydantic v2 in `docs/en/docs/tutorial/path-params.md`. PR [#10043](https://github.com/tiangolo/fastapi/pull/10043) by [@giuliowaitforitdavide](https://github.com/giuliowaitforitdavide).
  * âœ�ï¸� Fix typos in emoji docs and in some source examples. PR [#10438](https://github.com/tiangolo/fastapi/pull/10438) by [@afuetterer](https://github.com/afuetterer).
  * âœ�ï¸� Fix typo in `docs/en/docs/reference/dependencies.md`. PR [#10465](https://github.com/tiangolo/fastapi/pull/10465) by [@suravshresth](https://github.com/suravshresth).
  * âœ�ï¸� Fix typos and rewordings in `docs/en/docs/tutorial/body-nested-models.md`. PR [#10468](https://github.com/tiangolo/fastapi/pull/10468) by [@yogabonito](https://github.com/yogabonito).
  * ğŸ“� Update docs, remove references to removed `pydantic.Required` in `docs/en/docs/tutorial/query-params-str-validations.md`. PR [#10469](https://github.com/tiangolo/fastapi/pull/10469) by [@yogabonito](https://github.com/yogabonito).
  * âœ�ï¸� Fix typo in `docs/en/docs/reference/index.md`. PR [#10467](https://github.com/tiangolo/fastapi/pull/10467) by [@tarsil](https://github.com/tarsil).
  * ğŸ”¥ Remove unnecessary duplicated docstrings. PR [#10484](https://github.com/tiangolo/fastapi/pull/10484) by [@tiangolo](https://github.com/tiangolo).

### Internal[¶](#internal_57 "Permanent link")

  * âœ�ï¸� Update Pydantic links to dotenv support. PR [#10511](https://github.com/tiangolo/fastapi/pull/10511) by [@White-Mask](https://github.com/White-Mask).
  * âœ�ï¸� Update links in `docs/en/docs/async.md` and `docs/zh/docs/async.md` to make them relative. PR [#10498](https://github.com/tiangolo/fastapi/pull/10498) by [@hasnatsajid](https://github.com/hasnatsajid).
  * âœ�ï¸� Fix links in `docs/em/docs/async.md`. PR [#10507](https://github.com/tiangolo/fastapi/pull/10507) by [@hasnatsajid](https://github.com/hasnatsajid).
  * âœ�ï¸� Fix typo in `docs/em/docs/index.md`, Python 3.8. PR [#10521](https://github.com/tiangolo/fastapi/pull/10521) by [@kerriop](https://github.com/kerriop).
  * â¬† Bump pillow from 9.5.0 to 10.1.0. PR [#10446](https://github.com/tiangolo/fastapi/pull/10446) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * â¬† Update mkdocs-material requirement from <9.0.0,>=8.1.4 to >=8.1.4,<10.0.0. PR [#5862](https://github.com/tiangolo/fastapi/pull/5862) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * â¬† Bump mkdocs-material from 9.1.21 to 9.4.7. PR [#10545](https://github.com/tiangolo/fastapi/pull/10545) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * ğŸ‘· Install MkDocs Material Insiders only when secrets are available, for Dependabot. PR [#10544](https://github.com/tiangolo/fastapi/pull/10544) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”§ Update sponsors badges, Databento. PR [#10519](https://github.com/tiangolo/fastapi/pull/10519) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘· Adopt Ruff format. PR [#10517](https://github.com/tiangolo/fastapi/pull/10517) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”§ Add `CITATION.cff` file for academic citations. PR [#10496](https://github.com/tiangolo/fastapi/pull/10496) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ�› Fix overriding MKDocs theme lang in hook. PR [#10490](https://github.com/tiangolo/fastapi/pull/10490) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”¥ Drop/close Gitter chat. Questions should go to GitHub Discussions, free conversations to Discord.. PR [#10485](https://github.com/tiangolo/fastapi/pull/10485) by [@tiangolo](https://github.com/tiangolo).

## 0.104.0[¶](#01040 "Permanent link")

## Features[¶](#features_16 "Permanent link")

  * âœ¨ Add reference (code API) docs with PEP 727, add subclass with custom docstrings for `BackgroundTasks`, refactor docs structure. PR [#10392](https://github.com/tiangolo/fastapi/pull/10392) by [@tiangolo](https://github.com/tiangolo). New docs at [FastAPI Reference - Code API](https://fastapi.tiangolo.com/reference/).

## Upgrades[¶](#upgrades_19 "Permanent link")

  * â¬†ï¸� Drop support for Python 3.7, require Python 3.8 or above. PR [#10442](https://github.com/tiangolo/fastapi/pull/10442) by [@tiangolo](https://github.com/tiangolo).

### Internal[¶](#internal_58 "Permanent link")

  * â¬† Bump dawidd6/action-download-artifact from 2.27.0 to 2.28.0. PR [#10268](https://github.com/tiangolo/fastapi/pull/10268) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * â¬† Bump actions/checkout from 3 to 4. PR [#10208](https://github.com/tiangolo/fastapi/pull/10208) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * â¬† Bump pypa/gh-action-pypi-publish from 1.8.6 to 1.8.10. PR [#10061](https://github.com/tiangolo/fastapi/pull/10061) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * ğŸ”§ Update sponsors, Bump.sh images. PR [#10381](https://github.com/tiangolo/fastapi/pull/10381) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘¥ Update FastAPI People. PR [#10363](https://github.com/tiangolo/fastapi/pull/10363) by [@tiangolo](https://github.com/tiangolo).

## 0.103.2[¶](#01032 "Permanent link")

### Refactors[¶](#refactors_25 "Permanent link")

  * â¬†ï¸� Upgrade compatibility with Pydantic v2.4, new renamed functions and JSON Schema input/output models with default values. PR [#10344](https://github.com/tiangolo/fastapi/pull/10344) by [@tiangolo](https://github.com/tiangolo).

### Translations[¶](#translations_43 "Permanent link")

  * ğŸŒ� Add Ukrainian translation for `docs/uk/docs/tutorial/extra-data-types.md`. PR [#10132](https://github.com/tiangolo/fastapi/pull/10132) by [@ArtemKhymenko](https://github.com/ArtemKhymenko).
  * ğŸŒ� Fix typos in French translations for `docs/fr/docs/advanced/path-operation-advanced-configuration.md`, `docs/fr/docs/alternatives.md`, `docs/fr/docs/async.md`, `docs/fr/docs/features.md`, `docs/fr/docs/help-fastapi.md`, `docs/fr/docs/index.md`, `docs/fr/docs/python-types.md`, `docs/fr/docs/tutorial/body.md`, `docs/fr/docs/tutorial/first-steps.md`, `docs/fr/docs/tutorial/query-params.md`. PR [#10154](https://github.com/tiangolo/fastapi/pull/10154) by [@s-rigaud](https://github.com/s-rigaud).
  * ğŸŒ� Add Chinese translation for `docs/zh/docs/async.md`. PR [#5591](https://github.com/tiangolo/fastapi/pull/5591) by [@mkdir700](https://github.com/mkdir700).
  * ğŸŒ� Update Chinese translation for `docs/tutorial/security/simple-oauth2.md`. PR [#3844](https://github.com/tiangolo/fastapi/pull/3844) by [@jaystone776](https://github.com/jaystone776).
  * ğŸŒ� Add Korean translation for `docs/ko/docs/deployment/cloud.md`. PR [#10191](https://github.com/tiangolo/fastapi/pull/10191) by [@Sion99](https://github.com/Sion99).
  * ğŸŒ� Add Japanese translation for `docs/ja/docs/deployment/https.md`. PR [#10298](https://github.com/tiangolo/fastapi/pull/10298) by [@tamtam-fitness](https://github.com/tamtam-fitness).
  * ğŸŒ� Fix typo in Russian translation for `docs/ru/docs/tutorial/body-fields.md`. PR [#10224](https://github.com/tiangolo/fastapi/pull/10224) by [@AlertRED](https://github.com/AlertRED).
  * ğŸŒ� Add Polish translation for `docs/pl/docs/help-fastapi.md`. PR [#10121](https://github.com/tiangolo/fastapi/pull/10121) by [@romabozhanovgithub](https://github.com/romabozhanovgithub).
  * ğŸŒ� Add Russian translation for `docs/ru/docs/tutorial/header-params.md`. PR [#10226](https://github.com/tiangolo/fastapi/pull/10226) by [@AlertRED](https://github.com/AlertRED).
  * ğŸŒ� Add Chinese translation for `docs/zh/docs/deployment/versions.md`. PR [#10276](https://github.com/tiangolo/fastapi/pull/10276) by [@xzmeng](https://github.com/xzmeng).

### Internal[¶](#internal_59 "Permanent link")

  * ğŸ”§ Update sponsors, remove Flint. PR [#10349](https://github.com/tiangolo/fastapi/pull/10349) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”§ Rename label "awaiting review" to "awaiting-review" to simplify search queries. PR [#10343](https://github.com/tiangolo/fastapi/pull/10343) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”§ Update sponsors, enable Svix (revert #10228). PR [#10253](https://github.com/tiangolo/fastapi/pull/10253) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”§ Update sponsors, remove Svix. PR [#10228](https://github.com/tiangolo/fastapi/pull/10228) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”§ Update sponsors, add Bump.sh. PR [#10227](https://github.com/tiangolo/fastapi/pull/10227) by [@tiangolo](https://github.com/tiangolo).

## 0.103.1[¶](#01031 "Permanent link")

### Fixes[¶](#fixes_42 "Permanent link")

  * ğŸ“Œ Pin AnyIO to < 4.0.0 to handle an incompatibility while upgrading to Starlette 0.31.1. PR [#10194](https://github.com/tiangolo/fastapi/pull/10194) by [@tiangolo](https://github.com/tiangolo).

### Docs[¶](#docs_47 "Permanent link")

  * âœ�ï¸� Fix validation parameter name in docs, from `regex` to `pattern`. PR [#10085](https://github.com/tiangolo/fastapi/pull/10085) by [@pablodorrio](https://github.com/pablodorrio).
  * âœ�ï¸� Fix indent format in `docs/en/docs/deployment/server-workers.md`. PR [#10066](https://github.com/tiangolo/fastapi/pull/10066) by [@tamtam-fitness](https://github.com/tamtam-fitness).
  * âœ�ï¸� Fix Pydantic examples in tutorial for Python types. PR [#9961](https://github.com/tiangolo/fastapi/pull/9961) by [@rahulsalgare](https://github.com/rahulsalgare).
  * âœ�ï¸� Fix link to Pydantic docs in `docs/en/docs/tutorial/extra-data-types.md`. PR [#10155](https://github.com/tiangolo/fastapi/pull/10155) by [@hasnatsajid](https://github.com/hasnatsajid).
  * âœ�ï¸� Fix typo in `docs/en/docs/tutorial/handling-errors.md`. PR [#10170](https://github.com/tiangolo/fastapi/pull/10170) by [@poupapaa](https://github.com/poupapaa).
  * âœ�ï¸� Fix typo in `docs/en/docs/tutorial/dependencies/dependencies-in-path-operation-decorators.md`. PR [#10172](https://github.com/tiangolo/fastapi/pull/10172) by [@ragul-kachiappan](https://github.com/ragul-kachiappan).

### Translations[¶](#translations_44 "Permanent link")

  * ğŸŒ� Remove duplicate line in translation for `docs/pt/docs/tutorial/path-params.md`. PR [#10126](https://github.com/tiangolo/fastapi/pull/10126) by [@LecoOliveira](https://github.com/LecoOliveira).
  * ğŸŒ� Add Yoruba translation for `docs/yo/docs/index.md`. PR [#10033](https://github.com/tiangolo/fastapi/pull/10033) by [@AfolabiOlaoluwa](https://github.com/AfolabiOlaoluwa).
  * ğŸŒ� Add Ukrainian translation for `docs/uk/docs/python-types.md`. PR [#10080](https://github.com/tiangolo/fastapi/pull/10080) by [@rostik1410](https://github.com/rostik1410).
  * ğŸŒ� Add Vietnamese translations for `docs/vi/docs/tutorial/first-steps.md` and `docs/vi/docs/tutorial/index.md`. PR [#10088](https://github.com/tiangolo/fastapi/pull/10088) by [@magiskboy](https://github.com/magiskboy).
  * ğŸŒ� Add Ukrainian translation for `docs/uk/docs/alternatives.md`. PR [#10060](https://github.com/tiangolo/fastapi/pull/10060) by [@whysage](https://github.com/whysage).
  * ğŸŒ� Add Ukrainian translation for `docs/uk/docs/tutorial/index.md`. PR [#10079](https://github.com/tiangolo/fastapi/pull/10079) by [@rostik1410](https://github.com/rostik1410).
  * âœ�ï¸� Fix typos in `docs/en/docs/how-to/separate-openapi-schemas.md` and `docs/en/docs/tutorial/schema-extra-example.md`. PR [#10189](https://github.com/tiangolo/fastapi/pull/10189) by [@xzmeng](https://github.com/xzmeng).
  * ğŸŒ� Add Chinese translation for `docs/zh/docs/advanced/generate-clients.md`. PR [#9883](https://github.com/tiangolo/fastapi/pull/9883) by [@funny-cat-happy](https://github.com/funny-cat-happy).

### Refactors[¶](#refactors_26 "Permanent link")

  * âœ�ï¸� Fix typos in comment in `fastapi/applications.py`. PR [#10045](https://github.com/tiangolo/fastapi/pull/10045) by [@AhsanSheraz](https://github.com/AhsanSheraz).
  * âœ… Add missing test for OpenAPI examples, it was missing in coverage. PR [#10188](https://github.com/tiangolo/fastapi/pull/10188) by [@tiangolo](https://github.com/tiangolo).

### Internal[¶](#internal_60 "Permanent link")

  * ğŸ‘¥ Update FastAPI People. PR [#10186](https://github.com/tiangolo/fastapi/pull/10186) by [@tiangolo](https://github.com/tiangolo).

## 0.103.0[¶](#01030 "Permanent link")

### Features[¶](#features_17 "Permanent link")

  * âœ¨ Add support for `openapi_examples` in all FastAPI parameters. PR [#10152](https://github.com/tiangolo/fastapi/pull/10152) by [@tiangolo](https://github.com/tiangolo).
    * New docs: [OpenAPI-specific examples](https://fastapi.tiangolo.com/tutorial/schema-extra-example/#openapi-specific-examples).

### Docs[¶](#docs_48 "Permanent link")

  * ğŸ“� Add note to docs about Separate Input and Output Schemas with FastAPI version. PR [#10150](https://github.com/tiangolo/fastapi/pull/10150) by [@tiangolo](https://github.com/tiangolo).

## 0.102.0[¶](#01020 "Permanent link")

### Features[¶](#features_18 "Permanent link")

  * âœ¨ Add support for disabling the separation of input and output JSON Schemas in OpenAPI with Pydantic v2 with `separate_input_output_schemas=False`. PR [#10145](https://github.com/tiangolo/fastapi/pull/10145) by [@tiangolo](https://github.com/tiangolo).
    * New docs [Separate OpenAPI Schemas for Input and Output or Not](https://fastapi.tiangolo.com/how-to/separate-openapi-schemas/).
    * This PR also includes a new setup (internal tools) for generating screenshots for the docs.

### Refactors[¶](#refactors_27 "Permanent link")

  * â™»ï¸� Refactor tests for new Pydantic 2.2.1. PR [#10115](https://github.com/tiangolo/fastapi/pull/10115) by [@tiangolo](https://github.com/tiangolo).

### Docs[¶](#docs_49 "Permanent link")

  * ğŸ“� Add new docs section, How To - Recipes, move docs that don't have to be read by everyone to How To. PR [#10114](https://github.com/tiangolo/fastapi/pull/10114) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ“� Update Advanced docs, add links to sponsor courses. PR [#10113](https://github.com/tiangolo/fastapi/pull/10113) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ“� Update docs for generating clients. PR [#10112](https://github.com/tiangolo/fastapi/pull/10112) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ“� Tweak MkDocs and add redirects. PR [#10111](https://github.com/tiangolo/fastapi/pull/10111) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ“� Restructure docs for cloud providers, include links to sponsors. PR [#10110](https://github.com/tiangolo/fastapi/pull/10110) by [@tiangolo](https://github.com/tiangolo).

### Internal[¶](#internal_61 "Permanent link")

  * ğŸ”§ Update sponsors, add Speakeasy. PR [#10098](https://github.com/tiangolo/fastapi/pull/10098) by [@tiangolo](https://github.com/tiangolo).

## 0.101.1[¶](#01011 "Permanent link")

### Fixes[¶](#fixes_43 "Permanent link")

  * âœ¨ Add `ResponseValidationError` printable details, to show up in server error logs. PR [#10078](https://github.com/tiangolo/fastapi/pull/10078) by [@tiangolo](https://github.com/tiangolo).

### Refactors[¶](#refactors_28 "Permanent link")

  * âœ�ï¸� Fix typo in deprecation warnings in `fastapi/params.py`. PR [#9854](https://github.com/tiangolo/fastapi/pull/9854) by [@russbiggs](https://github.com/russbiggs).
  * âœ�ï¸� Fix typos in comments on internal code in `fastapi/concurrency.py` and `fastapi/routing.py`. PR [#9590](https://github.com/tiangolo/fastapi/pull/9590) by [@ElliottLarsen](https://github.com/ElliottLarsen).

### Docs[¶](#docs_50 "Permanent link")

  * âœ�ï¸� Fix typo in release notes. PR [#9835](https://github.com/tiangolo/fastapi/pull/9835) by [@francisbergin](https://github.com/francisbergin).
  * ğŸ“� Add external article: Build an SMS Spam Classifier Serverless Database with FaunaDB and FastAPI. PR [#9847](https://github.com/tiangolo/fastapi/pull/9847) by [@adejumoridwan](https://github.com/adejumoridwan).
  * ğŸ“� Fix typo in `docs/en/docs/contributing.md`. PR [#9878](https://github.com/tiangolo/fastapi/pull/9878) by [@VicenteMerino](https://github.com/VicenteMerino).
  * ğŸ“� Fix code highlighting in `docs/en/docs/tutorial/bigger-applications.md`. PR [#9806](https://github.com/tiangolo/fastapi/pull/9806) by [@theonlykingpin](https://github.com/theonlykingpin).

### Translations[¶](#translations_45 "Permanent link")

  * ğŸŒ� Add Japanese translation for `docs/ja/docs/deployment/concepts.md`. PR [#10062](https://github.com/tiangolo/fastapi/pull/10062) by [@tamtam-fitness](https://github.com/tamtam-fitness).
  * ğŸŒ� Add Japanese translation for `docs/ja/docs/deployment/server-workers.md`. PR [#10064](https://github.com/tiangolo/fastapi/pull/10064) by [@tamtam-fitness](https://github.com/tamtam-fitness).
  * ğŸŒ� Update Japanese translation for `docs/ja/docs/deployment/docker.md`. PR [#10073](https://github.com/tiangolo/fastapi/pull/10073) by [@tamtam-fitness](https://github.com/tamtam-fitness).
  * ğŸŒ� Add Ukrainian translation for `docs/uk/docs/fastapi-people.md`. PR [#10059](https://github.com/tiangolo/fastapi/pull/10059) by [@rostik1410](https://github.com/rostik1410).
  * ğŸŒ� Add Ukrainian translation for `docs/uk/docs/tutorial/cookie-params.md`. PR [#10032](https://github.com/tiangolo/fastapi/pull/10032) by [@rostik1410](https://github.com/rostik1410).
  * ğŸŒ� Add Russian translation for `docs/ru/docs/deployment/docker.md`. PR [#9971](https://github.com/tiangolo/fastapi/pull/9971) by [@Xewus](https://github.com/Xewus).
  * ğŸŒ� Add Vietnamese translation for `docs/vi/docs/python-types.md`. PR [#10047](https://github.com/tiangolo/fastapi/pull/10047) by [@magiskboy](https://github.com/magiskboy).
  * ğŸŒ� Add Russian translation for `docs/ru/docs/tutorial/dependencies/global-dependencies.md`. PR [#9970](https://github.com/tiangolo/fastapi/pull/9970) by [@dudyaosuplayer](https://github.com/dudyaosuplayer).
  * ğŸŒ� Add Urdu translation for `docs/ur/docs/benchmarks.md`. PR [#9974](https://github.com/tiangolo/fastapi/pull/9974) by [@AhsanSheraz](https://github.com/AhsanSheraz).

### Internal[¶](#internal_62 "Permanent link")

  * ğŸ”§ Add sponsor Porter. PR [#10051](https://github.com/tiangolo/fastapi/pull/10051) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”§ Update sponsors, add Jina back as bronze sponsor. PR [#10050](https://github.com/tiangolo/fastapi/pull/10050) by [@tiangolo](https://github.com/tiangolo).
  * â¬† Bump mypy from 1.4.0 to 1.4.1. PR [#9756](https://github.com/tiangolo/fastapi/pull/9756) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * â¬† Bump mkdocs-material from 9.1.17 to 9.1.21. PR [#9960](https://github.com/tiangolo/fastapi/pull/9960) by [@dependabot[bot]](https://github.com/apps/dependabot).

## 0.101.0[¶](#01010 "Permanent link")

### Features[¶](#features_19 "Permanent link")

  * âœ¨ Enable Pydantic's serialization mode for responses, add support for Pydantic's `computed_field`, better OpenAPI for response models, proper required attributes, better generated clients. PR [#10011](https://github.com/tiangolo/fastapi/pull/10011) by [@tiangolo](https://github.com/tiangolo).

### Refactors[¶](#refactors_29 "Permanent link")

  * âœ… Fix tests for compatibility with pydantic 2.1.1. PR [#9943](https://github.com/tiangolo/fastapi/pull/9943) by [@dmontagu](https://github.com/dmontagu).
  * âœ… Fix test error in Windows for `jsonable_encoder`. PR [#9840](https://github.com/tiangolo/fastapi/pull/9840) by [@iudeen](https://github.com/iudeen).

### Upgrades[¶](#upgrades_20 "Permanent link")

  * ğŸ“Œ Do not allow Pydantic 2.1.0 that breaks (require 2.1.1). PR [#10012](https://github.com/tiangolo/fastapi/pull/10012) by [@tiangolo](https://github.com/tiangolo).

### Translations[¶](#translations_46 "Permanent link")

  * ğŸŒ� Add Russian translation for `docs/ru/docs/tutorial/security/index.md`. PR [#9963](https://github.com/tiangolo/fastapi/pull/9963) by [@eVery1337](https://github.com/eVery1337).
  * ğŸŒ� Remove Vietnamese note about missing translation. PR [#9957](https://github.com/tiangolo/fastapi/pull/9957) by [@tiangolo](https://github.com/tiangolo).

### Internal[¶](#internal_63 "Permanent link")

  * ğŸ‘· Add GitHub Actions step dump context to debug external failures. PR [#10008](https://github.com/tiangolo/fastapi/pull/10008) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”§ Restore MkDocs Material pin after the fix. PR [#10001](https://github.com/tiangolo/fastapi/pull/10001) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”§ Update the Question template to ask for the Pydantic version. PR [#10000](https://github.com/tiangolo/fastapi/pull/10000) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ“� Update MkDocs Material dependencies. PR [#9986](https://github.com/tiangolo/fastapi/pull/9986) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘¥ Update FastAPI People. PR [#9999](https://github.com/tiangolo/fastapi/pull/9999) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ�³ Update Dockerfile with compatibility versions, to upgrade later. PR [#9998](https://github.com/tiangolo/fastapi/pull/9998) by [@tiangolo](https://github.com/tiangolo).
  * â�• Add pydantic-settings to FastAPI People dependencies. PR [#9988](https://github.com/tiangolo/fastapi/pull/9988) by [@tiangolo](https://github.com/tiangolo).
  * â™»ï¸� Update FastAPI People logic with new Pydantic. PR [#9985](https://github.com/tiangolo/fastapi/pull/9985) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ�± Update sponsors, Fern badge. PR [#9982](https://github.com/tiangolo/fastapi/pull/9982) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘· Deploy docs to Cloudflare Pages. PR [#9978](https://github.com/tiangolo/fastapi/pull/9978) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”§ Update sponsor Fern. PR [#9979](https://github.com/tiangolo/fastapi/pull/9979) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘· Update CI debug mode with Tmate. PR [#9977](https://github.com/tiangolo/fastapi/pull/9977) by [@tiangolo](https://github.com/tiangolo).

## 0.100.1[¶](#01001 "Permanent link")

### Fixes[¶](#fixes_44 "Permanent link")

  * ğŸ�› Replace `MultHostUrl` to `AnyUrl` for compatibility with older versions of Pydantic v1. PR [#9852](https://github.com/tiangolo/fastapi/pull/9852) by [@Kludex](https://github.com/Kludex).

### Docs[¶](#docs_51 "Permanent link")

  * ğŸ“� Update links for self-hosted Swagger UI, point to v5, for OpenAPI 31.0. PR [#9834](https://github.com/tiangolo/fastapi/pull/9834) by [@tiangolo](https://github.com/tiangolo).

### Translations[¶](#translations_47 "Permanent link")

  * ğŸŒ� Add Ukrainian translation for `docs/uk/docs/tutorial/body.md`. PR [#4574](https://github.com/tiangolo/fastapi/pull/4574) by [@ss-o-furda](https://github.com/ss-o-furda).
  * ğŸŒ� Add Vietnamese translation for `docs/vi/docs/features.md` and `docs/vi/docs/index.md`. PR [#3006](https://github.com/tiangolo/fastapi/pull/3006) by [@magiskboy](https://github.com/magiskboy).
  * ğŸŒ� Add Korean translation for `docs/ko/docs/async.md`. PR [#4179](https://github.com/tiangolo/fastapi/pull/4179) by [@NinaHwang](https://github.com/NinaHwang).
  * ğŸŒ� Add Chinese translation for `docs/zh/docs/tutorial/background-tasks.md`. PR [#9812](https://github.com/tiangolo/fastapi/pull/9812) by [@wdh99](https://github.com/wdh99).
  * ğŸŒ� Add French translation for `docs/fr/docs/tutorial/query-params-str-validations.md`. PR [#4075](https://github.com/tiangolo/fastapi/pull/4075) by [@Smlep](https://github.com/Smlep).
  * ğŸŒ� Add French translation for `docs/fr/docs/tutorial/index.md`. PR [#2234](https://github.com/tiangolo/fastapi/pull/2234) by [@JulianMaurin](https://github.com/JulianMaurin).
  * ğŸŒ� Add French translation for `docs/fr/docs/contributing.md`. PR [#2132](https://github.com/tiangolo/fastapi/pull/2132) by [@JulianMaurin](https://github.com/JulianMaurin).
  * ğŸŒ� Add French translation for `docs/fr/docs/benchmarks.md`. PR [#2155](https://github.com/tiangolo/fastapi/pull/2155) by [@clemsau](https://github.com/clemsau).
  * ğŸŒ� Update Chinese translations with new source files. PR [#9738](https://github.com/tiangolo/fastapi/pull/9738) by [@mahone3297](https://github.com/mahone3297).
  * ğŸŒ� Add Russian translation for `docs/ru/docs/tutorial/request-forms.md`. PR [#9841](https://github.com/tiangolo/fastapi/pull/9841) by [@dedkot01](https://github.com/dedkot01).
  * ğŸŒ� Update Chinese translation for `docs/zh/docs/tutorial/handling-errors.md`. PR [#9485](https://github.com/tiangolo/fastapi/pull/9485) by [@Creat55](https://github.com/Creat55).

### Internal[¶](#internal_64 "Permanent link")

  * ğŸ”§ Update sponsors, add Fern. PR [#9956](https://github.com/tiangolo/fastapi/pull/9956) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘· Update FastAPI People token. PR [#9844](https://github.com/tiangolo/fastapi/pull/9844) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘¥ Update FastAPI People. PR [#9775](https://github.com/tiangolo/fastapi/pull/9775) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘· Update MkDocs Material token. PR [#9843](https://github.com/tiangolo/fastapi/pull/9843) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘· Update token for latest changes. PR [#9842](https://github.com/tiangolo/fastapi/pull/9842) by [@tiangolo](https://github.com/tiangolo).

## 0.100.0[¶](#01000 "Permanent link")

âœ¨ Support for **Pydantic v2** âœ¨

Pydantic version 2 has the **core** re-written in **Rust** and includes a lot of improvements and features, for example:

  * Improved **correctness** in corner cases.
  * **Safer** types.
  * Better **performance** and **less energy** consumption.
  * Better **extensibility**.
  * etc.

...all this while keeping the **same Python API**. In most of the cases, for simple models, you can simply upgrade the Pydantic version and get all the benefits. ğŸš€

In some cases, for pure data validation and processing, you can get performance improvements of **20x** or more. This means 2,000% or more. ğŸ¤¯

When you use **FastAPI** , there's a lot more going on, processing the request and response, handling dependencies, executing **your own code** , and particularly, **waiting for the network**. But you will probably still get some nice performance improvements just from the upgrade.

The focus of this release is **compatibility** with Pydantic v1 and v2, to make sure your current apps keep working. Later there will be more focus on refactors, correctness, code improvements, and then **performance** improvements. Some third-party early beta testers that ran benchmarks on the beta releases of FastAPI reported improvements of **2x - 3x**. Which is not bad for just doing `pip install --upgrade fastapi pydantic`. This was not an official benchmark and I didn't check it myself, but it's a good sign.

### Migration[¶](#migration "Permanent link")

Check out the [Pydantic migration guide](https://docs.pydantic.dev/2.0/migration/).

For the things that need changes in your Pydantic models, the Pydantic team built [`bump-pydantic`](https://github.com/pydantic/bump-pydantic).

A command line tool that will **process your code** and update most of the things **automatically** for you. Make sure you have your code in git first, and review each of the changes to make sure everything is correct before committing the changes.

### Pydantic v1[¶](#pydantic-v1 "Permanent link")

**This version of FastAPI still supports Pydantic v1**. And although Pydantic v1 will be deprecated at some point, it will still be supported for a while.

This means that you can install the new Pydantic v2, and if something fails, you can install Pydantic v1 while you fix any problems you might have, but having the latest FastAPI.

There are **tests for both Pydantic v1 and v2** , and test **coverage** is kept at **100%**.

### Changes[¶](#changes "Permanent link")

  * There are **new parameter** fields supported by Pydantic `Field()` for:

    * `Path()`
    * `Query()`
    * `Header()`
    * `Cookie()`
    * `Body()`
    * `Form()`
    * `File()`
  * The new parameter fields are:

    * `default_factory`
    * `alias_priority`
    * `validation_alias`
    * `serialization_alias`
    * `discriminator`
    * `strict`
    * `multiple_of`
    * `allow_inf_nan`
    * `max_digits`
    * `decimal_places`
    * `json_schema_extra`

...you can read about them in the Pydantic docs.

  * The parameter `regex` has been deprecated and replaced by `pattern`.
    * You can read more about it in the docs for [Query Parameters and String Validations: Add regular expressions](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#add-regular-expressions).
  * New Pydantic models use an improved and simplified attribute `model_config` that takes a simple dict instead of an internal class `Config` for their configuration.
    * You can read more about it in the docs for [Declare Request Example Data](https://fastapi.tiangolo.com/tutorial/schema-extra-example/).
  * The attribute `schema_extra` for the internal class `Config` has been replaced by the key `json_schema_extra` in the new `model_config` dict.
    * You can read more about it in the docs for [Declare Request Example Data](https://fastapi.tiangolo.com/tutorial/schema-extra-example/).
  * When you install `"fastapi[all]"` it now also includes:
    * [`pydantic-settings`](https://docs.pydantic.dev/latest/usage/pydantic_settings/) \- for settings management.
    * [`pydantic-extra-types`](https://docs.pydantic.dev/latest/usage/types/extra_types/extra_types/) \- for extra types to be used with Pydantic.
  * Now Pydantic Settings is an additional optional package (included in `"fastapi[all]"`). To use settings you should now import `from pydantic_settings import BaseSettings` instead of importing from `pydantic` directly.

    * You can read more about it in the docs for [Settings and Environment Variables](https://fastapi.tiangolo.com/advanced/settings/).
  * PR [#9816](https://github.com/tiangolo/fastapi/pull/9816) by [@tiangolo](https://github.com/tiangolo), included all the work done (in multiple PRs) on the beta branch (`main-pv2`).

## 0.99.1[¶](#0991 "Permanent link")

### Fixes[¶](#fixes_45 "Permanent link")

  * ğŸ�› Fix JSON Schema accepting bools as valid JSON Schemas, e.g. `additionalProperties: false`. PR [#9781](https://github.com/tiangolo/fastapi/pull/9781) by [@tiangolo](https://github.com/tiangolo).

### Docs[¶](#docs_52 "Permanent link")

  * ğŸ“� Update source examples to use new JSON Schema examples field. PR [#9776](https://github.com/tiangolo/fastapi/pull/9776) by [@tiangolo](https://github.com/tiangolo).

## 0.99.0[¶](#0990 "Permanent link")

### Features[¶](#features_20 "Permanent link")

  * âœ¨ Add support for OpenAPI 3.1.0. PR [#9770](https://github.com/tiangolo/fastapi/pull/9770) by [@tiangolo](https://github.com/tiangolo).

    * New support for documenting **webhooks** , read the new docs here: [Advanced User Guide: OpenAPI Webhooks](https://fastapi.tiangolo.com/advanced/openapi-webhooks/).
    * Upgrade OpenAPI 3.1.0, this uses JSON Schema 2020-12.
    * Upgrade Swagger UI to version 5.x.x, that supports OpenAPI 3.1.0.
    * Updated `examples` field in `Query()`, `Cookie()`, `Body()`, etc. based on the latest JSON Schema and OpenAPI. Now it takes a list of examples and they are included directly in the JSON Schema, not outside. Read more about it (including the historical technical details) in the updated docs: [Tutorial: Declare Request Example Data](https://fastapi.tiangolo.com/tutorial/schema-extra-example/).
  * âœ¨ Add support for `deque` objects and children in `jsonable_encoder`. PR [#9433](https://github.com/tiangolo/fastapi/pull/9433) by [@cranium](https://github.com/cranium).

### Docs[¶](#docs_53 "Permanent link")

  * ğŸ“� Fix form for the FastAPI and friends newsletter. PR [#9749](https://github.com/tiangolo/fastapi/pull/9749) by [@tiangolo](https://github.com/tiangolo).

### Translations[¶](#translations_48 "Permanent link")

  * ğŸŒ� Add Persian translation for `docs/fa/docs/advanced/sub-applications.md`. PR [#9692](https://github.com/tiangolo/fastapi/pull/9692) by [@mojtabapaso](https://github.com/mojtabapaso).
  * ğŸŒ� Add Russian translation for `docs/ru/docs/tutorial/response-model.md`. PR [#9675](https://github.com/tiangolo/fastapi/pull/9675) by [@glsglsgls](https://github.com/glsglsgls).

### Internal[¶](#internal_65 "Permanent link")

  * ğŸ”¨ Enable linenums in MkDocs Material during local live development to simplify highlighting code. PR [#9769](https://github.com/tiangolo/fastapi/pull/9769) by [@tiangolo](https://github.com/tiangolo).
  * â¬† Update httpx requirement from <0.24.0,>=0.23.0 to >=0.23.0,<0.25.0. PR [#9724](https://github.com/tiangolo/fastapi/pull/9724) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * â¬† Bump mkdocs-material from 9.1.16 to 9.1.17. PR [#9746](https://github.com/tiangolo/fastapi/pull/9746) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * ğŸ”¥ Remove missing translation dummy pages, no longer necessary. PR [#9751](https://github.com/tiangolo/fastapi/pull/9751) by [@tiangolo](https://github.com/tiangolo).
  * â¬† [pre-commit.ci] pre-commit autoupdate. PR [#9259](https://github.com/tiangolo/fastapi/pull/9259) by [@pre-commit-ci[bot]](https://github.com/apps/pre-commit-ci).
  * âœ¨ Add Material for MkDocs Insiders features and cards. PR [#9748](https://github.com/tiangolo/fastapi/pull/9748) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”¥ Remove languages without translations. PR [#9743](https://github.com/tiangolo/fastapi/pull/9743) by [@tiangolo](https://github.com/tiangolo).
  * âœ¨ Refactor docs for building scripts, use MkDocs hooks, simplify (remove) configs for languages. PR [#9742](https://github.com/tiangolo/fastapi/pull/9742) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”¨ Add MkDocs hook that renames sections based on the first index file. PR [#9737](https://github.com/tiangolo/fastapi/pull/9737) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘· Make cron jobs run only on main repo, not on forks, to avoid error notifications from missing tokens. PR [#9735](https://github.com/tiangolo/fastapi/pull/9735) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”§ Update MkDocs for other languages. PR [#9734](https://github.com/tiangolo/fastapi/pull/9734) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘· Refactor Docs CI, run in multiple workers with a dynamic matrix to optimize speed. PR [#9732](https://github.com/tiangolo/fastapi/pull/9732) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”¥ Remove old internal GitHub Action watch-previews that is no longer needed. PR [#9730](https://github.com/tiangolo/fastapi/pull/9730) by [@tiangolo](https://github.com/tiangolo).
  * â¬†ï¸� Upgrade MkDocs and MkDocs Material. PR [#9729](https://github.com/tiangolo/fastapi/pull/9729) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘· Build and deploy docs only on docs changes. PR [#9728](https://github.com/tiangolo/fastapi/pull/9728) by [@tiangolo](https://github.com/tiangolo).

## 0.98.0[¶](#0980 "Permanent link")

### Features[¶](#features_21 "Permanent link")

  * âœ¨ Allow disabling `redirect_slashes` at the FastAPI app level. PR [#3432](https://github.com/tiangolo/fastapi/pull/3432) by [@cyberlis](https://github.com/cyberlis).

### Docs[¶](#docs_54 "Permanent link")

  * ğŸ“� Update docs on Pydantic using ujson internally. PR [#5804](https://github.com/tiangolo/fastapi/pull/5804) by [@mvasilkov](https://github.com/mvasilkov).
  * âœ� Rewording in `docs/en/docs/tutorial/debugging.md`. PR [#9581](https://github.com/tiangolo/fastapi/pull/9581) by [@ivan-abc](https://github.com/ivan-abc).
  * ğŸ“� Add german blog post (Domain-driven Design mit Python und FastAPI). PR [#9261](https://github.com/tiangolo/fastapi/pull/9261) by [@msander](https://github.com/msander).
  * âœ�ï¸� Tweak wording in `docs/en/docs/tutorial/security/index.md`. PR [#9561](https://github.com/tiangolo/fastapi/pull/9561) by [@jyothish-mohan](https://github.com/jyothish-mohan).
  * ğŸ“� Update `Annotated` notes in `docs/en/docs/tutorial/schema-extra-example.md`. PR [#9620](https://github.com/tiangolo/fastapi/pull/9620) by [@Alexandrhub](https://github.com/Alexandrhub).
  * âœ�ï¸� Fix typo `Annotation` -> `Annotated` in `docs/en/docs/tutorial/query-params-str-validations.md`. PR [#9625](https://github.com/tiangolo/fastapi/pull/9625) by [@mccricardo](https://github.com/mccricardo).
  * ğŸ“� Use in memory database for testing SQL in docs. PR [#1223](https://github.com/tiangolo/fastapi/pull/1223) by [@HarshaLaxman](https://github.com/HarshaLaxman).

### Translations[¶](#translations_49 "Permanent link")

  * ğŸŒ� Add Russian translation for `docs/ru/docs/tutorial/metadata.md`. PR [#9681](https://github.com/tiangolo/fastapi/pull/9681) by [@TabarakoAkula](https://github.com/TabarakoAkula).
  * ğŸŒ� Fix typo in Spanish translation for `docs/es/docs/tutorial/first-steps.md`. PR [#9571](https://github.com/tiangolo/fastapi/pull/9571) by [@lilidl-nft](https://github.com/lilidl-nft).
  * ğŸŒ� Add Russian translation for `docs/tutorial/path-operation-configuration.md`. PR [#9696](https://github.com/tiangolo/fastapi/pull/9696) by [@TabarakoAkula](https://github.com/TabarakoAkula).
  * ğŸŒ� Add Chinese translation for `docs/zh/docs/advanced/security/index.md`. PR [#9666](https://github.com/tiangolo/fastapi/pull/9666) by [@lordqyxz](https://github.com/lordqyxz).
  * ğŸŒ� Add Chinese translations for `docs/zh/docs/advanced/settings.md`. PR [#9652](https://github.com/tiangolo/fastapi/pull/9652) by [@ChoyeonChern](https://github.com/ChoyeonChern).
  * ğŸŒ� Add Chinese translations for `docs/zh/docs/advanced/websockets.md`. PR [#9651](https://github.com/tiangolo/fastapi/pull/9651) by [@ChoyeonChern](https://github.com/ChoyeonChern).
  * ğŸŒ� Add Chinese translation for `docs/zh/docs/tutorial/testing.md`. PR [#9641](https://github.com/tiangolo/fastapi/pull/9641) by [@wdh99](https://github.com/wdh99).
  * ğŸŒ� Add Russian translation for `docs/tutorial/extra-models.md`. PR [#9619](https://github.com/tiangolo/fastapi/pull/9619) by [@ivan-abc](https://github.com/ivan-abc).
  * ğŸŒ� Add Russian translation for `docs/tutorial/cors.md`. PR [#9608](https://github.com/tiangolo/fastapi/pull/9608) by [@ivan-abc](https://github.com/ivan-abc).
  * ğŸŒ� Add Polish translation for `docs/pl/docs/features.md`. PR [#5348](https://github.com/tiangolo/fastapi/pull/5348) by [@mbroton](https://github.com/mbroton).
  * ğŸŒ� Add Russian translation for `docs/ru/docs/tutorial/body-nested-models.md`. PR [#9605](https://github.com/tiangolo/fastapi/pull/9605) by [@Alexandrhub](https://github.com/Alexandrhub).

### Internal[¶](#internal_66 "Permanent link")

  * â¬† Bump ruff from 0.0.272 to 0.0.275. PR [#9721](https://github.com/tiangolo/fastapi/pull/9721) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * â¬† Update uvicorn[standard] requirement from <0.21.0,>=0.12.0 to >=0.12.0,<0.23.0. PR [#9463](https://github.com/tiangolo/fastapi/pull/9463) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * â¬† Bump mypy from 1.3.0 to 1.4.0. PR [#9719](https://github.com/tiangolo/fastapi/pull/9719) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * â¬† Update pre-commit requirement from <3.0.0,>=2.17.0 to >=2.17.0,<4.0.0. PR [#9251](https://github.com/tiangolo/fastapi/pull/9251) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * â¬† Bump pypa/gh-action-pypi-publish from 1.8.5 to 1.8.6. PR [#9482](https://github.com/tiangolo/fastapi/pull/9482) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * âœ�ï¸� Fix tooltips for light/dark theme toggler in docs. PR [#9588](https://github.com/tiangolo/fastapi/pull/9588) by [@pankaj1707k](https://github.com/pankaj1707k).
  * ğŸ”§ Set minimal hatchling version needed to build the package. PR [#9240](https://github.com/tiangolo/fastapi/pull/9240) by [@mgorny](https://github.com/mgorny).
  * ğŸ“� Add repo link to PyPI. PR [#9559](https://github.com/tiangolo/fastapi/pull/9559) by [@JacobCoffee](https://github.com/JacobCoffee).
  * âœ�ï¸� Fix typos in data for tests. PR [#4958](https://github.com/tiangolo/fastapi/pull/4958) by [@ryanrussell](https://github.com/ryanrussell).
  * ğŸ”§ Update sponsors, add Flint. PR [#9699](https://github.com/tiangolo/fastapi/pull/9699) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘· Lint in CI only once, only with one version of Python, run tests with all of them. PR [#9686](https://github.com/tiangolo/fastapi/pull/9686) by [@tiangolo](https://github.com/tiangolo).

## 0.97.0[¶](#0970 "Permanent link")

### Features[¶](#features_22 "Permanent link")

  * âœ¨ Add support for `dependencies` in WebSocket routes. PR [#4534](https://github.com/tiangolo/fastapi/pull/4534) by [@paulo-raca](https://github.com/paulo-raca).
  * âœ¨ Add exception handler for `WebSocketRequestValidationError` (which also allows to override it). PR [#6030](https://github.com/tiangolo/fastapi/pull/6030) by [@kristjanvalur](https://github.com/kristjanvalur).

### Refactors[¶](#refactors_30 "Permanent link")

  * â¬†ï¸� Upgrade and fully migrate to Ruff, remove isort, includes a couple of tweaks suggested by the new version of Ruff. PR [#9660](https://github.com/tiangolo/fastapi/pull/9660) by [@tiangolo](https://github.com/tiangolo).
  * â™»ï¸� Update internal type annotations and upgrade mypy. PR [#9658](https://github.com/tiangolo/fastapi/pull/9658) by [@tiangolo](https://github.com/tiangolo).
  * â™»ï¸� Simplify `AsyncExitStackMiddleware` as without Python 3.6 `AsyncExitStack` is always available. PR [#9657](https://github.com/tiangolo/fastapi/pull/9657) by [@tiangolo](https://github.com/tiangolo).

### Upgrades[¶](#upgrades_21 "Permanent link")

  * â¬†ï¸� Upgrade Black. PR [#9661](https://github.com/tiangolo/fastapi/pull/9661) by [@tiangolo](https://github.com/tiangolo).

### Internal[¶](#internal_67 "Permanent link")

  * ğŸ’š Update CI cache to fix installs when dependencies change. PR [#9659](https://github.com/tiangolo/fastapi/pull/9659) by [@tiangolo](https://github.com/tiangolo).
  * â¬‡ï¸� Separate requirements for development into their own requirements.txt files, they shouldn't be extras. PR [#9655](https://github.com/tiangolo/fastapi/pull/9655) by [@tiangolo](https://github.com/tiangolo).

## 0.96.1[¶](#0961 "Permanent link")

### Fixes[¶](#fixes_46 "Permanent link")

  * ğŸ�› Fix `HTTPException` header type annotations. PR [#9648](https://github.com/tiangolo/fastapi/pull/9648) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ�› Fix OpenAPI model fields int validations, `gte` to `ge`. PR [#9635](https://github.com/tiangolo/fastapi/pull/9635) by [@tiangolo](https://github.com/tiangolo).

### Upgrades[¶](#upgrades_22 "Permanent link")

  * ğŸ“Œ Update minimum version of Pydantic to >=1.7.4. This fixes an issue when trying to use an old version of Pydantic. PR [#9567](https://github.com/tiangolo/fastapi/pull/9567) by [@Kludex](https://github.com/Kludex).

### Refactors[¶](#refactors_31 "Permanent link")

  * â™» Remove `media_type` from `ORJSONResponse` as it's inherited from the parent class. PR [#5805](https://github.com/tiangolo/fastapi/pull/5805) by [@Kludex](https://github.com/Kludex).
  * â™» Instantiate `HTTPException` only when needed, optimization refactor. PR [#5356](https://github.com/tiangolo/fastapi/pull/5356) by [@pawamoy](https://github.com/pawamoy).

### Docs[¶](#docs_55 "Permanent link")

  * ğŸ”¥ Remove link to Pydantic's benchmark, as it was removed there. PR [#5811](https://github.com/tiangolo/fastapi/pull/5811) by [@Kludex](https://github.com/Kludex).

### Translations[¶](#translations_50 "Permanent link")

  * ğŸŒ� Fix spelling in Indonesian translation of `docs/id/docs/tutorial/index.md`. PR [#5635](https://github.com/tiangolo/fastapi/pull/5635) by [@purwowd](https://github.com/purwowd).
  * ğŸŒ� Add Russian translation for `docs/ru/docs/tutorial/index.md`. PR [#5896](https://github.com/tiangolo/fastapi/pull/5896) by [@Wilidon](https://github.com/Wilidon).
  * ğŸŒ� Add Chinese translations for `docs/zh/docs/advanced/response-change-status-code.md` and `docs/zh/docs/advanced/response-headers.md`. PR [#9544](https://github.com/tiangolo/fastapi/pull/9544) by [@ChoyeonChern](https://github.com/ChoyeonChern).
  * ğŸŒ� Add Russian translation for `docs/ru/docs/tutorial/schema-extra-example.md`. PR [#9621](https://github.com/tiangolo/fastapi/pull/9621) by [@Alexandrhub](https://github.com/Alexandrhub).

### Internal[¶](#internal_68 "Permanent link")

  * ğŸ”§ Add sponsor Platform.sh. PR [#9650](https://github.com/tiangolo/fastapi/pull/9650) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘· Add custom token to Smokeshow and Preview Docs for download-artifact, to prevent API rate limits. PR [#9646](https://github.com/tiangolo/fastapi/pull/9646) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘· Add custom tokens for GitHub Actions to avoid rate limits. PR [#9647](https://github.com/tiangolo/fastapi/pull/9647) by [@tiangolo](https://github.com/tiangolo).

## 0.96.0[¶](#0960 "Permanent link")

### Features[¶](#features_23 "Permanent link")

  * âš¡ Update `create_cloned_field` to use a global cache and improve startup performance. PR [#4645](https://github.com/tiangolo/fastapi/pull/4645) by [@madkinsz](https://github.com/madkinsz) and previous original PR by [@huonw](https://github.com/huonw).

### Docs[¶](#docs_56 "Permanent link")

  * ğŸ“� Update Deta deployment tutorial for compatibility with Deta Space. PR [#6004](https://github.com/tiangolo/fastapi/pull/6004) by [@mikBighne98](https://github.com/mikBighne98).
  * âœ�ï¸� Fix typo in Deta deployment tutorial. PR [#9501](https://github.com/tiangolo/fastapi/pull/9501) by [@lemonyte](https://github.com/lemonyte).

### Translations[¶](#translations_51 "Permanent link")

  * ğŸŒ� Add Russian translation for `docs/tutorial/body.md`. PR [#3885](https://github.com/tiangolo/fastapi/pull/3885) by [@solomein-sv](https://github.com/solomein-sv).
  * ğŸŒ� Add Russian translation for `docs/ru/docs/tutorial/static-files.md`. PR [#9580](https://github.com/tiangolo/fastapi/pull/9580) by [@Alexandrhub](https://github.com/Alexandrhub).
  * ğŸŒ� Add Russian translation for `docs/ru/docs/tutorial/query-params.md`. PR [#9584](https://github.com/tiangolo/fastapi/pull/9584) by [@Alexandrhub](https://github.com/Alexandrhub).
  * ğŸŒ� Add Russian translation for `docs/ru/docs/tutorial/first-steps.md`. PR [#9471](https://github.com/tiangolo/fastapi/pull/9471) by [@AGolicyn](https://github.com/AGolicyn).
  * ğŸŒ� Add Russian translation for `docs/ru/docs/tutorial/debugging.md`. PR [#9579](https://github.com/tiangolo/fastapi/pull/9579) by [@Alexandrhub](https://github.com/Alexandrhub).
  * ğŸŒ� Add Russian translation for `docs/ru/docs/tutorial/path-params.md`. PR [#9519](https://github.com/tiangolo/fastapi/pull/9519) by [@AGolicyn](https://github.com/AGolicyn).
  * ğŸŒ� Add Chinese translation for `docs/zh/docs/tutorial/static-files.md`. PR [#9436](https://github.com/tiangolo/fastapi/pull/9436) by [@wdh99](https://github.com/wdh99).
  * ğŸŒ� Update Spanish translation including new illustrations in `docs/es/docs/async.md`. PR [#9483](https://github.com/tiangolo/fastapi/pull/9483) by [@andresbermeoq](https://github.com/andresbermeoq).
  * ğŸŒ� Add Russian translation for `docs/ru/docs/tutorial/path-params-numeric-validations.md`. PR [#9563](https://github.com/tiangolo/fastapi/pull/9563) by [@ivan-abc](https://github.com/ivan-abc).
  * ğŸŒ� Add Russian translation for `docs/ru/docs/deployment/concepts.md`. PR [#9577](https://github.com/tiangolo/fastapi/pull/9577) by [@Xewus](https://github.com/Xewus).
  * ğŸŒ� Add Russian translation for `docs/ru/docs/tutorial/body-multiple-params.md`. PR [#9586](https://github.com/tiangolo/fastapi/pull/9586) by [@Alexandrhub](https://github.com/Alexandrhub).

### Internal[¶](#internal_69 "Permanent link")

  * ğŸ‘¥ Update FastAPI People. PR [#9602](https://github.com/tiangolo/fastapi/pull/9602) by [@github-actions[bot]](https://github.com/apps/github-actions).
  * ğŸ”§ Update sponsors, remove InvestSuite. PR [#9612](https://github.com/tiangolo/fastapi/pull/9612) by [@tiangolo](https://github.com/tiangolo).

## 0.95.2[¶](#0952 "Permanent link")

  * â¬†ï¸� Upgrade Starlette version to `>=0.27.0` for a security release. PR [#9541](https://github.com/tiangolo/fastapi/pull/9541) by [@tiangolo](https://github.com/tiangolo). Details on [Starlette's security advisory](https://github.com/encode/starlette/security/advisories/GHSA-v5gw-mw7f-84px).

### Translations[¶](#translations_52 "Permanent link")

  * ğŸŒ� Add Portuguese translation for `docs/pt/docs/advanced/events.md`. PR [#9326](https://github.com/tiangolo/fastapi/pull/9326) by [@oandersonmagalhaes](https://github.com/oandersonmagalhaes).
  * ğŸŒ� Add Russian translation for `docs/ru/docs/deployment/manually.md`. PR [#9417](https://github.com/tiangolo/fastapi/pull/9417) by [@Xewus](https://github.com/Xewus).
  * ğŸŒ� Add setup for translations to Lao. PR [#9396](https://github.com/tiangolo/fastapi/pull/9396) by [@TheBrown](https://github.com/TheBrown).
  * ğŸŒ� Add Russian translation for `docs/ru/docs/tutorial/testing.md`. PR [#9403](https://github.com/tiangolo/fastapi/pull/9403) by [@Xewus](https://github.com/Xewus).
  * ğŸŒ� Add Russian translation for `docs/ru/docs/deployment/https.md`. PR [#9428](https://github.com/tiangolo/fastapi/pull/9428) by [@Xewus](https://github.com/Xewus).
  * âœ� Fix command to install requirements in Windows. PR [#9445](https://github.com/tiangolo/fastapi/pull/9445) by [@MariiaRomanuik](https://github.com/MariiaRomanuik).
  * ğŸŒ� Add French translation for `docs/fr/docs/advanced/response-directly.md`. PR [#9415](https://github.com/tiangolo/fastapi/pull/9415) by [@axel584](https://github.com/axel584).
  * ğŸŒ� Initiate Czech translation setup. PR [#9288](https://github.com/tiangolo/fastapi/pull/9288) by [@3p1463k](https://github.com/3p1463k).
  * âœ� Fix typo in Portuguese docs for `docs/pt/docs/index.md`. PR [#9337](https://github.com/tiangolo/fastapi/pull/9337) by [@lucasbalieiro](https://github.com/lucasbalieiro).
  * ğŸŒ� Add Russian translation for `docs/ru/docs/tutorial/response-status-code.md`. PR [#9370](https://github.com/tiangolo/fastapi/pull/9370) by [@nadia3373](https://github.com/nadia3373).

### Internal[¶](#internal_70 "Permanent link")

  * ğŸ�› Fix `flask.escape` warning for internal tests. PR [#9468](https://github.com/tiangolo/fastapi/pull/9468) by [@samuelcolvin](https://github.com/samuelcolvin).
  * âœ… Refactor 2 tests, for consistency and simplification. PR [#9504](https://github.com/tiangolo/fastapi/pull/9504) by [@tiangolo](https://github.com/tiangolo).
  * âœ… Refactor OpenAPI tests, prepare for Pydantic v2. PR [#9503](https://github.com/tiangolo/fastapi/pull/9503) by [@tiangolo](https://github.com/tiangolo).
  * â¬† Bump dawidd6/action-download-artifact from 2.26.0 to 2.27.0. PR [#9394](https://github.com/tiangolo/fastapi/pull/9394) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * ğŸ’š Disable setup-python pip cache in CI. PR [#9438](https://github.com/tiangolo/fastapi/pull/9438) by [@tiangolo](https://github.com/tiangolo).
  * â¬† Bump pypa/gh-action-pypi-publish from 1.6.4 to 1.8.5. PR [#9346](https://github.com/tiangolo/fastapi/pull/9346) by [@dependabot[bot]](https://github.com/apps/dependabot).

## 0.95.1[¶](#0951 "Permanent link")

### Fixes[¶](#fixes_47 "Permanent link")

  * ğŸ�› Fix using `Annotated` in routers or path operations decorated multiple times. PR [#9315](https://github.com/tiangolo/fastapi/pull/9315) by [@sharonyogev](https://github.com/sharonyogev).

### Docs[¶](#docs_57 "Permanent link")

  * ğŸŒ� ğŸ” ğŸ“„ ğŸ�¢ Translate docs to Emoji ğŸ¥³ ğŸ�‰ ğŸ’¥ ğŸ¤¯ ğŸ¤¯. PR [#5385](https://github.com/tiangolo/fastapi/pull/5385) by [@LeeeeT](https://github.com/LeeeeT).
  * ğŸ“� Add notification message warning about old versions of FastAPI not supporting `Annotated`. PR [#9298](https://github.com/tiangolo/fastapi/pull/9298) by [@grdworkin](https://github.com/grdworkin).
  * ğŸ“� Fix typo in `docs/en/docs/advanced/behind-a-proxy.md`. PR [#5681](https://github.com/tiangolo/fastapi/pull/5681) by [@Leommjr](https://github.com/Leommjr).
  * âœ� Fix wrong import from typing module in Persian translations for `docs/fa/docs/index.md`. PR [#6083](https://github.com/tiangolo/fastapi/pull/6083) by [@Kimiaattaei](https://github.com/Kimiaattaei).
  * âœ�ï¸� Fix format, remove unnecessary asterisks in `docs/en/docs/help-fastapi.md`. PR [#9249](https://github.com/tiangolo/fastapi/pull/9249) by [@armgabrielyan](https://github.com/armgabrielyan).
  * âœ� Fix typo in `docs/en/docs/tutorial/query-params-str-validations.md`. PR [#9272](https://github.com/tiangolo/fastapi/pull/9272) by [@nicornk](https://github.com/nicornk).
  * âœ� Fix typo/bug in inline code example in `docs/en/docs/tutorial/query-params-str-validations.md`. PR [#9273](https://github.com/tiangolo/fastapi/pull/9273) by [@tim-habitat](https://github.com/tim-habitat).
  * âœ� Fix typo in `docs/en/docs/tutorial/path-params-numeric-validations.md`. PR [#9282](https://github.com/tiangolo/fastapi/pull/9282) by [@aadarsh977](https://github.com/aadarsh977).
  * âœ� Fix typo: 'wll' to 'will' in `docs/en/docs/tutorial/query-params-str-validations.md`. PR [#9380](https://github.com/tiangolo/fastapi/pull/9380) by [@dasstyxx](https://github.com/dasstyxx).

### Translations[¶](#translations_53 "Permanent link")

  * ğŸŒ� Add French translation for `docs/fr/docs/advanced/index.md`. PR [#5673](https://github.com/tiangolo/fastapi/pull/5673) by [@axel584](https://github.com/axel584).
  * ğŸŒ� Add Portuguese translation for `docs/pt/docs/tutorial/body-nested-models.md`. PR [#4053](https://github.com/tiangolo/fastapi/pull/4053) by [@luccasmmg](https://github.com/luccasmmg).
  * ğŸŒ� Add Russian translation for `docs/ru/docs/alternatives.md`. PR [#5994](https://github.com/tiangolo/fastapi/pull/5994) by [@Xewus](https://github.com/Xewus).
  * ğŸŒ� Add Portuguese translation for `docs/pt/docs/tutorial/extra-models.md`. PR [#5912](https://github.com/tiangolo/fastapi/pull/5912) by [@LorhanSohaky](https://github.com/LorhanSohaky).
  * ğŸŒ� Add Portuguese translation for `docs/pt/docs/tutorial/path-operation-configuration.md`. PR [#5936](https://github.com/tiangolo/fastapi/pull/5936) by [@LorhanSohaky](https://github.com/LorhanSohaky).
  * ğŸŒ� Add Russian translation for `docs/ru/docs/contributing.md`. PR [#6002](https://github.com/tiangolo/fastapi/pull/6002) by [@stigsanek](https://github.com/stigsanek).
  * ğŸŒ� Add Korean translation for `docs/tutorial/dependencies/classes-as-dependencies.md`. PR [#9176](https://github.com/tiangolo/fastapi/pull/9176) by [@sehwan505](https://github.com/sehwan505).
  * ğŸŒ� Add Russian translation for `docs/ru/docs/project-generation.md`. PR [#9243](https://github.com/tiangolo/fastapi/pull/9243) by [@Xewus](https://github.com/Xewus).
  * ğŸŒ� Add French translation for `docs/fr/docs/index.md`. PR [#9265](https://github.com/tiangolo/fastapi/pull/9265) by [@frabc](https://github.com/frabc).
  * ğŸŒ� Add Russian translation for `docs/ru/docs/tutorial/query-params-str-validations.md`. PR [#9267](https://github.com/tiangolo/fastapi/pull/9267) by [@dedkot01](https://github.com/dedkot01).
  * ğŸŒ� Add Russian translation for `docs/ru/docs/benchmarks.md`. PR [#9271](https://github.com/tiangolo/fastapi/pull/9271) by [@Xewus](https://github.com/Xewus).

### Internal[¶](#internal_71 "Permanent link")

  * ğŸ”§ Update sponsors: remove Jina. PR [#9388](https://github.com/tiangolo/fastapi/pull/9388) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”§ Update sponsors, add databento, remove Ines's course and StriveWorks. PR [#9351](https://github.com/tiangolo/fastapi/pull/9351) by [@tiangolo](https://github.com/tiangolo).

## 0.95.0[¶](#0950 "Permanent link")

### Highlights[¶](#highlights_1 "Permanent link")

This release adds support for dependencies and parameters using `Annotated` and recommends its usage. âœ¨

This has **several benefits** , one of the main ones is that now the parameters of your functions with `Annotated` would **not be affected** at all.

If you call those functions in **other places in your code** , the actual **default values** will be kept, your editor will help you notice missing **required arguments** , Python will require you to pass required arguments at **runtime** , you will be able to **use the same functions** for different things and with different libraries (e.g. **Typer** will soon support `Annotated` too, then you could use the same function for an API and a CLI), etc.

Because `Annotated` is **standard Python** , you still get all the **benefits** from editors and tools, like **autocompletion** , **inline errors** , etc.

One of the **biggest benefits** is that now you can create `Annotated` dependencies that are then shared by multiple _path operation functions_ , this will allow you to **reduce** a lot of **code duplication** in your codebase, while keeping all the support from editors and tools.

For example, you could have code like this:
    
    
    def get_current_user(token: str):
        # authenticate user
        return User()
    
    
    @app.get("/items/")
    def read_items(user: User = Depends(get_current_user)):
        ...
    
    
    @app.post("/items/")
    def create_item(*, user: User = Depends(get_current_user), item: Item):
        ...
    
    
    @app.get("/items/{item_id}")
    def read_item(*, user: User = Depends(get_current_user), item_id: int):
        ...
    
    
    @app.delete("/items/{item_id}")
    def delete_item(*, user: User = Depends(get_current_user), item_id: int):
        ...
    

There's a bit of code duplication for the dependency:
    
    
    user: User = Depends(get_current_user)
    

...the bigger the codebase, the more noticeable it is.

Now you can create an annotated dependency once, like this:
    
    
    CurrentUser = Annotated[User, Depends(get_current_user)]
    

And then you can reuse this `Annotated` dependency:
    
    
    CurrentUser = Annotated[User, Depends(get_current_user)]
    
    
    @app.get("/items/")
    def read_items(user: CurrentUser):
        ...
    
    
    @app.post("/items/")
    def create_item(user: CurrentUser, item: Item):
        ...
    
    
    @app.get("/items/{item_id}")
    def read_item(user: CurrentUser, item_id: int):
        ...
    
    
    @app.delete("/items/{item_id}")
    def delete_item(user: CurrentUser, item_id: int):
        ...
    

...and `CurrentUser` has all the typing information as `User`, so your editor will work as expected (autocompletion and everything), and **FastAPI** will be able to understand the dependency defined in `Annotated`. ğŸ˜�

Roughly **all the docs** have been rewritten to use `Annotated` as the main way to declare **parameters** and **dependencies**. All the **examples** in the docs now include a version with `Annotated` and a version without it, for each of the specific Python versions (when there are small differences/improvements in more recent versions). There were around 23K new lines added between docs, examples, and tests. ğŸš€

The key updated docs are:

  * Python Types Intro:
    * [Type Hints with Metadata Annotations](https://fastapi.tiangolo.com/python-types/#type-hints-with-metadata-annotations).
  * Tutorial:
    * [Query Parameters and String Validations - Additional validation](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#additional-validation)
      * [Advantages of `Annotated`](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#advantages-of-annotated)
    * [Path Parameters and Numeric Validations - Order the parameters as you need, tricks](https://fastapi.tiangolo.com/tutorial/path-params-numeric-validations/#order-the-parameters-as-you-need-tricks)
      * [Better with `Annotated`](https://fastapi.tiangolo.com/tutorial/path-params-numeric-validations/#better-with-annotated)
    * [Dependencies - First Steps - Share `Annotated` dependencies](https://fastapi.tiangolo.com/tutorial/dependencies/#share-annotated-dependencies)

Special thanks to [@nzig](https://github.com/nzig) for the core implementation and to [@adriangb](https://github.com/adriangb) for the inspiration and idea with [Xpresso](https://github.com/adriangb/xpresso)! ğŸš€

### Features[¶](#features_24 "Permanent link")

  * âœ¨Add support for PEP-593 `Annotated` for specifying dependencies and parameters. PR [#4871](https://github.com/tiangolo/fastapi/pull/4871) by [@nzig](https://github.com/nzig).

### Docs[¶](#docs_58 "Permanent link")

  * ğŸ“� Tweak tip recommending `Annotated` in docs. PR [#9270](https://github.com/tiangolo/fastapi/pull/9270) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ“� Update order of examples, latest Python version first, and simplify version tab names. PR [#9269](https://github.com/tiangolo/fastapi/pull/9269) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ“� Update all docs to use `Annotated` as the main recommendation, with new examples and tests. PR [#9268](https://github.com/tiangolo/fastapi/pull/9268) by [@tiangolo](https://github.com/tiangolo).

## 0.94.1[¶](#0941 "Permanent link")

### Fixes[¶](#fixes_48 "Permanent link")

  * ğŸ�¨ Fix types for lifespan, upgrade Starlette to 0.26.1. PR [#9245](https://github.com/tiangolo/fastapi/pull/9245) by [@tiangolo](https://github.com/tiangolo).

## 0.94.0[¶](#0940 "Permanent link")

### Upgrades[¶](#upgrades_23 "Permanent link")

  * â¬† Upgrade python-multipart to support 0.0.6. PR [#9212](https://github.com/tiangolo/fastapi/pull/9212) by [@musicinmybrain](https://github.com/musicinmybrain).
  * â¬†ï¸� Upgrade Starlette version, support new `lifespan` with state. PR [#9239](https://github.com/tiangolo/fastapi/pull/9239) by [@tiangolo](https://github.com/tiangolo).

### Docs[¶](#docs_59 "Permanent link")

  * ğŸ“� Update Sentry link in docs. PR [#9218](https://github.com/tiangolo/fastapi/pull/9218) by [@smeubank](https://github.com/smeubank).

### Translations[¶](#translations_54 "Permanent link")

  * ğŸŒ� Add Russian translation for `docs/ru/docs/history-design-future.md`. PR [#5986](https://github.com/tiangolo/fastapi/pull/5986) by [@Xewus](https://github.com/Xewus).

### Internal[¶](#internal_72 "Permanent link")

  * â�• Add `pydantic` to PyPI classifiers. PR [#5914](https://github.com/tiangolo/fastapi/pull/5914) by [@yezz123](https://github.com/yezz123).
  * â¬† Bump black from 22.10.0 to 23.1.0. PR [#5953](https://github.com/tiangolo/fastapi/pull/5953) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * â¬† Bump types-ujson from 5.6.0.0 to 5.7.0.1. PR [#6027](https://github.com/tiangolo/fastapi/pull/6027) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * â¬† Bump dawidd6/action-download-artifact from 2.24.3 to 2.26.0. PR [#6034](https://github.com/tiangolo/fastapi/pull/6034) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * â¬† [pre-commit.ci] pre-commit autoupdate. PR [#5709](https://github.com/tiangolo/fastapi/pull/5709) by [@pre-commit-ci[bot]](https://github.com/apps/pre-commit-ci).

## 0.93.0[¶](#0930 "Permanent link")

### Features[¶](#features_25 "Permanent link")

  * âœ¨ Add support for `lifespan` async context managers (superseding `startup` and `shutdown` events). Initial PR [#2944](https://github.com/tiangolo/fastapi/pull/2944) by [@uSpike](https://github.com/uSpike).

Now, instead of using independent `startup` and `shutdown` events, you can define that logic in a single function with `yield` decorated with `@asynccontextmanager` (an async context manager).

For example:
    
    
    from contextlib import asynccontextmanager
    
    from fastapi import FastAPI
    
    
    def fake_answer_to_everything_ml_model(x: float):
        return x * 42
    
    
    ml_models = {}
    
    
    @asynccontextmanager
    async def lifespan(app: FastAPI):
        # Load the ML model
        ml_models["answer_to_everything"] = fake_answer_to_everything_ml_model
        yield
        # Clean up the ML models and release the resources
        ml_models.clear()
    
    
    app = FastAPI(lifespan=lifespan)
    
    
    @app.get("/predict")
    async def predict(x: float):
        result = ml_models["answer_to_everything"](x)
        return {"result": result}
    

**Note** : This is the recommended way going forward, instead of using `startup` and `shutdown` events.

Read more about it in the new docs: [Advanced User Guide: Lifespan Events](https://fastapi.tiangolo.com/advanced/events/).

### Docs[¶](#docs_60 "Permanent link")

  * âœ� Fix formatting in `docs/en/docs/tutorial/metadata.md` for `ReDoc`. PR [#6005](https://github.com/tiangolo/fastapi/pull/6005) by [@eykamp](https://github.com/eykamp).

### Translations[¶](#translations_55 "Permanent link")

  * ğŸŒ� Tamil translations - initial setup. PR [#5564](https://github.com/tiangolo/fastapi/pull/5564) by [@gusty1g](https://github.com/gusty1g).
  * ğŸŒ� Add French translation for `docs/fr/docs/advanced/path-operation-advanced-configuration.md`. PR [#9221](https://github.com/tiangolo/fastapi/pull/9221) by [@axel584](https://github.com/axel584).
  * ğŸŒ� Add French translation for `docs/tutorial/debugging.md`. PR [#9175](https://github.com/tiangolo/fastapi/pull/9175) by [@frabc](https://github.com/frabc).
  * ğŸŒ� Initiate Armenian translation setup. PR [#5844](https://github.com/tiangolo/fastapi/pull/5844) by [@har8](https://github.com/har8).
  * ğŸŒ� Add French translation for `deployment/manually.md`. PR [#3693](https://github.com/tiangolo/fastapi/pull/3693) by [@rjNemo](https://github.com/rjNemo).

### Internal[¶](#internal_73 "Permanent link")

  * ğŸ‘· Update translation bot messages. PR [#9206](https://github.com/tiangolo/fastapi/pull/9206) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘· Update translations bot to use Discussions, and notify when a PR is done. PR [#9183](https://github.com/tiangolo/fastapi/pull/9183) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”§ Update sponsors-badges. PR [#9182](https://github.com/tiangolo/fastapi/pull/9182) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘¥ Update FastAPI People. PR [#9181](https://github.com/tiangolo/fastapi/pull/9181) by [@github-actions[bot]](https://github.com/apps/github-actions).
  * ğŸ”Š Log GraphQL errors in FastAPI People, because it returns 200, with a payload with an error. PR [#9171](https://github.com/tiangolo/fastapi/pull/9171) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ’š Fix/workaround GitHub Actions in Docker with git for FastAPI People. PR [#9169](https://github.com/tiangolo/fastapi/pull/9169) by [@tiangolo](https://github.com/tiangolo).
  * â™»ï¸� Refactor FastAPI Experts to use only discussions now that questions are migrated. PR [#9165](https://github.com/tiangolo/fastapi/pull/9165) by [@tiangolo](https://github.com/tiangolo).
  * â¬†ï¸� Upgrade analytics. PR [#6025](https://github.com/tiangolo/fastapi/pull/6025) by [@tiangolo](https://github.com/tiangolo).
  * â¬†ï¸� Upgrade and re-enable installing Typer-CLI. PR [#6008](https://github.com/tiangolo/fastapi/pull/6008) by [@tiangolo](https://github.com/tiangolo).

## 0.92.0[¶](#0920 "Permanent link")

ğŸš¨ This is a security fix. Please upgrade as soon as possible.

### Upgrades[¶](#upgrades_24 "Permanent link")

  * â¬†ï¸� Upgrade Starlette to 0.25.0. PR [#5996](https://github.com/tiangolo/fastapi/pull/5996) by [@tiangolo](https://github.com/tiangolo).
    * This solves a vulnerability that could allow denial of service attacks by using many small multipart fields/files (parts), consuming high CPU and memory.
    * Only applications using forms (e.g. file uploads) could be affected.
    * For most cases, upgrading won't have any breaking changes.

## 0.91.0[¶](#0910 "Permanent link")

### Upgrades[¶](#upgrades_25 "Permanent link")

  * â¬†ï¸� Upgrade Starlette version to `0.24.0` and refactor internals for compatibility. PR [#5985](https://github.com/tiangolo/fastapi/pull/5985) by [@tiangolo](https://github.com/tiangolo).
    * This can solve nuanced errors when using middlewares. Before Starlette `0.24.0`, a new instance of each middleware class would be created when a new middleware was added. That normally was not a problem, unless the middleware class expected to be created only once, with only one instance, that happened in some cases. This upgrade would solve those cases (thanks [@adriangb](https://github.com/adriangb)! Starlette PR [#2017](https://github.com/encode/starlette/pull/2017)). Now the middleware class instances are created once, right before the first request (the first time the app is called).
    * If you depended on that previous behavior, you might need to update your code. As always, make sure your tests pass before merging the upgrade.

## 0.90.1[¶](#0901 "Permanent link")

### Upgrades[¶](#upgrades_26 "Permanent link")

  * â¬†ï¸� Upgrade Starlette range to allow 0.23.1. PR [#5980](https://github.com/tiangolo/fastapi/pull/5980) by [@tiangolo](https://github.com/tiangolo).

### Docs[¶](#docs_61 "Permanent link")

  * âœ� Tweak wording to clarify `docs/en/docs/project-generation.md`. PR [#5930](https://github.com/tiangolo/fastapi/pull/5930) by [@chandra-deb](https://github.com/chandra-deb).
  * âœ� Update Pydantic GitHub URLs. PR [#5952](https://github.com/tiangolo/fastapi/pull/5952) by [@yezz123](https://github.com/yezz123).
  * ğŸ“� Add opinion from Cisco. PR [#5981](https://github.com/tiangolo/fastapi/pull/5981) by [@tiangolo](https://github.com/tiangolo).

### Translations[¶](#translations_56 "Permanent link")

  * ğŸŒ� Add Russian translation for `docs/ru/docs/tutorial/cookie-params.md`. PR [#5890](https://github.com/tiangolo/fastapi/pull/5890) by [@bnzone](https://github.com/bnzone).

### Internal[¶](#internal_74 "Permanent link")

  * âœ� Update `zip-docs.sh` internal script, remove extra space. PR [#5931](https://github.com/tiangolo/fastapi/pull/5931) by [@JuanPerdomo00](https://github.com/JuanPerdomo00).

## 0.90.0[¶](#0900 "Permanent link")

### Upgrades[¶](#upgrades_27 "Permanent link")

  * â¬†ï¸� Bump Starlette from 0.22.0 to 0.23.0. Initial PR [#5739](https://github.com/tiangolo/fastapi/pull/5739) by [@Kludex](https://github.com/Kludex).

### Docs[¶](#docs_62 "Permanent link")

  * ğŸ“� Add article "Tortoise ORM / FastAPI æ•´å�ˆå¿«é€Ÿç­†è¨˜" to External Links. PR [#5496](https://github.com/tiangolo/fastapi/pull/5496) by [@Leon0824](https://github.com/Leon0824).
  * ğŸ‘¥ Update FastAPI People. PR [#5954](https://github.com/tiangolo/fastapi/pull/5954) by [@github-actions[bot]](https://github.com/apps/github-actions).
  * ğŸ“� Micro-tweak help docs. PR [#5960](https://github.com/tiangolo/fastapi/pull/5960) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”§ Update new issue chooser to direct to GitHub Discussions. PR [#5948](https://github.com/tiangolo/fastapi/pull/5948) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ“� Recommend GitHub Discussions for questions. PR [#5944](https://github.com/tiangolo/fastapi/pull/5944) by [@tiangolo](https://github.com/tiangolo).

### Translations[¶](#translations_57 "Permanent link")

  * ğŸŒ� Add Russian translation for `docs/ru/docs/tutorial/body-fields.md`. PR [#5898](https://github.com/tiangolo/fastapi/pull/5898) by [@simatheone](https://github.com/simatheone).
  * ğŸŒ� Add Russian translation for `docs/ru/docs/help-fastapi.md`. PR [#5970](https://github.com/tiangolo/fastapi/pull/5970) by [@tiangolo](https://github.com/tiangolo).
  * ğŸŒ� Add Portuguese translation for `docs/pt/docs/tutorial/static-files.md`. PR [#5858](https://github.com/tiangolo/fastapi/pull/5858) by [@batlopes](https://github.com/batlopes).
  * ğŸŒ� Add Portuguese translation for `docs/pt/docs/tutorial/encoder.md`. PR [#5525](https://github.com/tiangolo/fastapi/pull/5525) by [@felipebpl](https://github.com/felipebpl).
  * ğŸŒ� Add Russian translation for `docs/ru/docs/contributing.md`. PR [#5870](https://github.com/tiangolo/fastapi/pull/5870) by [@Xewus](https://github.com/Xewus).

### Internal[¶](#internal_75 "Permanent link")

  * â¬†ï¸� Upgrade Ubuntu version for docs workflow. PR [#5971](https://github.com/tiangolo/fastapi/pull/5971) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”§ Update sponsors badges. PR [#5943](https://github.com/tiangolo/fastapi/pull/5943) by [@tiangolo](https://github.com/tiangolo).
  * âœ¨ Compute FastAPI Experts including GitHub Discussions. PR [#5941](https://github.com/tiangolo/fastapi/pull/5941) by [@tiangolo](https://github.com/tiangolo).
  * â¬†ï¸� Upgrade isort and update pre-commit. PR [#5940](https://github.com/tiangolo/fastapi/pull/5940) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”§ Add template for questions in Discussions. PR [#5920](https://github.com/tiangolo/fastapi/pull/5920) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”§ Update Sponsor Budget Insight to Powens. PR [#5916](https://github.com/tiangolo/fastapi/pull/5916) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”§ Update GitHub Sponsors badge data. PR [#5915](https://github.com/tiangolo/fastapi/pull/5915) by [@tiangolo](https://github.com/tiangolo).

## 0.89.1[¶](#0891 "Permanent link")

### Fixes[¶](#fixes_49 "Permanent link")

  * ğŸ�› Ignore Response classes on return annotation. PR [#5855](https://github.com/tiangolo/fastapi/pull/5855) by [@Kludex](https://github.com/Kludex). See the new docs in the PR below.

### Docs[¶](#docs_63 "Permanent link")

  * ğŸ“� Update docs and examples for Response Model with Return Type Annotations, and update runtime error. PR [#5873](https://github.com/tiangolo/fastapi/pull/5873) by [@tiangolo](https://github.com/tiangolo). New docs at [Response Model - Return Type: Other Return Type Annotations](https://fastapi.tiangolo.com/tutorial/response-model/#other-return-type-annotations).
  * ğŸ“� Add External Link: FastAPI lambda container: serverless simplified. PR [#5784](https://github.com/tiangolo/fastapi/pull/5784) by [@rafrasenberg](https://github.com/rafrasenberg).

### Translations[¶](#translations_58 "Permanent link")

  * ğŸŒ� Add Turkish translation for `docs/tr/docs/tutorial/first_steps.md`. PR [#5691](https://github.com/tiangolo/fastapi/pull/5691) by [@Kadermiyanyedi](https://github.com/Kadermiyanyedi).

## 0.89.0[¶](#0890 "Permanent link")

### Features[¶](#features_26 "Permanent link")

  * âœ¨ Add support for function return type annotations to declare the `response_model`. Initial PR [#1436](https://github.com/tiangolo/fastapi/pull/1436) by [@uriyyo](https://github.com/uriyyo).

Now you can declare the return type / `response_model` in the function return type annotation:
    
    
    from fastapi import FastAPI
    from pydantic import BaseModel
    
    app = FastAPI()
    
    
    class Item(BaseModel):
        name: str
        price: float
    
    
    @app.get("/items/")
    async def read_items() -> list[Item]:
        return [
            Item(name="Portal Gun", price=42.0),
            Item(name="Plumbus", price=32.0),
        ]
    

FastAPI will use the return type annotation to perform:

  * Data validation
  * Automatic documentation
    * It could power automatic client generators
  * **Data filtering**

Before this version it was only supported via the `response_model` parameter.

Read more about it in the new docs: [Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/).

### Docs[¶](#docs_64 "Permanent link")

  * ğŸ“� Add External Link: Authorization on FastAPI with Casbin. PR [#5712](https://github.com/tiangolo/fastapi/pull/5712) by [@Xhy-5000](https://github.com/Xhy-5000).
  * âœ� Fix typo in `docs/en/docs/async.md`. PR [#5785](https://github.com/tiangolo/fastapi/pull/5785) by [@Kingdageek](https://github.com/Kingdageek).
  * âœ� Fix typo in `docs/en/docs/deployment/concepts.md`. PR [#5824](https://github.com/tiangolo/fastapi/pull/5824) by [@kelbyfaessler](https://github.com/kelbyfaessler).

### Translations[¶](#translations_59 "Permanent link")

  * ğŸŒ� Add Russian translation for `docs/ru/docs/fastapi-people.md`. PR [#5577](https://github.com/tiangolo/fastapi/pull/5577) by [@Xewus](https://github.com/Xewus).
  * ğŸŒ� Fix typo in Chinese translation for `docs/zh/docs/benchmarks.md`. PR [#4269](https://github.com/tiangolo/fastapi/pull/4269) by [@15027668g](https://github.com/15027668g).
  * ğŸŒ� Add Korean translation for `docs/tutorial/cors.md`. PR [#3764](https://github.com/tiangolo/fastapi/pull/3764) by [@NinaHwang](https://github.com/NinaHwang).

### Internal[¶](#internal_76 "Permanent link")

  * â¬† Update coverage[toml] requirement from <7.0,>=6.5.0 to >=6.5.0,<8.0. PR [#5801](https://github.com/tiangolo/fastapi/pull/5801) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * â¬† Update uvicorn[standard] requirement from <0.19.0,>=0.12.0 to >=0.12.0,<0.21.0 for development. PR [#5795](https://github.com/tiangolo/fastapi/pull/5795) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * â¬† Bump dawidd6/action-download-artifact from 2.24.2 to 2.24.3. PR [#5842](https://github.com/tiangolo/fastapi/pull/5842) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * ğŸ‘¥ Update FastAPI People. PR [#5825](https://github.com/tiangolo/fastapi/pull/5825) by [@github-actions[bot]](https://github.com/apps/github-actions).
  * â¬† Bump types-ujson from 5.5.0 to 5.6.0.0. PR [#5735](https://github.com/tiangolo/fastapi/pull/5735) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * â¬† Bump pypa/gh-action-pypi-publish from 1.5.2 to 1.6.4. PR [#5750](https://github.com/tiangolo/fastapi/pull/5750) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * ğŸ‘· Add GitHub Action gate/check. PR [#5492](https://github.com/tiangolo/fastapi/pull/5492) by [@webknjaz](https://github.com/webknjaz).
  * ğŸ”§ Update sponsors, add Svix. PR [#5848](https://github.com/tiangolo/fastapi/pull/5848) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”§ Remove Doist sponsor. PR [#5847](https://github.com/tiangolo/fastapi/pull/5847) by [@tiangolo](https://github.com/tiangolo).
  * â¬† Update sqlalchemy requirement from <=1.4.41,>=1.3.18 to >=1.3.18,<1.4.43. PR [#5540](https://github.com/tiangolo/fastapi/pull/5540) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * â¬† Bump nwtgck/actions-netlify from 1.2.4 to 2.0.0. PR [#5757](https://github.com/tiangolo/fastapi/pull/5757) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * ğŸ‘· Refactor CI artifact upload/download for docs previews. PR [#5793](https://github.com/tiangolo/fastapi/pull/5793) by [@tiangolo](https://github.com/tiangolo).
  * â¬† Bump pypa/gh-action-pypi-publish from 1.5.1 to 1.5.2. PR [#5714](https://github.com/tiangolo/fastapi/pull/5714) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * ğŸ‘¥ Update FastAPI People. PR [#5722](https://github.com/tiangolo/fastapi/pull/5722) by [@github-actions[bot]](https://github.com/apps/github-actions).
  * ğŸ”§ Update sponsors, disable course bundle. PR [#5713](https://github.com/tiangolo/fastapi/pull/5713) by [@tiangolo](https://github.com/tiangolo).
  * â¬† Update typer[all] requirement from <0.7.0,>=0.6.1 to >=0.6.1,<0.8.0. PR [#5639](https://github.com/tiangolo/fastapi/pull/5639) by [@dependabot[bot]](https://github.com/apps/dependabot).

## 0.88.0[¶](#0880 "Permanent link")

### Upgrades[¶](#upgrades_28 "Permanent link")

  * â¬† Bump Starlette to version `0.22.0` to fix bad encoding for query parameters in new `TestClient`. PR [#5659](https://github.com/tiangolo/fastapi/pull/5659) by [@azogue](https://github.com/azogue).

### Docs[¶](#docs_65 "Permanent link")

  * âœ�ï¸� Fix typo in docs for `docs/en/docs/advanced/middleware.md`. PR [#5376](https://github.com/tiangolo/fastapi/pull/5376) by [@rifatrakib](https://github.com/rifatrakib).

### Translations[¶](#translations_60 "Permanent link")

  * ğŸŒ� Add Portuguese translation for `docs/pt/docs/deployment/docker.md`. PR [#5663](https://github.com/tiangolo/fastapi/pull/5663) by [@ayr-ton](https://github.com/ayr-ton).

### Internal[¶](#internal_77 "Permanent link")

  * ğŸ‘· Tweak build-docs to improve CI performance. PR [#5699](https://github.com/tiangolo/fastapi/pull/5699) by [@tiangolo](https://github.com/tiangolo).
  * â¬† [pre-commit.ci] pre-commit autoupdate. PR [#5566](https://github.com/tiangolo/fastapi/pull/5566) by [@pre-commit-ci[bot]](https://github.com/apps/pre-commit-ci).
  * â¬†ï¸� Upgrade Ruff. PR [#5698](https://github.com/tiangolo/fastapi/pull/5698) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘· Remove pip cache for Smokeshow as it depends on a requirements.txt. PR [#5700](https://github.com/tiangolo/fastapi/pull/5700) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ’š Fix pip cache for Smokeshow. PR [#5697](https://github.com/tiangolo/fastapi/pull/5697) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘· Fix and tweak CI cache handling. PR [#5696](https://github.com/tiangolo/fastapi/pull/5696) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘· Update `setup-python` action in tests to use new caching feature. PR [#5680](https://github.com/tiangolo/fastapi/pull/5680) by [@madkinsz](https://github.com/madkinsz).
  * â¬† Bump black from 22.8.0 to 22.10.0. PR [#5569](https://github.com/tiangolo/fastapi/pull/5569) by [@dependabot[bot]](https://github.com/apps/dependabot).

## 0.87.0[¶](#0870 "Permanent link")

Highlights of this release:

  * [Upgraded Starlette](https://github.com/encode/starlette/releases/tag/0.21.0)
    * Now the `TestClient` is based on HTTPX instead of Requests. ğŸš€
    * There are some possible **breaking changes** in the `TestClient` usage, but [@Kludex](https://github.com/Kludex) built [bump-testclient](https://github.com/Kludex/bump-testclient) to help you automatize migrating your tests. Make sure you are using Git and that you can undo any unnecessary changes (false positive changes, etc) before using `bump-testclient`.
  * New [WebSocketException (and docs)](https://fastapi.tiangolo.com/advanced/websockets/#using-depends-and-others), re-exported from Starlette.
  * Upgraded and relaxed dependencies for package extras `all` (including new Uvicorn version), when you install `"fastapi[all]"`.
  * New docs about how to [**Help Maintain FastAPI**](https://fastapi.tiangolo.com/help-fastapi/#help-maintain-fastapi).

### Features[¶](#features_27 "Permanent link")

  * â¬†ï¸� Upgrade and relax dependencies for extras "all". PR [#5634](https://github.com/tiangolo/fastapi/pull/5634) by [@tiangolo](https://github.com/tiangolo).
  * âœ¨ Re-export Starlette's `WebSocketException` and add it to docs. PR [#5629](https://github.com/tiangolo/fastapi/pull/5629) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ“� Update references to Requests for tests to HTTPX, and add HTTPX to extras. PR [#5628](https://github.com/tiangolo/fastapi/pull/5628) by [@tiangolo](https://github.com/tiangolo).
  * â¬† Upgrade Starlette to `0.21.0`, including the new [`TestClient` based on HTTPX](https://github.com/encode/starlette/releases/tag/0.21.0). PR [#5471](https://github.com/tiangolo/fastapi/pull/5471) by [@pawelrubin](https://github.com/pawelrubin).

### Docs[¶](#docs_66 "Permanent link")

  * âœ�ï¸� Tweak Help FastAPI from PR review after merging. PR [#5633](https://github.com/tiangolo/fastapi/pull/5633) by [@tiangolo](https://github.com/tiangolo).
  * âœ�ï¸� Clarify docs on CORS. PR [#5627](https://github.com/tiangolo/fastapi/pull/5627) by [@paxcodes](https://github.com/paxcodes).
  * ğŸ“� Update Help FastAPI: Help Maintain FastAPI. PR [#5632](https://github.com/tiangolo/fastapi/pull/5632) by [@tiangolo](https://github.com/tiangolo).

### Translations[¶](#translations_61 "Permanent link")

  * ğŸŒ� Fix highlight lines for Japanese translation for `docs/tutorial/query-params.md`. PR [#2969](https://github.com/tiangolo/fastapi/pull/2969) by [@ftnext](https://github.com/ftnext).
  * ğŸŒ� Add French translation for `docs/fr/docs/advanced/additional-status-code.md`. PR [#5477](https://github.com/tiangolo/fastapi/pull/5477) by [@axel584](https://github.com/axel584).
  * ğŸŒ� Add Portuguese translation for `docs/pt/docs/tutorial/request-forms-and-files.md`. PR [#5579](https://github.com/tiangolo/fastapi/pull/5579) by [@batlopes](https://github.com/batlopes).
  * ğŸŒ� Add Japanese translation for `docs/ja/docs/advanced/websockets.md`. PR [#4983](https://github.com/tiangolo/fastapi/pull/4983) by [@xryuseix](https://github.com/xryuseix).

### Internal[¶](#internal_78 "Permanent link")

  * âœ¨ Use Ruff for linting. PR [#5630](https://github.com/tiangolo/fastapi/pull/5630) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ› Add Arabic issue number to Notify Translations GitHub Action. PR [#5610](https://github.com/tiangolo/fastapi/pull/5610) by [@tiangolo](https://github.com/tiangolo).
  * â¬† Bump dawidd6/action-download-artifact from 2.24.1 to 2.24.2. PR [#5609](https://github.com/tiangolo/fastapi/pull/5609) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * â¬† Bump dawidd6/action-download-artifact from 2.24.0 to 2.24.1. PR [#5603](https://github.com/tiangolo/fastapi/pull/5603) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * ğŸ“� Update coverage badge to use Samuel Colvin's Smokeshow. PR [#5585](https://github.com/tiangolo/fastapi/pull/5585) by [@tiangolo](https://github.com/tiangolo).

## 0.86.0[¶](#0860 "Permanent link")

### Features[¶](#features_28 "Permanent link")

  * â¬† Add Python 3.11 to the officially supported versions. PR [#5587](https://github.com/tiangolo/fastapi/pull/5587) by [@tiangolo](https://github.com/tiangolo).
  * âœ… Enable tests for Python 3.11. PR [#4881](https://github.com/tiangolo/fastapi/pull/4881) by [@tiangolo](https://github.com/tiangolo).

### Fixes[¶](#fixes_50 "Permanent link")

  * ğŸ�› Close FormData (uploaded files) after the request is done. PR [#5465](https://github.com/tiangolo/fastapi/pull/5465) by [@adriangb](https://github.com/adriangb).

### Docs[¶](#docs_67 "Permanent link")

  * âœ� Fix typo in `docs/en/docs/tutorial/security/oauth2-jwt.md`. PR [#5584](https://github.com/tiangolo/fastapi/pull/5584) by [@vivekashok1221](https://github.com/vivekashok1221).

### Translations[¶](#translations_62 "Permanent link")

  * ğŸŒ� Update wording in Chinese translation for `docs/zh/docs/python-types.md`. PR [#5416](https://github.com/tiangolo/fastapi/pull/5416) by [@supercaizehua](https://github.com/supercaizehua).
  * ğŸŒ� Add Russian translation for `docs/ru/docs/deployment/index.md`. PR [#5336](https://github.com/tiangolo/fastapi/pull/5336) by [@Xewus](https://github.com/Xewus).
  * ğŸŒ� Update Chinese translation for `docs/tutorial/security/oauth2-jwt.md`. PR [#3846](https://github.com/tiangolo/fastapi/pull/3846) by [@jaystone776](https://github.com/jaystone776).

### Internal[¶](#internal_79 "Permanent link")

  * ğŸ‘· Update FastAPI People to exclude bots: pre-commit-ci, dependabot. PR [#5586](https://github.com/tiangolo/fastapi/pull/5586) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ�¨ Format OpenAPI JSON in `test_starlette_exception.py`. PR [#5379](https://github.com/tiangolo/fastapi/pull/5379) by [@iudeen](https://github.com/iudeen).
  * ğŸ‘· Switch from Codecov to Smokeshow plus pytest-cov to pure coverage for internal tests. PR [#5583](https://github.com/tiangolo/fastapi/pull/5583) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘¥ Update FastAPI People. PR [#5571](https://github.com/tiangolo/fastapi/pull/5571) by [@github-actions[bot]](https://github.com/apps/github-actions).

## 0.85.2[¶](#0852 "Permanent link")

### Docs[¶](#docs_68 "Permanent link")

  * âœ� Fix grammar and add helpful links to dependencies in `docs/en/docs/async.md`. PR [#5432](https://github.com/tiangolo/fastapi/pull/5432) by [@pamelafox](https://github.com/pamelafox).
  * âœ� Fix broken link in `alternatives.md`. PR [#5455](https://github.com/tiangolo/fastapi/pull/5455) by [@su-shubham](https://github.com/su-shubham).
  * âœ� Fix typo in docs about contributing, for compatibility with `pip` in Zsh. PR [#5523](https://github.com/tiangolo/fastapi/pull/5523) by [@zhangbo2012](https://github.com/zhangbo2012).
  * ğŸ“� Fix typo in docs with examples for Python 3.10 instead of 3.9. PR [#5545](https://github.com/tiangolo/fastapi/pull/5545) by [@feliciss](https://github.com/feliciss).

### Translations[¶](#translations_63 "Permanent link")

  * ğŸŒ� Add Portuguese translation for `docs/pt/docs/tutorial/request-forms.md`. PR [#4934](https://github.com/tiangolo/fastapi/pull/4934) by [@batlopes](https://github.com/batlopes).
  * ğŸŒ� Add Chinese translation for `docs/zh/docs/tutorial/dependencies/classes-as-dependencies.md`. PR [#4971](https://github.com/tiangolo/fastapi/pull/4971) by [@Zssaer](https://github.com/Zssaer).
  * ğŸŒ� Add French translation for `deployment/deta.md`. PR [#3692](https://github.com/tiangolo/fastapi/pull/3692) by [@rjNemo](https://github.com/rjNemo).
  * ğŸŒ� Update Chinese translation for `docs/zh/docs/tutorial/query-params-str-validations.md`. PR [#5255](https://github.com/tiangolo/fastapi/pull/5255) by [@hjlarry](https://github.com/hjlarry).
  * ğŸŒ� Add Chinese translation for `docs/zh/docs/tutorial/sql-databases.md`. PR [#4999](https://github.com/tiangolo/fastapi/pull/4999) by [@Zssaer](https://github.com/Zssaer).
  * ğŸŒ� Add Chinese translation for `docs/zh/docs/advanced/wsgi.md`. PR [#4505](https://github.com/tiangolo/fastapi/pull/4505) by [@ASpathfinder](https://github.com/ASpathfinder).
  * ğŸŒ� Add Portuguese translation for `docs/pt/docs/tutorial/body-multiple-params.md`. PR [#4111](https://github.com/tiangolo/fastapi/pull/4111) by [@lbmendes](https://github.com/lbmendes).
  * ğŸŒ� Add Portuguese translation for `docs/pt/docs/tutorial/path-params-numeric-validations.md`. PR [#4099](https://github.com/tiangolo/fastapi/pull/4099) by [@lbmendes](https://github.com/lbmendes).
  * ğŸŒ� Add French translation for `deployment/versions.md`. PR [#3690](https://github.com/tiangolo/fastapi/pull/3690) by [@rjNemo](https://github.com/rjNemo).
  * ğŸŒ� Add French translation for `docs/fr/docs/help-fastapi.md`. PR [#2233](https://github.com/tiangolo/fastapi/pull/2233) by [@JulianMaurin](https://github.com/JulianMaurin).
  * ğŸŒ� Fix typo in Chinese translation for `docs/zh/docs/tutorial/security/first-steps.md`. PR [#5530](https://github.com/tiangolo/fastapi/pull/5530) by [@yuki1sntSnow](https://github.com/yuki1sntSnow).
  * ğŸŒ� Add Portuguese translation for `docs/pt/docs/tutorial/response-status-code.md`. PR [#4922](https://github.com/tiangolo/fastapi/pull/4922) by [@batlopes](https://github.com/batlopes).
  * ğŸ”§ Add config for Tamil translations. PR [#5563](https://github.com/tiangolo/fastapi/pull/5563) by [@tiangolo](https://github.com/tiangolo).

### Internal[¶](#internal_80 "Permanent link")

  * â¬† Bump internal dependency mypy from 0.971 to 0.982. PR [#5541](https://github.com/tiangolo/fastapi/pull/5541) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * â¬† Bump nwtgck/actions-netlify from 1.2.3 to 1.2.4. PR [#5507](https://github.com/tiangolo/fastapi/pull/5507) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * â¬† Bump internal dependency types-ujson from 5.4.0 to 5.5.0. PR [#5537](https://github.com/tiangolo/fastapi/pull/5537) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * â¬† Bump dawidd6/action-download-artifact from 2.23.0 to 2.24.0. PR [#5508](https://github.com/tiangolo/fastapi/pull/5508) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * â¬† Update internal dependency pytest-cov requirement from <4.0.0,>=2.12.0 to >=2.12.0,<5.0.0. PR [#5539](https://github.com/tiangolo/fastapi/pull/5539) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * â¬† [pre-commit.ci] pre-commit autoupdate. PR [#5536](https://github.com/tiangolo/fastapi/pull/5536) by [@pre-commit-ci[bot]](https://github.com/apps/pre-commit-ci).
  * ğŸ�› Fix internal Trio test warnings. PR [#5547](https://github.com/tiangolo/fastapi/pull/5547) by [@samuelcolvin](https://github.com/samuelcolvin).
  * â¬† [pre-commit.ci] pre-commit autoupdate. PR [#5408](https://github.com/tiangolo/fastapi/pull/5408) by [@pre-commit-ci[bot]](https://github.com/apps/pre-commit-ci).
  * â¬†ï¸� Upgrade Typer to include Rich in scripts for docs. PR [#5502](https://github.com/tiangolo/fastapi/pull/5502) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ�› Fix calling `mkdocs` for languages as a subprocess to fix/enable MkDocs Material search plugin. PR [#5501](https://github.com/tiangolo/fastapi/pull/5501) by [@tiangolo](https://github.com/tiangolo).

## 0.85.1[¶](#0851 "Permanent link")

### Fixes[¶](#fixes_51 "Permanent link")

  * ğŸ�› Fix support for strings in OpenAPI status codes: `default`, `1XX`, `2XX`, `3XX`, `4XX`, `5XX`. PR [#5187](https://github.com/tiangolo/fastapi/pull/5187) by [@JarroVGIT](https://github.com/JarroVGIT).

### Docs[¶](#docs_69 "Permanent link")

  * ğŸ“� Add WayScript x FastAPI Tutorial to External Links section. PR [#5407](https://github.com/tiangolo/fastapi/pull/5407) by [@moneeka](https://github.com/moneeka).

### Internal[¶](#internal_81 "Permanent link")

  * ğŸ‘¥ Update FastAPI People. PR [#5447](https://github.com/tiangolo/fastapi/pull/5447) by [@github-actions[bot]](https://github.com/apps/github-actions).
  * ğŸ”§ Disable Material for MkDocs search plugin. PR [#5495](https://github.com/tiangolo/fastapi/pull/5495) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”‡ Ignore Trio warning in tests for CI. PR [#5483](https://github.com/tiangolo/fastapi/pull/5483) by [@samuelcolvin](https://github.com/samuelcolvin).

## 0.85.0[¶](#0850 "Permanent link")

### Features[¶](#features_29 "Permanent link")

  * â¬† Upgrade version required of Starlette from `0.19.1` to `0.20.4`. Initial PR [#4820](https://github.com/tiangolo/fastapi/pull/4820) by [@Kludex](https://github.com/Kludex).
    * This includes several bug fixes in Starlette.
  * â¬†ï¸� Upgrade Uvicorn max version in public extras: all. From `>=0.12.0,<0.18.0` to `>=0.12.0,<0.19.0`. PR [#5401](https://github.com/tiangolo/fastapi/pull/5401) by [@tiangolo](https://github.com/tiangolo).

### Internal[¶](#internal_82 "Permanent link")

  * â¬†ï¸� Upgrade dependencies for doc and dev internal extras: Typer, Uvicorn. PR [#5400](https://github.com/tiangolo/fastapi/pull/5400) by [@tiangolo](https://github.com/tiangolo).
  * â¬†ï¸� Upgrade test dependencies: Black, HTTPX, databases, types-ujson. PR [#5399](https://github.com/tiangolo/fastapi/pull/5399) by [@tiangolo](https://github.com/tiangolo).
  * â¬†ï¸� Upgrade mypy and tweak internal type annotations. PR [#5398](https://github.com/tiangolo/fastapi/pull/5398) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”§ Update test dependencies, upgrade Pytest, move dependencies from dev to test. PR [#5396](https://github.com/tiangolo/fastapi/pull/5396) by [@tiangolo](https://github.com/tiangolo).

## 0.84.0[¶](#0840 "Permanent link")

### Breaking Changes[¶](#breaking-changes_6 "Permanent link")

This version of FastAPI drops support for Python 3.6. ğŸ”¥ Please upgrade to a supported version of Python (3.7 or above), Python 3.6 reached the end-of-life a long time ago. ğŸ˜…â˜ 

  * ğŸ”§ Update package metadata, drop support for Python 3.6, move build internals from Flit to Hatch. PR [#5240](https://github.com/tiangolo/fastapi/pull/5240) by [@ofek](https://github.com/ofek).

## 0.83.0[¶](#0830 "Permanent link")

ğŸš¨ This is probably the last release (or one of the last releases) to support Python 3.6. ğŸ”¥

Python 3.6 reached the [end-of-life and is no longer supported by Python](https://www.python.org/downloads/release/python-3615/) since around a year ago.

You hopefully updated to a supported version of Python a while ago. If you haven't, you really should.

### Features[¶](#features_30 "Permanent link")

  * âœ¨ Add support in `jsonable_encoder` for include and exclude with dataclasses. PR [#4923](https://github.com/tiangolo/fastapi/pull/4923) by [@DCsunset](https://github.com/DCsunset).

### Fixes[¶](#fixes_52 "Permanent link")

  * ğŸ�› Fix `RuntimeError` raised when `HTTPException` has a status code with no content. PR [#5365](https://github.com/tiangolo/fastapi/pull/5365) by [@iudeen](https://github.com/iudeen).
  * ğŸ�› Fix empty response body when default `status_code` is empty but the a `Response` parameter with `response.status_code` is set. PR [#5360](https://github.com/tiangolo/fastapi/pull/5360) by [@tmeckel](https://github.com/tmeckel).

### Docs[¶](#docs_70 "Permanent link")

  * ğŸ“� Update `SECURITY.md`. PR [#5377](https://github.com/tiangolo/fastapi/pull/5377) by [@Kludex](https://github.com/Kludex).

### Internal[¶](#internal_83 "Permanent link")

  * â¬† [pre-commit.ci] pre-commit autoupdate. PR [#5352](https://github.com/tiangolo/fastapi/pull/5352) by [@pre-commit-ci[bot]](https://github.com/apps/pre-commit-ci).

## 0.82.0[¶](#0820 "Permanent link")

ğŸš¨ This is probably the last release (or one of the last releases) to support Python 3.6. ğŸ”¥

Python 3.6 reached the [end-of-life and is no longer supported by Python](https://www.python.org/downloads/release/python-3615/) since around a year ago.

You hopefully updated to a supported version of Python a while ago. If you haven't, you really should.

### Features[¶](#features_31 "Permanent link")

  * âœ¨ Export `WebSocketState` in `fastapi.websockets`. PR [#4376](https://github.com/tiangolo/fastapi/pull/4376) by [@matiuszka](https://github.com/matiuszka).
  * âœ¨ Support Python internal description on Pydantic model's docstring. PR [#3032](https://github.com/tiangolo/fastapi/pull/3032) by [@Kludex](https://github.com/Kludex).
  * âœ¨ Update `ORJSONResponse` to support non `str` keys and serializing Numpy arrays. PR [#3892](https://github.com/tiangolo/fastapi/pull/3892) by [@baby5](https://github.com/baby5).

### Fixes[¶](#fixes_53 "Permanent link")

  * ğŸ�› Allow exit code for dependencies with `yield` to always execute, by removing capacity limiter for them, to e.g. allow closing DB connections without deadlocks. PR [#5122](https://github.com/tiangolo/fastapi/pull/5122) by [@adriangb](https://github.com/adriangb).
  * ğŸ�› Fix FastAPI People GitHub Action: set HTTPX timeout for GraphQL query request. PR [#5222](https://github.com/tiangolo/fastapi/pull/5222) by [@iudeen](https://github.com/iudeen).
  * ğŸ�› Make sure a parameter defined as required is kept required in OpenAPI even if defined as optional in another dependency. PR [#4319](https://github.com/tiangolo/fastapi/pull/4319) by [@cd17822](https://github.com/cd17822).
  * ğŸ�› Fix support for path parameters in WebSockets. PR [#3879](https://github.com/tiangolo/fastapi/pull/3879) by [@davidbrochart](https://github.com/davidbrochart).

### Docs[¶](#docs_71 "Permanent link")

  * âœ� Update Hypercorn link, now pointing to GitHub. PR [#5346](https://github.com/tiangolo/fastapi/pull/5346) by [@baconfield](https://github.com/baconfield).
  * âœ� Tweak wording in `docs/en/docs/advanced/dataclasses.md`. PR [#3698](https://github.com/tiangolo/fastapi/pull/3698) by [@pfackeldey](https://github.com/pfackeldey).
  * ğŸ“� Add note about Python 3.10 `X | Y` operator in explanation about Response Models. PR [#5307](https://github.com/tiangolo/fastapi/pull/5307) by [@MendyLanda](https://github.com/MendyLanda).
  * ğŸ“� Add link to New Relic article: "How to monitor FastAPI application performance using Python agent". PR [#5260](https://github.com/tiangolo/fastapi/pull/5260) by [@sjyothi54](https://github.com/sjyothi54).
  * ğŸ“� Update docs for `ORJSONResponse` with details about improving performance. PR [#2615](https://github.com/tiangolo/fastapi/pull/2615) by [@falkben](https://github.com/falkben).
  * ğŸ“� Add docs for creating a custom Response class. PR [#5331](https://github.com/tiangolo/fastapi/pull/5331) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ“� Add tip about using alias for form data fields. PR [#5329](https://github.com/tiangolo/fastapi/pull/5329) by [@tiangolo](https://github.com/tiangolo).

### Translations[¶](#translations_64 "Permanent link")

  * ğŸŒ� Add Russian translation for `docs/ru/docs/features.md`. PR [#5315](https://github.com/tiangolo/fastapi/pull/5315) by [@Xewus](https://github.com/Xewus).
  * ğŸŒ� Update Chinese translation for `docs/zh/docs/tutorial/request-files.md`. PR [#4529](https://github.com/tiangolo/fastapi/pull/4529) by [@ASpathfinder](https://github.com/ASpathfinder).
  * ğŸŒ� Add Chinese translation for `docs/zh/docs/tutorial/encoder.md`. PR [#4969](https://github.com/tiangolo/fastapi/pull/4969) by [@Zssaer](https://github.com/Zssaer).
  * ğŸŒ� Fix MkDocs file line for Portuguese translation of `background-task.md`. PR [#5242](https://github.com/tiangolo/fastapi/pull/5242) by [@ComicShrimp](https://github.com/ComicShrimp).

### Internal[¶](#internal_84 "Permanent link")

  * ğŸ‘¥ Update FastAPI People. PR [#5347](https://github.com/tiangolo/fastapi/pull/5347) by [@github-actions[bot]](https://github.com/apps/github-actions).
  * â¬† Bump dawidd6/action-download-artifact from 2.22.0 to 2.23.0. PR [#5321](https://github.com/tiangolo/fastapi/pull/5321) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * â¬† [pre-commit.ci] pre-commit autoupdate. PR [#5318](https://github.com/tiangolo/fastapi/pull/5318) by [@pre-commit-ci[bot]](https://github.com/apps/pre-commit-ci).
  * âœ� Fix a small code highlight line error. PR [#5256](https://github.com/tiangolo/fastapi/pull/5256) by [@hjlarry](https://github.com/hjlarry).
  * â™» Internal small refactor, move `operation_id` parameter position in delete method for consistency with the code. PR [#4474](https://github.com/tiangolo/fastapi/pull/4474) by [@hiel](https://github.com/hiel).
  * ğŸ”§ Update sponsors, disable ImgWhale. PR [#5338](https://github.com/tiangolo/fastapi/pull/5338) by [@tiangolo](https://github.com/tiangolo).

## 0.81.0[¶](#0810 "Permanent link")

### Features[¶](#features_32 "Permanent link")

  * âœ¨ Add ReDoc `<noscript>` warning when JS is disabled. PR [#5074](https://github.com/tiangolo/fastapi/pull/5074) by [@evroon](https://github.com/evroon).
  * âœ¨ Add support for `FrozenSet` in parameters (e.g. query). PR [#2938](https://github.com/tiangolo/fastapi/pull/2938) by [@juntatalor](https://github.com/juntatalor).
  * âœ¨ Allow custom middlewares to raise `HTTPException`s and propagate them. PR [#2036](https://github.com/tiangolo/fastapi/pull/2036) by [@ghandic](https://github.com/ghandic).
  * âœ¨ Preserve `json.JSONDecodeError` information when handling invalid JSON in request body, to support custom exception handlers that use its information. PR [#4057](https://github.com/tiangolo/fastapi/pull/4057) by [@UKnowWhoIm](https://github.com/UKnowWhoIm).

### Fixes[¶](#fixes_54 "Permanent link")

  * ğŸ�› Fix `jsonable_encoder` for dataclasses with pydantic-compatible fields. PR [#3607](https://github.com/tiangolo/fastapi/pull/3607) by [@himbeles](https://github.com/himbeles).
  * ğŸ�› Fix support for extending `openapi_extras` with parameter lists. PR [#4267](https://github.com/tiangolo/fastapi/pull/4267) by [@orilevari](https://github.com/orilevari).

### Docs[¶](#docs_72 "Permanent link")

  * âœ� Fix a simple typo in `docs/en/docs/python-types.md`. PR [#5193](https://github.com/tiangolo/fastapi/pull/5193) by [@GlitchingCore](https://github.com/GlitchingCore).
  * âœ� Fix typos in `tests/test_schema_extra_examples.py`. PR [#5126](https://github.com/tiangolo/fastapi/pull/5126) by [@supraaxdd](https://github.com/supraaxdd).
  * âœ� Fix typos in `docs/en/docs/tutorial/path-params-numeric-validations.md`. PR [#5142](https://github.com/tiangolo/fastapi/pull/5142) by [@invisibleroads](https://github.com/invisibleroads).
  * ğŸ“� Add step about upgrading pip in the venv to avoid errors when installing dependencies `docs/en/docs/contributing.md`. PR [#5181](https://github.com/tiangolo/fastapi/pull/5181) by [@edisnake](https://github.com/edisnake).
  * âœ� Reword and clarify text in tutorial `docs/en/docs/tutorial/body-nested-models.md`. PR [#5169](https://github.com/tiangolo/fastapi/pull/5169) by [@papb](https://github.com/papb).
  * âœ� Fix minor typo in `docs/en/docs/features.md`. PR [#5206](https://github.com/tiangolo/fastapi/pull/5206) by [@OtherBarry](https://github.com/OtherBarry).
  * âœ� Fix minor typos in `docs/en/docs/async.md`. PR [#5125](https://github.com/tiangolo/fastapi/pull/5125) by [@Ksenofanex](https://github.com/Ksenofanex).
  * ğŸ“� Add external link to docs: "Fastapi, Docker(Docker compose) and Postgres". PR [#5033](https://github.com/tiangolo/fastapi/pull/5033) by [@krishnardt](https://github.com/krishnardt).
  * ğŸ“� Simplify example for docs for Additional Responses, remove unnecessary `else`. PR [#4693](https://github.com/tiangolo/fastapi/pull/4693) by [@adriangb](https://github.com/adriangb).
  * ğŸ“� Update docs, compare enums with identity instead of equality. PR [#4905](https://github.com/tiangolo/fastapi/pull/4905) by [@MicaelJarniac](https://github.com/MicaelJarniac).
  * âœ� Fix typo in `docs/en/docs/python-types.md`. PR [#4886](https://github.com/tiangolo/fastapi/pull/4886) by [@MicaelJarniac](https://github.com/MicaelJarniac).
  * ğŸ�¨ Fix syntax highlighting in docs for OpenAPI Callbacks. PR [#4368](https://github.com/tiangolo/fastapi/pull/4368) by [@xncbf](https://github.com/xncbf).
  * âœ� Reword confusing sentence in docs file `typo-fix-path-params-numeric-validations.md`. PR [#3219](https://github.com/tiangolo/fastapi/pull/3219) by [@ccrenfroe](https://github.com/ccrenfroe).
  * ğŸ“� Update docs for handling HTTP Basic Auth with `secrets.compare_digest()` to account for non-ASCII characters. PR [#3536](https://github.com/tiangolo/fastapi/pull/3536) by [@lewoudar](https://github.com/lewoudar).
  * ğŸ“� Update docs for testing, fix examples with relative imports. PR [#5302](https://github.com/tiangolo/fastapi/pull/5302) by [@tiangolo](https://github.com/tiangolo).

### Translations[¶](#translations_65 "Permanent link")

  * ğŸŒ� Add Russian translation for `docs/ru/docs/index.md`. PR [#5289](https://github.com/tiangolo/fastapi/pull/5289) by [@impocode](https://github.com/impocode).
  * ğŸŒ� Add Russian translation for `docs/ru/docs/deployment/versions.md`. PR [#4985](https://github.com/tiangolo/fastapi/pull/4985) by [@emp7yhead](https://github.com/emp7yhead).
  * ğŸŒ� Add Portuguese translation for `docs/pt/docs/tutorial/header-params.md`. PR [#4921](https://github.com/tiangolo/fastapi/pull/4921) by [@batlopes](https://github.com/batlopes).
  * ğŸŒ� Update `ko/mkdocs.yml` for a missing link. PR [#5020](https://github.com/tiangolo/fastapi/pull/5020) by [@dalinaum](https://github.com/dalinaum).

### Internal[¶](#internal_85 "Permanent link")

  * â¬† Bump dawidd6/action-download-artifact from 2.21.1 to 2.22.0. PR [#5258](https://github.com/tiangolo/fastapi/pull/5258) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * â¬† [pre-commit.ci] pre-commit autoupdate. PR [#5196](https://github.com/tiangolo/fastapi/pull/5196) by [@pre-commit-ci[bot]](https://github.com/apps/pre-commit-ci).
  * ğŸ”¥ Delete duplicated tests in `tests/test_tutorial/test_sql_databases/test_sql_databases.py`. PR [#5040](https://github.com/tiangolo/fastapi/pull/5040) by [@raccoonyy](https://github.com/raccoonyy).
  * â™» Simplify internal RegEx in `fastapi/utils.py`. PR [#5057](https://github.com/tiangolo/fastapi/pull/5057) by [@pylounge](https://github.com/pylounge).
  * ğŸ”§ Fix Type hint of `auto_error` which does not need to be `Optional[bool]`. PR [#4933](https://github.com/tiangolo/fastapi/pull/4933) by [@DavidKimDY](https://github.com/DavidKimDY).
  * ğŸ”§ Update mypy config, use `strict = true` instead of manual configs. PR [#4605](https://github.com/tiangolo/fastapi/pull/4605) by [@michaeloliverx](https://github.com/michaeloliverx).
  * â™» Change a `dict()` for `{}` in `fastapi/utils.py`. PR [#3138](https://github.com/tiangolo/fastapi/pull/3138) by [@ShahriyarR](https://github.com/ShahriyarR).
  * â™» Move internal variable for errors in `jsonable_encoder` to put related code closer. PR [#4560](https://github.com/tiangolo/fastapi/pull/4560) by [@GuilleQP](https://github.com/GuilleQP).
  * â™» Simplify conditional assignment in `fastapi/dependencies/utils.py`. PR [#4597](https://github.com/tiangolo/fastapi/pull/4597) by [@cikay](https://github.com/cikay).
  * â¬† Upgrade version pin accepted for Flake8, for internal code, to `flake8 >=3.8.3,<6.0.0`. PR [#4097](https://github.com/tiangolo/fastapi/pull/4097) by [@jamescurtin](https://github.com/jamescurtin).
  * ğŸ�± Update Jina banner, fix typo. PR [#5301](https://github.com/tiangolo/fastapi/pull/5301) by [@tiangolo](https://github.com/tiangolo).

## 0.80.0[¶](#0800 "Permanent link")

### Breaking Changes - Fixes[¶](#breaking-changes-fixes "Permanent link")

  * ğŸ�› Fix `response_model` not invalidating `None`. PR [#2725](https://github.com/tiangolo/fastapi/pull/2725) by [@hukkin](https://github.com/hukkin).

If you are using `response_model` with some type that doesn't include `None` but the function is returning `None`, it will now raise an internal server error, because you are returning invalid data that violates the contract in `response_model`. Before this release it would allow breaking that contract returning `None`.

For example, if you have an app like this:
    
    
    from fastapi import FastAPI
    from pydantic import BaseModel
    
    class Item(BaseModel):
        name: str
        price: Optional[float] = None
        owner_ids: Optional[List[int]] = None
    
    app = FastAPI()
    
    @app.get("/items/invalidnone", response_model=Item)
    def get_invalid_none():
        return None
    

...calling the path `/items/invalidnone` will raise an error, because `None` is not a valid type for the `response_model` declared with `Item`.

You could also be implicitly returning `None` without realizing, for example:
    
    
    from fastapi import FastAPI
    from pydantic import BaseModel
    
    class Item(BaseModel):
        name: str
        price: Optional[float] = None
        owner_ids: Optional[List[int]] = None
    
    app = FastAPI()
    
    @app.get("/items/invalidnone", response_model=Item)
    def get_invalid_none():
        if flag:
            return {"name": "foo"}
        # if flag is False, at this point the function will implicitly return None
    

If you have _path operations_ using `response_model` that need to be allowed to return `None`, make it explicit in `response_model` using `Union[Something, None]`:
    
    
    from typing import Union
    
    from fastapi import FastAPI
    from pydantic import BaseModel
    
    class Item(BaseModel):
        name: str
        price: Optional[float] = None
        owner_ids: Optional[List[int]] = None
    
    app = FastAPI()
    
    @app.get("/items/invalidnone", response_model=Union[Item, None])
    def get_invalid_none():
        return None
    

This way the data will be correctly validated, you won't have an internal server error, and the documentation will also reflect that this _path operation_ could return `None` (or `null` in JSON).

### Fixes[¶](#fixes_55 "Permanent link")

  * â¬† Upgrade Swagger UI copy of `oauth2-redirect.html` to include fixes for flavors of authorization code flows in Swagger UI. PR [#3439](https://github.com/tiangolo/fastapi/pull/3439) initial PR by [@koonpeng](https://github.com/koonpeng).
  * â™» Strip empty whitespace from description extracted from docstrings. PR [#2821](https://github.com/tiangolo/fastapi/pull/2821) by [@and-semakin](https://github.com/and-semakin).
  * ğŸ�› Fix cached dependencies when using a dependency in `Security()` and other places (e.g. `Depends()`) with different OAuth2 scopes. PR [#2945](https://github.com/tiangolo/fastapi/pull/2945) by [@laggardkernel](https://github.com/laggardkernel).
  * ğŸ�¨ Update type annotations for `response_model`, allow things like `Union[str, None]`. PR [#5294](https://github.com/tiangolo/fastapi/pull/5294) by [@tiangolo](https://github.com/tiangolo).

### Translations[¶](#translations_66 "Permanent link")

  * ğŸŒ� Fix typos in German translation for `docs/de/docs/features.md`. PR [#4533](https://github.com/tiangolo/fastapi/pull/4533) by [@0xflotus](https://github.com/0xflotus).
  * ğŸŒ� Add missing navigator for `encoder.md` in Korean translation. PR [#5238](https://github.com/tiangolo/fastapi/pull/5238) by [@joonas-yoon](https://github.com/joonas-yoon).
  * (Empty PR merge by accident) [#4913](https://github.com/tiangolo/fastapi/pull/4913).

## 0.79.1[¶](#0791 "Permanent link")

### Fixes[¶](#fixes_56 "Permanent link")

  * ğŸ�› Fix `jsonable_encoder` using `include` and `exclude` parameters for non-Pydantic objects. PR [#2606](https://github.com/tiangolo/fastapi/pull/2606) by [@xaviml](https://github.com/xaviml).
  * ğŸ�› Fix edge case with repeated aliases names not shown in OpenAPI. PR [#2351](https://github.com/tiangolo/fastapi/pull/2351) by [@klaa97](https://github.com/klaa97).
  * ğŸ“� Add misc dependency installs to tutorial docs. PR [#2126](https://github.com/tiangolo/fastapi/pull/2126) by [@TeoZosa](https://github.com/TeoZosa).

### Docs[¶](#docs_73 "Permanent link")

  * ğŸ“� Add note giving credit for illustrations to [Ketrina Thompson](https://www.instagram.com/ketrinadrawsalot/). PR [#5284](https://github.com/tiangolo/fastapi/pull/5284) by [@tiangolo](https://github.com/tiangolo).
  * âœ� Fix typo in `python-types.md`. PR [#5116](https://github.com/tiangolo/fastapi/pull/5116) by [@Kludex](https://github.com/Kludex).
  * âœ� Fix typo in `docs/en/docs/python-types.md`. PR [#5007](https://github.com/tiangolo/fastapi/pull/5007) by [@atiabbz](https://github.com/atiabbz).
  * ğŸ“� Remove unneeded Django/Flask references from async topic intro. PR [#5280](https://github.com/tiangolo/fastapi/pull/5280) by [@carltongibson](https://github.com/carltongibson).
  * âœ¨ Add illustrations for Concurrent burgers and Parallel burgers. PR [#5277](https://github.com/tiangolo/fastapi/pull/5277) by [@tiangolo](https://github.com/tiangolo). Updated docs at: [Concurrency and Burgers](https://fastapi.tiangolo.com/async/#concurrency-and-burgers).

### Translations[¶](#translations_67 "Permanent link")

  * ğŸŒ� Add Portuguese translation for `docs/pt/docs/tutorial/query-params.md`. PR [#4775](https://github.com/tiangolo/fastapi/pull/4775) by [@batlopes](https://github.com/batlopes).
  * ğŸŒ� Add Portuguese translation for `docs/pt/docs/tutorial/security/first-steps.md`. PR [#4954](https://github.com/tiangolo/fastapi/pull/4954) by [@FLAIR7](https://github.com/FLAIR7).
  * ğŸŒ� Add translation for `docs/zh/docs/advanced/response-cookies.md`. PR [#4638](https://github.com/tiangolo/fastapi/pull/4638) by [@zhangbo2012](https://github.com/zhangbo2012).
  * ğŸŒ� Add French translation for `docs/fr/docs/deployment/index.md`. PR [#3689](https://github.com/tiangolo/fastapi/pull/3689) by [@rjNemo](https://github.com/rjNemo).
  * ğŸŒ� Add Portuguese translation for `tutorial/handling-errors.md`. PR [#4769](https://github.com/tiangolo/fastapi/pull/4769) by [@frnsimoes](https://github.com/frnsimoes).
  * ğŸŒ� Add French translation for `docs/fr/docs/history-design-future.md`. PR [#3451](https://github.com/tiangolo/fastapi/pull/3451) by [@rjNemo](https://github.com/rjNemo).
  * ğŸŒ� Add Russian translation for `docs/ru/docs/tutorial/background-tasks.md`. PR [#4854](https://github.com/tiangolo/fastapi/pull/4854) by [@AdmiralDesu](https://github.com/AdmiralDesu).
  * ğŸŒ� Add Chinese translation for `docs/tutorial/security/first-steps.md`. PR [#3841](https://github.com/tiangolo/fastapi/pull/3841) by [@jaystone776](https://github.com/jaystone776).
  * ğŸŒ� Add Japanese translation for `docs/ja/docs/advanced/nosql-databases.md`. PR [#4205](https://github.com/tiangolo/fastapi/pull/4205) by [@sUeharaE4](https://github.com/sUeharaE4).
  * ğŸŒ� Add Indonesian translation for `docs/id/docs/tutorial/index.md`. PR [#4705](https://github.com/tiangolo/fastapi/pull/4705) by [@bas-baskara](https://github.com/bas-baskara).
  * ğŸŒ� Add Persian translation for `docs/fa/docs/index.md` and tweak right-to-left CSS. PR [#2395](https://github.com/tiangolo/fastapi/pull/2395) by [@mohsen-mahmoodi](https://github.com/mohsen-mahmoodi).

### Internal[¶](#internal_86 "Permanent link")

  * ğŸ”§ Update Jina sponsorship. PR [#5283](https://github.com/tiangolo/fastapi/pull/5283) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”§ Update Jina sponsorship. PR [#5272](https://github.com/tiangolo/fastapi/pull/5272) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”§ Update sponsors, Striveworks badge. PR [#5179](https://github.com/tiangolo/fastapi/pull/5179) by [@tiangolo](https://github.com/tiangolo).

## 0.79.0[¶](#0790 "Permanent link")

### Fixes - Breaking Changes[¶](#fixes-breaking-changes "Permanent link")

  * ğŸ�› Fix removing body from status codes that do not support it. PR [#5145](https://github.com/tiangolo/fastapi/pull/5145) by [@tiangolo](https://github.com/tiangolo).
    * Setting `status_code` to `204`, `304`, or any code below `200` (1xx) will remove the body from the response.
    * This fixes an error in Uvicorn that otherwise would be thrown: `RuntimeError: Response content longer than Content-Length`.
    * This removes `fastapi.openapi.constants.STATUS_CODES_WITH_NO_BODY`, it is replaced by a function in utils.

### Translations[¶](#translations_68 "Permanent link")

  * ğŸŒ� Start of Hebrew translation. PR [#5050](https://github.com/tiangolo/fastapi/pull/5050) by [@itay-raveh](https://github.com/itay-raveh).
  * ğŸ”§ Add config for Swedish translations notification. PR [#5147](https://github.com/tiangolo/fastapi/pull/5147) by [@tiangolo](https://github.com/tiangolo).
  * ğŸŒ� Start of Swedish translation. PR [#5062](https://github.com/tiangolo/fastapi/pull/5062) by [@MrRawbin](https://github.com/MrRawbin).
  * ğŸŒ� Add Japanese translation for `docs/ja/docs/advanced/index.md`. PR [#5043](https://github.com/tiangolo/fastapi/pull/5043) by [@wakabame](https://github.com/wakabame).
  * ğŸŒ�ğŸ‡µğŸ‡± Add Polish translation for `docs/pl/docs/tutorial/first-steps.md`. PR [#5024](https://github.com/tiangolo/fastapi/pull/5024) by [@Valaraucoo](https://github.com/Valaraucoo).

### Internal[¶](#internal_87 "Permanent link")

  * ğŸ”§ Update translations notification for Hebrew. PR [#5158](https://github.com/tiangolo/fastapi/pull/5158) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”§ Update Dependabot commit message. PR [#5156](https://github.com/tiangolo/fastapi/pull/5156) by [@tiangolo](https://github.com/tiangolo).
  * â¬† Bump actions/upload-artifact from 2 to 3. PR [#5148](https://github.com/tiangolo/fastapi/pull/5148) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * â¬† Bump actions/cache from 2 to 3. PR [#5149](https://github.com/tiangolo/fastapi/pull/5149) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * ğŸ”§ Update sponsors badge configs. PR [#5155](https://github.com/tiangolo/fastapi/pull/5155) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘¥ Update FastAPI People. PR [#5154](https://github.com/tiangolo/fastapi/pull/5154) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”§ Update Jina sponsor badges. PR [#5151](https://github.com/tiangolo/fastapi/pull/5151) by [@tiangolo](https://github.com/tiangolo).
  * â¬† Bump actions/checkout from 2 to 3. PR [#5133](https://github.com/tiangolo/fastapi/pull/5133) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * â¬† [pre-commit.ci] pre-commit autoupdate. PR [#5030](https://github.com/tiangolo/fastapi/pull/5030) by [@pre-commit-ci[bot]](https://github.com/apps/pre-commit-ci).
  * â¬† Bump nwtgck/actions-netlify from 1.1.5 to 1.2.3. PR [#5132](https://github.com/tiangolo/fastapi/pull/5132) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * â¬† Bump codecov/codecov-action from 2 to 3. PR [#5131](https://github.com/tiangolo/fastapi/pull/5131) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * â¬† Bump dawidd6/action-download-artifact from 2.9.0 to 2.21.1. PR [#5130](https://github.com/tiangolo/fastapi/pull/5130) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * â¬† Bump actions/setup-python from 2 to 4. PR [#5129](https://github.com/tiangolo/fastapi/pull/5129) by [@dependabot[bot]](https://github.com/apps/dependabot).
  * ğŸ‘· Add Dependabot. PR [#5128](https://github.com/tiangolo/fastapi/pull/5128) by [@tiangolo](https://github.com/tiangolo).
  * â™»ï¸� Move from `Optional[X]` to `Union[X, None]` for internal utils. PR [#5124](https://github.com/tiangolo/fastapi/pull/5124) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”§ Update sponsors, remove Dropbase, add Doist. PR [#5096](https://github.com/tiangolo/fastapi/pull/5096) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”§ Update sponsors, remove Classiq, add ImgWhale. PR [#5079](https://github.com/tiangolo/fastapi/pull/5079) by [@tiangolo](https://github.com/tiangolo).

## 0.78.0[¶](#0780 "Permanent link")

### Features[¶](#features_33 "Permanent link")

  * âœ¨ Add support for omitting `...` as default value when declaring required parameters with:

  * `Path()`

  * `Query()`
  * `Header()`
  * `Cookie()`
  * `Body()`
  * `Form()`
  * `File()`

New docs at [Tutorial - Query Parameters and String Validations - Make it required](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#make-it-required). PR [#4906](https://github.com/tiangolo/fastapi/pull/4906) by [@tiangolo](https://github.com/tiangolo).

Up to now, declaring a required parameter while adding additional validation or metadata needed using `...` (Ellipsis).

For example:
    
    
    from fastapi import Cookie, FastAPI, Header, Path, Query
    
    app = FastAPI()
    
    
    @app.get("/items/{item_id}")
    def main(
        item_id: int = Path(default=..., gt=0),
        query: str = Query(default=..., max_length=10),
        session: str = Cookie(default=..., min_length=3),
        x_trace: str = Header(default=..., title="Tracing header"),
    ):
        return {"message": "Hello World"}
    

...all these parameters are required because the default value is `...` (Ellipsis).

But now it's possible and supported to just omit the default value, as would be done with Pydantic fields, and the parameters would still be required.

âœ¨ For example, this is now supported:
    
    
    from fastapi import Cookie, FastAPI, Header, Path, Query
    
    app = FastAPI()
    
    
    @app.get("/items/{item_id}")
    def main(
        item_id: int = Path(gt=0),
        query: str = Query(max_length=10),
        session: str = Cookie(min_length=3),
        x_trace: str = Header(title="Tracing header"),
    ):
        return {"message": "Hello World"}
    

To declare parameters as optional (not required), you can set a default value as always, for example using `None`:
    
    
    from typing import Union
    from fastapi import Cookie, FastAPI, Header, Path, Query
    
    app = FastAPI()
    
    
    @app.get("/items/{item_id}")
    def main(
        item_id: int = Path(gt=0),
        query: Union[str, None] = Query(default=None, max_length=10),
        session: Union[str, None] = Cookie(default=None, min_length=3),
        x_trace: Union[str, None] = Header(default=None, title="Tracing header"),
    ):
        return {"message": "Hello World"}
    

### Docs[¶](#docs_74 "Permanent link")

  * ğŸ“� Add docs recommending `Union` over `Optional` and migrate source examples. New docs at [Python Types Intro - Using `Union` or `Optional`](https://fastapi.tiangolo.com/python-types/#using-union-or-optional). PR [#4908](https://github.com/tiangolo/fastapi/pull/4908) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ�¨ Fix default value as set in tutorial for Path Operations Advanced Configurations. PR [#4899](https://github.com/tiangolo/fastapi/pull/4899) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ“� Add documentation for redefined path operations. PR [#4864](https://github.com/tiangolo/fastapi/pull/4864) by [@madkinsz](https://github.com/madkinsz).
  * ğŸ“� Updates links for Celery documentation. PR [#4736](https://github.com/tiangolo/fastapi/pull/4736) by [@sammyzord](https://github.com/sammyzord).
  * âœ� Fix example code with sets in tutorial for body nested models. PR [#3030](https://github.com/tiangolo/fastapi/pull/3030) by [@hitrust](https://github.com/hitrust).
  * âœ� Fix links to Pydantic docs. PR [#4670](https://github.com/tiangolo/fastapi/pull/4670) by [@kinuax](https://github.com/kinuax).
  * ğŸ“� Update docs about Swagger UI self-hosting with newer source links. PR [#4813](https://github.com/tiangolo/fastapi/pull/4813) by [@Kastakin](https://github.com/Kastakin).
  * ğŸ“� Add link to external article: Building the Poll App From Django Tutorial With FastAPI And React. PR [#4778](https://github.com/tiangolo/fastapi/pull/4778) by [@jbrocher](https://github.com/jbrocher).
  * ğŸ“� Add OpenAPI warning to "Body - Fields" docs with extra schema extensions. PR [#4846](https://github.com/tiangolo/fastapi/pull/4846) by [@ml-evs](https://github.com/ml-evs).

### Translations[¶](#translations_69 "Permanent link")

  * ğŸŒ� Fix code examples in Japanese translation for `docs/ja/docs/tutorial/testing.md`. PR [#4623](https://github.com/tiangolo/fastapi/pull/4623) by [@hirotoKirimaru](https://github.com/hirotoKirimaru).

### Internal[¶](#internal_88 "Permanent link")

  * â™» Refactor dict value extraction to minimize key lookups `fastapi/utils.py`. PR [#3139](https://github.com/tiangolo/fastapi/pull/3139) by [@ShahriyarR](https://github.com/ShahriyarR).
  * âœ… Add tests for required nonable parameters and body fields. PR [#4907](https://github.com/tiangolo/fastapi/pull/4907) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘· Fix installing Material for MkDocs Insiders in CI. PR [#4897](https://github.com/tiangolo/fastapi/pull/4897) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘· Add pre-commit CI instead of custom GitHub Action. PR [#4896](https://github.com/tiangolo/fastapi/pull/4896) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘· Add pre-commit GitHub Action workflow. PR [#4895](https://github.com/tiangolo/fastapi/pull/4895) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ“� Add dark mode auto switch to docs based on OS preference. PR [#4869](https://github.com/tiangolo/fastapi/pull/4869) by [@ComicShrimp](https://github.com/ComicShrimp).
  * ğŸ”¥ Remove un-used old pending tests, already covered in other places. PR [#4891](https://github.com/tiangolo/fastapi/pull/4891) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”§ Add Python formatting hooks to pre-commit. PR [#4890](https://github.com/tiangolo/fastapi/pull/4890) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”§ Add pre-commit with first config and first formatting pass. PR [#4888](https://github.com/tiangolo/fastapi/pull/4888) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘· Disable CI installing Material for MkDocs in forks. PR [#4410](https://github.com/tiangolo/fastapi/pull/4410) by [@dolfinus](https://github.com/dolfinus).

## 0.77.1[¶](#0771 "Permanent link")

### Upgrades[¶](#upgrades_29 "Permanent link")

  * â¬† Upgrade Starlette from 0.19.0 to 0.19.1. PR [#4819](https://github.com/tiangolo/fastapi/pull/4819) by [@Kludex](https://github.com/Kludex).

### Docs[¶](#docs_75 "Permanent link")

  * ğŸ“� Add link to german article: REST-API Programmieren mittels Python und dem FastAPI Modul. PR [#4624](https://github.com/tiangolo/fastapi/pull/4624) by [@fschuermeyer](https://github.com/fschuermeyer).
  * ğŸ“� Add external link: PyCharm Guide to FastAPI. PR [#4512](https://github.com/tiangolo/fastapi/pull/4512) by [@mukulmantosh](https://github.com/mukulmantosh).
  * ğŸ“� Add external link to article: Building an API with FastAPI and Supabase and Deploying on Deta. PR [#4440](https://github.com/tiangolo/fastapi/pull/4440) by [@aUnicornDev](https://github.com/aUnicornDev).
  * âœ� Fix small typo in `docs/en/docs/tutorial/security/first-steps.md`. PR [#4515](https://github.com/tiangolo/fastapi/pull/4515) by [@KikoIlievski](https://github.com/KikoIlievski).

### Translations[¶](#translations_70 "Permanent link")

  * ğŸŒ� Add Polish translation for `docs/pl/docs/tutorial/index.md`. PR [#4516](https://github.com/tiangolo/fastapi/pull/4516) by [@MKaczkow](https://github.com/MKaczkow).
  * âœ� Fix typo in deployment. PR [#4629](https://github.com/tiangolo/fastapi/pull/4629) by [@raisulislam541](https://github.com/raisulislam541).
  * ğŸŒ� Add Portuguese translation for `docs/pt/docs/help-fastapi.md`. PR [#4583](https://github.com/tiangolo/fastapi/pull/4583) by [@mateusjs](https://github.com/mateusjs).

### Internal[¶](#internal_89 "Permanent link")

  * ğŸ”§ Add notifications in issue for Uzbek translations. PR [#4884](https://github.com/tiangolo/fastapi/pull/4884) by [@tiangolo](https://github.com/tiangolo).

## 0.77.0[¶](#0770 "Permanent link")

### Upgrades[¶](#upgrades_30 "Permanent link")

  * â¬† Upgrade Starlette from 0.18.0 to 0.19.0. PR [#4488](https://github.com/tiangolo/fastapi/pull/4488) by [@Kludex](https://github.com/Kludex).
    * When creating an explicit `JSONResponse` the `content` argument is now required.

### Docs[¶](#docs_76 "Permanent link")

  * ğŸ“� Add external link to article: Seamless FastAPI Configuration with ConfZ. PR [#4414](https://github.com/tiangolo/fastapi/pull/4414) by [@silvanmelchior](https://github.com/silvanmelchior).
  * ğŸ“� Add external link to article: 5 Advanced Features of FastAPI You Should Try. PR [#4436](https://github.com/tiangolo/fastapi/pull/4436) by [@kaustubhgupta](https://github.com/kaustubhgupta).
  * âœ� Reword to improve legibility of docs about `TestClient`. PR [#4389](https://github.com/tiangolo/fastapi/pull/4389) by [@rgilton](https://github.com/rgilton).
  * ğŸ“� Add external link to blog post about Kafka, FastAPI, and Ably. PR [#4044](https://github.com/tiangolo/fastapi/pull/4044) by [@Ugbot](https://github.com/Ugbot).
  * âœ� Fix typo in `docs/en/docs/tutorial/sql-databases.md`. PR [#4875](https://github.com/tiangolo/fastapi/pull/4875) by [@wpyoga](https://github.com/wpyoga).
  * âœ� Fix typo in `docs/en/docs/async.md`. PR [#4726](https://github.com/tiangolo/fastapi/pull/4726) by [@Prezu](https://github.com/Prezu).

### Translations[¶](#translations_71 "Permanent link")

  * ğŸŒ� Update source example highlights for `docs/zh/docs/tutorial/query-params-str-validations.md`. PR [#4237](https://github.com/tiangolo/fastapi/pull/4237) by [@caimaoy](https://github.com/caimaoy).
  * ğŸŒ� Remove translation docs references to aiofiles as it's no longer needed since AnyIO. PR [#3594](https://github.com/tiangolo/fastapi/pull/3594) by [@alonme](https://github.com/alonme).
  * âœ� ğŸŒ� Fix typo in Portuguese translation for `docs/pt/docs/tutorial/path-params.md`. PR [#4722](https://github.com/tiangolo/fastapi/pull/4722) by [@CleoMenezesJr](https://github.com/CleoMenezesJr).
  * ğŸŒ� Fix live docs server for translations for some languages. PR [#4729](https://github.com/tiangolo/fastapi/pull/4729) by [@wakabame](https://github.com/wakabame).
  * ğŸŒ� Add Portuguese translation for `docs/pt/docs/tutorial/cookie-params.md`. PR [#4112](https://github.com/tiangolo/fastapi/pull/4112) by [@lbmendes](https://github.com/lbmendes).
  * ğŸŒ� Fix French translation for `docs/tutorial/body.md`. PR [#4332](https://github.com/tiangolo/fastapi/pull/4332) by [@Smlep](https://github.com/Smlep).
  * ğŸŒ� Add Japanese translation for `docs/ja/docs/advanced/conditional-openapi.md`. PR [#2631](https://github.com/tiangolo/fastapi/pull/2631) by [@sh0nk](https://github.com/sh0nk).
  * ğŸŒ� Fix Japanese translation of `docs/ja/docs/tutorial/body.md`. PR [#3062](https://github.com/tiangolo/fastapi/pull/3062) by [@a-takahashi223](https://github.com/a-takahashi223).
  * ğŸŒ� Add Portuguese translation for `docs/pt/docs/tutorial/background-tasks.md`. PR [#2170](https://github.com/tiangolo/fastapi/pull/2170) by [@izaguerreiro](https://github.com/izaguerreiro).
  * ğŸŒ� Add Portuguese translation for `docs/deployment/deta.md`. PR [#4442](https://github.com/tiangolo/fastapi/pull/4442) by [@lsglucas](https://github.com/lsglucas).
  * ğŸŒ� Add Russian translation for `docs/async.md`. PR [#4036](https://github.com/tiangolo/fastapi/pull/4036) by [@Winand](https://github.com/Winand).
  * ğŸŒ� Add Portuguese translation for `docs/tutorial/body.md`. PR [#3960](https://github.com/tiangolo/fastapi/pull/3960) by [@leandrodesouzadev](https://github.com/leandrodesouzadev).
  * ğŸŒ� Add Portuguese translation of `tutorial/extra-data-types.md`. PR [#4077](https://github.com/tiangolo/fastapi/pull/4077) by [@luccasmmg](https://github.com/luccasmmg).
  * ğŸŒ� Update German translation for `docs/features.md`. PR [#3905](https://github.com/tiangolo/fastapi/pull/3905) by [@jomue](https://github.com/jomue).

## 0.76.0[¶](#0760 "Permanent link")

### Upgrades[¶](#upgrades_31 "Permanent link")

  * â¬† Upgrade Starlette from 0.17.1 to 0.18.0. PR [#4483](https://github.com/tiangolo/fastapi/pull/4483) by [@Kludex](https://github.com/Kludex).

### Internal[¶](#internal_90 "Permanent link")

  * ğŸ‘¥ Update FastAPI People. PR [#4847](https://github.com/tiangolo/fastapi/pull/4847) by [@github-actions[bot]](https://github.com/apps/github-actions).
  * ğŸ”§ Add Budget Insight sponsor. PR [#4824](https://github.com/tiangolo/fastapi/pull/4824) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ�± Update sponsor, ExoFlare badge. PR [#4822](https://github.com/tiangolo/fastapi/pull/4822) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”§ Update sponsors, enable Dropbase again, update TalkPython link. PR [#4821](https://github.com/tiangolo/fastapi/pull/4821) by [@tiangolo](https://github.com/tiangolo).

## 0.75.2[¶](#0752 "Permanent link")

This release includes upgrades to third-party packages that handle security issues. Although there's a chance these issues don't affect you in particular, please upgrade as soon as possible.

### Fixes[¶](#fixes_57 "Permanent link")

  * âœ… Fix new/recent tests with new fixed `ValidationError` JSON Schema. PR [#4806](https://github.com/tiangolo/fastapi/pull/4806) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ�› Fix JSON Schema for `ValidationError` at field `loc`. PR [#3810](https://github.com/tiangolo/fastapi/pull/3810) by [@dconathan](https://github.com/dconathan).
  * ğŸ�› Fix support for prefix on APIRouter WebSockets. PR [#2640](https://github.com/tiangolo/fastapi/pull/2640) by [@Kludex](https://github.com/Kludex).

### Upgrades[¶](#upgrades_32 "Permanent link")

  * â¬†ï¸� Update ujson ranges for CVE-2021-45958. PR [#4804](https://github.com/tiangolo/fastapi/pull/4804) by [@tiangolo](https://github.com/tiangolo).
  * â¬†ï¸� Upgrade dependencies upper range for extras "all". PR [#4803](https://github.com/tiangolo/fastapi/pull/4803) by [@tiangolo](https://github.com/tiangolo).
  * â¬† Upgrade Swagger UI - swagger-ui-dist@4. This handles a security issue in Swagger UI itself where it could be possible to inject HTML into Swagger UI. Please upgrade as soon as you can, in particular if you expose your Swagger UI (`/docs`) publicly to non-expert users. PR [#4347](https://github.com/tiangolo/fastapi/pull/4347) by [@RAlanWright](https://github.com/RAlanWright).

### Internal[¶](#internal_91 "Permanent link")

  * ğŸ”§ Update sponsors, add: ExoFlare, Ines Course; remove: Dropbase, Vim.so, Calmcode; update: Striveworks, TalkPython and TestDriven.io. PR [#4805](https://github.com/tiangolo/fastapi/pull/4805) by [@tiangolo](https://github.com/tiangolo).
  * â¬†ï¸� Upgrade Codecov GitHub Action. PR [#4801](https://github.com/tiangolo/fastapi/pull/4801) by [@tiangolo](https://github.com/tiangolo).

## 0.75.1[¶](#0751 "Permanent link")

### Translations[¶](#translations_72 "Permanent link")

  * ğŸŒ� Start Dutch translations. PR [#4703](https://github.com/tiangolo/fastapi/pull/4703) by [@tiangolo](https://github.com/tiangolo).
  * ğŸŒ� Start Persian/Farsi translations. PR [#4243](https://github.com/tiangolo/fastapi/pull/4243) by [@aminalaee](https://github.com/aminalaee).
  * âœ� Reword sentence about handling errors. PR [#1993](https://github.com/tiangolo/fastapi/pull/1993) by [@khuhroproeza](https://github.com/khuhroproeza).

### Internal[¶](#internal_92 "Permanent link")

  * ğŸ‘¥ Update FastAPI People. PR [#4752](https://github.com/tiangolo/fastapi/pull/4752) by [@github-actions[bot]](https://github.com/apps/github-actions).
  * â�– Temporarily remove typer-cli from dependencies and upgrade Black to unblock Pydantic CI. PR [#4754](https://github.com/tiangolo/fastapi/pull/4754) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”§ Add configuration to notify Dutch translations. PR [#4702](https://github.com/tiangolo/fastapi/pull/4702) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘¥ Update FastAPI People. PR [#4699](https://github.com/tiangolo/fastapi/pull/4699) by [@github-actions[bot]](https://github.com/apps/github-actions).
  * ğŸ�› Fix FastAPI People generation to include missing file in commit. PR [#4695](https://github.com/tiangolo/fastapi/pull/4695) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”§ Update Classiq sponsor links. PR [#4688](https://github.com/tiangolo/fastapi/pull/4688) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”§ Add Classiq sponsor. PR [#4671](https://github.com/tiangolo/fastapi/pull/4671) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ“� Add Jina's QA Bot to the docs to help people that want to ask quick questions. PR [#4655](https://github.com/tiangolo/fastapi/pull/4655) by [@tiangolo](https://github.com/tiangolo) based on original PR [#4626](https://github.com/tiangolo/fastapi/pull/4626) by [@hanxiao](https://github.com/hanxiao).

## 0.75.0[¶](#0750 "Permanent link")

### Features[¶](#features_34 "Permanent link")

  * âœ¨ Add support for custom `generate_unique_id_function` and docs for generating clients. New docs: [Advanced - Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/). PR [#4650](https://github.com/tiangolo/fastapi/pull/4650) by [@tiangolo](https://github.com/tiangolo).

## 0.74.1[¶](#0741 "Permanent link")

### Features[¶](#features_35 "Permanent link")

  * âœ¨ Include route in scope to allow middleware and other tools to extract its information. PR [#4603](https://github.com/tiangolo/fastapi/pull/4603) by [@tiangolo](https://github.com/tiangolo).

## 0.74.0[¶](#0740 "Permanent link")

### Breaking Changes[¶](#breaking-changes_7 "Permanent link")

  * âœ¨ Update internal `AsyncExitStack` to fix context for dependencies with `yield`. PR [#4575](https://github.com/tiangolo/fastapi/pull/4575) by [@tiangolo](https://github.com/tiangolo).

Dependencies with `yield` can now catch `HTTPException` and custom exceptions. For example:
    
    
    async def get_database():
        with Session() as session:
            try:
                yield session
            except HTTPException:
                session.rollback()
                raise
            finally:
                session.close()
    

After the dependency with `yield` handles the exception (or not) the exception is raised again. So that any exception handlers can catch it, or ultimately the default internal `ServerErrorMiddleware`.

If you depended on exceptions not being received by dependencies with `yield`, and receiving an exception breaks the code after `yield`, you can use a block with `try` and `finally`:
    
    
    async def do_something():
        try:
            yield something
        finally:
            some_cleanup()
    

...that way the `finally` block is run regardless of any exception that might happen.

### Features[¶](#features_36 "Permanent link")

  * The same PR [#4575](https://github.com/tiangolo/fastapi/pull/4575) from above also fixes the `contextvars` context for the code before and after `yield`. This was the main objective of that PR.

This means that now, if you set a value in a context variable before `yield`, the value would still be available after `yield` (as you would intuitively expect). And it also means that you can reset the context variable with a token afterwards.

For example, this works correctly now:
    
    
    from contextvars import ContextVar
    from typing import Any, Dict, Optional
    
    
    legacy_request_state_context_var: ContextVar[Optional[Dict[str, Any]]] = ContextVar(
        "legacy_request_state_context_var", default=None
    )
    
    async def set_up_request_state_dependency():
        request_state = {"user": "deadpond"}
        contextvar_token = legacy_request_state_context_var.set(request_state)
        yield request_state
        legacy_request_state_context_var.reset(contextvar_token)
    

...before this change it would raise an error when resetting the context variable, because the `contextvars` context was different, because of the way it was implemented.

**Note** : You probably don't need `contextvars`, and you should probably avoid using them. But they are powerful and useful in some advanced scenarios, for example, migrating from code that used Flask's `g` semi-global variable.

**Technical Details** : If you want to know more of the technical details you can check out the PR description [#4575](https://github.com/tiangolo/fastapi/pull/4575).

### Internal[¶](#internal_93 "Permanent link")

  * ğŸ”§ Add Striveworks sponsor. PR [#4596](https://github.com/tiangolo/fastapi/pull/4596) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ’š Only build docs on push when on master to avoid duplicate runs from PRs. PR [#4564](https://github.com/tiangolo/fastapi/pull/4564) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘¥ Update FastAPI People. PR [#4502](https://github.com/tiangolo/fastapi/pull/4502) by [@github-actions[bot]](https://github.com/apps/github-actions).

## 0.73.0[¶](#0730 "Permanent link")

### Features[¶](#features_37 "Permanent link")

  * âœ¨ Add support for declaring `UploadFile` parameters without explicit `File()`. PR [#4469](https://github.com/tiangolo/fastapi/pull/4469) by [@tiangolo](https://github.com/tiangolo). New docs: [Request Files - File Parameters with UploadFile](https://fastapi.tiangolo.com/tutorial/request-files/#file-parameters-with-uploadfile).
  * âœ¨ Add support for tags with Enums. PR [#4468](https://github.com/tiangolo/fastapi/pull/4468) by [@tiangolo](https://github.com/tiangolo). New docs: [Path Operation Configuration - Tags with Enums](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags-with-enums).
  * âœ¨ Allow hiding from OpenAPI (and Swagger UI) `Query`, `Cookie`, `Header`, and `Path` parameters. PR [#3144](https://github.com/tiangolo/fastapi/pull/3144) by [@astraldawn](https://github.com/astraldawn). New docs: [Query Parameters and String Validations - Exclude from OpenAPI](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-from-openapi).

### Docs[¶](#docs_77 "Permanent link")

  * ğŸ“� Tweak and improve docs for Request Files. PR [#4470](https://github.com/tiangolo/fastapi/pull/4470) by [@tiangolo](https://github.com/tiangolo).

### Fixes[¶](#fixes_58 "Permanent link")

  * ğŸ�› Fix bug preventing to use OpenAPI when using tuples. PR [#3874](https://github.com/tiangolo/fastapi/pull/3874) by [@victorbenichoux](https://github.com/victorbenichoux).
  * ğŸ�› Prefer custom encoder over defaults if specified in `jsonable_encoder`. PR [#2061](https://github.com/tiangolo/fastapi/pull/2061) by [@viveksunder](https://github.com/viveksunder).
    * ğŸ’š Duplicate PR to trigger CI. PR [#4467](https://github.com/tiangolo/fastapi/pull/4467) by [@tiangolo](https://github.com/tiangolo).

### Internal[¶](#internal_94 "Permanent link")

  * ğŸ�› Fix docs dependencies cache, to get the latest Material for MkDocs. PR [#4466](https://github.com/tiangolo/fastapi/pull/4466) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”§ Add sponsor Dropbase. PR [#4465](https://github.com/tiangolo/fastapi/pull/4465) by [@tiangolo](https://github.com/tiangolo).

## 0.72.0[¶](#0720 "Permanent link")

### Features[¶](#features_38 "Permanent link")

  * âœ¨ Enable configuring Swagger UI parameters. Original PR [#2568](https://github.com/tiangolo/fastapi/pull/2568) by [@jmriebold](https://github.com/jmriebold). Here are the new docs: [Configuring Swagger UI](https://fastapi.tiangolo.com/advanced/extending-openapi/#configuring-swagger-ui).

### Docs[¶](#docs_78 "Permanent link")

  * ğŸ“� Update Python Types docs, add missing 3.6 / 3.9 example. PR [#4434](https://github.com/tiangolo/fastapi/pull/4434) by [@tiangolo](https://github.com/tiangolo).

### Translations[¶](#translations_73 "Permanent link")

  * ğŸŒ� Update Chinese translation for `docs/help-fastapi.md`. PR [#3847](https://github.com/tiangolo/fastapi/pull/3847) by [@jaystone776](https://github.com/jaystone776).
  * ğŸŒ� Fix Korean translation for `docs/ko/docs/index.md`. PR [#4195](https://github.com/tiangolo/fastapi/pull/4195) by [@kty4119](https://github.com/kty4119).
  * ğŸŒ� Add Polish translation for `docs/pl/docs/index.md`. PR [#4245](https://github.com/tiangolo/fastapi/pull/4245) by [@MicroPanda123](https://github.com/MicroPanda123).
  * ğŸŒ� Add Chinese translation for `docs\tutorial\path-operation-configuration.md`. PR [#3312](https://github.com/tiangolo/fastapi/pull/3312) by [@jaystone776](https://github.com/jaystone776).

### Internal[¶](#internal_95 "Permanent link")

  * ğŸ”§ Enable MkDocs Material Insiders' `content.tabs.link`. PR [#4399](https://github.com/tiangolo/fastapi/pull/4399) by [@tiangolo](https://github.com/tiangolo).

## 0.71.0[¶](#0710 "Permanent link")

### Features[¶](#features_39 "Permanent link")

  * âœ¨ Add docs and tests for Python 3.9 and Python 3.10. PR [#3712](https://github.com/tiangolo/fastapi/pull/3712) by [@tiangolo](https://github.com/tiangolo).
    * You can start with [Python Types Intro](https://fastapi.tiangolo.com/python-types/), it explains what changes between different Python versions, in Python 3.9 and in Python 3.10.
    * All the FastAPI docs are updated. Each code example in the docs that could use different syntax in Python 3.9 or Python 3.10 now has all the alternatives in tabs.
  * â¬†ï¸� Upgrade Starlette to 0.17.1. PR [#4145](https://github.com/tiangolo/fastapi/pull/4145) by [@simondale00](https://github.com/simondale00).

### Internal[¶](#internal_96 "Permanent link")

  * ğŸ‘¥ Update FastAPI People. PR [#4354](https://github.com/tiangolo/fastapi/pull/4354) by [@github-actions[bot]](https://github.com/apps/github-actions).
  * ğŸ”§ Add FastAPI Trove Classifier for PyPI as now there's one ğŸ¤·ğŸ˜�. PR [#4386](https://github.com/tiangolo/fastapi/pull/4386) by [@tiangolo](https://github.com/tiangolo).
  * â¬† Upgrade MkDocs Material and configs. PR [#4385](https://github.com/tiangolo/fastapi/pull/4385) by [@tiangolo](https://github.com/tiangolo).

## 0.70.1[¶](#0701 "Permanent link")

There's nothing interesting in this particular FastAPI release. It is mainly to enable/unblock the release of the next version of Pydantic that comes packed with features and improvements. ğŸ¤©

### Fixes[¶](#fixes_59 "Permanent link")

  * ğŸ�› Fix JSON Schema for dataclasses, supporting the fixes in Pydantic 1.9. PR [#4272](https://github.com/tiangolo/fastapi/pull/4272) by [@PrettyWood](https://github.com/PrettyWood).

### Translations[¶](#translations_74 "Permanent link")

  * ğŸŒ� Add Korean translation for `docs/tutorial/request-forms-and-files.md`. PR [#3744](https://github.com/tiangolo/fastapi/pull/3744) by [@NinaHwang](https://github.com/NinaHwang).
  * ğŸŒ� Add Korean translation for `docs/tutorial/request-files.md`. PR [#3743](https://github.com/tiangolo/fastapi/pull/3743) by [@NinaHwang](https://github.com/NinaHwang).
  * ğŸŒ� Add portuguese translation for `docs/tutorial/query-params-str-validations.md`. PR [#3965](https://github.com/tiangolo/fastapi/pull/3965) by [@leandrodesouzadev](https://github.com/leandrodesouzadev).
  * ğŸŒ� Add Korean translation for `docs/tutorial/response-status-code.md`. PR [#3742](https://github.com/tiangolo/fastapi/pull/3742) by [@NinaHwang](https://github.com/NinaHwang).
  * ğŸŒ� Add Korean translation for Tutorial - JSON Compatible Encoder. PR [#3152](https://github.com/tiangolo/fastapi/pull/3152) by [@NEONKID](https://github.com/NEONKID).
  * ğŸŒ� Add Korean translation for Tutorial - Path Parameters and Numeric Validations. PR [#2432](https://github.com/tiangolo/fastapi/pull/2432) by [@hard-coders](https://github.com/hard-coders).
  * ğŸŒ� Add Korean translation for `docs/ko/docs/deployment/versions.md`. PR [#4121](https://github.com/tiangolo/fastapi/pull/4121) by [@DevDae](https://github.com/DevDae).
  * ğŸŒ� Fix Korean translation for `docs/ko/docs/tutorial/index.md`. PR [#4193](https://github.com/tiangolo/fastapi/pull/4193) by [@kimjaeyoonn](https://github.com/kimjaeyoonn).
  * ğŸ”§ Add CryptAPI sponsor. PR [#4264](https://github.com/tiangolo/fastapi/pull/4264) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ“� Update `docs/tutorial/dependencies/classes-as-dependencies`: Add type of query parameters in a description of `Classes as dependencies`. PR [#4015](https://github.com/tiangolo/fastapi/pull/4015) by [@0417taehyun](https://github.com/0417taehyun).
  * ğŸŒ� Add French translation for Tutorial - First steps. PR [#3455](https://github.com/tiangolo/fastapi/pull/3455) by [@Smlep](https://github.com/Smlep).
  * ğŸŒ� Add French translation for `docs/tutorial/path-params.md`. PR [#3548](https://github.com/tiangolo/fastapi/pull/3548) by [@Smlep](https://github.com/Smlep).
  * ğŸŒ� Add French translation for `docs/tutorial/query-params.md`. PR [#3556](https://github.com/tiangolo/fastapi/pull/3556) by [@Smlep](https://github.com/Smlep).
  * ğŸŒ� Add Turkish translation for `docs/python-types.md`. PR [#3926](https://github.com/tiangolo/fastapi/pull/3926) by [@BilalAlpaslan](https://github.com/BilalAlpaslan).

### Internal[¶](#internal_97 "Permanent link")

  * ğŸ‘¥ Update FastAPI People. PR [#4274](https://github.com/tiangolo/fastapi/pull/4274) by [@github-actions[bot]](https://github.com/apps/github-actions).

## 0.70.0[¶](#0700 "Permanent link")

This release just upgrades Starlette to the latest version, `0.16.0`, which includes several bug fixes and some small breaking changes.

These last **three consecutive releases** are independent so that you can **migrate gradually** :

  * First to FastAPI `0.68.2`, with no breaking changes, but upgrading all the sub-dependencies.
  * Next to FastAPI `0.69.0`, which upgrades Starlette to `0.15.0`, with AnyIO support, and a higher chance of having breaking changes in your code.
  * Finally to FastAPI `0.70.0`, just upgrading Starlette to the latest version `0.16.0` with additional bug fixes.

This way, in case there was a breaking change for your code in one of the releases, you can still benefit from the previous upgrades. âœ¨

### Breaking Changes - Upgrade[¶](#breaking-changes-upgrade "Permanent link")

  * â¬†ï¸� Upgrade Starlette to 0.16.0. PR [#4016](https://github.com/tiangolo/fastapi/pull/4016) by [@tiangolo](https://github.com/tiangolo).

Also upgrades the ranges of optional dependencies:

  * `"jinja2 >=2.11.2,<4.0.0"`
  * `"itsdangerous >=1.1.0,<3.0.0"`

## 0.69.0[¶](#0690 "Permanent link")

### Breaking Changes - Upgrade[¶](#breaking-changes-upgrade_1 "Permanent link")

This release adds support for [Trio](https://trio.readthedocs.io/en/stable/). âœ¨

It upgrades the version of Starlette to `0.15.0`, now based on [AnyIO](https://anyio.readthedocs.io/en/stable/), and the internal async components in **FastAPI** are now based on AnyIO as well, making it compatible with both **asyncio** and **Trio**.

You can read the docs about running [FastAPI with Trio using Hypercorn](https://fastapi.tiangolo.com/deployment/manually/#hypercorn-with-trio).

This release also removes `graphene` as an optional dependency for GraphQL. If you need to work with GraphQL, the recommended library now is [Strawberry](https://strawberry.rocks/). You can read the new [FastAPI with GraphQL docs](https://fastapi.tiangolo.com/advanced/graphql/).

### Features[¶](#features_40 "Permanent link")

  * âœ¨ Add support for Trio via AnyIO, upgrading Starlette to `0.15.0`. PR [#3372](https://github.com/tiangolo/fastapi/pull/3372) by [@graingert](https://github.com/graingert).
  * â�– Remove `graphene` as an optional dependency. PR [#4007](https://github.com/tiangolo/fastapi/pull/4007) by [@tiangolo](https://github.com/tiangolo).

### Docs[¶](#docs_79 "Permanent link")

  * ğŸ“� Add docs for using Trio with Hypercorn. PR [#4014](https://github.com/tiangolo/fastapi/pull/4014) by [@tiangolo](https://github.com/tiangolo).
  * âœ� Fix typos in Deployment Guide. PR [#3975](https://github.com/tiangolo/fastapi/pull/3975) by [@ghandic](https://github.com/ghandic).
  * ğŸ“� Update docs with pip install calls when using extras with brackets, use quotes for compatibility with Zsh. PR [#3131](https://github.com/tiangolo/fastapi/pull/3131) by [@tomwei7](https://github.com/tomwei7).
  * ğŸ“� Add external link to article: Deploying ML Models as API Using FastAPI and Heroku. PR [#3904](https://github.com/tiangolo/fastapi/pull/3904) by [@kaustubhgupta](https://github.com/kaustubhgupta).
  * âœ� Fix typo in file paths in `docs/en/docs/contributing.md`. PR [#3752](https://github.com/tiangolo/fastapi/pull/3752) by [@NinaHwang](https://github.com/NinaHwang).
  * âœ� Fix a typo in `docs/en/docs/advanced/path-operation-advanced-configuration.md` and `docs/en/docs/release-notes.md`. PR [#3750](https://github.com/tiangolo/fastapi/pull/3750) by [@saintmalik](https://github.com/saintmalik).
  * âœ�ï¸� Add a missing comma in the security tutorial. PR [#3564](https://github.com/tiangolo/fastapi/pull/3564) by [@jalvaradosegura](https://github.com/jalvaradosegura).
  * âœ� Fix typo in `docs/en/docs/help-fastapi.md`. PR [#3760](https://github.com/tiangolo/fastapi/pull/3760) by [@jaystone776](https://github.com/jaystone776).
  * âœ� Fix typo about file path in `docs/en/docs/tutorial/bigger-applications.md`. PR [#3285](https://github.com/tiangolo/fastapi/pull/3285) by [@HolyDorus](https://github.com/HolyDorus).
  * âœ� Re-word to clarify test client in `docs/en/docs/tutorial/testing.md`. PR [#3382](https://github.com/tiangolo/fastapi/pull/3382) by [@Bharat123rox](https://github.com/Bharat123rox).
  * ğŸ“� Fix incorrect highlighted code. PR [#3325](https://github.com/tiangolo/fastapi/pull/3325) by [@paxcodes](https://github.com/paxcodes).
  * ğŸ“� Add external link to article: How-to deploy FastAPI app to Heroku. PR [#3241](https://github.com/tiangolo/fastapi/pull/3241) by [@Jarmos-san](https://github.com/Jarmos-san).
  * âœ� Fix typo (mistranslation) in `docs/en/docs/advanced/templates.md`. PR [#3211](https://github.com/tiangolo/fastapi/pull/3211) by [@oerpli](https://github.com/oerpli).
  * ğŸ“� Remove note about (now supported) feature from Swagger UI in `docs/en/docs/tutorial/request-files.md`. PR [#2803](https://github.com/tiangolo/fastapi/pull/2803) by [@gsganden](https://github.com/gsganden).
  * âœ� Fix typo re-word in `docs/tutorial/handling-errors.md`. PR [#2700](https://github.com/tiangolo/fastapi/pull/2700) by [@graue70](https://github.com/graue70).

### Translations[¶](#translations_75 "Permanent link")

  * ğŸŒ� Initialize Azerbaijani translations. PR [#3941](https://github.com/tiangolo/fastapi/pull/3941) by [@madatbay](https://github.com/madatbay).
  * ğŸŒ� Add Turkish translation for `docs/fastapi-people.md`. PR [#3848](https://github.com/tiangolo/fastapi/pull/3848) by [@BilalAlpaslan](https://github.com/BilalAlpaslan).

### Internal[¶](#internal_98 "Permanent link")

  * ğŸ“� Add supported Python versions badge. PR [#2794](https://github.com/tiangolo/fastapi/pull/2794) by [@hramezani](https://github.com/hramezani).
  * âœ� Fix link in Japanese docs for `docs/ja/docs/deployment/docker.md`. PR [#3245](https://github.com/tiangolo/fastapi/pull/3245) by [@utamori](https://github.com/utamori).
  * ğŸ”§ Correct DeprecationWarning config and comment in pytest settings. PR [#4008](https://github.com/tiangolo/fastapi/pull/4008) by [@graingert](https://github.com/graingert).
  * ğŸ”§ Swap light/dark theme button icon. PR [#3246](https://github.com/tiangolo/fastapi/pull/3246) by [@eddsalkield](https://github.com/eddsalkield).
  * ğŸ”§ Lint only in Python 3.7 and above. PR [#4006](https://github.com/tiangolo/fastapi/pull/4006) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”§ Add GitHub Action notify-translations config for Azerbaijani. PR [#3995](https://github.com/tiangolo/fastapi/pull/3995) by [@tiangolo](https://github.com/tiangolo).

## 0.68.2[¶](#0682 "Permanent link")

This release has **no breaking changes**. ğŸ�‰

It upgrades the version ranges of sub-dependencies to allow applications using FastAPI to easily upgrade them.

Soon there will be a new FastAPI release upgrading Starlette to take advantage of recent improvements, but as that has a higher chance of having breaking changes, it will be in a separate release.

### Features[¶](#features_41 "Permanent link")

  * â¬†Increase supported version of aiofiles to suppress warnings. PR [#2899](https://github.com/tiangolo/fastapi/pull/2899) by [@SnkSynthesis](https://github.com/SnkSynthesis).
  * â�– Do not require backports in Python >= 3.7. PR [#1880](https://github.com/tiangolo/fastapi/pull/1880) by [@FFY00](https://github.com/FFY00).
  * â¬† Upgrade required Python version to >= 3.6.1, needed by typing.Deque, used by Pydantic. PR [#2733](https://github.com/tiangolo/fastapi/pull/2733) by [@hukkin](https://github.com/hukkin).
  * â¬†ï¸� Bump Uvicorn max range to 0.15.0. PR [#3345](https://github.com/tiangolo/fastapi/pull/3345) by [@Kludex](https://github.com/Kludex).

### Docs[¶](#docs_80 "Permanent link")

  * ğŸ“� Update GraphQL docs, recommend Strawberry. PR [#3981](https://github.com/tiangolo/fastapi/pull/3981) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ“� Re-write and extend Deployment guide: Concepts, Uvicorn, Gunicorn, Docker, Containers, Kubernetes. PR [#3974](https://github.com/tiangolo/fastapi/pull/3974) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ“� Upgrade HTTPS guide with more explanations and diagrams. PR [#3950](https://github.com/tiangolo/fastapi/pull/3950) by [@tiangolo](https://github.com/tiangolo).

### Translations[¶](#translations_76 "Permanent link")

  * ğŸŒ� Add Turkish translation for `docs/features.md`. PR [#1950](https://github.com/tiangolo/fastapi/pull/1950) by [@ycd](https://github.com/ycd).
  * ğŸŒ� Add Turkish translation for `docs/benchmarks.md`. PR [#2729](https://github.com/tiangolo/fastapi/pull/2729) by [@Telomeraz](https://github.com/Telomeraz).
  * ğŸŒ� Add Turkish translation for `docs/index.md`. PR [#1908](https://github.com/tiangolo/fastapi/pull/1908) by [@ycd](https://github.com/ycd).
  * ğŸŒ� Add French translation for `docs/tutorial/body.md`. PR [#3671](https://github.com/tiangolo/fastapi/pull/3671) by [@Smlep](https://github.com/Smlep).
  * ğŸŒ� Add French translation for `deployment/docker.md`. PR [#3694](https://github.com/tiangolo/fastapi/pull/3694) by [@rjNemo](https://github.com/rjNemo).
  * ğŸŒ� Add Portuguese translation for `docs/tutorial/path-params.md`. PR [#3664](https://github.com/tiangolo/fastapi/pull/3664) by [@FelipeSilva93](https://github.com/FelipeSilva93).
  * ğŸŒ� Add Portuguese translation for `docs/deployment/https.md`. PR [#3754](https://github.com/tiangolo/fastapi/pull/3754) by [@lsglucas](https://github.com/lsglucas).
  * ğŸŒ� Add German translation for `docs/features.md`. PR [#3699](https://github.com/tiangolo/fastapi/pull/3699) by [@mawassk](https://github.com/mawassk).

### Internal[¶](#internal_99 "Permanent link")

  * âœ¨ Update GitHub Action: notify-translations, to avoid a race conditions. PR [#3989](https://github.com/tiangolo/fastapi/pull/3989) by [@tiangolo](https://github.com/tiangolo).
  * â¬†ï¸� Upgrade development `autoflake`, supporting multi-line imports. PR [#3988](https://github.com/tiangolo/fastapi/pull/3988) by [@tiangolo](https://github.com/tiangolo).
  * â¬†ï¸� Increase dependency ranges for tests and docs: pytest-cov, pytest-asyncio, black, httpx, sqlalchemy, databases, mkdocs-markdownextradata-plugin. PR [#3987](https://github.com/tiangolo/fastapi/pull/3987) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘¥ Update FastAPI People. PR [#3986](https://github.com/tiangolo/fastapi/pull/3986) by [@github-actions[bot]](https://github.com/apps/github-actions).
  * ğŸ’š Fix badges in README and main page. PR [#3979](https://github.com/tiangolo/fastapi/pull/3979) by [@ghandic](https://github.com/ghandic).
  * â¬† Upgrade internal testing dependencies: mypy to version 0.910, add newly needed type packages. PR [#3350](https://github.com/tiangolo/fastapi/pull/3350) by [@ArcLightSlavik](https://github.com/ArcLightSlavik).
  * âœ¨ Add Deepset Sponsorship. PR [#3976](https://github.com/tiangolo/fastapi/pull/3976) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ�¨ Tweak CSS styles for shell animations. PR [#3888](https://github.com/tiangolo/fastapi/pull/3888) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”§ Add new Sponsor Calmcode.io. PR [#3777](https://github.com/tiangolo/fastapi/pull/3777) by [@tiangolo](https://github.com/tiangolo).

## 0.68.1[¶](#0681 "Permanent link")

  * âœ¨ Add support for `read_with_orm_mode`, to support [SQLModel](https://sqlmodel.tiangolo.com/) relationship attributes. PR [#3757](https://github.com/tiangolo/fastapi/pull/3757) by [@tiangolo](https://github.com/tiangolo).

### Translations[¶](#translations_77 "Permanent link")

  * ğŸŒ� Add Portuguese translation of `docs/fastapi-people.md`. PR [#3461](https://github.com/tiangolo/fastapi/pull/3461) by [@ComicShrimp](https://github.com/ComicShrimp).
  * ğŸŒ� Add Chinese translation for `docs/tutorial/dependencies/dependencies-in-path-operation-decorators.md`. PR [#3492](https://github.com/tiangolo/fastapi/pull/3492) by [@jaystone776](https://github.com/jaystone776).
  * ğŸ”§ Add new Translation tracking issues for German and Indonesian. PR [#3718](https://github.com/tiangolo/fastapi/pull/3718) by [@tiangolo](https://github.com/tiangolo).
  * ğŸŒ� Add Chinese translation for `docs/tutorial/dependencies/sub-dependencies.md`. PR [#3491](https://github.com/tiangolo/fastapi/pull/3491) by [@jaystone776](https://github.com/jaystone776).
  * ğŸŒ� Add Portuguese translation for `docs/advanced/index.md`. PR [#3460](https://github.com/tiangolo/fastapi/pull/3460) by [@ComicShrimp](https://github.com/ComicShrimp).
  * ğŸŒ� Portuguese translation of `docs/async.md`. PR [#1330](https://github.com/tiangolo/fastapi/pull/1330) by [@Serrones](https://github.com/Serrones).
  * ğŸŒ� Add French translation for `docs/async.md`. PR [#3416](https://github.com/tiangolo/fastapi/pull/3416) by [@Smlep](https://github.com/Smlep).

### Internal[¶](#internal_100 "Permanent link")

  * âœ¨ Add GitHub Action: Notify Translations. PR [#3715](https://github.com/tiangolo/fastapi/pull/3715) by [@tiangolo](https://github.com/tiangolo).
  * âœ¨ Update computation of FastAPI People and sponsors. PR [#3714](https://github.com/tiangolo/fastapi/pull/3714) by [@tiangolo](https://github.com/tiangolo).
  * âœ¨ Enable recent Material for MkDocs Insiders features. PR [#3710](https://github.com/tiangolo/fastapi/pull/3710) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”¥ Remove/clean extra imports from examples in docs for features. PR [#3709](https://github.com/tiangolo/fastapi/pull/3709) by [@tiangolo](https://github.com/tiangolo).
  * â�• Update docs library to include sources in Markdown. PR [#3648](https://github.com/tiangolo/fastapi/pull/3648) by [@tiangolo](https://github.com/tiangolo).
  * â¬† Enable tests for Python 3.9. PR [#2298](https://github.com/tiangolo/fastapi/pull/2298) by [@Kludex](https://github.com/Kludex).
  * ğŸ‘¥ Update FastAPI People. PR [#3642](https://github.com/tiangolo/fastapi/pull/3642) by [@github-actions[bot]](https://github.com/apps/github-actions).

## 0.68.0[¶](#0680 "Permanent link")

### Features[¶](#features_42 "Permanent link")

  * âœ¨ Add support for extensions and updates to the OpenAPI schema in each _path operation_. New docs: [FastAPI Path Operation Advanced Configuration - OpenAPI Extra](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#openapi-extra). Initial PR [#1922](https://github.com/tiangolo/fastapi/pull/1922) by [@edouardlp](https://github.com/edouardlp).
  * âœ¨ Add additional OpenAPI metadata parameters to `FastAPI` class, shown on the automatic API docs UI. New docs: [Metadata and Docs URLs](https://fastapi.tiangolo.com/tutorial/metadata/). Initial PR [#1812](https://github.com/tiangolo/fastapi/pull/1812) by [@dkreeft](https://github.com/dkreeft).
  * âœ¨ Add `description` parameter to all the security scheme classes, e.g. `APIKeyQuery(name="key", description="A very cool API key")`. PR [#1757](https://github.com/tiangolo/fastapi/pull/1757) by [@hylkepostma](https://github.com/hylkepostma).
  * âœ¨ Update OpenAPI models, supporting recursive models and extensions. PR [#3628](https://github.com/tiangolo/fastapi/pull/3628) by [@tiangolo](https://github.com/tiangolo).
  * âœ¨ Import and re-export data structures from Starlette, used by Request properties, on `fastapi.datastructures`. Initial PR [#1872](https://github.com/tiangolo/fastapi/pull/1872) by [@jamescurtin](https://github.com/jamescurtin).

### Docs[¶](#docs_81 "Permanent link")

  * ğŸ“� Update docs about async and response-model with more gender neutral language. PR [#1869](https://github.com/tiangolo/fastapi/pull/1869) by [@Edward-Knight](https://github.com/Edward-Knight).

### Translations[¶](#translations_78 "Permanent link")

  * ğŸŒ� Add Russian translation for `docs/python-types.md`. PR [#3039](https://github.com/tiangolo/fastapi/pull/3039) by [@dukkee](https://github.com/dukkee).
  * ğŸŒ� Add Chinese translation for `docs/tutorial/dependencies/index.md`. PR [#3489](https://github.com/tiangolo/fastapi/pull/3489) by [@jaystone776](https://github.com/jaystone776).
  * ğŸŒ� Add Russian translation for `docs/external-links.md`. PR [#3036](https://github.com/tiangolo/fastapi/pull/3036) by [@dukkee](https://github.com/dukkee).
  * ğŸŒ� Add Chinese translation for `docs/tutorial/dependencies/global-dependencies.md`. PR [#3493](https://github.com/tiangolo/fastapi/pull/3493) by [@jaystone776](https://github.com/jaystone776).
  * ğŸŒ� Add Portuguese translation for `docs/deployment/versions.md`. PR [#3618](https://github.com/tiangolo/fastapi/pull/3618) by [@lsglucas](https://github.com/lsglucas).
  * ğŸŒ� Add Japanese translation for `docs/tutorial/security/oauth2-jwt.md`. PR [#3526](https://github.com/tiangolo/fastapi/pull/3526) by [@sattosan](https://github.com/sattosan).

### Internal[¶](#internal_101 "Permanent link")

  * âœ… Add the `docs_src` directory to test coverage and update tests. Initial PR [#1904](https://github.com/tiangolo/fastapi/pull/1904) by [@Kludex](https://github.com/Kludex).
  * ğŸ”§ Add new GitHub templates with forms for new issues. PR [#3612](https://github.com/tiangolo/fastapi/pull/3612) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ“� Add official FastAPI Twitter to docs: [@fastapi](https://x.com/fastapi). PR [#3578](https://github.com/tiangolo/fastapi/pull/3578) by [@tiangolo](https://github.com/tiangolo).

## 0.67.0[¶](#0670 "Permanent link")

### Features[¶](#features_43 "Permanent link")

  * âœ¨ Add support for `dataclasses` in request bodies and `response_model`. New documentation: [Advanced User Guide - Using Dataclasses](https://fastapi.tiangolo.com/advanced/dataclasses/). PR [#3577](https://github.com/tiangolo/fastapi/pull/3577) by [@tiangolo](https://github.com/tiangolo).
  * âœ¨ Support `dataclasses` in responses. PR [#3576](https://github.com/tiangolo/fastapi/pull/3576) by [@tiangolo](https://github.com/tiangolo), continuation from initial PR [#2722](https://github.com/tiangolo/fastapi/pull/2722) by [@amitlissack](https://github.com/amitlissack).

### Docs[¶](#docs_82 "Permanent link")

  * ğŸ“� Add external link: How to Create A Fake Certificate Authority And Generate TLS Certs for FastAPI. PR [#2839](https://github.com/tiangolo/fastapi/pull/2839) by [@aitoehigie](https://github.com/aitoehigie).
  * âœ� Fix code highlighted line in: `body-nested-models.md`. PR [#3463](https://github.com/tiangolo/fastapi/pull/3463) by [@jaystone776](https://github.com/jaystone776).
  * âœ� Fix typo in `body-nested-models.md`. PR [#3462](https://github.com/tiangolo/fastapi/pull/3462) by [@jaystone776](https://github.com/jaystone776).
  * âœ� Fix typo "might me" -> "might be" in `docs/en/docs/tutorial/schema-extra-example.md`. PR [#3362](https://github.com/tiangolo/fastapi/pull/3362) by [@dbrakman](https://github.com/dbrakman).
  * ğŸ“� Add external link: Building simple E-Commerce with NuxtJS and FastAPI. PR [#3271](https://github.com/tiangolo/fastapi/pull/3271) by [@ShahriyarR](https://github.com/ShahriyarR).
  * ğŸ“� Add external link: Serve a machine learning model using Sklearn, FastAPI and Docker. PR [#2974](https://github.com/tiangolo/fastapi/pull/2974) by [@rodrigo-arenas](https://github.com/rodrigo-arenas).
  * âœ�ï¸� Fix typo on docstring in datastructures file. PR [#2887](https://github.com/tiangolo/fastapi/pull/2887) by [@Kludex](https://github.com/Kludex).
  * ğŸ“� Add External Link: Deploy FastAPI on Ubuntu and Serve using Caddy 2 Web Server. PR [#3572](https://github.com/tiangolo/fastapi/pull/3572) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ“� Add External Link, replaces #1898. PR [#3571](https://github.com/tiangolo/fastapi/pull/3571) by [@tiangolo](https://github.com/tiangolo).

### Internal[¶](#internal_102 "Permanent link")

  * ğŸ�¨ Improve style for sponsors, add radius border. PR [#2388](https://github.com/tiangolo/fastapi/pull/2388) by [@Kludex](https://github.com/Kludex).
  * ğŸ‘· Update GitHub Action latest-changes. PR [#3574](https://github.com/tiangolo/fastapi/pull/3574) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘· Update GitHub Action latest-changes. PR [#3573](https://github.com/tiangolo/fastapi/pull/3573) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘· Rename and clarify CI workflow job names. PR [#3570](https://github.com/tiangolo/fastapi/pull/3570) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘· Update GitHub Action latest-changes, strike 2 âš¾. PR [#3575](https://github.com/tiangolo/fastapi/pull/3575) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”§ Sort external links in docs to have the most recent at the top. PR [#3568](https://github.com/tiangolo/fastapi/pull/3568) by [@tiangolo](https://github.com/tiangolo).

## 0.66.1[¶](#0661 "Permanent link")

### Translations[¶](#translations_79 "Permanent link")

  * ğŸŒ� Add basic setup for German translations. PR [#3522](https://github.com/tiangolo/fastapi/pull/3522) by [@0x4Dark](https://github.com/0x4Dark).
  * ğŸŒ� Add Portuguese translation for `docs/tutorial/security/index.md`. PR [#3507](https://github.com/tiangolo/fastapi/pull/3507) by [@oandersonmagalhaes](https://github.com/oandersonmagalhaes).
  * ğŸŒ� Add Portuguese translation for `docs/deployment/index.md`. PR [#3337](https://github.com/tiangolo/fastapi/pull/3337) by [@lsglucas](https://github.com/lsglucas).

### Internal[¶](#internal_103 "Permanent link")

  * ğŸ”§ Configure strict pytest options and update/refactor tests. Upgrade pytest to `>=6.2.4,<7.0.0` and pytest-cov to `>=2.12.0,<3.0.0`. Initial PR [#2790](https://github.com/tiangolo/fastapi/pull/2790) by [@graingert](https://github.com/graingert).
  * â¬†ï¸� Upgrade python-jose dependency to `>=3.3.0,<4.0.0` for tests. PR [#3468](https://github.com/tiangolo/fastapi/pull/3468) by [@tiangolo](https://github.com/tiangolo).

## 0.66.0[¶](#0660 "Permanent link")

### Features[¶](#features_44 "Permanent link")

  * âœ¨ Allow setting the `response_class` to `RedirectResponse` or `FileResponse` and returning the URL from the function. New and updated docs are in the tutorial section **Custom Response - HTML, Stream, File, others** , in [RedirectResponse](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse) and in [FileResponse](https://fastapi.tiangolo.com/advanced/custom-response/#fileresponse). PR [#3457](https://github.com/tiangolo/fastapi/pull/3457) by [@tiangolo](https://github.com/tiangolo).

### Fixes[¶](#fixes_60 "Permanent link")

  * ğŸ�› Fix include/exclude for dicts in `jsonable_encoder`. PR [#2016](https://github.com/tiangolo/fastapi/pull/2016) by [@Rubikoid](https://github.com/Rubikoid).
  * ğŸ�› Support custom OpenAPI / JSON Schema fields in the generated output OpenAPI. PR [#1429](https://github.com/tiangolo/fastapi/pull/1429) by [@jmagnusson](https://github.com/jmagnusson).

### Translations[¶](#translations_80 "Permanent link")

  * ğŸŒ� Add Spanish translation for `tutorial/query-params.md`. PR [#2243](https://github.com/tiangolo/fastapi/pull/2243) by [@mariacamilagl](https://github.com/mariacamilagl).
  * ğŸŒ� Add Spanish translation for `advanced/response-directly.md`. PR [#1253](https://github.com/tiangolo/fastapi/pull/1253) by [@jfunez](https://github.com/jfunez).
  * ğŸŒ� Add Spanish translation for `advanced/additional-status-codes.md`. PR [#1252](https://github.com/tiangolo/fastapi/pull/1252) by [@jfunez](https://github.com/jfunez).
  * ğŸŒ� Add Spanish translation for `advanced/path-operation-advanced-configuration.md`. PR [#1251](https://github.com/tiangolo/fastapi/pull/1251) by [@jfunez](https://github.com/jfunez).

## 0.65.3[¶](#0653 "Permanent link")

### Fixes[¶](#fixes_61 "Permanent link")

  * â™» Assume request bodies contain JSON when no Content-Type header is provided. This fixes a breaking change introduced by [0.65.2 with PR #2118](https://github.com/tiangolo/fastapi/pull/2118). It should allow upgrading FastAPI applications with clients that send JSON data without a `Content-Type` header. And there's still protection against CSRFs. PR [#3456](https://github.com/tiangolo/fastapi/pull/3456) by [@tiangolo](https://github.com/tiangolo).

### Translations[¶](#translations_81 "Permanent link")

  * ğŸŒ� Initialize Indonesian translations. PR [#3014](https://github.com/tiangolo/fastapi/pull/3014) by [@pace-noge](https://github.com/pace-noge).
  * ğŸŒ� Add Spanish translation of Tutorial - Path Parameters. PR [#2219](https://github.com/tiangolo/fastapi/pull/2219) by [@mariacamilagl](https://github.com/mariacamilagl).
  * ğŸŒ� Add Spanish translation of Tutorial - First Steps. PR [#2208](https://github.com/tiangolo/fastapi/pull/2208) by [@mariacamilagl](https://github.com/mariacamilagl).
  * ğŸŒ� Portuguese translation of Tutorial - Body - Fields. PR [#3420](https://github.com/tiangolo/fastapi/pull/3420) by [@ComicShrimp](https://github.com/ComicShrimp).
  * ğŸŒ� Add Chinese translation for Tutorial - Request - Forms - and - Files. PR [#3249](https://github.com/tiangolo/fastapi/pull/3249) by [@jaystone776](https://github.com/jaystone776).
  * ğŸŒ� Add Chinese translation for Tutorial - Handling - Errors. PR [#3299](https://github.com/tiangolo/fastapi/pull/3299) by [@jaystone776](https://github.com/jaystone776).
  * ğŸŒ� Add Chinese translation for Tutorial - Form - Data. PR [#3248](https://github.com/tiangolo/fastapi/pull/3248) by [@jaystone776](https://github.com/jaystone776).
  * ğŸŒ� Add Chinese translation for Tutorial - Body - Updates. PR [#3237](https://github.com/tiangolo/fastapi/pull/3237) by [@jaystone776](https://github.com/jaystone776).
  * ğŸŒ� Add Chinese translation for FastAPI People. PR [#3112](https://github.com/tiangolo/fastapi/pull/3112) by [@hareru](https://github.com/hareru).
  * ğŸŒ� Add French translation for Project Generation. PR [#3197](https://github.com/tiangolo/fastapi/pull/3197) by [@Smlep](https://github.com/Smlep).
  * ğŸŒ� Add French translation for Python Types Intro. PR [#3185](https://github.com/tiangolo/fastapi/pull/3185) by [@Smlep](https://github.com/Smlep).
  * ğŸŒ� Add French translation for External Links. PR [#3103](https://github.com/tiangolo/fastapi/pull/3103) by [@Smlep](https://github.com/Smlep).
  * ğŸŒ� Add French translation for Alternatives, Inspiration and Comparisons. PR [#3020](https://github.com/tiangolo/fastapi/pull/3020) by [@rjNemo](https://github.com/rjNemo).
  * ğŸŒ� Fix Chinese translation code snippet mismatch in Tutorial - Python Types Intro. PR [#2573](https://github.com/tiangolo/fastapi/pull/2573) by [@BoYanZh](https://github.com/BoYanZh).
  * ğŸŒ� Add Portuguese translation for Development Contributing. PR [#1364](https://github.com/tiangolo/fastapi/pull/1364) by [@Serrones](https://github.com/Serrones).
  * ğŸŒ� Add Chinese translation for Tutorial - Request - Files. PR [#3244](https://github.com/tiangolo/fastapi/pull/3244) by [@jaystone776](https://github.com/jaystone776).

### Internal[¶](#internal_104 "Permanent link")

  * ğŸ‘¥ Update FastAPI People. PR [#3450](https://github.com/tiangolo/fastapi/pull/3450) by [@github-actions[bot]](https://github.com/apps/github-actions).
  * ğŸ‘¥ Update FastAPI People. PR [#3319](https://github.com/tiangolo/fastapi/pull/3319) by [@github-actions[bot]](https://github.com/apps/github-actions).
  * â¬† Upgrade docs development dependency on `typer-cli` to >=0.0.12 to fix conflicts. PR [#3429](https://github.com/tiangolo/fastapi/pull/3429) by [@tiangolo](https://github.com/tiangolo).

## 0.65.2[¶](#0652 "Permanent link")

### Security fixes[¶](#security-fixes_1 "Permanent link")

  * ğŸ”’ Check Content-Type request header before assuming JSON. Initial PR [#2118](https://github.com/tiangolo/fastapi/pull/2118) by [@patrickkwang](https://github.com/patrickkwang).

This change fixes a [CSRF](https://en.wikipedia.org/wiki/Cross-site_request_forgery) security vulnerability when using cookies for authentication in path operations with JSON payloads sent by browsers.

In versions lower than `0.65.2`, FastAPI would try to read the request payload as JSON even if the `content-type` header sent was not set to `application/json` or a compatible JSON media type (e.g. `application/geo+json`).

So, a request with a content type of `text/plain` containing JSON data would be accepted and the JSON data would be extracted.

But requests with content type `text/plain` are exempt from [CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) preflights, for being considered [Simple requests](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#simple_requests). So, the browser would execute them right away including cookies, and the text content could be a JSON string that would be parsed and accepted by the FastAPI application.

See [CVE-2021-32677](https://github.com/tiangolo/fastapi/security/advisories/GHSA-8h2j-cgx8-6xv7) for more details.

Thanks to [Dima Boger](https://x.com/b0g3r) for the security report! ğŸ™‡ğŸ”’

### Internal[¶](#internal_105 "Permanent link")

  * ğŸ”§ Update sponsors badge, course bundle. PR [#3340](https://github.com/tiangolo/fastapi/pull/3340) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”§ Add new gold sponsor Jina ğŸ�‰. PR [#3291](https://github.com/tiangolo/fastapi/pull/3291) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”§ Add new banner sponsor badge for FastAPI courses bundle. PR [#3288](https://github.com/tiangolo/fastapi/pull/3288) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘· Upgrade Issue Manager GitHub Action. PR [#3236](https://github.com/tiangolo/fastapi/pull/3236) by [@tiangolo](https://github.com/tiangolo).

## 0.65.1[¶](#0651 "Permanent link")

### Security fixes[¶](#security-fixes_2 "Permanent link")

  * ğŸ“Œ Upgrade pydantic pin, to handle security vulnerability [CVE-2021-29510](https://github.com/pydantic/pydantic/security/advisories/GHSA-5jqp-qgf6-3pvh). PR [#3213](https://github.com/tiangolo/fastapi/pull/3213) by [@tiangolo](https://github.com/tiangolo).

## 0.65.0[¶](#0650 "Permanent link")

### Breaking Changes - Upgrade[¶](#breaking-changes-upgrade_2 "Permanent link")

  * â¬†ï¸� Upgrade Starlette to `0.14.2`, including internal `UJSONResponse` migrated from Starlette. This includes several bug fixes and features from Starlette. PR [#2335](https://github.com/tiangolo/fastapi/pull/2335) by [@hanneskuettner](https://github.com/hanneskuettner).

### Translations[¶](#translations_82 "Permanent link")

  * ğŸŒ� Initialize new language Polish for translations. PR [#3170](https://github.com/tiangolo/fastapi/pull/3170) by [@neternefer](https://github.com/neternefer).

### Internal[¶](#internal_106 "Permanent link")

  * ğŸ‘· Add GitHub Action cache to speed up CI installs. PR [#3204](https://github.com/tiangolo/fastapi/pull/3204) by [@tiangolo](https://github.com/tiangolo).
  * â¬†ï¸� Upgrade setup-python GitHub Action to v2. PR [#3203](https://github.com/tiangolo/fastapi/pull/3203) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ�› Fix docs script to generate a new translation language with `overrides` boilerplate. PR [#3202](https://github.com/tiangolo/fastapi/pull/3202) by [@tiangolo](https://github.com/tiangolo).
  * âœ¨ Add new Deta banner badge with new sponsorship tier ğŸ™‡. PR [#3194](https://github.com/tiangolo/fastapi/pull/3194) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘¥ Update FastAPI People. PR [#3189](https://github.com/tiangolo/fastapi/pull/3189) by [@github-actions[bot]](https://github.com/apps/github-actions).
  * ğŸ”Š Update FastAPI People to allow better debugging. PR [#3188](https://github.com/tiangolo/fastapi/pull/3188) by [@tiangolo](https://github.com/tiangolo).

## 0.64.0[¶](#0640 "Permanent link")

### Features[¶](#features_45 "Permanent link")

  * âœ¨ Add support for adding multiple `examples` in request bodies and path, query, cookie, and header params. New docs: [Declare Request Example Data](https://fastapi.tiangolo.com/tutorial/schema-extra-example/#body-with-multiple-examples). Initial PR [#1267](https://github.com/tiangolo/fastapi/pull/1267) by [@austinorr](https://github.com/austinorr).

### Fixes[¶](#fixes_62 "Permanent link")

  * ğŸ“Œ Pin SQLAlchemy range for tests, as it doesn't use SemVer. PR [#3001](https://github.com/tiangolo/fastapi/pull/3001) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ�¨ Add newly required type annotations for mypy. PR [#2882](https://github.com/tiangolo/fastapi/pull/2882) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ�¨ Remove internal "type: ignore", now unnecessary. PR [#2424](https://github.com/tiangolo/fastapi/pull/2424) by [@AsakuraMizu](https://github.com/AsakuraMizu).

### Docs[¶](#docs_83 "Permanent link")

  * ğŸ“� Add link to article in Russian "FastAPI: Ğ·Ğ½Ğ°ĞºĞ¾Ğ¼Ğ¸Ğ¼Ñ�Ñ� Ñ� Ñ„Ñ€ĞµĞ¹Ğ¼Ğ²Ğ¾Ñ€ĞºĞ¾Ğ¼". PR [#2564](https://github.com/tiangolo/fastapi/pull/2564) by [@trkohler](https://github.com/trkohler).
  * ğŸ“� Add external link to blog post "Authenticate Your FastAPI App with Auth0". PR [#2172](https://github.com/tiangolo/fastapi/pull/2172) by [@dompatmore](https://github.com/dompatmore).
  * ğŸ“� Fix broken link to article: Machine learning model serving in Python using FastAPI and Streamlit. PR [#2557](https://github.com/tiangolo/fastapi/pull/2557) by [@davidefiocco](https://github.com/davidefiocco).
  * ğŸ“� Add FastAPI Medium Article: Deploy a dockerized FastAPI application to AWS. PR [#2515](https://github.com/tiangolo/fastapi/pull/2515) by [@vjanz](https://github.com/vjanz).
  * âœ� Fix typo in Tutorial - Handling Errors. PR [#2486](https://github.com/tiangolo/fastapi/pull/2486) by [@johnthagen](https://github.com/johnthagen).
  * âœ� Fix typo in Security OAuth2 scopes. PR [#2407](https://github.com/tiangolo/fastapi/pull/2407) by [@jugmac00](https://github.com/jugmac00).
  * âœ� Fix typo/clarify docs for SQL (Relational) Databases. PR [#2393](https://github.com/tiangolo/fastapi/pull/2393) by [@kangni](https://github.com/kangni).
  * ğŸ“� Add external link to "FastAPI for Flask Users". PR [#2280](https://github.com/tiangolo/fastapi/pull/2280) by [@amitness](https://github.com/amitness).

### Translations[¶](#translations_83 "Permanent link")

  * ğŸŒ� Fix Chinese translation of Tutorial - Query Parameters, remove obsolete content. PR [#3051](https://github.com/tiangolo/fastapi/pull/3051) by [@louis70109](https://github.com/louis70109).
  * ğŸŒ� Add French translation for Tutorial - Background Tasks. PR [#3098](https://github.com/tiangolo/fastapi/pull/3098) by [@Smlep](https://github.com/Smlep).
  * ğŸŒ� Fix Korean translation for docs/ko/docs/index.md. PR [#3159](https://github.com/tiangolo/fastapi/pull/3159) by [@SueNaEunYang](https://github.com/SueNaEunYang).
  * ğŸŒ� Add Korean translation for Tutorial - Query Parameters. PR [#2390](https://github.com/tiangolo/fastapi/pull/2390) by [@hard-coders](https://github.com/hard-coders).
  * ğŸŒ� Add French translation for FastAPI People. PR [#2232](https://github.com/tiangolo/fastapi/pull/2232) by [@JulianMaurin](https://github.com/JulianMaurin).
  * ğŸŒ� Add Korean translation for Tutorial - Path Parameters. PR [#2355](https://github.com/tiangolo/fastapi/pull/2355) by [@hard-coders](https://github.com/hard-coders).
  * ğŸŒ� Add French translation for Features. PR [#2157](https://github.com/tiangolo/fastapi/pull/2157) by [@Jefidev](https://github.com/Jefidev).
  * ğŸ‘¥ Update FastAPI People. PR [#3031](https://github.com/tiangolo/fastapi/pull/3031) by [@github-actions[bot]](https://github.com/apps/github-actions).
  * ğŸŒ� Add Chinese translation for Tutorial - Debugging. PR [#2737](https://github.com/tiangolo/fastapi/pull/2737) by [@blt232018](https://github.com/blt232018).
  * ğŸŒ� Add Chinese translation for Tutorial - Security - OAuth2 with Password (and hashing), Bearer with JWT tokens. PR [#2642](https://github.com/tiangolo/fastapi/pull/2642) by [@waynerv](https://github.com/waynerv).
  * ğŸŒ� Add Korean translation for Tutorial - Header Parameters. PR [#2589](https://github.com/tiangolo/fastapi/pull/2589) by [@mode9](https://github.com/mode9).
  * ğŸŒ� Add Chinese translation for Tutorial - Metadata and Docs URLs. PR [#2559](https://github.com/tiangolo/fastapi/pull/2559) by [@blt232018](https://github.com/blt232018).
  * ğŸŒ� Add Korean translation for Tutorial - First Steps. PR [#2323](https://github.com/tiangolo/fastapi/pull/2323) by [@hard-coders](https://github.com/hard-coders).
  * ğŸŒ� Add Chinese translation for Tutorial - CORS (Cross-Origin Resource Sharing). PR [#2540](https://github.com/tiangolo/fastapi/pull/2540) by [@blt232018](https://github.com/blt232018).
  * ğŸŒ� Add Chinese translation for Tutorial - Middleware. PR [#2334](https://github.com/tiangolo/fastapi/pull/2334) by [@lpdswing](https://github.com/lpdswing).
  * ğŸŒ� Add Korean translation for Tutorial - Intro. PR [#2317](https://github.com/tiangolo/fastapi/pull/2317) by [@hard-coders](https://github.com/hard-coders).
  * ğŸŒ� Add Chinese translation for Tutorial - Bigger Applications - Multiple Files. PR [#2453](https://github.com/tiangolo/fastapi/pull/2453) by [@waynerv](https://github.com/waynerv).
  * ğŸŒ� Add Chinese translation for Tutorial - Security - Security Intro. PR [#2443](https://github.com/tiangolo/fastapi/pull/2443) by [@waynerv](https://github.com/waynerv).
  * ğŸŒ� Add Chinese translation for Tutorial - Header Parameters. PR [#2412](https://github.com/tiangolo/fastapi/pull/2412) by [@maoyibo](https://github.com/maoyibo).
  * ğŸŒ� Add Chinese translation for Tutorial - Extra Data Types. PR [#2410](https://github.com/tiangolo/fastapi/pull/2410) by [@maoyibo](https://github.com/maoyibo).
  * ğŸŒ� Add Japanese translation for Deployment - Docker. PR [#2312](https://github.com/tiangolo/fastapi/pull/2312) by [@tokusumi](https://github.com/tokusumi).
  * ğŸŒ� Add Japanese translation for Deployment - Versions. PR [#2310](https://github.com/tiangolo/fastapi/pull/2310) by [@tokusumi](https://github.com/tokusumi).
  * ğŸŒ� Add Chinese translation for Tutorial - Cookie Parameters. PR [#2261](https://github.com/tiangolo/fastapi/pull/2261) by [@alicrazy1947](https://github.com/alicrazy1947).
  * ğŸŒ� Add Japanese translation for Tutorial - Static files. PR [#2260](https://github.com/tiangolo/fastapi/pull/2260) by [@tokusumi](https://github.com/tokusumi).
  * ğŸŒ� Add Japanese translation for Tutorial - Testing. PR [#2259](https://github.com/tiangolo/fastapi/pull/2259) by [@tokusumi](https://github.com/tokusumi).
  * ğŸŒ� Add Japanese translation for Tutorial - Debugging. PR [#2256](https://github.com/tiangolo/fastapi/pull/2256) by [@tokusumi](https://github.com/tokusumi).
  * ğŸŒ� Add Japanese translation for Tutorial - Middleware. PR [#2255](https://github.com/tiangolo/fastapi/pull/2255) by [@tokusumi](https://github.com/tokusumi).
  * ğŸŒ� Add Japanese translation for Concurrency and async / await. PR [#2058](https://github.com/tiangolo/fastapi/pull/2058) by [@tokusumi](https://github.com/tokusumi).
  * ğŸŒ� Add Chinese translation for Tutorial - Security - Simple OAuth2 with Password and Bearer. PR [#2514](https://github.com/tiangolo/fastapi/pull/2514) by [@waynerv](https://github.com/waynerv).
  * ğŸŒ� Add Japanese translation for Deployment - Deta. PR [#2314](https://github.com/tiangolo/fastapi/pull/2314) by [@tokusumi](https://github.com/tokusumi).
  * ğŸŒ� Add Chinese translation for Tutorial - Security - Get Current User. PR [#2474](https://github.com/tiangolo/fastapi/pull/2474) by [@waynerv](https://github.com/waynerv).
  * ğŸŒ� Add Japanese translation for Deployment - Manually. PR [#2313](https://github.com/tiangolo/fastapi/pull/2313) by [@tokusumi](https://github.com/tokusumi).
  * ğŸŒ� Add Japanese translation for Deployment - Intro. PR [#2309](https://github.com/tiangolo/fastapi/pull/2309) by [@tokusumi](https://github.com/tokusumi).
  * ğŸŒ� Add Japanese translation for FastAPI People. PR [#2254](https://github.com/tiangolo/fastapi/pull/2254) by [@tokusumi](https://github.com/tokusumi).
  * ğŸŒ� Add Japanese translation for Advanced - Path Operation Advanced Configuration. PR [#2124](https://github.com/tiangolo/fastapi/pull/2124) by [@Attsun1031](https://github.com/Attsun1031).
  * ğŸŒ� Add Japanese translation for External Links. PR [#2070](https://github.com/tiangolo/fastapi/pull/2070) by [@tokusumi](https://github.com/tokusumi).
  * ğŸŒ� Add Japanese translation for Tutorial - Body - Updates. PR [#1956](https://github.com/tiangolo/fastapi/pull/1956) by [@SwftAlpc](https://github.com/SwftAlpc).
  * ğŸŒ� Add Japanese translation for Tutorial - Form Data. PR [#1943](https://github.com/tiangolo/fastapi/pull/1943) by [@SwftAlpc](https://github.com/SwftAlpc).
  * ğŸŒ� Add Japanese translation for Tutorial - Cookie Parameters. PR [#1933](https://github.com/tiangolo/fastapi/pull/1933) by [@SwftAlpc](https://github.com/SwftAlpc).

### Internal[¶](#internal_107 "Permanent link")

  * ğŸ”§ Update top banner, point to newsletter. PR [#3003](https://github.com/tiangolo/fastapi/pull/3003) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”§ Disable sponsor WeTransfer. PR [#3002](https://github.com/tiangolo/fastapi/pull/3002) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘¥ Update FastAPI People. PR [#2880](https://github.com/tiangolo/fastapi/pull/2880) by [@github-actions[bot]](https://github.com/apps/github-actions).
  * ğŸ‘¥ Update FastAPI People. PR [#2739](https://github.com/tiangolo/fastapi/pull/2739) by [@github-actions[bot]](https://github.com/apps/github-actions).
  * ğŸ”§ Add new Gold Sponsor Talk Python ğŸ�‰. PR [#2673](https://github.com/tiangolo/fastapi/pull/2673) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”§ Add new Gold Sponsor vim.so ğŸ�‰. PR [#2669](https://github.com/tiangolo/fastapi/pull/2669) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”§ Add FastAPI user survey banner. PR [#2623](https://github.com/tiangolo/fastapi/pull/2623) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”§ Add new Bronze Sponsor(s) ğŸ¥‰ğŸ�‰. PR [#2622](https://github.com/tiangolo/fastapi/pull/2622) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ“� Update social links: add Discord, fix GitHub. PR [#2621](https://github.com/tiangolo/fastapi/pull/2621) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”§ Update FastAPI People GitHub Sponsors order. PR [#2620](https://github.com/tiangolo/fastapi/pull/2620) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”§ Update InvestSuite sponsor data. PR [#2608](https://github.com/tiangolo/fastapi/pull/2608) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘¥ Update FastAPI People. PR [#2590](https://github.com/tiangolo/fastapi/pull/2590) by [@github-actions[bot]](https://github.com/apps/github-actions).

## 0.63.0[¶](#0630 "Permanent link")

### Features[¶](#features_46 "Permanent link")

  * âœ¨ Improve type annotations, add support for mypy --strict, internally and for external packages. PR [#2547](https://github.com/tiangolo/fastapi/pull/2547) by [@tiangolo](https://github.com/tiangolo).

### Breaking changes[¶](#breaking-changes_8 "Permanent link")

  * â¬†ï¸� Upgrade Uvicorn when installing `fastapi[all]` to the latest version including `uvloop`, the new range is `uvicorn[standard] >=0.12.0,<0.14.0`. PR [#2548](https://github.com/tiangolo/fastapi/pull/2548) by [@tiangolo](https://github.com/tiangolo).

### Fixes[¶](#fixes_63 "Permanent link")

  * ğŸ�› PR [#2547](https://github.com/tiangolo/fastapi/pull/2547) (read above) also fixes some false-positive mypy errors with `callbacks` parameters and when using the `OAuth2` class.

### Docs[¶](#docs_84 "Permanent link")

  * ğŸ“� Update Uvicorn installation instructions to use uvicorn[standard] (includes uvloop). PR [#2543](https://github.com/tiangolo/fastapi/pull/2543) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ“� Update title for Deta tutorial. PR [#2466](https://github.com/tiangolo/fastapi/pull/2466) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘¥ Update FastAPI People. PR [#2454](https://github.com/tiangolo/fastapi/pull/2454) by [@github-actions[bot]](https://github.com/apps/github-actions).

### Translations[¶](#translations_84 "Permanent link")

  * ğŸŒ� Add docs lang selector widget. PR [#2542](https://github.com/tiangolo/fastapi/pull/2542) by [@tiangolo](https://github.com/tiangolo).
  * ğŸŒ� Add Chinese translation for Tutorial - Response Status Code. PR [#2442](https://github.com/tiangolo/fastapi/pull/2442) by [@waynerv](https://github.com/waynerv).
  * ğŸŒ� Start translation of the documentation for the Albanian language. PR [#2516](https://github.com/tiangolo/fastapi/pull/2516) by [@vjanz](https://github.com/vjanz).
  * ğŸŒ� Add Chinese translation for Tutorial - Extra Models. PR [#2416](https://github.com/tiangolo/fastapi/pull/2416) by [@waynerv](https://github.com/waynerv).
  * ğŸŒ� Add Chinese translation for Tutorial - Response Model. PR [#2414](https://github.com/tiangolo/fastapi/pull/2414) by [@waynerv](https://github.com/waynerv).
  * ğŸŒ� Add Chinese translation for Tutorial - Schema Extra Example. PR [#2411](https://github.com/tiangolo/fastapi/pull/2411) by [@maoyibo](https://github.com/maoyibo).
  * ğŸŒ� Add Korean translation for Index. PR [#2192](https://github.com/tiangolo/fastapi/pull/2192) by [@hard-coders](https://github.com/hard-coders).
  * ğŸŒ� Add Japanese translation for Advanced User Guide - Additional Status Codes. PR [#2145](https://github.com/tiangolo/fastapi/pull/2145) by [@Attsun1031](https://github.com/Attsun1031).

### Internal[¶](#internal_108 "Permanent link")

  * ğŸ�› Fix docs overrides directory for translations. PR [#2541](https://github.com/tiangolo/fastapi/pull/2541) by [@tiangolo](https://github.com/tiangolo).
  * â�– Remove Typer as a docs building dependency (covered by typer-cli) to fix pip resolver conflicts. PR [#2539](https://github.com/tiangolo/fastapi/pull/2539) by [@tiangolo](https://github.com/tiangolo).
  * âœ¨ Add newsletter: FastAPI and friends. PR [#2509](https://github.com/tiangolo/fastapi/pull/2509) by [@tiangolo](https://github.com/tiangolo).
  * âœ¨ Add new Gold Sponsor: InvestSuite ğŸ�‰. PR [#2508](https://github.com/tiangolo/fastapi/pull/2508) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”§ Add issue template configs. PR [#2476](https://github.com/tiangolo/fastapi/pull/2476) by [@tiangolo](https://github.com/tiangolo).

## 0.62.0[¶](#0620 "Permanent link")

### Features[¶](#features_47 "Permanent link")

  * âœ¨ Add support for shared/top-level parameters (dependencies, tags, etc). PR [#2434](https://github.com/tiangolo/fastapi/pull/2434) by [@tiangolo](https://github.com/tiangolo).

Up to now, for several options, the only way to apply them to a group of _path operations_ was in `include_router`. That works well, but the call to `app.include_router()` or `router.include_router()` is normally done in another file.

That means that, for example, to apply authentication to all the _path operations_ in a router it would end up being done in a different file, instead of keeping related logic together.

Setting options in `include_router` still makes sense in some cases, for example, to override or increase configurations from a third party router included in an app. But in a router that is part of a bigger application, it would probably make more sense to add those settings when creating the `APIRouter`.

**In`FastAPI`**

This allows setting the (mostly new) parameters (additionally to the already existing parameters):

  * `default_response_class`: updated to handle defaults in `APIRouter` and `include_router`.
  * `dependencies`: to include âœ¨ top-level dependencies âœ¨ that apply to the whole application. E.g. to add global authentication.
  * `callbacks`: OpenAPI callbacks that apply to all the _path operations_.
  * `deprecated`: to mark all the _path operations_ as deprecated. ğŸ¤·
  * `include_in_schema`: to allow excluding all the _path operations_ from the OpenAPI schema.
  * `responses`: OpenAPI responses that apply to all the _path operations_.

For example:
    
    
    from fastapi import FastAPI, Depends
    
    
    async def some_dependency():
        return
    
    
    app = FastAPI(dependencies=[Depends(some_dependency)])
    

**In`APIRouter`**

This allows setting the (mostly new) parameters (additionally to the already existing parameters):

  * `default_response_class`: updated to handle defaults in `APIRouter` and `include_router`. For example, it's not needed to set it explicitly when [creating callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).
  * `dependencies`: to include âœ¨ router-level dependencies âœ¨ that apply to all the _path operations_ in a router. Up to now, this was only possible with `include_router`.
  * `callbacks`: OpenAPI callbacks that apply to all the _path operations_ in this router.
  * `deprecated`: to mark all the _path operations_ in a router as deprecated.
  * `include_in_schema`: to allow excluding all the _path operations_ in a router from the OpenAPI schema.
  * `responses`: OpenAPI responses that apply to all the _path operations_ in a router.
  * `prefix`: to set the path prefix for a router. Up to now, this was only possible when calling `include_router`.
  * `tags`: OpenAPI tags to apply to all the _path operations_ in this router.

For example:
    
    
    from fastapi import APIRouter, Depends
    
    
    async def some_dependency():
        return
    
    
    router = APIRouter(prefix="/users", dependencies=[Depends(some_dependency)])
    

**In`include_router`**

Most of these settings are now supported in `APIRouter`, which normally lives closer to the related code, so it is recommended to use `APIRouter` when possible.

But `include_router` is still useful to, for example, adding options (like `dependencies`, `prefix`, and `tags`) when including a third party router, or a generic router that is shared between several projects.

This PR allows setting the (mostly new) parameters (additionally to the already existing parameters):

  * `default_response_class`: updated to handle defaults in `APIRouter` and `FastAPI`.
  * `deprecated`: to mark all the _path operations_ in a router as deprecated in OpenAPI.
  * `include_in_schema`: to allow disabling all the _path operations_ from showing in the OpenAPI schema.
  * `callbacks`: OpenAPI callbacks that apply to all the _path operations_ in this router.

Note: all the previous parameters are still there, so it's still possible to declare `dependencies` in `include_router`.

### Breaking Changes[¶](#breaking-changes_9 "Permanent link")

  * PR [#2434](https://github.com/tiangolo/fastapi/pull/2434) includes several improvements that shouldn't affect normal use cases, but could affect in advanced scenarios:
    * If you are testing the generated OpenAPI (you shouldn't, FastAPI already tests it extensively for you): the order for `tags` in `include_router` and _path operations_ was updated for consistency, but it's a simple order change.
    * If you have advanced custom logic to access each route's `route.response_class`, or the `router.default_response_class`, or the `app.default_response_class`: the default value for `response_class` in `APIRoute` and for `default_response_class` in `APIRouter` and `FastAPI` is now a `DefaultPlaceholder` used internally to handle and solve default values and overrides. The actual response class inside the `DefaultPlaceholder` is available at `route.response_class.value`.

### Docs[¶](#docs_85 "Permanent link")

  * PR [#2434](https://github.com/tiangolo/fastapi/pull/2434) (above) includes new or updated docs:

    * [Advanced User Guide - OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).
    * [Tutorial - Bigger Applications](https://fastapi.tiangolo.com/tutorial/bigger-applications/).
    * [Tutorial - Dependencies - Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).
    * [Tutorial - Dependencies - Global Dependencies](https://fastapi.tiangolo.com/tutorial/dependencies/global-dependencies/).
  * ğŸ“� Add FastAPI monitoring blog post to External Links. PR [#2324](https://github.com/tiangolo/fastapi/pull/2324) by [@louisguitton](https://github.com/louisguitton).

  * âœ�ï¸� Fix typo in Deta tutorial. PR [#2320](https://github.com/tiangolo/fastapi/pull/2320) by [@tiangolo](https://github.com/tiangolo).
  * âœ¨ Add Discord chat. PR [#2322](https://github.com/tiangolo/fastapi/pull/2322) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ“� Fix image links for sponsors. PR [#2304](https://github.com/tiangolo/fastapi/pull/2304) by [@tiangolo](https://github.com/tiangolo).

### Translations[¶](#translations_85 "Permanent link")

  * ğŸŒ� Add Japanese translation for Advanced - Custom Response. PR [#2193](https://github.com/tiangolo/fastapi/pull/2193) by [@Attsun1031](https://github.com/Attsun1031).
  * ğŸŒ� Add Chinese translation for Benchmarks. PR [#2119](https://github.com/tiangolo/fastapi/pull/2119) by [@spaceack](https://github.com/spaceack).
  * ğŸŒ� Add Chinese translation for Tutorial - Body - Nested Models. PR [#1609](https://github.com/tiangolo/fastapi/pull/1609) by [@waynerv](https://github.com/waynerv).
  * ğŸŒ� Add Chinese translation for Advanced - Custom Response. PR [#1459](https://github.com/tiangolo/fastapi/pull/1459) by [@RunningIkkyu](https://github.com/RunningIkkyu).
  * ğŸŒ� Add Chinese translation for Advanced - Return a Response Directly. PR [#1452](https://github.com/tiangolo/fastapi/pull/1452) by [@RunningIkkyu](https://github.com/RunningIkkyu).
  * ğŸŒ� Add Chinese translation for Advanced - Additional Status Codes. PR [#1451](https://github.com/tiangolo/fastapi/pull/1451) by [@RunningIkkyu](https://github.com/RunningIkkyu).
  * ğŸŒ� Add Chinese translation for Advanced - Path Operation Advanced Configuration. PR [#1447](https://github.com/tiangolo/fastapi/pull/1447) by [@RunningIkkyu](https://github.com/RunningIkkyu).
  * ğŸŒ� Add Chinese translation for Advanced User Guide - Intro. PR [#1445](https://github.com/tiangolo/fastapi/pull/1445) by [@RunningIkkyu](https://github.com/RunningIkkyu).

### Internal[¶](#internal_109 "Permanent link")

  * ğŸ”§ Update TestDriven link to course in sponsors section. PR [#2435](https://github.com/tiangolo/fastapi/pull/2435) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ�± Update sponsor logos. PR [#2418](https://github.com/tiangolo/fastapi/pull/2418) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ’š Fix disabling install of Material for MkDocs Insiders in forks, strike 1 âš¾. PR [#2340](https://github.com/tiangolo/fastapi/pull/2340) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ�› Fix disabling Material for MkDocs Insiders install in forks. PR [#2339](https://github.com/tiangolo/fastapi/pull/2339) by [@tiangolo](https://github.com/tiangolo).
  * âœ¨ Add silver sponsor WeTransfer. PR [#2338](https://github.com/tiangolo/fastapi/pull/2338) by [@tiangolo](https://github.com/tiangolo).
  * âœ¨ Set up and enable Material for MkDocs Insiders for the docs. PR [#2325](https://github.com/tiangolo/fastapi/pull/2325) by [@tiangolo](https://github.com/tiangolo).

## 0.61.2[¶](#0612 "Permanent link")

### Fixes[¶](#fixes_64 "Permanent link")

  * ğŸ“Œ Relax Swagger UI version pin. PR [#2089](https://github.com/tiangolo/fastapi/pull/2089) by [@jmriebold](https://github.com/jmriebold).
  * ğŸ�› Fix bug overriding custom HTTPException and RequestValidationError from exception_handlers. PR [#1924](https://github.com/tiangolo/fastapi/pull/1924) by [@uriyyo](https://github.com/uriyyo).
  * âœ�ï¸� Fix typo on dependencies utils and cleanup unused variable. PR [#1912](https://github.com/tiangolo/fastapi/pull/1912) by [@Kludex](https://github.com/Kludex).

### Docs[¶](#docs_86 "Permanent link")

  * âœ�ï¸� Fix typo in Tutorial - Path Parameters. PR [#2231](https://github.com/tiangolo/fastapi/pull/2231) by [@mariacamilagl](https://github.com/mariacamilagl).
  * âœ� Fix a stylistic error in docs. PR [#2206](https://github.com/tiangolo/fastapi/pull/2206) by [@ddobrinskiy](https://github.com/ddobrinskiy).
  * âœ� Fix capitalizaiton typo in docs. PR [#2204](https://github.com/tiangolo/fastapi/pull/2204) by [@imba-tjd](https://github.com/imba-tjd).
  * âœ� Fix typo in docs. PR [#2179](https://github.com/tiangolo/fastapi/pull/2179) by [@ammarasmro](https://github.com/ammarasmro).
  * ğŸ“� Update/fix links in docs to use HTTPS. PR [#2165](https://github.com/tiangolo/fastapi/pull/2165) by [@imba-tjd](https://github.com/imba-tjd).
  * âœ� Fix typos and add rewording in docs. PR [#2159](https://github.com/tiangolo/fastapi/pull/2159) by [@nukopy](https://github.com/nukopy).
  * ğŸ“� Fix code consistency in examples for Tutorial - User Guide - Path Parameters. PR [#2158](https://github.com/tiangolo/fastapi/pull/2158) by [@nukopy](https://github.com/nukopy).
  * ğŸ“� Fix renamed parameter `content_type` typo. PR [#2135](https://github.com/tiangolo/fastapi/pull/2135) by [@TeoZosa](https://github.com/TeoZosa).
  * âœ� Fix minor typos in docs. PR [#2122](https://github.com/tiangolo/fastapi/pull/2122) by [@TeoZosa](https://github.com/TeoZosa).
  * âœ� Fix typos in docs and source examples. PR [#2102](https://github.com/tiangolo/fastapi/pull/2102) by [@AdrianDeAnda](https://github.com/AdrianDeAnda).
  * âœ� Fix incorrect Celery URLs in docs. PR [#2100](https://github.com/tiangolo/fastapi/pull/2100) by [@CircleOnCircles](https://github.com/CircleOnCircles).
  * ğŸ“� Simplify intro to Python Types, all currently supported Python versions include type hints ğŸ�‰. PR [#2085](https://github.com/tiangolo/fastapi/pull/2085) by [@ninjaaron](https://github.com/ninjaaron).
  * ğŸ“� Fix example code with sets in Tutorial - Body - Nested Models 3. PR [#2054](https://github.com/tiangolo/fastapi/pull/2054) by [@hitrust](https://github.com/hitrust).
  * ğŸ“� Fix example code with sets in Tutorial - Body - Nested Models 2. PR [#2053](https://github.com/tiangolo/fastapi/pull/2053) by [@hitrust](https://github.com/hitrust).
  * ğŸ“� Fix example code with sets in Tutorial - Body - Nested Models. PR [#2052](https://github.com/tiangolo/fastapi/pull/2052) by [@hitrust](https://github.com/hitrust).
  * âœ� Fix typo in Benchmarks. PR [#1995](https://github.com/tiangolo/fastapi/pull/1995) by [@AlejoAsd](https://github.com/AlejoAsd).
  * ğŸ“� Add note in CORS tutorial about allow_origins with ["*"] and allow_credentials. PR [#1895](https://github.com/tiangolo/fastapi/pull/1895) by [@dsmurrell](https://github.com/dsmurrell).
  * ğŸ“� Add deployment to Deta, the first gold sponsor ğŸ�‰. PR [#2303](https://github.com/tiangolo/fastapi/pull/2303) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘¥ Update FastAPI People. PR [#2282](https://github.com/tiangolo/fastapi/pull/2282) by [@github-actions[bot]](https://github.com/apps/github-actions).
  * âœ�ï¸� Fix uppercase in Tutorial - Query parameters. PR [#2245](https://github.com/tiangolo/fastapi/pull/2245) by [@mariacamilagl](https://github.com/mariacamilagl).
  * ğŸ“� Add articles to External Links. PR [#2247](https://github.com/tiangolo/fastapi/pull/2247) by [@tiangolo](https://github.com/tiangolo).
  * âœ� Fix typo in Spanish tutorial index. PR [#2020](https://github.com/tiangolo/fastapi/pull/2020) by [@aviloncho](https://github.com/aviloncho).

### Translations[¶](#translations_86 "Permanent link")

  * ğŸŒ� Add Japanese translation for Advanced Tutorial - Response Directly. PR [#2191](https://github.com/tiangolo/fastapi/pull/2191) by [@Attsun1031](https://github.com/Attsun1031).
  * ğŸ“� Add Japanese translation for Tutorial - Security - First Steps. PR [#2153](https://github.com/tiangolo/fastapi/pull/2153) by [@komtaki](https://github.com/komtaki).
  * ğŸŒ� Add Japanese translation for Tutorial - Query Parameters and String Validations. PR [#1901](https://github.com/tiangolo/fastapi/pull/1901) by [@SwftAlpc](https://github.com/SwftAlpc).
  * ğŸŒ� Add Portuguese translation for External Links. PR [#1443](https://github.com/tiangolo/fastapi/pull/1443) by [@Serrones](https://github.com/Serrones).
  * ğŸŒ� Add Japanese translation for Tutorial - CORS. PR [#2125](https://github.com/tiangolo/fastapi/pull/2125) by [@tokusumi](https://github.com/tokusumi).
  * ğŸŒ� Add Japanese translation for Contributing. PR [#2067](https://github.com/tiangolo/fastapi/pull/2067) by [@komtaki](https://github.com/komtaki).
  * ğŸŒ� Add Japanese translation for Project Generation. PR [#2050](https://github.com/tiangolo/fastapi/pull/2050) by [@tokusumi](https://github.com/tokusumi).
  * ğŸŒ� Add Japanese translation for Alternatives. PR [#2043](https://github.com/tiangolo/fastapi/pull/2043) by [@Attsun1031](https://github.com/Attsun1031).
  * ğŸŒ� Add Japanese translation for History Design and Future. PR [#2002](https://github.com/tiangolo/fastapi/pull/2002) by [@komtaki](https://github.com/komtaki).
  * ğŸŒ� Add Japanese translation for Benchmarks. PR [#1992](https://github.com/tiangolo/fastapi/pull/1992) by [@komtaki](https://github.com/komtaki).
  * ğŸŒ� Add Japanese translation for Tutorial - Header Parameters. PR [#1935](https://github.com/tiangolo/fastapi/pull/1935) by [@SwftAlpc](https://github.com/SwftAlpc).
  * ğŸŒ� Add Portuguese translation for Tutorial - First Steps. PR [#1861](https://github.com/tiangolo/fastapi/pull/1861) by [@jessicapaz](https://github.com/jessicapaz).
  * ğŸŒ� Add Portuguese translation for Python Types. PR [#1796](https://github.com/tiangolo/fastapi/pull/1796) by [@izaguerreiro](https://github.com/izaguerreiro).
  * ğŸŒ� Add Japanese translation for Help FastAPI. PR [#1692](https://github.com/tiangolo/fastapi/pull/1692) by [@tokusumi](https://github.com/tokusumi).
  * ğŸŒ� Add Japanese translation for Tutorial - Body. PR [#1683](https://github.com/tiangolo/fastapi/pull/1683) by [@tokusumi](https://github.com/tokusumi).
  * ğŸŒ� Add Japanese translation for Tutorial - Query Params. PR [#1674](https://github.com/tiangolo/fastapi/pull/1674) by [@tokusumi](https://github.com/tokusumi).
  * ğŸŒ� Add Japanese translation for tutorial/path-params.md. PR [#1671](https://github.com/tiangolo/fastapi/pull/1671) by [@tokusumi](https://github.com/tokusumi).
  * ğŸŒ� Add Japanese translation for tutorial/first-steps.md. PR [#1658](https://github.com/tiangolo/fastapi/pull/1658) by [@tokusumi](https://github.com/tokusumi).
  * ğŸŒ� Add Japanese translation for tutorial/index.md. PR [#1656](https://github.com/tiangolo/fastapi/pull/1656) by [@tokusumi](https://github.com/tokusumi).
  * ğŸŒ� Add translation to Portuguese for Project Generation. PR [#1602](https://github.com/tiangolo/fastapi/pull/1602) by [@Serrones](https://github.com/Serrones).
  * ğŸŒ� Add Japanese translation for Features. PR [#1625](https://github.com/tiangolo/fastapi/pull/1625) by [@tokusumi](https://github.com/tokusumi).
  * ğŸŒ� Initialize new language Korean for translations. PR [#2018](https://github.com/tiangolo/fastapi/pull/2018) by [@hard-coders](https://github.com/hard-coders).
  * ğŸŒ� Add Portuguese translation of Deployment. PR [#1374](https://github.com/tiangolo/fastapi/pull/1374) by [@Serrones](https://github.com/Serrones).

### Internal[¶](#internal_110 "Permanent link")

  * ğŸ”¥ Cleanup after upgrade for Docs Previews GitHub Action. PR [#2248](https://github.com/tiangolo/fastapi/pull/2248) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ�› Fix CI docs preview, unzip docs. PR [#2246](https://github.com/tiangolo/fastapi/pull/2246) by [@tiangolo](https://github.com/tiangolo).
  * âœ¨ Add instant docs deploy previews for PRs from forks. PR [#2244](https://github.com/tiangolo/fastapi/pull/2244) by [@tiangolo](https://github.com/tiangolo).
  * âš¡ï¸� Build docs for languages in parallel in subprocesses to speed up CI. PR [#2242](https://github.com/tiangolo/fastapi/pull/2242) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ�› Fix docs order generation for partial translations. PR [#2238](https://github.com/tiangolo/fastapi/pull/2238) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘¥ Update FastAPI People. PR [#2202](https://github.com/tiangolo/fastapi/pull/2202) by [@github-actions[bot]](https://github.com/apps/github-actions).
  * â™»ï¸� Update FastAPI People GitHub Action to send the PR as github-actions. PR [#2201](https://github.com/tiangolo/fastapi/pull/2201) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”§ Update FastAPI People GitHub Action config, run monthly. PR [#2199](https://github.com/tiangolo/fastapi/pull/2199) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ�› Fix FastAPI People GitHub Action Docker dependency, strike 1 âš¾. PR [#2198](https://github.com/tiangolo/fastapi/pull/2198) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ�› Fix FastAPI People GitHub Action Docker dependencies. PR [#2197](https://github.com/tiangolo/fastapi/pull/2197) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ�› Fix FastAPI People GitHub Action when there's nothing to change. PR [#2196](https://github.com/tiangolo/fastapi/pull/2196) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘¥ Add new section FastAPI People. PR [#2195](https://github.com/tiangolo/fastapi/pull/2195) by [@tiangolo](https://github.com/tiangolo).
  * â¬†ï¸� Upgrade GitHub Action Latest Changes. PR [#2190](https://github.com/tiangolo/fastapi/pull/2190) by [@tiangolo](https://github.com/tiangolo).
  * â¬†ï¸� Upgrade GitHub Action Label Approved. PR [#2189](https://github.com/tiangolo/fastapi/pull/2189) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”§ Update GitHub Action Label Approved, run at 12:00. PR [#2185](https://github.com/tiangolo/fastapi/pull/2185) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘· Upgrade GitHub Action Latest Changes. PR [#2184](https://github.com/tiangolo/fastapi/pull/2184) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘· Set GitHub Action Label Approved to run daily, not every minute. PR [#2163](https://github.com/tiangolo/fastapi/pull/2163) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ”¥ Remove pr-approvals GitHub Action as it's not compatible with forks. Use the new one. PR [#2162](https://github.com/tiangolo/fastapi/pull/2162) by [@tiangolo](https://github.com/tiangolo).
  * ğŸ‘· Add GitHub Action Latest Changes. PR [#2160](https://github.com/tiangolo/fastapi/pull/2160).
  * ğŸ‘· Add GitHub Action Label Approved. PR [#2161](https://github.com/tiangolo/fastapi/pull/2161).

## 0.61.1[¶](#0611 "Permanent link")

### Fixes[¶](#fixes_65 "Permanent link")

  * Fix issues using `jsonable_encoder` with SQLAlchemy models directly. PR [#1987](https://github.com/tiangolo/fastapi/pull/1987).

### Docs[¶](#docs_87 "Permanent link")

  * Fix typo in NoSQL docs. PR [#1980](https://github.com/tiangolo/fastapi/pull/1980) by [@facundojmaero](https://github.com/facundojmaero).

### Translations[¶](#translations_87 "Permanent link")

  * Add translation for [main page to Japanese](https://fastapi.tiangolo.com/ja/) PR [#1571](https://github.com/tiangolo/fastapi/pull/1571) by [@ryuckel](https://github.com/ryuckel).
  * Initialize French translations. PR [#1975](https://github.com/tiangolo/fastapi/pull/1975) by [@JulianMaurin-BM](https://github.com/JulianMaurin-BM).
  * Initialize Turkish translations. PR [#1905](https://github.com/tiangolo/fastapi/pull/1905) by [@ycd](https://github.com/ycd).

### Internal[¶](#internal_111 "Permanent link")

  * Improve docs maintainability by updating `hl_lines` syntax to use ranges. PR [#1863](https://github.com/tiangolo/fastapi/pull/1863) by [@la-mar](https://github.com/la-mar).

## 0.61.0[¶](#0610 "Permanent link")

### Features[¶](#features_48 "Permanent link")

  * Add support for injecting `HTTPConnection` (as `Request` and `WebSocket`). Useful for sharing app state in dependencies. PR [#1827](https://github.com/tiangolo/fastapi/pull/1827) by [@nsidnev](https://github.com/nsidnev).
  * Export `WebSocketDisconnect` and add example handling WebSocket disconnections to docs. PR [#1822](https://github.com/tiangolo/fastapi/pull/1822) by [@rkbeatss](https://github.com/rkbeatss).

### Breaking Changes[¶](#breaking-changes_10 "Permanent link")

  * Require Pydantic > `1.0.0`.
    * Remove support for deprecated Pydantic `0.32.2`. This improves maintainability and allows new features.
    * In `FastAPI` and `APIRouter`:
      * Remove _path operation decorators_ related/deprecated parameter `response_model_skip_defaults` (use `response_model_exclude_unset` instead).
      * Change _path operation decorators_ parameter default for `response_model_exclude` from `set()` to `None` (as is in Pydantic).
    * In `encoders.jsonable_encoder`:
      * Remove deprecated `skip_defaults`, use instead `exclude_unset`.
      * Set default of `exclude` from `set()` to `None` (as is in Pydantic).
    * PR [#1862](https://github.com/tiangolo/fastapi/pull/1862).
  * In `encoders.jsonable_encoder` remove parameter `sqlalchemy_safe`.
    * It was an early hack to allow returning SQLAlchemy models, but it was never documented, and the recommended way is using Pydantic's `orm_mode` as described in the tutorial: [SQL (Relational) Databases](https://fastapi.tiangolo.com/tutorial/sql-databases/).
    * PR [#1864](https://github.com/tiangolo/fastapi/pull/1864).

### Docs[¶](#docs_88 "Permanent link")

  * Add link to the course by TestDriven.io: [Test-Driven Development with FastAPI and Docker](https://testdriven.io/courses/tdd-fastapi/). PR [#1860](https://github.com/tiangolo/fastapi/pull/1860).
  * Fix empty log message in docs example about handling errors. PR [#1815](https://github.com/tiangolo/fastapi/pull/1815) by [@manlix](https://github.com/manlix).
  * Reword text to reduce ambiguity while not being gender-specific. PR [#1824](https://github.com/tiangolo/fastapi/pull/1824) by [@Mause](https://github.com/Mause).

### Internal[¶](#internal_112 "Permanent link")

  * Add Flake8 linting. Original PR [#1774](https://github.com/tiangolo/fastapi/pull/1774) by [@MashhadiNima](https://github.com/MashhadiNima).
  * Disable Gitter bot, as it's currently broken, and Gitter's response doesn't show the problem. PR [#1853](https://github.com/tiangolo/fastapi/pull/1853).

## 0.60.2[¶](#0602 "Permanent link")

  * Fix typo in docs for query parameters. PR [#1832](https://github.com/tiangolo/fastapi/pull/1832) by [@ycd](https://github.com/ycd).
  * Add docs about [Async Tests](https://fastapi.tiangolo.com/advanced/async-tests/). PR [#1619](https://github.com/tiangolo/fastapi/pull/1619) by [@empicano](https://github.com/empicano).
  * Raise an exception when using form data (`Form`, `File`) without having `python-multipart` installed.
    * Up to now the application would run, and raise an exception only when receiving a request with form data, the new behavior, raising early, will prevent from deploying applications with broken dependencies.
    * It also detects if the correct package `python-multipart` is installed instead of the incorrect `multipart` (both importable as `multipart`).
    * PR [#1851](https://github.com/tiangolo/fastapi/pull/1851) based on original PR [#1627](https://github.com/tiangolo/fastapi/pull/1627) by [@chrisngyn](https://github.com/chrisngyn), [@YKo20010](https://github.com/YKo20010), [@kx-chen](https://github.com/kx-chen).
  * Re-enable Gitter releases bot. PR [#1831](https://github.com/tiangolo/fastapi/pull/1831).
  * Add link to async SQL databases tutorial from main SQL tutorial. PR [#1813](https://github.com/tiangolo/fastapi/pull/1813) by [@short2strings](https://github.com/short2strings).
  * Fix typo in tutorial about behind a proxy. PR [#1807](https://github.com/tiangolo/fastapi/pull/1807) by [@toidi](https://github.com/toidi).
  * Fix typo in Portuguese docs. PR [#1795](https://github.com/tiangolo/fastapi/pull/1795) by [@izaguerreiro](https://github.com/izaguerreiro).
  * Add translations setup for Ukrainian. PR [#1830](https://github.com/tiangolo/fastapi/pull/1830).
  * Add external link [Build And Host Fast Data Science Applications Using FastAPI](https://towardsdatascience.com/build-and-host-fast-data-science-applications-using-fastapi-823be8a1d6a0). PR [#1786](https://github.com/tiangolo/fastapi/pull/1786) by [@Kludex](https://github.com/Kludex).
  * Fix encoding of Pydantic models that inherit from others models with custom `json_encoders`. PR [#1769](https://github.com/tiangolo/fastapi/pull/1769) by [@henrybetts](https://github.com/henrybetts).
  * Simplify and improve `jsonable_encoder`. PR [#1754](https://github.com/tiangolo/fastapi/pull/1754) by [@MashhadiNima](https://github.com/MashhadiNima).
  * Simplify internal code syntax in several points. PR [#1753](https://github.com/tiangolo/fastapi/pull/1753) by [@uriyyo](https://github.com/uriyyo).
  * Improve internal typing, declare `Optional` parameters. PR [#1731](https://github.com/tiangolo/fastapi/pull/1731) by [@MashhadiNima](https://github.com/MashhadiNima).
  * Add external link [Deploy FastAPI on Azure App Service](https://www.tutlinks.com/deploy-fastapi-on-azure/) to docs. PR [#1726](https://github.com/tiangolo/fastapi/pull/1726) by [@windson](https://github.com/windson).
  * Add link to Starlette docs about WebSocket testing. PR [#1717](https://github.com/tiangolo/fastapi/pull/1717) by [@hellocoldworld](https://github.com/hellocoldworld).
  * Refactor generating dependant, merge for loops. PR [#1714](https://github.com/tiangolo/fastapi/pull/1714) by [@Bloodielie](https://github.com/Bloodielie).
  * Update example for templates with Jinja to include HTML media type. PR [#1690](https://github.com/tiangolo/fastapi/pull/1690) by [@frafra](https://github.com/frafra).
  * Fix typos in docs for security. PR [#1678](https://github.com/tiangolo/fastapi/pull/1678) by [@nilslindemann](https://github.com/nilslindemann).
  * Fix typos in docs for dependencies. PR [#1675](https://github.com/tiangolo/fastapi/pull/1675) by [@nilslindemann](https://github.com/nilslindemann).
  * Fix type annotation for `**extra` parameters in `FastAPI`. PR [#1659](https://github.com/tiangolo/fastapi/pull/1659) by [@bharel](https://github.com/bharel).
  * Bump MkDocs Material to fix docs in browsers with dark mode. PR [#1789](https://github.com/tiangolo/fastapi/pull/1789) by [@adriencaccia](https://github.com/adriencaccia).
  * Remove docs preview comment from each commit. PR [#1826](https://github.com/tiangolo/fastapi/pull/1826).
  * Update GitHub context extraction for Gitter notification bot. PR [#1766](https://github.com/tiangolo/fastapi/pull/1766).

## 0.60.1[¶](#0601 "Permanent link")

  * Add debugging logs for GitHub actions to introspect GitHub hidden context. PR [#1764](https://github.com/tiangolo/fastapi/pull/1764).
  * Use OS preference theme for online docs. PR [#1760](https://github.com/tiangolo/fastapi/pull/1760) by [@adriencaccia](https://github.com/adriencaccia).
  * Upgrade Starlette to version `0.13.6` to handle a vulnerability when using static files in Windows. PR [#1759](https://github.com/tiangolo/fastapi/pull/1759) by [@jamesag26](https://github.com/jamesag26).
  * Pin Swagger UI temporarily, waiting for a fix for [swagger-api/swagger-ui#6249](https://github.com/swagger-api/swagger-ui/issues/6249). PR [#1763](https://github.com/tiangolo/fastapi/pull/1763).
  * Update GitHub Actions, use commit from PR for docs preview, not commit from pre-merge. PR [#1761](https://github.com/tiangolo/fastapi/pull/1761).
  * Update GitHub Actions, refactor Gitter bot. PR [#1746](https://github.com/tiangolo/fastapi/pull/1746).

## 0.60.0[¶](#0600 "Permanent link")

  * Add GitHub Action to watch for missing preview docs and trigger a preview deploy. PR [#1740](https://github.com/tiangolo/fastapi/pull/1740).
  * Add custom GitHub Action to get artifact with docs preview. PR [#1739](https://github.com/tiangolo/fastapi/pull/1739).
  * Add new GitHub Actions to preview docs from PRs. PR [#1738](https://github.com/tiangolo/fastapi/pull/1738).
  * Add XML test coverage to support GitHub Actions. PR [#1737](https://github.com/tiangolo/fastapi/pull/1737).
  * Update badges and remove Travis now that GitHub Actions is the main CI. PR [#1736](https://github.com/tiangolo/fastapi/pull/1736).
  * Add GitHub Actions for CI, move from Travis. PR [#1735](https://github.com/tiangolo/fastapi/pull/1735).
  * Add support for adding OpenAPI schema for GET requests with a body. PR [#1626](https://github.com/tiangolo/fastapi/pull/1626) by [@victorphoenix3](https://github.com/victorphoenix3).

## 0.59.0[¶](#0590 "Permanent link")

  * Fix typo in docstring for OAuth2 utils. PR [#1621](https://github.com/tiangolo/fastapi/pull/1621) by [@tomarv2](https://github.com/tomarv2).
  * Update JWT docs to use Python-jose instead of PyJWT. Initial PR [#1610](https://github.com/tiangolo/fastapi/pull/1610) by [@asheux](https://github.com/asheux).
  * Fix/re-enable search bar in docs. PR [#1703](https://github.com/tiangolo/fastapi/pull/1703).
  * Auto-generate a "server" in OpenAPI `servers` when there's a `root_path` instead of prefixing all the `paths`:
    * Add a new parameter for `FastAPI` classes: `root_path_in_servers` to disable the auto-generation of `servers`.
    * New docs about `root_path` and `servers` in [Additional Servers](https://fastapi.tiangolo.com/advanced/behind-a-proxy/#additional-servers).
    * Update OAuth2 examples to use a relative URL for `tokenUrl="token"` to make sure those examples keep working as-is even when behind a reverse proxy.
    * Initial PR [#1596](https://github.com/tiangolo/fastapi/pull/1596) by [@rkbeatss](https://github.com/rkbeatss).
  * Fix typo/link in External Links. PR [#1702](https://github.com/tiangolo/fastapi/pull/1702).
  * Update handling of [External Links](https://fastapi.tiangolo.com/external-links/) to use a data file and allow translating the headers without becoming obsolete quickly when new links are added. PR [#https://github.com/tiangolo/fastapi/pull/1701](https://github.com/tiangolo/fastapi/pull/1701).
  * Add external link [Machine learning model serving in Python using FastAPI and Streamlit](https://davidefiocco.github.io/2020/06/27/streamlit-fastapi-ml-serving.html) to docs. PR [#1669](https://github.com/tiangolo/fastapi/pull/1669) by [@davidefiocco](https://github.com/davidefiocco).
  * Add note in docs on order in Pydantic Unions. PR [#1591](https://github.com/tiangolo/fastapi/pull/1591) by [@kbanc](https://github.com/kbanc).
  * Improve support for tests in editor. PR [#1699](https://github.com/tiangolo/fastapi/pull/1699).
  * Pin dependencies. PR [#1697](https://github.com/tiangolo/fastapi/pull/1697).
  * Update isort to version 5.x.x. PR [#1670](https://github.com/tiangolo/fastapi/pull/1670) by [@asheux](https://github.com/asheux).

## 0.58.1[¶](#0581 "Permanent link")

  * Add link in docs to Pydantic data types. PR [#1612](https://github.com/tiangolo/fastapi/pull/1612) by [@tayoogunbiyi](https://github.com/tayoogunbiyi).
  * Fix link in warning logs for `openapi_prefix`. PR [#1611](https://github.com/tiangolo/fastapi/pull/1611) by [@bavaria95](https://github.com/bavaria95).
  * Fix bad link in docs. PR [#1603](https://github.com/tiangolo/fastapi/pull/1603) by [@molto0504](https://github.com/molto0504).
  * Add Vim temporary files to `.gitignore` for contributors using Vim. PR [#1590](https://github.com/tiangolo/fastapi/pull/1590) by [@asheux](https://github.com/asheux).
  * Fix typo in docs for sub-applications. PR [#1578](https://github.com/tiangolo/fastapi/pull/1578) by [@schlpbch](https://github.com/schlpbch).
  * Use `Optional` in all the examples in the docs. Original PR [#1574](https://github.com/tiangolo/fastapi/pull/1574) by [@chrisngyn](https://github.com/chrisngyn), [@kx-chen](https://github.com/kx-chen), [@YKo20010](https://github.com/YKo20010). Updated and merged PR [#1644](https://github.com/tiangolo/fastapi/pull/1644).
  * Update tests and handling of `response_model_by_alias`. PR [#1642](https://github.com/tiangolo/fastapi/pull/1642).
  * Add translation to Chinese for [Body - Fields - è¯·æ±‚ä½“ - å­—æ®µ](https://fastapi.tiangolo.com/zh/tutorial/body-fields/). PR [#1569](https://github.com/tiangolo/fastapi/pull/1569) by [@waynerv](https://github.com/waynerv).
  * Update Chinese translation of main page. PR [#1564](https://github.com/tiangolo/fastapi/pull/1564) by [@waynerv](https://github.com/waynerv).
  * Add translation to Chinese for [Body - Multiple Parameters - è¯·æ±‚ä½“ - å¤šä¸ªå�‚æ•°](https://fastapi.tiangolo.com/zh/tutorial/body-multiple-params/). PR [#1532](https://github.com/tiangolo/fastapi/pull/1532) by [@waynerv](https://github.com/waynerv).
  * Add translation to Chinese for [Path Parameters and Numeric Validations - è·¯å¾„å�‚æ•°å’Œæ•°å€¼æ ¡éªŒ](https://fastapi.tiangolo.com/zh/tutorial/path-params-numeric-validations/). PR [#1506](https://github.com/tiangolo/fastapi/pull/1506) by [@waynerv](https://github.com/waynerv).
  * Add GitHub action to auto-label approved PRs (mainly for translations). PR [#1638](https://github.com/tiangolo/fastapi/pull/1638).

## 0.58.0[¶](#0580 "Permanent link")

  * Deep merge OpenAPI responses to preserve all the additional metadata. PR [#1577](https://github.com/tiangolo/fastapi/pull/1577).
  * Mention in docs that only main app events are run (not sub-apps). PR [#1554](https://github.com/tiangolo/fastapi/pull/1554) by [@amacfie](https://github.com/amacfie).
  * Fix body validation error response, do not include body variable when it is not embedded. PR [#1553](https://github.com/tiangolo/fastapi/pull/1553) by [@amacfie](https://github.com/amacfie).
  * Fix testing OAuth2 security scopes when using dependency overrides. PR [#1549](https://github.com/tiangolo/fastapi/pull/1549) by [@amacfie](https://github.com/amacfie).
  * Fix Model for JSON Schema keyword `not` as a JSON Schema instead of a list. PR [#1548](https://github.com/tiangolo/fastapi/pull/1548) by [@v-do](https://github.com/v-do).
  * Add support for OpenAPI `servers`. PR [#1547](https://github.com/tiangolo/fastapi/pull/1547) by [@mikaello](https://github.com/mikaello).

## 0.57.0[¶](#0570 "Permanent link")

  * Remove broken link from "External Links". PR [#1565](https://github.com/tiangolo/fastapi/pull/1565) by [@victorphoenix3](https://github.com/victorphoenix3).
  * Update/fix docs for [WebSockets with dependencies](https://fastapi.tiangolo.com/advanced/websockets/#using-depends-and-others). Original PR [#1540](https://github.com/tiangolo/fastapi/pull/1540) by [@ChihSeanHsu](https://github.com/ChihSeanHsu).
  * Add support for Python's `http.HTTPStatus` in `status_code` parameters. PR [#1534](https://github.com/tiangolo/fastapi/pull/1534) by [@retnikt](https://github.com/retnikt).
  * When using Pydantic models with `__root__`, use the internal value in `jsonable_encoder`. PR [#1524](https://github.com/tiangolo/fastapi/pull/1524) by [@patrickkwang](https://github.com/patrickkwang).
  * Update docs for path parameters. PR [#1521](https://github.com/tiangolo/fastapi/pull/1521) by [@yankeexe](https://github.com/yankeexe).
  * Update docs for first steps, links and rewording. PR [#1518](https://github.com/tiangolo/fastapi/pull/1518) by [@yankeexe](https://github.com/yankeexe).
  * Enable `showCommonExtensions` in Swagger UI to show additional validations like `maxLength`, etc. PR [#1466](https://github.com/tiangolo/fastapi/pull/1466) by [@TiewKH](https://github.com/TiewKH).
  * Make `OAuth2PasswordRequestFormStrict` importable directly from `fastapi.security`. PR [#1462](https://github.com/tiangolo/fastapi/pull/1462) by [@RichardHoekstra](https://github.com/RichardHoekstra).
  * Add docs about [Default response class](https://fastapi.tiangolo.com/advanced/custom-response/#default-response-class). PR [#1455](https://github.com/tiangolo/fastapi/pull/1455) by [@TezRomacH](https://github.com/TezRomacH).
  * Add note in docs about additional parameters `response_model_exclude_defaults` and `response_model_exclude_none` in [Response Model](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter). PR [#1427](https://github.com/tiangolo/fastapi/pull/1427) by [@wshayes](https://github.com/wshayes).
  * Add note about [PyCharm Pydantic plugin](https://github.com/koxudaxi/pydantic-pycharm-plugin) to docs. PR [#1420](https://github.com/tiangolo/fastapi/pull/1420) by [@koxudaxi](https://github.com/koxudaxi).
  * Update and clarify testing function name. PR [#1395](https://github.com/tiangolo/fastapi/pull/1395) by [@chenl](https://github.com/chenl).
  * Fix duplicated headers created by indirect dependencies that use the request directly. PR [#1386](https://github.com/tiangolo/fastapi/pull/1386) by [@obataku](https://github.com/obataku) from tests by [@scottsmith2gmail](https://github.com/scottsmith2gmail).
  * Upgrade Starlette version to `0.13.4`. PR [#1361](https://github.com/tiangolo/fastapi/pull/1361) by [@rushton](https://github.com/rushton).
  * Improve error handling and feedback for requests with invalid JSON. PR [#1354](https://github.com/tiangolo/fastapi/pull/1354) by [@aviramha](https://github.com/aviramha).
  * Add support for declaring metadata for tags in OpenAPI. New docs at [Tutorial - Metadata and Docs URLs - Metadata for tags](https://fastapi.tiangolo.com/tutorial/metadata/#metadata-for-tags). PR [#1348](https://github.com/tiangolo/fastapi/pull/1348) by [@thomas-maschler](https://github.com/thomas-maschler).
  * Add basic setup for Russian translations. PR [#1566](https://github.com/tiangolo/fastapi/pull/1566).
  * Remove obsolete Chinese articles after adding official community translations. PR [#1510](https://github.com/tiangolo/fastapi/pull/1510) by [@waynerv](https://github.com/waynerv).
  * Add `__repr__` for _path operation function_ parameter helpers (like `Query`, `Depends`, etc) to simplify debugging. PR [#1560](https://github.com/tiangolo/fastapi/pull/1560) by [@rkbeatss](https://github.com/rkbeatss) and [@victorphoenix3](https://github.com/victorphoenix3).

## 0.56.1[¶](#0561 "Permanent link")

  * Add link to advanced docs from tutorial. PR [#1512](https://github.com/tiangolo/fastapi/pull/1512) by [@kx-chen](https://github.com/kx-chen).
  * Remove internal unnecessary f-strings. PR [#1526](https://github.com/tiangolo/fastapi/pull/1526) by [@kotamatsuoka](https://github.com/kotamatsuoka).
  * Add translation to Chinese for [Query Parameters and String Validations - æŸ¥è¯¢å�‚æ•°å’Œå­—ç¬¦ä¸²æ ¡éªŒ](https://fastapi.tiangolo.com/zh/tutorial/query-params-str-validations/). PR [#1500](https://github.com/tiangolo/fastapi/pull/1500) by [@waynerv](https://github.com/waynerv).
  * Add translation to Chinese for [Request Body - è¯·æ±‚ä½“](https://fastapi.tiangolo.com/zh/tutorial/body/). PR [#1492](https://github.com/tiangolo/fastapi/pull/1492) by [@waynerv](https://github.com/waynerv).
  * Add translation to Chinese for [Help FastAPI - Get Help - å¸®åŠ© FastAPI - è�·å�–å¸®åŠ©](https://fastapi.tiangolo.com/zh/help-fastapi/). PR [#1465](https://github.com/tiangolo/fastapi/pull/1465) by [@waynerv](https://github.com/waynerv).
  * Add translation to Chinese for [Query Parameters - æŸ¥è¯¢å�‚æ•°](https://fastapi.tiangolo.com/zh/tutorial/query-params/). PR [#1454](https://github.com/tiangolo/fastapi/pull/1454) by [@waynerv](https://github.com/waynerv).
  * Add translation to Chinese for [Contributing - å¼€å�‘ - è´¡çŒ®](https://fastapi.tiangolo.com/zh/contributing/). PR [#1460](https://github.com/tiangolo/fastapi/pull/1460) by [@waynerv](https://github.com/waynerv).
  * Add translation to Chinese for [Path Parameters - è·¯å¾„å�‚æ•°](https://fastapi.tiangolo.com/zh/tutorial/path-params/). PR [#1453](https://github.com/tiangolo/fastapi/pull/1453) by [@waynerv](https://github.com/waynerv).
  * Add official Microsoft project generator for [serving spaCy with FastAPI and Azure Cognitive Skills](https://github.com/microsoft/cookiecutter-spacy-fastapi) to [Project Generators](https://fastapi.tiangolo.com/project-generation/). PR [#1390](https://github.com/tiangolo/fastapi/pull/1390) by [@kabirkhan](https://github.com/kabirkhan).
  * Update docs in [Python Types Intro](https://fastapi.tiangolo.com/python-types/) to include info about `Optional`. Original PR [#1377](https://github.com/tiangolo/fastapi/pull/1377) by [@yaegassy](https://github.com/yaegassy).
  * Fix support for callable class dependencies with `yield`. PR [#1365](https://github.com/tiangolo/fastapi/pull/1365) by [@mrosales](https://github.com/mrosales).
  * Fix/remove incorrect error logging when a client sends invalid payloads. PR [#1351](https://github.com/tiangolo/fastapi/pull/1351) by [@dbanty](https://github.com/dbanty).
  * Add translation to Chinese for [First Steps - ç¬¬ä¸€æ­¥](https://fastapi.tiangolo.com/zh/tutorial/first-steps/). PR [#1323](https://github.com/tiangolo/fastapi/pull/1323) by [@waynerv](https://github.com/waynerv).
  * Fix generating OpenAPI for apps using callbacks with routers including Pydantic models. PR [#1322](https://github.com/tiangolo/fastapi/pull/1322) by [@nsidnev](https://github.com/nsidnev).
  * Optimize internal regex performance in `get_path_param_names()`. PR [#1243](https://github.com/tiangolo/fastapi/pull/1243) by [@heckad](https://github.com/heckad).
  * Remove `*,` from functions in docs where it's not needed. PR [#1239](https://github.com/tiangolo/fastapi/pull/1239) by [@pankaj-giri](https://github.com/pankaj-giri).
  * Start translations for Italian. PR [#1557](https://github.com/tiangolo/fastapi/pull/1557) by [@csr](https://github.com/csr).

## 0.56.0[¶](#0560 "Permanent link")

  * Add support for ASGI `root_path`:
    * Use `root_path` internally for mounted applications, so that OpenAPI and the docs UI works automatically without extra configurations and parameters.
    * Add new `root_path` parameter for `FastAPI` applications to provide it in cases where it can be set with the command line (e.g. for Uvicorn and Hypercorn, with the parameter `--root-path`).
    * Deprecate `openapi_prefix` parameter in favor of the new `root_path` parameter.
    * Add new/updated docs for [Sub Applications - Mounts](https://fastapi.tiangolo.com/advanced/sub-applications/), without `openapi_prefix` (as it is now handled automatically).
    * Add new/updated docs for [Behind a Proxy](https://fastapi.tiangolo.com/advanced/behind-a-proxy/), including how to setup a local testing proxy with Traefik and using `root_path`.
    * Update docs for [Extending OpenAPI](https://fastapi.tiangolo.com/advanced/extending-openapi/) with the new `openapi_prefix` parameter passed (internally generated from `root_path`).
    * Original PR [#1199](https://github.com/tiangolo/fastapi/pull/1199) by [@iksteen](https://github.com/iksteen).
  * Update new issue templates and docs: [Help FastAPI - Get Help](https://fastapi.tiangolo.com/help-fastapi/). PR [#1531](https://github.com/tiangolo/fastapi/pull/1531).
  * Update GitHub action issue-manager. PR [#1520](https://github.com/tiangolo/fastapi/pull/1520).
  * Add new links:
    * **English articles** :
      * [Real-time Notifications with Python and Postgres](https://wuilly.com/2019/10/real-time-notifications-with-python-and-postgres/) by [Guillermo Cruz](https://wuilly.com/).
      * [Microservice in Python using FastAPI](https://dev.to/paurakhsharma/microservice-in-python-using-fastapi-24cc) by [Paurakh Sharma Humagain](https://x.com/PaurakhSharma).
      * [Build simple API service with Python FastAPI â€” Part 1](https://dev.to/cuongld2/build-simple-api-service-with-python-fastapi-part-1-581o) by [cuongld2](https://dev.to/cuongld2).
      * [FastAPI + Zeit.co = ğŸš€](https://paulsec.github.io/posts/fastapi_plus_zeit_serverless_fu/) by [Paul Sec](https://x.com/PaulWebSec).
      * [Build a web API from scratch with FastAPI - the workshop](https://dev.to/tiangolo/build-a-web-api-from-scratch-with-fastapi-the-workshop-2ehe) by [SebastiÃ¡n RamÃ­rez (tiangolo)](https://x.com/tiangolo).
      * [Build a Secure Twilio Webhook with Python and FastAPI](https://www.twilio.com/blog/build-secure-twilio-webhook-python-fastapi) by [Twilio](https://www.twilio.com).
      * [Using FastAPI with Django](https://www.stavros.io/posts/fastapi-with-django/) by [Stavros Korokithakis](https://x.com/Stavros).
      * [Introducing Dispatch](https://netflixtechblog.com/introducing-dispatch-da4b8a2a8072) by [Netflix](https://netflixtechblog.com/).
    * **Podcasts** :
      * [Build The Next Generation Of Python Web Applications With FastAPI - Episode 259 - interview to SebastÃ­an RamÃ­rez (tiangolo)](https://www.pythonpodcast.com/fastapi-web-application-framework-episode-259/) by [Podcast.`__init__`](https://www.pythonpodcast.com/).
    * **Talks** :
      * [PyConBY 2020: Serve ML models easily with FastAPI](https://www.youtube.com/watch?v=z9K5pwb0rt8) by [SebastiÃ¡n RamÃ­rez (tiangolo)](https://x.com/tiangolo).
      * [[VIRTUAL] Py.Amsterdam's flying Software Circus: Intro to FastAPI](https://www.youtube.com/watch?v=PnpTY1f4k2U) by [SebastiÃ¡n RamÃ­rez (tiangolo)](https://x.com/tiangolo).
    * PR [#1467](https://github.com/tiangolo/fastapi/pull/1467).
  * Add translation to Chinese for [Python Types Intro - Python ç±»å�‹æ��ç¤ºç®€ä»‹](https://fastapi.tiangolo.com/zh/python-types/). PR [#1197](https://github.com/tiangolo/fastapi/pull/1197) by [@waynerv](https://github.com/waynerv).

## 0.55.1[¶](#0551 "Permanent link")

  * Fix handling of enums with their own schema in path parameters. To support [pydantic/pydantic#1432](https://github.com/pydantic/pydantic/pull/1432) in FastAPI. PR [#1463](https://github.com/tiangolo/fastapi/pull/1463).

## 0.55.0[¶](#0550 "Permanent link")

  * Allow enums to allow them to have their own schemas in OpenAPI. To support [pydantic/pydantic#1432](https://github.com/pydantic/pydantic/pull/1432) in FastAPI. PR [#1461](https://github.com/tiangolo/fastapi/pull/1461).
  * Add links for funding through [GitHub sponsors](https://github.com/sponsors/tiangolo). PR [#1425](https://github.com/tiangolo/fastapi/pull/1425).
  * Update issue template for for questions. PR [#1344](https://github.com/tiangolo/fastapi/pull/1344) by [@retnikt](https://github.com/retnikt).
  * Update warning about storing passwords in docs. PR [#1336](https://github.com/tiangolo/fastapi/pull/1336) by [@skorokithakis](https://github.com/skorokithakis).
  * Fix typo. PR [#1326](https://github.com/tiangolo/fastapi/pull/1326) by [@chenl](https://github.com/chenl).
  * Add translation to Portuguese for [Alternatives, Inspiration and Comparisons - Alternativas, InspiraÃ§Ã£o e ComparaÃ§Ãµes](https://fastapi.tiangolo.com/pt/alternatives/). PR [#1325](https://github.com/tiangolo/fastapi/pull/1325) by [@Serrones](https://github.com/Serrones).
  * Fix 2 typos in docs. PR [#1324](https://github.com/tiangolo/fastapi/pull/1324) by [@waynerv](https://github.com/waynerv).
  * Update CORS docs, fix correct default of `max_age=600`. PR [#1301](https://github.com/tiangolo/fastapi/pull/1301) by [@derekbekoe](https://github.com/derekbekoe).
  * Add translation of [main page to Portuguese](https://fastapi.tiangolo.com/pt/). PR [#1300](https://github.com/tiangolo/fastapi/pull/1300) by [@Serrones](https://github.com/Serrones).
  * Re-word and clarify docs for extra info in fields. PR [#1299](https://github.com/tiangolo/fastapi/pull/1299) by [@chris-allnutt](https://github.com/chris-allnutt).
  * Make sure the `*` in short features in the docs is consistent (after `.`) in all languages. PR [#1424](https://github.com/tiangolo/fastapi/pull/1424).
  * Update order of execution for `get_db` in SQLAlchemy tutorial. PR [#1293](https://github.com/tiangolo/fastapi/pull/1293) by [@bcb](https://github.com/bcb).
  * Fix typos in Async docs. PR [#1423](https://github.com/tiangolo/fastapi/pull/1423).

## 0.54.2[¶](#0542 "Permanent link")

  * Add translation to Spanish for [Concurrency and async / await - Concurrencia y async / await](https://fastapi.tiangolo.com/es/async/). PR [#1290](https://github.com/tiangolo/fastapi/pull/1290) by [@alvaropernas](https://github.com/alvaropernas).
  * Remove obsolete vote link. PR [#1289](https://github.com/tiangolo/fastapi/pull/1289) by [@donhui](https://github.com/donhui).
  * Allow disabling docs UIs by just disabling OpenAPI with `openapi_url=None`. New example in docs: [Advanced: Conditional OpenAPI](https://fastapi.tiangolo.com/advanced/conditional-openapi/). PR [#1421](https://github.com/tiangolo/fastapi/pull/1421).
  * Add translation to Portuguese for [Benchmarks - ComparaÃ§Ãµes](https://fastapi.tiangolo.com/pt/benchmarks/). PR [#1274](https://github.com/tiangolo/fastapi/pull/1274) by [@Serrones](https://github.com/Serrones).
  * Add translation to Portuguese for [Tutorial - User Guide - Intro - Tutorial - Guia de UsuÃ¡rio - IntroduÃ§Ã£o](https://fastapi.tiangolo.com/pt/tutorial/). PR [#1259](https://github.com/tiangolo/fastapi/pull/1259) by [@marcosmmb](https://github.com/marcosmmb).
  * Allow using Unicode in MkDocs for translations. PR [#1419](https://github.com/tiangolo/fastapi/pull/1419).
  * Add translation to Spanish for [Advanced User Guide - Intro - GuÃ­a de Usuario Avanzada - IntroducciÃ³n](https://fastapi.tiangolo.com/es/advanced/). PR [#1250](https://github.com/tiangolo/fastapi/pull/1250) by [@jfunez](https://github.com/jfunez).
  * Add translation to Portuguese for [History, Design and Future - HistÃ³ria, Design e Futuro](https://fastapi.tiangolo.com/pt/history-design-future/). PR [#1249](https://github.com/tiangolo/fastapi/pull/1249) by [@marcosmmb](https://github.com/marcosmmb).
  * Add translation to Portuguese for [Features - Recursos](https://fastapi.tiangolo.com/pt/features/). PR [#1248](https://github.com/tiangolo/fastapi/pull/1248) by [@marcosmmb](https://github.com/marcosmmb).
  * Add translation to Spanish for [Tutorial - User Guide - Intro - Tutorial - GuÃ­a de Usuario - IntroducciÃ³n](https://fastapi.tiangolo.com/es/tutorial/). PR [#1244](https://github.com/tiangolo/fastapi/pull/1244) by [@MartinEliasQ](https://github.com/MartinEliasQ).
  * Add translation to Chinese for [Deployment - éƒ¨ç½²](https://fastapi.tiangolo.com/zh/deployment/). PR [#1203](https://github.com/tiangolo/fastapi/pull/1203) by [@RunningIkkyu](https://github.com/RunningIkkyu).
  * Add translation to Chinese for [Tutorial - User Guide - Intro - æ•™ç¨‹ - ç”¨æˆ·æŒ‡å�— - ç®€ä»‹](https://fastapi.tiangolo.com/zh/tutorial/). PR [#1202](https://github.com/tiangolo/fastapi/pull/1202) by [@waynerv](https://github.com/waynerv).
  * Add translation to Chinese for [Features - ç‰¹æ€§](https://fastapi.tiangolo.com/zh/features/). PR [#1192](https://github.com/tiangolo/fastapi/pull/1192) by [@Dustyposa](https://github.com/Dustyposa).
  * Add translation for [main page to Chinese](https://fastapi.tiangolo.com/zh/) PR [#1191](https://github.com/tiangolo/fastapi/pull/1191) by [@waynerv](https://github.com/waynerv).
  * Update docs for project generation. PR [#1287](https://github.com/tiangolo/fastapi/pull/1287).
  * Add Spanish translation for [IntroducciÃ³n a los Tipos de Python (Python Types Intro)](https://fastapi.tiangolo.com/es/python-types/). PR [#1237](https://github.com/tiangolo/fastapi/pull/1237) by [@mariacamilagl](https://github.com/mariacamilagl).
  * Add Spanish translation for [CaracterÃ­sticas (Features)](https://fastapi.tiangolo.com/es/features/). PR [#1220](https://github.com/tiangolo/fastapi/pull/1220) by [@mariacamilagl](https://github.com/mariacamilagl).

## 0.54.1[¶](#0541 "Permanent link")

  * Update database test setup. PR [#1226](https://github.com/tiangolo/fastapi/pull/1226).
  * Improve test debugging by showing response text in failing tests. PR [#1222](https://github.com/tiangolo/fastapi/pull/1222) by [@samuelcolvin](https://github.com/samuelcolvin).

## 0.54.0[¶](#0540 "Permanent link")

  * Fix grammatical mistakes in async docs. PR [#1188](https://github.com/tiangolo/fastapi/pull/1188) by [@mickeypash](https://github.com/mickeypash).
  * Add support for `response_model_exclude_defaults` and `response_model_exclude_none`:
    * Deprecate the parameter `include_none` in `jsonable_encoder` and add the inverted `exclude_none`, to keep in sync with Pydantic.
    * PR [#1166](https://github.com/tiangolo/fastapi/pull/1166) by [@voegtlel](https://github.com/voegtlel).
  * Add example about [Testing a Database](https://fastapi.tiangolo.com/advanced/testing-database/). Initial PR [#1144](https://github.com/tiangolo/fastapi/pull/1144) by [@duganchen](https://github.com/duganchen).
  * Update docs for [Development - Contributing: Translations](https://fastapi.tiangolo.com/contributing/#translations) including note about reviewing translation PRs. [#1215](https://github.com/tiangolo/fastapi/pull/1215).
  * Update log style in README.md for GitHub Markdown compatibility. PR [#1200](https://github.com/tiangolo/fastapi/pull/1200) by [#geekgao](https://github.com/geekgao).
  * Add Python venv `env` to `.gitignore`. PR [#1212](https://github.com/tiangolo/fastapi/pull/1212) by [@cassiobotaro](https://github.com/cassiobotaro).
  * Start Portuguese translations. PR [#1210](https://github.com/tiangolo/fastapi/pull/1210) by [@cassiobotaro](https://github.com/cassiobotaro).
  * Update docs for Pydantic's `Settings` using a dependency with `@lru_cache()`. PR [#1214](https://github.com/tiangolo/fastapi/pull/1214).
  * Add first translation to Spanish [FastAPI](https://fastapi.tiangolo.com/es/). PR [#1201](https://github.com/tiangolo/fastapi/pull/1201) by [@mariacamilagl](https://github.com/mariacamilagl).
  * Add docs about [Settings and Environment Variables](https://fastapi.tiangolo.com/advanced/settings/). Initial PR [1118](https://github.com/tiangolo/fastapi/pull/1118) by [@alexmitelman](https://github.com/alexmitelman).

## 0.53.2[¶](#0532 "Permanent link")

  * Fix automatic embedding of body fields for dependencies and sub-dependencies. Original PR [#1079](https://github.com/tiangolo/fastapi/pull/1079) by [@Toad2186](https://github.com/Toad2186).
  * Fix dependency overrides in WebSocket testing. PR [#1122](https://github.com/tiangolo/fastapi/pull/1122) by [@amitlissack](https://github.com/amitlissack).
  * Fix docs script to ensure languages are always sorted. PR [#1189](https://github.com/tiangolo/fastapi/pull/1189).
  * Start translations for Chinese. PR [#1187](https://github.com/tiangolo/fastapi/pull/1187) by [@RunningIkkyu](https://github.com/RunningIkkyu).
  * Add docs for [Schema Extra - Example](https://fastapi.tiangolo.com/tutorial/schema-extra-example/). PR [#1185](https://github.com/tiangolo/fastapi/pull/1185).

## 0.53.1[¶](#0531 "Permanent link")

  * Fix included example after translations refactor. PR [#1182](https://github.com/tiangolo/fastapi/pull/1182).
  * Add docs example for `example` in `Field`. Docs at [Body - Fields: JSON Schema extras](https://fastapi.tiangolo.com/tutorial/body-fields/#json-schema-extras). PR [#1106](https://github.com/tiangolo/fastapi/pull/1106) by [@JohnPaton](https://github.com/JohnPaton).
  * Fix using recursive models in `response_model`. PR [#1164](https://github.com/tiangolo/fastapi/pull/1164) by [@voegtlel](https://github.com/voegtlel).
  * Add docs for [Pycharm Debugging](https://fastapi.tiangolo.com/tutorial/debugging/). PR [#1096](https://github.com/tiangolo/fastapi/pull/1096) by [@youngquan](https://github.com/youngquan).
  * Fix typo in docs. PR [#1148](https://github.com/tiangolo/fastapi/pull/1148) by [@PLNech](https://github.com/PLNech).
  * Update Windows development environment instructions. PR [#1179](https://github.com/tiangolo/fastapi/pull/1179).

## 0.53.0[¶](#0530 "Permanent link")

  * Update test coverage badge. PR [#1175](https://github.com/tiangolo/fastapi/pull/1175).
  * Add `orjson` to `pip install fastapi[all]`. PR [#1161](https://github.com/tiangolo/fastapi/pull/1161) by [@michael0liver](https://github.com/michael0liver).
  * Fix included example for `GZipMiddleware`. PR [#1138](https://github.com/tiangolo/fastapi/pull/1138) by [@arimbr](https://github.com/arimbr).
  * Fix class name in docstring for `OAuth2PasswordRequestFormStrict`. PR [#1126](https://github.com/tiangolo/fastapi/pull/1126) by [@adg-mh](https://github.com/adg-mh).
  * Clarify function name in example in docs. PR [#1121](https://github.com/tiangolo/fastapi/pull/1121) by [@tmsick](https://github.com/tmsick).
  * Add external link [Apache Kafka producer and consumer with FastAPI and aiokafka](https://iwpnd.pw/articles/2020-03/apache-kafka-fastapi-geostream) to docs. PR [#1112](https://github.com/tiangolo/fastapi/pull/1112) by [@iwpnd](https://github.com/iwpnd).
  * Fix serialization when using `by_alias` or `exclude_unset` and returning data with Pydantic models. PR [#1074](https://github.com/tiangolo/fastapi/pull/1074) by [@juhovh-aiven](https://github.com/juhovh-aiven).
  * Add Gitter chat to docs. PR [#1061](https://github.com/tiangolo/fastapi/pull/1061) by [@aakashnand](https://github.com/aakashnand).
  * Update and simplify translations docs. PR [#1171](https://github.com/tiangolo/fastapi/pull/1171).
  * Update development of FastAPI docs, set address to `127.0.0.1` to improve Windows support. PR [#1169](https://github.com/tiangolo/fastapi/pull/1169) by [@mariacamilagl](https://github.com/mariacamilagl).
  * Add support for docs translations. New docs: [Development - Contributing: Docs: Translations](https://fastapi.tiangolo.com/contributing/#translations). PR [#1168](https://github.com/tiangolo/fastapi/pull/1168).
  * Update terminal styles in docs and add note about [**Typer** , the FastAPI of CLIs](https://typer.tiangolo.com/). PR [#1139](https://github.com/tiangolo/fastapi/pull/1139).

## 0.52.0[¶](#0520 "Permanent link")

  * Add new high-performance JSON response class using `orjson`. New docs: [Custom Response - HTML, Stream, File, others: `ORJSONResponse`](https://fastapi.tiangolo.com/advanced/custom-response/#use-orjsonresponse). PR [#1065](https://github.com/tiangolo/fastapi/pull/1065).

## 0.51.0[¶](#0510 "Permanent link")

  * Re-export utils from Starlette:
    * This allows using things like `from fastapi.responses import JSONResponse` instead of `from starlette.responses import JSONResponse`.
    * It's mainly syntax sugar, a convenience for developer experience.
    * Now `Request`, `Response`, `WebSocket`, `status` can be imported directly from `fastapi` as in `from fastapi import Response`. This is because those are frequently used, to use the request directly, to set headers and cookies, to get status codes, etc.
    * Documentation changes in many places, but new docs and noticeable improvements:
      * [Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/).
      * [Advanced Middleware](https://fastapi.tiangolo.com/advanced/middleware/).
      * [Including WSGI - Flask, Django, others](https://fastapi.tiangolo.com/advanced/wsgi/).
    * PR [#1064](https://github.com/tiangolo/fastapi/pull/1064).

## 0.50.0[¶](#0500 "Permanent link")

  * Add link to Release Notes from docs about pinning versions for deployment. PR [#1058](https://github.com/tiangolo/fastapi/pull/1058).
  * Upgrade code to use the latest version of Starlette, including:
    * Several bug fixes.
    * Optional redirects of slashes, with or without ending in `/`.
    * Events for routers, `"startup"`, and `"shutdown"`.
    * PR [#1057](https://github.com/tiangolo/fastapi/pull/1057).
  * Add docs about pinning FastAPI versions for deployment: [Deployment: FastAPI versions](https://fastapi.tiangolo.com/deployment/#fastapi-versions). PR [#1056](https://github.com/tiangolo/fastapi/pull/1056).

## 0.49.2[¶](#0492 "Permanent link")

  * Fix links in release notes. PR [#1052](https://github.com/tiangolo/fastapi/pull/1052) by [@sattosan](https://github.com/sattosan).
  * Fix typo in release notes. PR [#1051](https://github.com/tiangolo/fastapi/pull/1051) by [@sattosan](https://github.com/sattosan).
  * Refactor/clarify `serialize_response` parameter name to avoid confusion. PR [#1031](https://github.com/tiangolo/fastapi/pull/1031) by [@patrickmckenna](https://github.com/patrickmckenna).
  * Refactor calling each a path operation's handler function in an isolated function, to simplify profiling. PR [#1027](https://github.com/tiangolo/fastapi/pull/1027) by [@sm-Fifteen](https://github.com/sm-Fifteen).
  * Add missing dependencies for testing. PR [#1026](https://github.com/tiangolo/fastapi/pull/1026) by [@sm-Fifteen](https://github.com/sm-Fifteen).
  * Fix accepting valid types for response models, including Python types like `List[int]`. PR [#1017](https://github.com/tiangolo/fastapi/pull/1017) by [@patrickmckenna](https://github.com/patrickmckenna).
  * Fix format in SQL tutorial. PR [#1015](https://github.com/tiangolo/fastapi/pull/1015) by [@vegarsti](https://github.com/vegarsti).

## 0.49.1[¶](#0491 "Permanent link")

  * Fix path operation duplicated parameters when used in dependencies and the path operation function. PR [#994](https://github.com/tiangolo/fastapi/pull/994) by [@merowinger92](https://github.com/merowinger92).
  * Update Netlify previews deployment GitHub action as the fix is already merged and there's a new release. PR [#1047](https://github.com/tiangolo/fastapi/pull/1047).
  * Move mypy configurations to config file. PR [#987](https://github.com/tiangolo/fastapi/pull/987) by [@hukkinj1](https://github.com/hukkinj1).
  * Temporary fix to Netlify previews not deployable from PRs from forks. PR [#1046](https://github.com/tiangolo/fastapi/pull/1046) by [@mariacamilagl](https://github.com/mariacamilagl).

## 0.49.0[¶](#0490 "Permanent link")

  * Fix encoding of `pathlib` paths in `jsonable_encoder`. PR [#978](https://github.com/tiangolo/fastapi/pull/978) by [@patrickmckenna](https://github.com/patrickmckenna).
  * Add articles to [External Links](https://fastapi.tiangolo.com/external-links/): [Pythonã�®Web frameworkã�®ãƒ‘ãƒ•ã‚©ãƒ¼ãƒ�ãƒ³ã‚¹æ¯”è¼ƒ (Django, Flask, responder, FastAPI, japronto)](https://qiita.com/bee2/items/0ad260ab9835a2087dae) and [[FastAPI] Pythonè£½ã�®ASGI Web ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ FastAPIã�«å…¥é–€ã�™ã‚‹](https://qiita.com/bee2/items/75d9c0d7ba20e7a4a0e9). PR [#974](https://github.com/tiangolo/fastapi/pull/974) by [@tokusumi](https://github.com/tokusumi).
  * Fix broken links in docs. PR [#949](https://github.com/tiangolo/fastapi/pull/949) by [@tsotnikov](https://github.com/tsotnikov).
  * Fix small typos. PR [#941](https://github.com/tiangolo/fastapi/pull/941) by [@NikitaKolesov](https://github.com/NikitaKolesov).
  * Update and clarify docs for dependencies with `yield`. PR [#986](https://github.com/tiangolo/fastapi/pull/986).
  * Add Mermaid JS support for diagrams in docs. Add first diagrams to [Dependencies: First Steps](https://fastapi.tiangolo.com/tutorial/dependencies/) and [Dependencies with `yield` and `HTTPException`](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-with-yield/#dependencies-with-yield-and-httpexception). PR [#985](https://github.com/tiangolo/fastapi/pull/985).
  * Update CI to run docs deployment in GitHub actions. PR [#983](https://github.com/tiangolo/fastapi/pull/983).
  * Allow `callable`s in _path operation functions_ , like functions modified with `functools.partial`. PR [#977](https://github.com/tiangolo/fastapi/pull/977).

## 0.48.0[¶](#0480 "Permanent link")

  * Run linters first in tests to error out faster. PR [#948](https://github.com/tiangolo/fastapi/pull/948).
  * Log warning about `email-validator` only when used. PR [#946](https://github.com/tiangolo/fastapi/pull/946).
  * Simplify [Peewee docs](https://fastapi.tiangolo.com/advanced/sql-databases-peewee/) with double dependency with `yield`. PR [#947](https://github.com/tiangolo/fastapi/pull/947).
  * Add article [External Links](https://fastapi.tiangolo.com/external-links/): [Create and Deploy FastAPI app to Heroku](https://www.tutlinks.com/create-and-deploy-fastapi-app-to-heroku/). PR [#942](https://github.com/tiangolo/fastapi/pull/942) by [@windson](https://github.com/windson).
  * Update description of Sanic, as it is now ASGI too. PR [#932](https://github.com/tiangolo/fastapi/pull/932) by [@raphaelauv](https://github.com/raphaelauv).
  * Fix typo in main page. PR [#920](https://github.com/tiangolo/fastapi/pull/920) by [@mMarzeta](https://github.com/mMarzeta).
  * Fix parsing of possibly invalid bodies. PR [#918](https://github.com/tiangolo/fastapi/pull/918) by [@dmontagu](https://github.com/dmontagu).
  * Fix typo [#916](https://github.com/tiangolo/fastapi/pull/916) by [@adursun](https://github.com/adursun).
  * Allow `Any` type for enums in OpenAPI. PR [#906](https://github.com/tiangolo/fastapi/pull/906) by [@songzhi](https://github.com/songzhi).
  * Add article to [External Links](https://fastapi.tiangolo.com/external-links/): [How to continuously deploy a FastAPI to AWS Lambda with AWS SAM](https://iwpnd.pw/articles/2020-01/deploy-fastapi-to-aws-lambda). PR [#901](https://github.com/tiangolo/fastapi/pull/901) by [@iwpnd](https://github.com/iwpnd).
  * Add note about using Body parameters without Pydantic. PR [#900](https://github.com/tiangolo/fastapi/pull/900) by [@pawamoy](https://github.com/pawamoy).
  * Fix Pydantic field clone logic. PR [#899](https://github.com/tiangolo/fastapi/pull/899) by [@deuce2367](https://github.com/deuce2367).
  * Fix link in middleware docs. PR [#893](https://github.com/tiangolo/fastapi/pull/893) by [@linchiwei123](https://github.com/linchiwei123).
  * Rename default API title from "Fast API" to "FastAPI" for consistency. PR [#890](https://github.com/tiangolo/fastapi/pull/890).

## 0.47.1[¶](#0471 "Permanent link")

  * Fix model filtering in `response_model`, cloning sub-models. PR [#889](https://github.com/tiangolo/fastapi/pull/889).
  * Fix FastAPI serialization of Pydantic models using ORM mode blocking the event loop. PR [#888](https://github.com/tiangolo/fastapi/pull/888).

## 0.47.0[¶](#0470 "Permanent link")

  * Refactor documentation to make a simpler and shorter [Tutorial - User Guide](https://fastapi.tiangolo.com/tutorial/) and an additional [Advanced User Guide](https://fastapi.tiangolo.com/advanced/) with all the additional docs. PR [#887](https://github.com/tiangolo/fastapi/pull/887).
  * Tweak external links, Markdown format, typos. PR [#881](https://github.com/tiangolo/fastapi/pull/881).
  * Fix bug in tutorial handling HTTP Basic Auth `username` and `password`. PR [#865](https://github.com/tiangolo/fastapi/pull/865) by [@isaevpd](https://github.com/isaevpd).
  * Fix handling form _path operation_ parameters declared with pure classes like `list`, `tuple`, etc. PR [#856](https://github.com/tiangolo/fastapi/pull/856) by [@nsidnev](https://github.com/nsidnev).
  * Add request `body` to `RequestValidationError`, new docs: [Use the `RequestValidationError` body](https://fastapi.tiangolo.com/tutorial/handling-errors/#use-the-requestvalidationerror-body). Initial PR [#853](https://github.com/tiangolo/fastapi/pull/853) by [@aviramha](https://github.com/aviramha).
  * Update [External Links](https://fastapi.tiangolo.com/external-links/) with new links and dynamic GitHub projects with `fastapi` topic. PR [#850](https://github.com/tiangolo/fastapi/pull/850).
  * Fix Peewee `contextvars` handling in docs: [SQL (Relational) Databases with Peewee](https://fastapi.tiangolo.com/advanced/sql-databases-peewee/). PR [#879](https://github.com/tiangolo/fastapi/pull/879).
  * Setup development environment with Python's Venv and Flit, instead of requiring the extra Pipenv duplicating dependencies. Updated docs: [Development - Contributing](https://fastapi.tiangolo.com/contributing/). PR [#877](https://github.com/tiangolo/fastapi/pull/877).
  * Update docs for [HTTP Basic Auth](https://fastapi.tiangolo.com/advanced/security/http-basic-auth/) to improve security against timing attacks. Initial PR [#807](https://github.com/tiangolo/fastapi/pull/807) by [@zwass](https://github.com/zwass).

## 0.46.0[¶](#0460 "Permanent link")

  * Fix typos and tweak configs. PR [#837](https://github.com/tiangolo/fastapi/pull/837).
  * Add link to Chinese article in [External Links](https://fastapi.tiangolo.com/external-links/). PR [810](https://github.com/tiangolo/fastapi/pull/810) by [@wxq0309](https://github.com/wxq0309).
  * Implement `OAuth2AuthorizationCodeBearer` class. PR [#797](https://github.com/tiangolo/fastapi/pull/797) by [@kuwv](https://github.com/kuwv).
  * Update example upgrade in docs main page. PR [#795](https://github.com/tiangolo/fastapi/pull/795) by [@cdeil](https://github.com/cdeil).
  * Fix callback handling for sub-routers. PR [#792](https://github.com/tiangolo/fastapi/pull/792) by [@jekirl](https://github.com/jekirl).
  * Fix typos. PR [#784](https://github.com/tiangolo/fastapi/pull/784) by [@kkinder](https://github.com/kkinder).
  * Add 4 Japanese articles to [External Links](https://fastapi.tiangolo.com/external-links/). PR [#783](https://github.com/tiangolo/fastapi/pull/783) by [@HymanZHAN](https://github.com/HymanZHAN).
  * Add support for subtypes of main types in `jsonable_encoder`, e.g. asyncpg's UUIDs. PR [#756](https://github.com/tiangolo/fastapi/pull/756) by [@RmStorm](https://github.com/RmStorm).
  * Fix usage of Pydantic's `HttpUrl` in docs. PR [#832](https://github.com/tiangolo/fastapi/pull/832) by [@Dustyposa](https://github.com/Dustyposa).
  * Fix Twitter links in docs. PR [#813](https://github.com/tiangolo/fastapi/pull/813) by [@justindujardin](https://github.com/justindujardin).
  * Add docs for correctly [using FastAPI with Peewee ORM](https://fastapi.tiangolo.com/advanced/sql-databases-peewee/). Including how to overwrite parts of Peewee to correctly handle async threads. PR [#789](https://github.com/tiangolo/fastapi/pull/789).

## 0.45.0[¶](#0450 "Permanent link")

  * Add support for OpenAPI Callbacks:
    * New docs: [OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).
    * Refactor generation of `operationId`s to be valid Python names (also valid variables in most languages).
    * Add `default_response_class` parameter to `APIRouter`.
    * Original PR [#722](https://github.com/tiangolo/fastapi/pull/722) by [@booooh](https://github.com/booooh).
  * Refactor logging to use the same logger everywhere, update log strings and levels. PR [#781](https://github.com/tiangolo/fastapi/pull/781).
  * Add article to [External Links](https://fastapi.tiangolo.com/external-links/): [ĞŸĞ¾Ñ‡ĞµĞ¼Ñƒ Ğ’Ñ‹ Ğ´Ğ¾Ğ»Ğ¶Ğ½Ñ‹ Ğ¿Ğ¾Ğ¿Ñ€Ğ¾Ğ±Ğ¾Ğ²Ğ°Ñ‚ÑŒ FastAPI?](https://habr.com/ru/post/478620/). PR [#766](https://github.com/tiangolo/fastapi/pull/766) by [@prostomarkeloff](https://github.com/prostomarkeloff).
  * Remove gender bias in docs for handling errors. PR [#780](https://github.com/tiangolo/fastapi/pull/780). Original idea in PR [#761](https://github.com/tiangolo/fastapi/pull/761) by [@classywhetten](https://github.com/classywhetten).
  * Rename docs and references to `body-schema` to `body-fields` to keep in line with Pydantic. PR [#746](https://github.com/tiangolo/fastapi/pull/746) by [@prostomarkeloff](https://github.com/prostomarkeloff).

## 0.44.1[¶](#0441 "Permanent link")

  * Add GitHub social preview images to git. PR [#752](https://github.com/tiangolo/fastapi/pull/752).
  * Update PyPI "trove classifiers". PR [#751](https://github.com/tiangolo/fastapi/pull/751).
  * Add full support for Python 3.8. Enable Python 3.8 in full in Travis. PR [749](https://github.com/tiangolo/fastapi/pull/749).
  * Update "new issue" templates. PR [#749](https://github.com/tiangolo/fastapi/pull/749).
  * Fix serialization of errors for exotic Pydantic types. PR [#748](https://github.com/tiangolo/fastapi/pull/748) by [@dmontagu](https://github.com/dmontagu).

## 0.44.0[¶](#0440 "Permanent link")

  * Add GitHub action [Issue Manager](https://github.com/tiangolo/issue-manager). PR [#742](https://github.com/tiangolo/fastapi/pull/742).
  * Fix typos in docs. PR [734](https://github.com/tiangolo/fastapi/pull/734) by [@bundabrg](https://github.com/bundabrg).
  * Fix usage of `custom_encoder` in `jsonable_encoder`. PR [#715](https://github.com/tiangolo/fastapi/pull/715) by [@matrixise](https://github.com/matrixise).
  * Fix invalid XML example. PR [710](https://github.com/tiangolo/fastapi/pull/710) by [@OcasoProtal](https://github.com/OcasoProtal).
  * Fix typos and update wording in deployment docs. PR [#700](https://github.com/tiangolo/fastapi/pull/700) by [@marier-nico](https://github.com/tiangolo/fastapi/pull/700).
  * Add note about dependencies in `APIRouter` docs. PR [#698](https://github.com/tiangolo/fastapi/pull/698) by [@marier-nico](https://github.com/marier-nico).
  * Add support for async class methods as dependencies [#681](https://github.com/tiangolo/fastapi/pull/681) by [@frankie567](https://github.com/frankie567).
  * Add FastAPI with Swagger UI cheatsheet to external links. PR [#671](https://github.com/tiangolo/fastapi/pull/671) by [@euri10](https://github.com/euri10).
  * Fix typo in HTTP protocol in CORS example. PR [#647](https://github.com/tiangolo/fastapi/pull/647) by [@forestmonster](https://github.com/forestmonster).
  * Add support for Pydantic versions `1.0.0` and above, with temporary (deprecated) backwards compatibility for Pydantic `0.32.2`. PR [#646](https://github.com/tiangolo/fastapi/pull/646) by [@dmontagu](https://github.com/dmontagu).

## 0.43.0[¶](#0430 "Permanent link")

  * Update docs to reduce gender bias. PR [#645](https://github.com/tiangolo/fastapi/pull/645) by [@ticosax](https://github.com/ticosax).
  * Add docs about [overriding the `operationId` for all the _path operations_](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#using-the-path-operation-function-name-as-the-operationid) based on their function name. PR [#642](https://github.com/tiangolo/fastapi/pull/642) by [@SKalt](https://github.com/SKalt).
  * Fix validators in models generating an incorrect key order. PR [#637](https://github.com/tiangolo/fastapi/pull/637) by [@jaddison](https://github.com/jaddison).
  * Generate correct OpenAPI docs for responses with no content. PR [#621](https://github.com/tiangolo/fastapi/pull/621) by [@brotskydotcom](https://github.com/brotskydotcom).
  * Remove `$` from Bash code blocks in docs for consistency. PR [#613](https://github.com/tiangolo/fastapi/pull/613) by [@nstapelbroek](https://github.com/nstapelbroek).
  * Add docs for [self-serving docs' (Swagger UI) static assets](https://fastapi.tiangolo.com/advanced/extending-openapi/#self-hosting-javascript-and-css-for-docs), e.g. to use the docs offline, or without Internet. Initial PR [#557](https://github.com/tiangolo/fastapi/pull/557) by [@svalouch](https://github.com/svalouch).
  * Fix `black` linting after upgrade. PR [#682](https://github.com/tiangolo/fastapi/pull/682) by [@frankie567](https://github.com/frankie567).

## 0.42.0[¶](#0420 "Permanent link")

  * Add dependencies with `yield`, a.k.a. exit steps, context managers, cleanup, teardown, ...
    * This allows adding extra code after a dependency is done. It can be used, for example, to close database connections.
    * Dependencies with `yield` can be normal or `async`, **FastAPI** will run normal dependencies in a threadpool.
    * They can be combined with normal dependencies.
    * It's possible to have arbitrary trees/levels of dependencies with `yield` and exit steps are handled in the correct order automatically.
    * It works by default in Python 3.7 or above. For Python 3.6, it requires the extra backport dependencies:
      * `async-exit-stack`
      * `async-generator`
    * New docs at [Dependencies with `yield`](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-with-yield/).
    * Updated database docs [SQL (Relational) Databases: Main **FastAPI** app](https://fastapi.tiangolo.com/tutorial/sql-databases/#main-fastapi-app).
    * PR [#595](https://github.com/tiangolo/fastapi/pull/595).
  * Fix `sitemap.xml` in website. PR [#598](https://github.com/tiangolo/fastapi/pull/598) by [@samuelcolvin](https://github.com/samuelcolvin).

## 0.41.0[¶](#0410 "Permanent link")

  * Upgrade required Starlette to `0.12.9`, the new range is `>=0.12.9,<=0.12.9`.
    * Add `State` to FastAPI apps at `app.state`.
    * PR [#593](https://github.com/tiangolo/fastapi/pull/593).
  * Improve handling of custom classes for `Request`s and `APIRoute`s.
    * This helps to more easily solve use cases like:
      * Reading a body before and/or after a request (equivalent to a middleware).
      * Run middleware-like code only for a subset of _path operations_.
      * Process a request before passing it to a _path operation function_. E.g. decompressing, deserializing, etc.
      * Processing a response after being generated by _path operation functions_ but before returning it. E.g. adding custom headers, logging, adding extra metadata.
    * New docs section: [Custom Request and APIRoute class](https://fastapi.tiangolo.com/advanced/custom-request-and-route/).
    * PR [#589](https://github.com/tiangolo/fastapi/pull/589) by [@dmontagu](https://github.com/dmontagu).
  * Fix preserving custom route class in routers when including other sub-routers. PR [#538](https://github.com/tiangolo/fastapi/pull/538) by [@dmontagu](https://github.com/dmontagu).

## 0.40.0[¶](#0400 "Permanent link")

  * Add notes to docs about installing `python-multipart` when using forms. PR [#574](https://github.com/tiangolo/fastapi/pull/574) by [@sliptonic](https://github.com/sliptonic).
  * Generate OpenAPI schemas in alphabetical order. PR [#554](https://github.com/tiangolo/fastapi/pull/554) by [@dmontagu](https://github.com/dmontagu).
  * Add support for truncating docstrings from _path operation functions_.
    * New docs at [Advanced description from docstring](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#advanced-description-from-docstring).
    * PR [#556](https://github.com/tiangolo/fastapi/pull/556) by [@svalouch](https://github.com/svalouch).
  * Fix `DOCTYPE` in HTML files generated for Swagger UI and ReDoc. PR [#537](https://github.com/tiangolo/fastapi/pull/537) by [@Trim21](https://github.com/Trim21).
  * Fix handling `4XX` responses overriding default `422` validation error responses. PR [#517](https://github.com/tiangolo/fastapi/pull/517) by [@tsouvarev](https://github.com/tsouvarev).
  * Fix typo in documentation for [Simple HTTP Basic Auth](https://fastapi.tiangolo.com/advanced/security/http-basic-auth/#simple-http-basic-auth). PR [#514](https://github.com/tiangolo/fastapi/pull/514) by [@prostomarkeloff](https://github.com/prostomarkeloff).
  * Fix incorrect documentation example in [first steps](https://fastapi.tiangolo.com/tutorial/first-steps/). PR [#511](https://github.com/tiangolo/fastapi/pull/511) by [@IgnatovFedor](https://github.com/IgnatovFedor).
  * Add support for Swagger UI [initOauth](https://github.com/swagger-api/swagger-ui/blob/master/docs/usage/oauth2.md) settings with the parameter `swagger_ui_init_oauth`. PR [#499](https://github.com/tiangolo/fastapi/pull/499) by [@zamiramir](https://github.com/zamiramir).

## 0.39.0[¶](#0390 "Permanent link")

  * Allow path parameters to have default values (e.g. `None`) and discard them instead of raising an error.
    * This allows declaring a parameter like `user_id: str = None` that can be taken from a query parameter, but the same _path operation_ can be included in a router with a path `/users/{user_id}`, in which case will be taken from the path and will be required.
    * PR [#464](https://github.com/tiangolo/fastapi/pull/464) by [@jonathanunderwood](https://github.com/jonathanunderwood).
  * Add support for setting a `default_response_class` in the `FastAPI` instance or in `include_router`. Initial PR [#467](https://github.com/tiangolo/fastapi/pull/467) by [@toppk](https://github.com/toppk).
  * Add support for type annotations using strings and `from __future__ import annotations`. PR [#451](https://github.com/tiangolo/fastapi/pull/451) by [@dmontagu](https://github.com/dmontagu).

## 0.38.1[¶](#0381 "Permanent link")

  * Fix incorrect `Request` class import. PR [#493](https://github.com/tiangolo/fastapi/pull/493) by [@kamalgill](https://github.com/kamalgill).

## 0.38.0[¶](#0380 "Permanent link")

  * Add recent articles to [External Links](https://fastapi.tiangolo.com/external-links/) and recent opinions. PR [#490](https://github.com/tiangolo/fastapi/pull/490).
  * Upgrade support range for Starlette to include `0.12.8`. The new range is `>=0.11.1,<=0.12.8"`. PR [#477](https://github.com/tiangolo/fastapi/pull/477) by [@dmontagu](https://github.com/dmontagu).
  * Upgrade support to Pydantic version 0.32.2 and update internal code to use it (breaking change). PR [#463](https://github.com/tiangolo/fastapi/pull/463) by [@dmontagu](https://github.com/dmontagu).

## 0.37.0[¶](#0370 "Permanent link")

  * Add support for custom route classes for advanced use cases. PR [#468](https://github.com/tiangolo/fastapi/pull/468) by [@dmontagu](https://github.com/dmontagu).
  * Allow disabling Google fonts in ReDoc. PR [#481](https://github.com/tiangolo/fastapi/pull/481) by [@b1-luettje](https://github.com/b1-luettje).
  * Fix security issue: when returning a sub-class of a response model and using `skip_defaults` it could leak information. PR [#485](https://github.com/tiangolo/fastapi/pull/485) by [@dmontagu](https://github.com/dmontagu).
  * Enable tests for Python 3.8-dev. PR [#465](https://github.com/tiangolo/fastapi/pull/465) by [@Jamim](https://github.com/Jamim).
  * Add support and tests for Pydantic dataclasses in `response_model`. PR [#454](https://github.com/tiangolo/fastapi/pull/454) by [@dconathan](https://github.com/dconathan).
  * Fix typo in OAuth2 JWT tutorial. PR [#447](https://github.com/tiangolo/fastapi/pull/447) by [@pablogamboa](https://github.com/pablogamboa).
  * Use the `media_type` parameter in `Body()` params to set the media type in OpenAPI for `requestBody`. PR [#439](https://github.com/tiangolo/fastapi/pull/439) by [@divums](https://github.com/divums).
  * Add article [Deploying a scikit-learn model with ONNX and FastAPI](https://medium.com/@nico.axtmann95/deploying-a-scikit-learn-model-with-onnx-und-fastapi-1af398268915) by [Nico Axtmann](https://www.linkedin.com/in/nico-axtmann). PR [#438](https://github.com/tiangolo/fastapi/pull/438) by [@naxty](https://github.com/naxty).
  * Allow setting custom `422` (validation error) response/schema in OpenAPI.
    * And use media type from response class instead of fixed `application/json` (the default).
    * PR [#437](https://github.com/tiangolo/fastapi/pull/437) by [@divums](https://github.com/divums).
  * Fix using `"default"` extra response with status codes at the same time. PR [#489](https://github.com/tiangolo/fastapi/pull/489).
  * Allow additional responses to use status code ranges (like `5XX` and `4XX`) and `"default"`. PR [#435](https://github.com/tiangolo/fastapi/pull/435) by [@divums](https://github.com/divums).

## 0.36.0[¶](#0360 "Permanent link")

  * Fix implementation for `skip_defaults` when returning a Pydantic model. PR [#422](https://github.com/tiangolo/fastapi/pull/422) by [@dmontagu](https://github.com/dmontagu).
  * Fix OpenAPI generation when using the same dependency in multiple places for the same _path operation_. PR [#417](https://github.com/tiangolo/fastapi/pull/417) by [@dmontagu](https://github.com/dmontagu).
  * Allow having empty paths in _path operations_ used with `include_router` and a `prefix`.
    * This allows having a router for `/cats` and all its _path operations_ , while having one of them for `/cats`.
    * Now it doesn't have to be only `/cats/` (with a trailing slash).
    * To use it, declare the path in the _path operation_ as the empty string (`""`).
    * PR [#415](https://github.com/tiangolo/fastapi/pull/415) by [@vitalik](https://github.com/vitalik).
  * Fix mypy error after merging PR #415. PR [#462](https://github.com/tiangolo/fastapi/pull/462).

## 0.35.0[¶](#0350 "Permanent link")

  * Fix typo in routing `assert`. PR [#419](https://github.com/tiangolo/fastapi/pull/419) by [@pablogamboa](https://github.com/pablogamboa).
  * Fix typo in docs. PR [#411](https://github.com/tiangolo/fastapi/pull/411) by [@bronsen](https://github.com/bronsen).
  * Fix parsing a body type declared with `Union`. PR [#400](https://github.com/tiangolo/fastapi/pull/400) by [@koxudaxi](https://github.com/koxudaxi).

## 0.34.0[¶](#0340 "Permanent link")

  * Upgrade Starlette supported range to include the latest `0.12.7`. The new range is `0.11.1,<=0.12.7`. PR [#367](https://github.com/tiangolo/fastapi/pull/367) by [@dedsm](https://github.com/dedsm).

  * Add test for OpenAPI schema with duplicate models from PR [#333](https://github.com/tiangolo/fastapi/pull/333) by [@dmontagu](https://github.com/dmontagu). PR [#385](https://github.com/tiangolo/fastapi/pull/385).

## 0.33.0[¶](#0330 "Permanent link")

  * Upgrade Pydantic version to `0.30.0`. PR [#384](https://github.com/tiangolo/fastapi/pull/384) by [@jekirl](https://github.com/jekirl).

## 0.32.0[¶](#0320 "Permanent link")

  * Fix typo in docs for features. PR [#380](https://github.com/tiangolo/fastapi/pull/380) by [@MartinoMensio](https://github.com/MartinoMensio).

  * Fix source code `limit` for example in [Query Parameters](https://fastapi.tiangolo.com/tutorial/query-params/). PR [#366](https://github.com/tiangolo/fastapi/pull/366) by [@Smashman](https://github.com/Smashman).

  * Update wording in docs about [OAuth2 scopes](https://fastapi.tiangolo.com/advanced/security/oauth2-scopes/). PR [#371](https://github.com/tiangolo/fastapi/pull/371) by [@cjw296](https://github.com/cjw296).

  * Update docs for `Enum`s to inherit from `str` and improve Swagger UI rendering. PR [#351](https://github.com/tiangolo/fastapi/pull/351).

  * Fix regression, add Swagger UI deep linking again. PR [#350](https://github.com/tiangolo/fastapi/pull/350).

  * Add test for having path templates in `prefix` of `.include_router`. PR [#349](https://github.com/tiangolo/fastapi/pull/349).

  * Add note to docs: [Include the same router multiple times with different `prefix`](https://fastapi.tiangolo.com/tutorial/bigger-applications/#include-the-same-router-multiple-times-with-different-prefix). PR [#348](https://github.com/tiangolo/fastapi/pull/348).

  * Fix OpenAPI/JSON Schema generation for two functions with the same name (in different modules) with the same composite bodies.

    * Composite bodies' IDs are now based on path, not only on route name, as the auto-generated name uses the function names, that can be duplicated in different modules.
    * The same new ID generation applies to response models.
    * This also changes the generated title for those models.
    * Only composite bodies and response models are affected because those are generated dynamically, they don't have a module (a Python file).
    * This also adds the possibility of using `.include_router()` with the same `APIRouter` _multiple_ times, with different prefixes, e.g. `/api/v2` and `/api/latest`, and it will now work correctly.
    * PR [#347](https://github.com/tiangolo/fastapi/pull/347).

## 0.31.0[¶](#0310 "Permanent link")

  * Upgrade Pydantic supported version to `0.29.0`.
    * New supported version range is `"pydantic >=0.28,<=0.29.0"`.
    * This adds support for Pydantic [Generic Models](https://docs.pydantic.dev/latest/#generic-models), kudos to [@dmontagu](https://github.com/dmontagu).
    * PR [#344](https://github.com/tiangolo/fastapi/pull/344).

## 0.30.1[¶](#0301 "Permanent link")

  * Add section in docs about [External Links and Articles](https://fastapi.tiangolo.com/external-links/). PR [#341](https://github.com/tiangolo/fastapi/pull/341).

  * Remove `Pipfile.lock` from the repository as it is only used by FastAPI contributors (developers of FastAPI itself). See the PR for more details. PR [#340](https://github.com/tiangolo/fastapi/pull/340).

  * Update section about [Help FastAPI - Get Help](https://fastapi.tiangolo.com/help-fastapi/). PR [#339](https://github.com/tiangolo/fastapi/pull/339).

  * Refine internal type declarations to improve/remove Mypy errors in users' code. PR [#338](https://github.com/tiangolo/fastapi/pull/338).

  * Update and clarify [SQL tutorial with SQLAlchemy](https://fastapi.tiangolo.com/tutorial/sql-databases/). PR [#331](https://github.com/tiangolo/fastapi/pull/331) by [@mariacamilagl](https://github.com/mariacamilagl).

  * Add SQLite [online viewers to the docs](https://fastapi.tiangolo.com/tutorial/sql-databases/#interact-with-the-database-directly). PR [#330](https://github.com/tiangolo/fastapi/pull/330) by [@cyrilbois](https://github.com/cyrilbois).

## 0.30.0[¶](#0300 "Permanent link")

  * Add support for Pydantic's ORM mode:

    * Updated documentation about SQL with SQLAlchemy, using Pydantic models with ORM mode, SQLAlchemy models with relations, separation of files, simplification of code and other changes. New docs: [SQL (Relational) Databases](https://fastapi.tiangolo.com/tutorial/sql-databases/).
    * The new support for ORM mode fixes issues/adds features related to ORMs with lazy-loading, hybrid properties, dynamic/getters (using `@property` decorators) and several other use cases.
    * This applies to ORMs like SQLAlchemy, Peewee, Tortoise ORM, GINO ORM and virtually any other.
    * If your _path operations_ return an arbitrary object with attributes (e.g. `my_item.name` instead of `my_item["name"]`) AND you use a `response_model`, make sure to update the Pydantic models with `orm_mode = True` as described in the docs (link above).
    * New documentation about receiving plain `dict`s as request bodies: [Bodies of arbitrary `dict`s](https://fastapi.tiangolo.com/tutorial/body-nested-models/#bodies-of-arbitrary-dicts).
    * New documentation about returning arbitrary `dict`s in responses: [Response with arbitrary `dict`](https://fastapi.tiangolo.com/tutorial/extra-models/#response-with-arbitrary-dict).
    * **Technical Details** :
      * When declaring a `response_model` it is used directly to generate the response content, from whatever was returned from the _path operation function_.
      * Before this, the return content was first passed through `jsonable_encoder` to ensure it was a "jsonable" object, like a `dict`, instead of an arbitrary object with attributes (like an ORM model). That's why you should make sure to update your Pydantic models for objects with attributes to use `orm_mode = True`.
      * If you don't have a `response_model`, the return object will still be passed through `jsonable_encoder` first.
      * When a `response_model` is declared, the same `response_model` type declaration won't be used as is, it will be "cloned" to create an new one (a cloned Pydantic `Field` with all the submodels cloned as well).
      * This avoids/fixes a potential security issue: as the returned object is passed directly to Pydantic, if the returned object was a subclass of the `response_model` (e.g. you return a `UserInDB` that inherits from `User` but contains extra fields, like `hashed_password`, and `User` is used in the `response_model`), it would still pass the validation (because `UserInDB` is a subclass of `User`) and the object would be returned as-is, including the `hashed_password`. To fix this, the declared `response_model` is cloned, if it is a Pydantic model class (or contains Pydantic model classes in it, e.g. in a `List[Item]`), the Pydantic model class(es) will be a different one (the "cloned" one). So, an object that is a subclass won't simply pass the validation and returned as-is, because it is no longer a sub-class of the cloned `response_model`. Instead, a new Pydantic model object will be created with the contents of the returned object. So, it will be a new object (made with the data from the returned one), and will be filtered by the cloned `response_model`, containing only the declared fields as normally.
    * PR [#322](https://github.com/tiangolo/fastapi/pull/322).
  * Remove/clean unused RegEx code in routing. PR [#314](https://github.com/tiangolo/fastapi/pull/314) by [@dmontagu](https://github.com/dmontagu).

  * Use default response status code descriptions for additional responses. PR [#313](https://github.com/tiangolo/fastapi/pull/313) by [@duxiaoyao](https://github.com/duxiaoyao).

  * Upgrade Pydantic support to `0.28`. PR [#320](https://github.com/tiangolo/fastapi/pull/320) by [@jekirl](https://github.com/jekirl).

## 0.29.1[¶](#0291 "Permanent link")

  * Fix handling an empty-body request with a required body param. PR [#311](https://github.com/tiangolo/fastapi/pull/311).

  * Fix broken link in docs: [Return a Response directly](https://fastapi.tiangolo.com/advanced/response-directly/). PR [#306](https://github.com/tiangolo/fastapi/pull/306) by [@dmontagu](https://github.com/dmontagu).

  * Fix docs discrepancy in docs for [Response Model](https://fastapi.tiangolo.com/tutorial/response-model/). PR [#288](https://github.com/tiangolo/fastapi/pull/288) by [@awiddersheim](https://github.com/awiddersheim).

## 0.29.0[¶](#0290 "Permanent link")

  * Add support for declaring a `Response` parameter:
    * This allows declaring:
      * [Response Cookies](https://fastapi.tiangolo.com/advanced/response-cookies/).
      * [Response Headers](https://fastapi.tiangolo.com/advanced/response-headers/).
      * An HTTP Status Code different than the default: [Response - Change Status Code](https://fastapi.tiangolo.com/advanced/response-change-status-code/).
    * All of this while still being able to return arbitrary objects (`dict`, DB model, etc).
    * Update attribution to Hug, for inspiring the `response` parameter pattern.
    * PR [#294](https://github.com/tiangolo/fastapi/pull/294).

## 0.28.0[¶](#0280 "Permanent link")

  * Implement dependency cache per request.

    * This avoids calling each dependency multiple times for the same request.
    * This is useful while calling external services, performing costly computation, etc.
    * This also means that if a dependency was declared as a _path operation decorator_ dependency, possibly at the router level (with `.include_router()`) and then it is declared again in a specific _path operation_ , the dependency will be called only once.
    * The cache can be disabled per dependency declaration, using `use_cache=False` as in `Depends(your_dependency, use_cache=False)`.
    * Updated docs at: [Using the same dependency multiple times](https://fastapi.tiangolo.com/tutorial/dependencies/sub-dependencies/#using-the-same-dependency-multiple-times).
    * PR [#292](https://github.com/tiangolo/fastapi/pull/292).
  * Implement dependency overrides for testing.

    * This allows using overrides/mocks of dependencies during tests.
    * New docs: [Testing Dependencies with Overrides](https://fastapi.tiangolo.com/advanced/testing-dependencies/).
    * PR [#291](https://github.com/tiangolo/fastapi/pull/291).

## 0.27.2[¶](#0272 "Permanent link")

  * Fix path and query parameters receiving `dict` as a valid type. It should be mapped to a body payload. PR [#287](https://github.com/tiangolo/fastapi/pull/287). Updated docs at: [Query parameter list / multiple values with defaults: Using `list`](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#using-list).

## 0.27.1[¶](#0271 "Permanent link")

  * Fix `auto_error=False` handling in `HTTPBearer` security scheme. Do not `raise` when there's an incorrect `Authorization` header if `auto_error=False`. PR [#282](https://github.com/tiangolo/fastapi/pull/282).

  * Fix type declaration of `HTTPException`. PR [#279](https://github.com/tiangolo/fastapi/pull/279).

## 0.27.0[¶](#0270 "Permanent link")

  * Fix broken link in docs about OAuth 2.0 with scopes. PR [#275](https://github.com/tiangolo/fastapi/pull/275) by [@dmontagu](https://github.com/dmontagu).

  * Refactor param extraction using Pydantic `Field`:

    * Large refactor, improvement, and simplification of param extraction from _path operations_.
    * Fix/add support for list _query parameters_ with list defaults. New documentation: [Query parameter list / multiple values with defaults](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#query-parameter-list-multiple-values-with-defaults).
    * Add support for enumerations in _path operation_ parameters. New documentation: [Path Parameters: Predefined values](https://fastapi.tiangolo.com/tutorial/path-params/#predefined-values).
    * Add support for type annotations using `Optional` as in `param: Optional[str] = None`. New documentation: [Optional type declarations](https://fastapi.tiangolo.com/tutorial/query-params/#optional-type-declarations).
    * PR [#278](https://github.com/tiangolo/fastapi/pull/278).

## 0.26.0[¶](#0260 "Permanent link")

  * Separate error handling for validation errors.

    * This will allow developers to customize the exception handlers.
    * Document better how to handle exceptions and use error handlers.
    * Include `RequestValidationError` and `WebSocketRequestValidationError` (this last one will be useful once [encode/starlette#527](https://github.com/encode/starlette/pull/527) or equivalent is merged).
    * New documentation about exceptions handlers:
      * [Install custom exception handlers](https://fastapi.tiangolo.com/tutorial/handling-errors/#install-custom-exception-handlers).
      * [Override the default exception handlers](https://fastapi.tiangolo.com/tutorial/handling-errors/#override-the-default-exception-handlers).
      * [Reuse **FastAPI's** exception handlers](https://fastapi.tiangolo.com/tutorial/handling-errors/#reuse-fastapis-exception-handlers).
    * PR [#273](https://github.com/tiangolo/fastapi/pull/273).
  * Fix support for _paths_ in _path parameters_ without needing explicit `Path(...)`.

    * PR [#256](https://github.com/tiangolo/fastapi/pull/256).
    * Documented in PR [#272](https://github.com/tiangolo/fastapi/pull/272) by [@wshayes](https://github.com/wshayes).
    * New documentation at: [Path Parameters containing paths](https://fastapi.tiangolo.com/tutorial/path-params/#path-parameters-containing-paths).
  * Update docs for testing FastAPI. Include using `POST`, sending JSON, testing headers, etc. New documentation: [Testing](https://fastapi.tiangolo.com/tutorial/testing/#testing-extended-example). PR [#271](https://github.com/tiangolo/fastapi/pull/271).

  * Fix type declaration of `response_model` to allow generic Python types as `List[Model]`. Mainly to fix `mypy` for users. PR [#266](https://github.com/tiangolo/fastapi/pull/266).

## 0.25.0[¶](#0250 "Permanent link")

  * Add support for Pydantic's `include`, `exclude`, `by_alias`.

    * Update documentation: [Response Model](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
    * Add docs for: [Body - updates](https://fastapi.tiangolo.com/tutorial/body-updates/), using Pydantic's `skip_defaults`.
    * Add method consistency tests.
    * PR [#264](https://github.com/tiangolo/fastapi/pull/264).
  * Add `CONTRIBUTING.md` file to GitHub, to help new contributors. PR [#255](https://github.com/tiangolo/fastapi/pull/255) by [@wshayes](https://github.com/wshayes).

  * Add support for Pydantic's `skip_defaults`:

    * There's a new _path operation decorator_ parameter `response_model_skip_defaults`.
      * The name of the parameter will most probably change in a future version to `response_skip_defaults`, `model_skip_defaults` or something similar.
    * New [documentation section about using `response_model_skip_defaults`](https://fastapi.tiangolo.com/tutorial/response-model/#response-model-encoding-parameters).
    * PR [#248](https://github.com/tiangolo/fastapi/pull/248) by [@wshayes](https://github.com/wshayes).

## 0.24.0[¶](#0240 "Permanent link")

  * Add support for WebSockets with dependencies and parameters.

    * Support included for:
      * `Depends`
      * `Security`
      * `Cookie`
      * `Header`
      * `Path`
      * `Query`
      * ...as these are compatible with the WebSockets protocol (e.g. `Body` is not).
    * [Updated documentation for WebSockets](https://fastapi.tiangolo.com/advanced/websockets/).
    * PR [#178](https://github.com/tiangolo/fastapi/pull/178) by [@jekirl](https://github.com/jekirl).
  * Upgrade the compatible version of Pydantic to `0.26.0`.

    * This includes JSON Schema support for IP address and network objects, bug fixes, and other features.
    * PR [#247](https://github.com/tiangolo/fastapi/pull/247) by [@euri10](https://github.com/euri10).

## 0.23.0[¶](#0230 "Permanent link")

  * Upgrade the compatible version of Starlette to `0.12.0`.

    * This includes support for ASGI 3 (the latest version of the standard).
    * It's now possible to use [Starlette's `StreamingResponse`](https://www.starlette.dev/responses/#streamingresponse) with iterators, like [file-like](https://docs.python.org/3/glossary.html#term-file-like-object) objects (as those returned by `open()`).
    * It's now possible to use the low level utility `iterate_in_threadpool` from `starlette.concurrency` (for advanced scenarios).
    * PR [#243](https://github.com/tiangolo/fastapi/pull/243).
  * Add OAuth2 redirect page for Swagger UI. This allows having delegated authentication in the Swagger UI docs. For this to work, you need to add `{your_origin}/docs/oauth2-redirect` to the allowed callbacks in your OAuth2 provider (in Auth0, Facebook, Google, etc).

    * For example, during development, it could be `http://localhost:8000/docs/oauth2-redirect`.
    * Keep in mind that this callback URL is independent of whichever one is used by your frontend. You might also have another callback at `https://yourdomain.com/login/callback`.
    * This is only to allow delegated authentication in the API docs with Swagger UI.
    * PR [#198](https://github.com/tiangolo/fastapi/pull/198) by [@steinitzu](https://github.com/steinitzu).
  * Make Swagger UI and ReDoc route handlers (_path operations_) be `async` functions instead of lambdas to improve performance. PR [#241](https://github.com/tiangolo/fastapi/pull/241) by [@Trim21](https://github.com/Trim21).

  * Make Swagger UI and ReDoc URLs parameterizable, allowing to host and serve local versions of them and have offline docs. PR [#112](https://github.com/tiangolo/fastapi/pull/112) by [@euri10](https://github.com/euri10).

## 0.22.0[¶](#0220 "Permanent link")

  * Add support for `dependencies` parameter:

    * A parameter in _path operation decorators_ , for dependencies that should be executed but the return value is not important or not used in the _path operation function_.
    * A parameter in the `.include_router()` method of FastAPI applications and routers, to include dependencies that should be executed in each _path operation_ in a router.
      * This is useful, for example, to require authentication or permissions in specific group of _path operations_.
      * Different `dependencies` can be applied to different routers.
    * These `dependencies` are run before the normal parameter dependencies. And normal dependencies are run too. They can be combined.
    * Dependencies declared in a router are executed first, then the ones defined in _path operation decorators_ , and then the ones declared in normal parameters. They are all combined and executed.
    * All this also supports using `Security` with `scopes` in those `dependencies` parameters, for more advanced OAuth 2.0 security scenarios with scopes.
    * New documentation about [dependencies in _path operation decorators_](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).
    * New documentation about [dependencies in the `include_router()` method](https://fastapi.tiangolo.com/tutorial/bigger-applications/#include-an-apirouter-with-a-prefix-tags-responses-and-dependencies).
    * PR [#235](https://github.com/tiangolo/fastapi/pull/235).
  * Fix OpenAPI documentation of Starlette URL convertors. Specially useful when using `path` convertors, to take a whole path as a parameter, like `/some/url/{p:path}`. PR [#234](https://github.com/tiangolo/fastapi/pull/234) by [@euri10](https://github.com/euri10).

  * Make default parameter utilities exported from `fastapi` be functions instead of classes (the new functions return instances of those classes). To be able to override the return types and fix `mypy` errors in FastAPI's users' code. Applies to `Path`, `Query`, `Header`, `Cookie`, `Body`, `Form`, `File`, `Depends`, and `Security`. PR [#226](https://github.com/tiangolo/fastapi/pull/226) and PR [#231](https://github.com/tiangolo/fastapi/pull/231).

  * Separate development scripts `test.sh`, `lint.sh`, and `format.sh`. PR [#232](https://github.com/tiangolo/fastapi/pull/232).

  * Re-enable `black` formatting checks for Python 3.7. PR [#229](https://github.com/tiangolo/fastapi/pull/229) by [@zamiramir](https://github.com/zamiramir).

## 0.21.0[¶](#0210 "Permanent link")

  * On body parsing errors, raise `from` previous exception, to allow better introspection in logging code. PR [#192](https://github.com/tiangolo/fastapi/pull/195) by [@ricardomomm](https://github.com/ricardomomm).

  * Use Python logger named "`fastapi`" instead of root logger. PR [#222](https://github.com/tiangolo/fastapi/pull/222) by [@euri10](https://github.com/euri10).

  * Upgrade Pydantic to version 0.25. PR [#225](https://github.com/tiangolo/fastapi/pull/225) by [@euri10](https://github.com/euri10).

  * Fix typo in routing. PR [#221](https://github.com/tiangolo/fastapi/pull/221) by [@djlambert](https://github.com/djlambert).

## 0.20.1[¶](#0201 "Permanent link")

  * Add typing information to package including file `py.typed`. PR [#209](https://github.com/tiangolo/fastapi/pull/209) by [@meadsteve](https://github.com/meadsteve).

  * Add FastAPI bot for Gitter. To automatically announce new releases. PR [#189](https://github.com/tiangolo/fastapi/pull/189).

## 0.20.0[¶](#0200 "Permanent link")

  * Upgrade OAuth2:

    * Upgrade Password flow using Bearer tokens to use the correct HTTP status code 401 `UNAUTHORIZED`, with `WWW-Authenticate` headers.
    * Update, simplify, and improve all the [security docs](https://fastapi.tiangolo.com/advanced/security/).
    * Add new `scope_str` to `SecurityScopes` and update docs: [OAuth2 scopes](https://fastapi.tiangolo.com/advanced/security/oauth2-scopes/).
    * Update docs, images, tests.
    * PR [#188](https://github.com/tiangolo/fastapi/pull/188).
  * Include [Hypercorn](https://gitlab.com/pgjones/hypercorn) as an alternative ASGI server in the docs. PR [#187](https://github.com/tiangolo/fastapi/pull/187).

  * Add docs for [Static Files](https://fastapi.tiangolo.com/tutorial/static-files/) and [Templates](https://fastapi.tiangolo.com/advanced/templates/). PR [#186](https://github.com/tiangolo/fastapi/pull/186).

  * Add docs for handling [Response Cookies](https://fastapi.tiangolo.com/advanced/response-cookies/) and [Response Headers](https://fastapi.tiangolo.com/advanced/response-headers/). PR [#185](https://github.com/tiangolo/fastapi/pull/185).

  * Fix typos in docs. PR [#176](https://github.com/tiangolo/fastapi/pull/176) by [@chdsbd](https://github.com/chdsbd).

## 0.19.0[¶](#0190 "Permanent link")

  * Rename _path operation decorator_ parameter `content_type` to `response_class`. PR [#183](https://github.com/tiangolo/fastapi/pull/183).

  * Add docs:

    * How to use the `jsonable_encoder` in [JSON compatible encoder](https://fastapi.tiangolo.com/tutorial/encoder/).
    * How to [Return a Response directly](https://fastapi.tiangolo.com/advanced/response-directly/).
    * Update how to use a [Custom Response Class](https://fastapi.tiangolo.com/advanced/custom-response/).
    * PR [#184](https://github.com/tiangolo/fastapi/pull/184).

## 0.18.0[¶](#0180 "Permanent link")

  * Add docs for [HTTP Basic Auth](https://fastapi.tiangolo.com/advanced/custom-response/). PR [#177](https://github.com/tiangolo/fastapi/pull/177).

  * Upgrade HTTP Basic Auth handling with automatic headers (automatic browser login prompt). PR [#175](https://github.com/tiangolo/fastapi/pull/175).

  * Update dependencies for security. PR [#174](https://github.com/tiangolo/fastapi/pull/174).

  * Add docs for [Middleware](https://fastapi.tiangolo.com/tutorial/middleware/). PR [#173](https://github.com/tiangolo/fastapi/pull/173).

## 0.17.0[¶](#0170 "Permanent link")

  * Make Flit publish from CI. PR [#170](https://github.com/tiangolo/fastapi/pull/170).

  * Add documentation about handling [CORS (Cross-Origin Resource Sharing)](https://fastapi.tiangolo.com/tutorial/cors/). PR [#169](https://github.com/tiangolo/fastapi/pull/169).

  * By default, encode by alias. This allows using Pydantic `alias` parameters working by default. PR [#168](https://github.com/tiangolo/fastapi/pull/168).

## 0.16.0[¶](#0160 "Permanent link")

  * Upgrade _path operation_ `docstring` parsing to support proper Markdown descriptions. New documentation at [Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#description-from-docstring). PR [#163](https://github.com/tiangolo/fastapi/pull/163).

  * Refactor internal usage of Pydantic to use correct data types. PR [#164](https://github.com/tiangolo/fastapi/pull/164).

  * Upgrade Pydantic to version `0.23`. PR [#160](https://github.com/tiangolo/fastapi/pull/160) by [@euri10](https://github.com/euri10).

  * Fix typo in Tutorial about Extra Models. PR [#159](https://github.com/tiangolo/fastapi/pull/159) by [@danielmichaels](https://github.com/danielmichaels).

  * Fix [Query Parameters](https://fastapi.tiangolo.com/tutorial/query-params/) URL examples in docs. PR [#157](https://github.com/tiangolo/fastapi/pull/157) by [@hayata-yamamoto](https://github.com/hayata-yamamoto).

## 0.15.0[¶](#0150 "Permanent link")

  * Add support for multiple file uploads (as a single form field). New docs at: [Multiple file uploads](https://fastapi.tiangolo.com/tutorial/request-files/#multiple-file-uploads). PR [#158](https://github.com/tiangolo/fastapi/pull/158).

  * Add docs for: [Additional Status Codes](https://fastapi.tiangolo.com/advanced/additional-status-codes/). PR [#156](https://github.com/tiangolo/fastapi/pull/156).

## 0.14.0[¶](#0140 "Permanent link")

  * Improve automatically generated names of _path operations_ in OpenAPI (in API docs). A function `read_items` instead of having a generated name "Read Items Get" will have "Read Items". PR [#155](https://github.com/tiangolo/fastapi/pull/155).

  * Add docs for: [Testing **FastAPI**](https://fastapi.tiangolo.com/tutorial/testing/). PR [#151](https://github.com/tiangolo/fastapi/pull/151).

  * Update `/docs` Swagger UI to enable deep linking. This allows sharing the URL pointing directly to the _path operation_ documentation in the docs. PR [#148](https://github.com/tiangolo/fastapi/pull/148) by [@wshayes](https://github.com/wshayes).

  * Update development dependencies, `Pipfile.lock`. PR [#150](https://github.com/tiangolo/fastapi/pull/150).

  * Include Falcon and Hug in: [Alternatives, Inspiration and Comparisons](https://fastapi.tiangolo.com/alternatives/).

## 0.13.0[¶](#0130 "Permanent link")

  * Improve/upgrade OAuth2 scopes support with `SecurityScopes`:
    * `SecurityScopes` can be declared as a parameter like `Request`, to get the scopes of all super-dependencies/dependants.
    * Improve `Security` handling, merging scopes when declaring `SecurityScopes`.
    * Allow using `SecurityBase` (like `OAuth2`) classes with `Depends` and still document them. `Security` now is needed only to declare `scopes`.
    * Updated docs about: [OAuth2 with Password (and hashing), Bearer with JWT tokens](https://fastapi.tiangolo.com/tutorial/security/oauth2-jwt/).
    * New docs about: [OAuth2 scopes](https://fastapi.tiangolo.com/advanced/security/oauth2-scopes/).
    * PR [#141](https://github.com/tiangolo/fastapi/pull/141).

## 0.12.1[¶](#0121 "Permanent link")

  * Fix bug: handling additional `responses` in `APIRouter.include_router()`. PR [#140](https://github.com/tiangolo/fastapi/pull/140).

  * Fix typo in SQL tutorial. PR [#138](https://github.com/tiangolo/fastapi/pull/138) by [@mostaphaRoudsari](https://github.com/mostaphaRoudsari).

  * Fix typos in section about nested models and OAuth2 with JWT. PR [#127](https://github.com/tiangolo/fastapi/pull/127) by [@mmcloud](https://github.com/mmcloud).

## 0.12.0[¶](#0120 "Permanent link")

  * Add additional `responses` parameter to _path operation decorators_ to extend responses in OpenAPI (and API docs).
    * It also allows extending existing responses generated from `response_model`, declare other media types (like images), etc.
    * The new documentation is here: [Additional Responses](https://fastapi.tiangolo.com/advanced/additional-responses/).
    * `responses` can also be added to `.include_router()`, the updated docs are here: [Bigger Applications](https://fastapi.tiangolo.com/tutorial/bigger-applications/#add-some-custom-tags-and-responses).
    * PR [#97](https://github.com/tiangolo/fastapi/pull/97) originally initiated by [@barsi](https://github.com/barsi).
  * Update `scripts/test-cov-html.sh` to allow passing extra parameters like `-vv`, for development.

## 0.11.0[¶](#0110 "Permanent link")

  * Add `auto_error` parameter to security utility functions. Allowing them to be optional. Also allowing to have multiple alternative security schemes that are then checked in a single dependency instead of each one verifying and returning the error to the client automatically when not satisfied. PR [#134](https://github.com/tiangolo/fastapi/pull/134).

  * Update [SQL Tutorial](https://fastapi.tiangolo.com/tutorial/sql-databases/#create-a-middleware-to-handle-sessions) to close database sessions even when there are exceptions. PR [#89](https://github.com/tiangolo/fastapi/pull/89) by [@alexiri](https://github.com/alexiri).

  * Fix duplicate dependency in `pyproject.toml`. PR [#128](https://github.com/tiangolo/fastapi/pull/128) by [@zxalif](https://github.com/zxalif).

## 0.10.3[¶](#0103 "Permanent link")

  * Add Gitter chat, badge, links, etc. <https://gitter.im/tiangolo/fastapi> . PR [#117](https://github.com/tiangolo/fastapi/pull/117).

  * Add docs about [Extending OpenAPI](https://fastapi.tiangolo.com/advanced/extending-openapi/). PR [#126](https://github.com/tiangolo/fastapi/pull/126).

  * Make Travis run Ubuntu Xenial (newer version) and Python 3.7 instead of Python 3.7-dev. PR [#92](https://github.com/tiangolo/fastapi/pull/92) by [@blueyed](https://github.com/blueyed).

  * Fix duplicated param variable creation. PR [#123](https://github.com/tiangolo/fastapi/pull/123) by [@yihuang](https://github.com/yihuang).

  * Add note in [Response Model docs](https://fastapi.tiangolo.com/tutorial/response-model/) about why using a function parameter instead of a function return type annotation. PR [#109](https://github.com/tiangolo/fastapi/pull/109) by [@JHSaunders](https://github.com/JHSaunders).

  * Fix event docs (startup/shutdown) function name. PR [#105](https://github.com/tiangolo/fastapi/pull/105) by [@stratosgear](https://github.com/stratosgear).

## 0.10.2[¶](#0102 "Permanent link")

  * Fix OpenAPI (JSON Schema) for declarations of Python `Union` (JSON Schema `additionalProperties`). PR [#121](https://github.com/tiangolo/fastapi/pull/121).

  * Update [Background Tasks](https://fastapi.tiangolo.com/tutorial/background-tasks/) with a note on Celery.

  * Document response models using unions and lists, updated at: [Extra Models](https://fastapi.tiangolo.com/tutorial/extra-models/). PR [#108](https://github.com/tiangolo/fastapi/pull/108).

## 0.10.1[¶](#0101 "Permanent link")

  * Add docs and tests for [encode/databases](https://github.com/encode/databases). New docs at: [Async SQL (Relational) Databases](https://fastapi.tiangolo.com/advanced/async-sql-databases/). PR [#107](https://github.com/tiangolo/fastapi/pull/107).

## 0.10.0[¶](#0100 "Permanent link")

  * Add support for Background Tasks in _path operation functions_ and dependencies. New documentation about [Background Tasks is here](https://fastapi.tiangolo.com/tutorial/background-tasks/). PR [#103](https://github.com/tiangolo/fastapi/pull/103).

  * Add support for `.websocket_route()` in `APIRouter`. PR [#100](https://github.com/tiangolo/fastapi/pull/100) by [@euri10](https://github.com/euri10).

  * New docs section about [Events: startup - shutdown](https://fastapi.tiangolo.com/advanced/events/). PR [#99](https://github.com/tiangolo/fastapi/pull/99).

## 0.9.1[¶](#091 "Permanent link")

  * Document receiving [Multiple values with the same query parameter](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#query-parameter-list-multiple-values) and [Duplicate headers](https://fastapi.tiangolo.com/tutorial/header-params/#duplicate-headers). PR [#95](https://github.com/tiangolo/fastapi/pull/95).

## 0.9.0[¶](#090 "Permanent link")

  * Upgrade compatible Pydantic version to `0.21.0`. PR [#90](https://github.com/tiangolo/fastapi/pull/90).

  * Add documentation for: [Application Configuration](https://fastapi.tiangolo.com/tutorial/application-configuration/).

  * Fix typo in docs. PR [#76](https://github.com/tiangolo/fastapi/pull/76) by [@matthewhegarty](https://github.com/matthewhegarty).

  * Fix link in "Deployment" to "Bigger Applications".

## 0.8.0[¶](#080 "Permanent link")

  * Make development scripts executable. PR [#76](https://github.com/tiangolo/fastapi/pull/76) by [@euri10](https://github.com/euri10).

  * Add support for adding `tags` in `app.include_router()`. PR [#55](https://github.com/tiangolo/fastapi/pull/55) by [@euri10](https://github.com/euri10). Documentation updated in the section: [Bigger Applications](https://fastapi.tiangolo.com/tutorial/bigger-applications/).

  * Update docs related to Uvicorn to use new `--reload` option from version `0.5.x`. PR [#74](https://github.com/tiangolo/fastapi/pull/74).

  * Update `isort` imports and scripts to be compatible with newer versions. PR [#75](https://github.com/tiangolo/fastapi/pull/75).

## 0.7.1[¶](#071 "Permanent link")

  * Update [technical details about `async def` handling](https://fastapi.tiangolo.com/async/#path-operation-functions) with respect to previous frameworks. PR [#64](https://github.com/tiangolo/fastapi/pull/64) by [@haizaar](https://github.com/haizaar).

  * Add [deployment documentation for Docker in Raspberry Pi](https://fastapi.tiangolo.com/deployment/#raspberry-pi-and-other-architectures) and other architectures.

  * Trigger Docker images build on Travis CI automatically. PR [#65](https://github.com/tiangolo/fastapi/pull/65).

## 0.7.0[¶](#070 "Permanent link")

  * Add support for `UploadFile` in `File` parameter annotations.
    * This includes a file-like interface.
    * Here's the updated documentation for declaring [`File` parameters with `UploadFile`](https://fastapi.tiangolo.com/tutorial/request-files/#file-parameters-with-uploadfile).
    * And here's the updated documentation for using [`Form` parameters mixed with `File` parameters, supporting `bytes` and `UploadFile`](https://fastapi.tiangolo.com/tutorial/request-forms-and-files/) at the same time.
    * PR [#63](https://github.com/tiangolo/fastapi/pull/63).

## 0.6.4[¶](#064 "Permanent link")

  * Add [technical details about `async def` handling to docs](https://fastapi.tiangolo.com/async/#very-technical-details). PR [#61](https://github.com/tiangolo/fastapi/pull/61).

  * Add docs for [Debugging FastAPI applications in editors](https://fastapi.tiangolo.com/tutorial/debugging/).

  * Clarify [Bigger Applications deployed with Docker](https://fastapi.tiangolo.com/deployment/#bigger-applications).

  * Fix typos in docs.

  * Add section about [History, Design and Future](https://fastapi.tiangolo.com/history-design-future/).

  * Add docs for using [WebSockets with **FastAPI**](https://fastapi.tiangolo.com/advanced/websockets/). PR [#62](https://github.com/tiangolo/fastapi/pull/62).

## 0.6.3[¶](#063 "Permanent link")

  * Add Favicons to docs. PR [#53](https://github.com/tiangolo/fastapi/pull/53).

## 0.6.2[¶](#062 "Permanent link")

  * Introduce new project generator based on FastAPI and PostgreSQL: <https://github.com/tiangolo/full-stack-fastapi-postgresql>. PR [#52](https://github.com/tiangolo/fastapi/pull/52).

  * Update [SQL tutorial with SQLAlchemy, using `Depends` to improve editor support and reduce code repetition](https://fastapi.tiangolo.com/tutorial/sql-databases/). PR [#52](https://github.com/tiangolo/fastapi/pull/52).

  * Improve middleware naming in tutorial for SQL with SQLAlchemy <https://fastapi.tiangolo.com/tutorial/sql-databases/>.

## 0.6.1[¶](#061 "Permanent link")

  * Add docs for GraphQL: <https://fastapi.tiangolo.com/advanced/graphql/>. PR [#48](https://github.com/tiangolo/fastapi/pull/48).

## 0.6.0[¶](#060 "Permanent link")

  * Update SQL with SQLAlchemy tutorial at <https://fastapi.tiangolo.com/tutorial/sql-databases/> using the new official `request.state`. PR [#45](https://github.com/tiangolo/fastapi/pull/45).

  * Upgrade Starlette to version `0.11.1` and add required compatibility changes. PR [#44](https://github.com/tiangolo/fastapi/pull/44).

## 0.5.1[¶](#051 "Permanent link")

  * Add section about [helping and getting help with **FastAPI**](https://fastapi.tiangolo.com/help-fastapi/).

  * Add note about [path operations order in docs](https://fastapi.tiangolo.com/tutorial/path-params/#order-matters).

  * Update [section about error handling](https://fastapi.tiangolo.com/tutorial/handling-errors/) with more information and make relation with Starlette error handling utilities more explicit. PR [#41](https://github.com/tiangolo/fastapi/pull/41).

  * Add [Development - Contributing section to the docs](). PR [#42](https://github.com/tiangolo/fastapi/pull/42).

## 0.5.0[¶](#050 "Permanent link")

  * Add new `HTTPException` with support for custom headers. With new documentation for handling errors at: <https://fastapi.tiangolo.com/tutorial/handling-errors/>. PR [#35](https://github.com/tiangolo/fastapi/pull/35).

  * Add [documentation to use Starlette `Request` object](https://fastapi.tiangolo.com/advanced/using-request-directly/) directly. Check [#25](https://github.com/tiangolo/fastapi/pull/25) by [@euri10](https://github.com/euri10).

  * Add issue templates to simplify reporting bugs, getting help, etc: [#34](https://github.com/tiangolo/fastapi/pull/34).

  * Update example for the SQLAlchemy tutorial at <https://fastapi.tiangolo.com/tutorial/sql-databases/> using middleware and database session attached to request.

## 0.4.0[¶](#040 "Permanent link")

  * Add `openapi_prefix`, support for reverse proxy and mounting sub-applications. See the docs at <https://fastapi.tiangolo.com/advanced/sub-applications-proxy/>: [#26](https://github.com/tiangolo/fastapi/pull/26) by [@kabirkhan](https://github.com/kabirkhan).

  * Update [docs/tutorial for SQLAlchemy](https://fastapi.tiangolo.com/tutorial/sql-databases/) including note about _DB Browser for SQLite_.

## 0.3.0[¶](#030 "Permanent link")

  * Fix/add SQLAlchemy support, including ORM, and update [docs for SQLAlchemy](https://fastapi.tiangolo.com/tutorial/sql-databases/): [#30](https://github.com/tiangolo/fastapi/pull/30).

## 0.2.1[¶](#021 "Permanent link")

  * Fix `jsonable_encoder` for Pydantic models with `Config` but without `json_encoders`: [#29](https://github.com/tiangolo/fastapi/pull/29).

## 0.2.0[¶](#020 "Permanent link")

  * Fix typos in Security section: [#24](https://github.com/tiangolo/fastapi/pull/24) by [@kkinder](https://github.com/kkinder).

  * Add support for Pydantic custom JSON encoders: [#21](https://github.com/tiangolo/fastapi/pull/21) by [@euri10](https://github.com/euri10).

## 0.1.19[¶](#0119 "Permanent link")

  * Upgrade Starlette version to the current latest `0.10.1`: [#17](https://github.com/tiangolo/fastapi/pull/17) by [@euri10](https://github.com/euri10).

---
